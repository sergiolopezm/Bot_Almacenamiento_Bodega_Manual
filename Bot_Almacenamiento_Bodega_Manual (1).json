{
  "name": "Bot_Almacenamiento_Bodega_Manual",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "b53e7f9a-75f6-4090-a956-97c8fa707895",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -11216,
        4464
      ],
      "id": "682c4edf-1aed-401c-9584-4dc315452590",
      "name": "Mensaje Entrada",
      "webhookId": "b53e7f9a-75f6-4090-a956-97c8fa707895"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "42be7c60-3517-4559-9891-c6e774f76888",
              "name": "message.id",
              "value": "={{ $json.body.data.key.id }}",
              "type": "string"
            },
            {
              "id": "4379efd4-3f5c-418c-8126-c3ce1e18b7a3",
              "name": "message.contenido",
              "value": "={{ $json.body.data.message.conversation }}",
              "type": "string"
            },
            {
              "id": "08d830cc-5846-41e2-b2f5-d2e6dbbb37e2",
              "name": "message.date",
              "value": "={{ new Date(Date.now() - 5*60*60*1000).toISOString() }}",
              "type": "string"
            },
            {
              "id": "51f87c32-fe22-430b-9a43-04f45e9cc969",
              "name": "message.chat.id",
              "value": "={{ $json.body.data.key.remoteJid }}",
              "type": "string"
            },
            {
              "id": "18719256-6e5b-4a97-91c3-9a4e9c440997",
              "name": "message.chat.instance",
              "value": "={{ $json.body.instance }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -11008,
        4464
      ],
      "id": "c3aa94f2-d857-45e5-a217-e4b193706108",
      "name": "Parametrizaci√≥n"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO MensajesWhatsApp (message_id, contenido, fecha, chat_id, instance)\nVALUES ('{{ $json.message.id }}',\n        '{{ $json.message.contenido }}',\n        FORMAT(CONVERT(datetime, '{{ $json.message.date }}', 127), 'yyyy-MM-dd HH:mm:ss'),\n        '{{ $json[\"message\"][\"chat\"][\"id\"] }}',\n        '{{ $json[\"message\"][\"chat\"][\"instance\"] }}');\n"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        -10800,
        4464
      ],
      "id": "5b18eebc-9a7f-4124-8ef7-18720acbca47",
      "name": "Guarda el mensaje en SQL",
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT * FROM MensajesWhatsApp\nWHERE chat_id = '{{ $('Parametrizaci√≥n').item.json.message.chat.id }}'\n   OR (chat_id = 'agenteAI' AND message_id IN (\n       SELECT message_id \n       FROM MensajesWhatsApp \n       WHERE chat_id = '{{ $('Parametrizaci√≥n').item.json.message.chat.id }}'\n   ))\nORDER BY fecha ASC;\n"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        -10560,
        4464
      ],
      "id": "2c67ec5b-40c5-469b-8f84-93669c5c408e",
      "name": "Recupera todos los mensajes",
      "alwaysOutputData": true,
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Obtener los mensajes del input\nconst mensajes = $input.all();\n\n// Asegurar que haya mensajes antes de continuar\nif (mensajes.length === 0) {\n  return [{ mensajeCount: 0, tiempoUltimoMensaje: null }];\n}\n\n// Obtener la fecha del √∫ltimo mensaje\nconst fechaMensajeStr = mensajes[mensajes.length - 1].json.fecha; // Aseg√∫rate de que 'fecha' es el nombre correcto\nconst fechaMensajeDate = new Date(fechaMensajeStr); // Convertir a Date\n\n// Obtener la fecha y hora actual\nconst fechaActual = new Date();\n\n// Calcular la diferencia en segundos\nconst diferenciaSegundos = Math.floor((fechaActual.getTime() - fechaMensajeDate.getTime()) / 1000);\n\n// Retornar datos para el nodo Switch\nreturn [{\n  mensajeCount: mensajes.length,\n  tiempoUltimoMensaje: diferenciaSegundos\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -10368,
        4848
      ],
      "id": "d30bc702-22da-4b42-8dba-d2b6496c3fa9",
      "name": "Count y Tiempo √öltimo Mensaje"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "81c77bfb-8151-4c31-9380-784ae2c20f02",
              "leftValue": "={{ $json.mensajeCount }}",
              "rightValue": 1,
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            },
            {
              "id": "e049aa85-8cb2-483a-814e-0b17613927a5",
              "leftValue": "={{ $json.tiempoUltimoMensaje }}",
              "rightValue": 5,
              "operator": {
                "type": "number",
                "operation": "lte"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -10144,
        4672
      ],
      "id": "2a680412-3e80-45ee-8c22-96e54c0e485a",
      "name": "If (Salida 0 - No hacer nada)"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "e327003b-210e-4d36-a17d-6550957ca66c",
              "leftValue": "={{ $json.tiempoUltimoMensaje }}",
              "rightValue": 5,
              "operator": {
                "type": "number",
                "operation": "gte"
              }
            },
            {
              "id": "de6f6e64-1e10-434c-8bc5-303d98bdb3ac",
              "leftValue": "={{ $json.tiempoUltimoMensaje }}",
              "rightValue": 15,
              "operator": {
                "type": "number",
                "operation": "lte"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -9920,
        4784
      ],
      "id": "9af5a4ad-bfe1-43bb-abb9-5cb3157c6f58",
      "name": "If (Salida 1 - Esperar)"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "143c51ad-50d4-44ee-a050-61e4ffcf2eb3",
              "leftValue": "={{ $json.tiempoUltimoMensaje }}",
              "rightValue": 15,
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -9728,
        4960
      ],
      "id": "3af7db82-8330-475e-85c6-929322e69c38",
      "name": "If (Salida 2 - Seguir)"
    },
    {
      "parameters": {
        "amount": "={{$json[\"tiempoUltimoMensaje\"]}}"
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        -9056,
        5024
      ],
      "id": "c8d2f127-6159-4c3a-aaee-ab2da32b6696",
      "name": "Espera X segundos",
      "webhookId": "9c8f7481-324f-499e-9136-938ad85f693c"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -9920,
        4592
      ],
      "id": "c7f02879-f729-4f1c-8e4a-c3197bc57553",
      "name": "No Operation, do nothing"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -9488,
        5024
      ],
      "id": "d44c9c66-4359-44e6-bf99-cbd61e252e17",
      "name": "No Operation, do nothing1"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "8086b05f-a632-494c-a9c3-d1b74bc1a244",
              "name": "infoMensaje.chat_id",
              "value": "={{ $('Merge de Datos').first().json.chat_id }}",
              "type": "string"
            },
            {
              "id": "5d101db7-b90d-4464-8da5-68b82779fc85",
              "name": "infoMensaje.historialMensajes",
              "value": "={{ $json.historialMensajes }}",
              "type": "string"
            },
            {
              "id": "5c95d18f-1470-4096-83a5-f0a55234d1e5",
              "name": "infoMensaje.count",
              "value": "={{ $('If (Salida 2 - Seguir)').first().json.mensajeCount }}",
              "type": "string"
            },
            {
              "id": "0c776e32-ba1b-41b2-86f4-33f19d7c06dc",
              "name": "infoMensaje.tiempoUltimoMensaje",
              "value": "={{ $('If (Salida 2 - Seguir)').first().json.tiempoUltimoMensaje }}",
              "type": "string"
            },
            {
              "id": "d86a9164-3da9-4e08-872b-c05816a4ef92",
              "name": "infoMensaje.mensajeActual",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.message.conversation }}",
              "type": "string"
            },
            {
              "id": "530fe022-b6aa-4e79-adbb-c4f32edd8ccb",
              "name": "infoMensaje.fechaMensajeActual",
              "value": "={{ $('Parametrizaci√≥n').first().json.message.date.split('T')[0] }}",
              "type": "string"
            },
            {
              "id": "c51a7336-1fd0-40aa-a1b6-7afab57af93c",
              "name": "infoMensaje.horaMensajeActual",
              "value": "={{ \n  new Date($('Parametrizaci√≥n').first().json.message.date)\n    .toLocaleTimeString(\"es-CO\", { \n      hour: '2-digit', \n      minute: '2-digit', \n      hour12: true,\n      timeZone: 'UTC' \n    }) \n}}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -8800,
        4832
      ],
      "id": "5051bfef-2bd5-45af-87ce-f6e8496012de",
      "name": "Organiza el Mensaje"
    },
    {
      "parameters": {
        "jsCode": "// Obtener todos los datos de entrada\nconst datosEntrada = $input.all();\n\n// Filtrar solo los objetos que contienen un mensaje, descartando estad√≠sticas\nconst mensajes = datosEntrada.filter(item => item.json.message_id);\n\n// Funci√≥n para convertir la fecha a formato Colombia (UTC-5) en formato de 12 horas\nfunction convertirHoraColombia(fechaUTC) {\n    if (!fechaUTC) return \"[Hora no encontrada]\";\n    let fecha = new Date(fechaUTC);\n    fecha.setHours(fecha.getHours()); // Convertir a UTC-5\n    return fecha.toLocaleTimeString('es-CO', { hour: '2-digit', minute: '2-digit', hour12: true });\n}\n\n// Funci√≥n para dar formato de fecha en espa√±ol sin hora\nfunction formatearFecha(fechaUTC) {\n    if (!fechaUTC) return \"[Fecha no encontrada]\";\n    let fecha = new Date(fechaUTC);\n    return fecha.toLocaleDateString('es-CO', { year: 'numeric', month: 'long', day: 'numeric' });\n}\n\n// Estructurar los mensajes en un formato claro para el agente IA\nconst mensajesEstructurados = mensajes.map((mensaje, index) => {\n    let fecha = mensaje.json.fecha ? formatearFecha(mensaje.json.fecha) : \"[Fecha no encontrada]\";\n    let hora = mensaje.json.fecha ? convertirHoraColombia(mensaje.json.fecha) : \"[Hora no encontrada]\";\n    let contenido = mensaje.json.contenido || \"[Sin contenido]\";\n    \n    // Determinar si el mensaje es del usuario o del agente IA\n    let remitente = mensaje.json.chat_id === 'agenteAI' ? 'El Agente ChatBot IA dice:' : 'El usuario dice:';\n    \n    return `Mensaje ${index + 1} enviado el ${fecha} a las ${hora}.\\n${remitente} \"${contenido}\".`;\n});\n\n// Unir todos los mensajes en un solo texto estructurado\nconst historialMensajes = mensajesEstructurados.join('\\n\\n');\n\n// Retornar los datos estructurados\nreturn [{ historialMensajes }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -9056,
        4832
      ],
      "id": "8e6b1514-be6c-4cd6-ba8a-6a3e75ccb438",
      "name": "Organizaci√≥n y estructuracion de mensajes"
    },
    {
      "parameters": {
        "content": "# üì© Agrupa todos los mensajes del usuario\n\n## üîπ Este flujo se encarga de recibir y almacenar los mensajes enviados por el usuario, recuperar el historial completo de la conversaci√≥n, estructurar la informaci√≥n de manera clara y organizada, y enviarla al siguiente proceso para su interpretaci√≥n y respuesta.\n",
        "height": 1000,
        "width": 3480,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -11296,
        4272
      ],
      "typeVersion": 1,
      "id": "c1657091-d406-4aae-8d38-8bedff6e8044",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT DISTINCT * FROM CitasRecepcion\nWHERE chat_id = '{{ $json.chat_id }}'\nAND (estado = 'PROGRAMADA' OR estado = 'REPROGRAMADA')\nORDER BY fecha_creacion ASC;"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        -9200,
        4480
      ],
      "id": "e88f1ec8-9d25-4461-8c85-088b9088680e",
      "name": "Recuperar historial Citas",
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        -9488,
        4480
      ],
      "id": "dd7202a9-1cb5-4cdc-8d25-51726b2132d3",
      "name": "Merge de Datos"
    },
    {
      "parameters": {
        "jsCode": "// Obtener todos los elementos del historial de citas\nconst historialCitas = $input.all();\n\n// Verificar si hay datos\nif (!historialCitas || historialCitas.length === 0) {\n  return [{ historialCitasFormateado: \"No hay historial de citas disponible\" }];\n}\n\n// Funci√≥n para obtener valor seguro\nfunction getValorSeguro(objeto, propiedad) {\n  try {\n    // Intenta acceder directamente\n    if (objeto && objeto[propiedad] !== undefined && objeto[propiedad] !== null) {\n      return objeto[propiedad];\n    }\n    \n    // Intenta acceder a trav√©s de json\n    if (objeto && objeto.json && objeto.json[propiedad] !== undefined && objeto.json[propiedad] !== null) {\n      return objeto.json[propiedad];\n    }\n    \n    return 'N/A';\n  } catch (error) {\n    return 'N/A';\n  }\n}\n\n// Funci√≥n para formatear fecha\nfunction formatearFecha(fechaStr) {\n  if (!fechaStr || fechaStr === 'N/A') return 'N/A';\n  \n  try {\n    const fecha = new Date(fechaStr);\n    return fecha.toLocaleDateString('es-CO', { year: 'numeric', month: 'long', day: 'numeric' });\n  } catch (error) {\n    return fechaStr;\n  }\n}\n\n// Estructurar las citas en un formato claro\nconst citasEstructuradas = historialCitas.map((cita, index) => {\n  // Obtener valores de forma segura\n  const id = getValorSeguro(cita, 'id');\n  const chatId = getValorSeguro(cita, 'chat_id');\n  const nombre = getValorSeguro(cita, 'nombre');\n  const ordenCompra = getValorSeguro(cita, 'orden_compra');\n  const peso = getValorSeguro(cita, 'peso');\n  const unidades = getValorSeguro(cita, 'unidades');\n  const fechaCita = formatearFecha(getValorSeguro(cita, 'fecha_cita'));\n  const estado = getValorSeguro(cita, 'estado');\n  const fechaCreacion = formatearFecha(getValorSeguro(cita, 'fecha_creacion'));\n  const chatHistorial = getValorSeguro(cita, 'chat_historial');\n  \n  // Crear texto estructurado para esta cita\n  let citaTexto = `CITA #${index + 1}\\n`;\n  citaTexto += `ID: ${id}\\n`;\n  citaTexto += `Chat ID: ${chatId}\\n`;\n  citaTexto += `Nombre: ${nombre}\\n`;\n  citaTexto += `Orden de compra: ${ordenCompra}\\n`;\n  citaTexto += `Peso: ${peso}\\n`;\n  citaTexto += `Unidades: ${unidades}\\n`;\n  citaTexto += `Fecha de cita: ${fechaCita}\\n`;\n  citaTexto += `Estado: ${estado}\\n`;\n  citaTexto += `Fecha de creaci√≥n: ${fechaCreacion}\\n`;\n  \n  // Agregar historial de chat si existe\n  if (chatHistorial && chatHistorial !== 'N/A') {\n    citaTexto += `Chat: ${chatHistorial}\\n`;\n  }\n  \n  return citaTexto;\n});\n\n// Unir todas las citas en un solo texto estructurado\nconst historialCitasFormateado = citasEstructuradas.join('\\n\\n');\n\n// Retornar un objeto simple con el texto formateado\nreturn [{ historialCitasFormateado }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -8768,
        4480
      ],
      "id": "20a9bd4a-2977-47f2-9237-7e86cc6a36fb",
      "name": "Organizaci√≥n y estructuracion historial citas"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.removeDuplicates",
      "typeVersion": 2,
      "position": [
        -8976,
        4480
      ],
      "id": "5c021fd3-8fda-4bf3-b685-712fc498c39d",
      "name": "Remueve registros de citas duplicados"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "51f49645-ea1d-4717-8195-837dbb674f73",
              "name": "infoMensajecita.chat_id",
              "value": "={{ $('Remueve registros de citas duplicados').first().json.chat_id }}",
              "type": "string"
            },
            {
              "id": "ae0619ec-87bc-47d7-9b8a-d7b629bbea4a",
              "name": "infoMensajecita.historialCitas",
              "value": "={{ $json.historialCitasFormateado }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -8544,
        4480
      ],
      "id": "38e26d2c-deb5-4c95-98d4-240d2e6b63ec",
      "name": "Organiza el historial de citas"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        -8240,
        4704
      ],
      "id": "18286306-4735-4c83-92fb-5253ebfe3c15",
      "name": "Merge de Datos para session ID"
    },
    {
      "parameters": {
        "jsCode": "const output = {};\n\n// Variables auxiliares para garantizar la estructura fija\noutput.infoMensajecita = { chat_id: \"\", historialCitas: \"\" };\noutput.infoMensaje = { \n    chat_id: \"\", \n    historialMensajes: \"\", \n    count: \"0\", \n    tiempoUltimoMensaje: \"0\", \n    mensajeActual: \"\", \n    fechaMensajeActual: \"\", \n    horaMensajeActual: \"\" \n};\n\n// Recorremos los items de entrada y asignamos los datos si existen\nfor (const item of $input.all()) {\n    if (item.json.infoMensajecita) {\n        output.infoMensajecita = item.json.infoMensajecita;\n    }\n    if (item.json.infoMensaje) {\n        output.infoMensaje = item.json.infoMensaje;\n    }\n}\n\n// Generar Session ID basado en los datos disponibles\noutput.sessionId = output.infoMensajecita.chat_id || output.infoMensaje.chat_id || null;\n\n// Calcular la semana actual\nconst fechaActual = new Date();\nconst inicioAno = new Date(fechaActual.getFullYear(), 0, 1);\nconst diff = fechaActual - inicioAno;\nconst diasDesdeInicio = Math.floor(diff / (1000 * 60 * 60 * 24));\nconst numeroSemana = Math.ceil((diasDesdeInicio + inicioAno.getDay()) / 7);\noutput.hojaSeleccionada = `SEMANA ${numeroSemana}`;\n\n// Devolver un solo objeto con todos los datos unificados\nreturn [{ json: output }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -8000,
        4704
      ],
      "id": "fb498ad1-0d47-4cd3-8579-2f831c5568f4",
      "name": "Unificaci√≥n y consistencia de datos"
    },
    {
      "parameters": {
        "url": "https://graph.microsoft.com/v1.0/sites/a592f886-4560-4e62-9646-1eee7add7abe/drives/b!hviSpWBFYk6WRh7uet16vnNAUYuuQRlGj3ZyS9kSvGVZ4DSg6c5MRqYYm2MdAER8/items/01PPLUUYXY5E2GK3SJ25EZLJPUYJ43H3ME/content",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "microsoftOAuth2Api",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "file",
              "outputPropertyName": "ExcelMallaRecibido2025"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -864,
        1280
      ],
      "id": "f691f761-50ad-42b8-aad9-bdc9d0d7d693",
      "name": "HTTP Request MALLA DE RECIBO 2025",
      "credentials": {
        "microsoftOAuth2Api": {
          "id": "mh8Z8hxFvd7LDO8D",
          "name": "CuentaMy SharePoint App Desarrollador1 Konfie "
        }
      }
    },
    {
      "parameters": {
        "operation": "xlsx",
        "binaryPropertyName": "ExcelMallaRecibido2025",
        "options": {
          "sheetName": "={{ $('Unificaci√≥n y consistencia de datos').item.json.hojaSeleccionada }}"
        }
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -608,
        1168
      ],
      "id": "51252768-e3c0-4af2-841c-a1571dec7217",
      "name": "Extract MALLA DE RECIBO 2025"
    },
    {
      "parameters": {
        "url": "https://graph.microsoft.com/v1.0/drives/b!hviSpWBFYk6WRh7uet16vnNAUYuuQRlGj3ZyS9kSvGVZ4DSg6c5MRqYYm2MdAER8/items/01PPLUUYTWY3753ZJ6ERAZ6LQBYUR2JOTY/content",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "microsoftOAuth2Api",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "file",
              "outputPropertyName": "MallaFija"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -864,
        1664
      ],
      "id": "9e0d1b26-4e64-4e37-8c97-a19fd71917db",
      "name": "HTTP Request Malla Fija",
      "credentials": {
        "microsoftOAuth2Api": {
          "id": "mh8Z8hxFvd7LDO8D",
          "name": "CuentaMy SharePoint App Desarrollador1 Konfie "
        }
      }
    },
    {
      "parameters": {
        "operation": "xlsx",
        "binaryPropertyName": "MallaFija",
        "options": {
          "sheetName": "DatosProveedor"
        }
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -608,
        1520
      ],
      "id": "129ce911-d9c3-4f6f-8155-a130fcadaa8d",
      "name": "Extract Datos Proveedor"
    },
    {
      "parameters": {
        "jsCode": "// Obtener los datos del Excel\nconst excelData = $input.all();\nconst hojaSeleccionada = $('Unificaci√≥n y consistencia de datos').first().json.hojaSeleccionada;\n\n// Obtener hora local en Bogot√°\nconst ahora = new Date(new Date().toLocaleString(\"en-US\", { timeZone: \"America/Bogota\" }));\nconst diaSemanaActual = ahora.getDay(); // 0=domingo, 1=lunes, ..., 5=viernes\nconst horaActual = ahora.getHours();\nconst minutosActual = ahora.getMinutes();\n// Determinar si es despu√©s de las 16:30\nconst pasoLimiteDia = horaActual > 16 || (horaActual === 16 && minutosActual >= 30);\n\n// Definir estructura de la semana y los d√≠as\nconst diasSemana = ['lunes', 'martes', 'mi√©rcoles', 'jueves', 'viernes'];\n\n// Mapeo para saber qu√© d√≠as incluir si hoy es x d√≠a y pas√≥ el l√≠mite\n/**\n * Dado el d√≠a de la semana actual (0=domingo ... 6=s√°bado),\n * devuelve qu√© d√≠as de la semana actual deben incluirse seg√∫n si pas√≥ el l√≠mite.\n */\nfunction diasValidosSemanaActual(diaSemanaActual, pasoLimite) {\n  const mapa = {\n    1: ['martes', 'mi√©rcoles', 'jueves', 'viernes'],   // lunes\n    2: ['mi√©rcoles', 'jueves', 'viernes'],             // martes\n    3: ['jueves', 'viernes'],                          // mi√©rcoles\n    4: ['viernes'],                                     // jueves\n    5: []                                               // viernes (muy tarde para s√°bado)\n  };\n  if (diaSemanaActual < 1 || diaSemanaActual > 5) {\n    return []; // s√°bado o domingo no se agendan en semana actual\n  }\n  if (!pasoLimite) {\n    // a√∫n est√° antes de las 4:30 p.m., se puede incluir el d√≠a siguiente\n    const siguiente = diasSemana[diaSemanaActual];\n    return [siguiente, ...mapa[diaSemanaActual]];\n  }\n  return mapa[diaSemanaActual];\n}\n\n// Objeto para almacenar la malla estructurada\nconst mallaEstructurada = {\n  titulo: \"\",\n  a√±o: \"\",\n  semana: \"\",\n  rangoDias: \"\",\n  franjas: [],\n  dias: {}\n};\n\n// Tabla de meses y d√≠as. Ajusta si necesitas contemplar bisiestos, etc.\nconst meses = {\n  \"enero\": 1,\n  \"febrero\": 2,\n  \"marzo\": 3,\n  \"abril\": 4,\n  \"mayo\": 5,\n  \"junio\": 6,\n  \"julio\": 7,\n  \"agosto\": 8,\n  \"septiembre\": 9,\n  \"octubre\": 10,\n  \"noviembre\": 11,\n  \"diciembre\": 12\n};\n\nconst nombreMes = {\n  1: \"enero\",\n  2: \"febrero\",\n  3: \"marzo\",\n  4: \"abril\",\n  5: \"mayo\",\n  6: \"junio\",\n  7: \"julio\",\n  8: \"agosto\",\n  9: \"septiembre\",\n  10: \"octubre\",\n  11: \"noviembre\",\n  12: \"diciembre\"\n};\n\n/**\n * Funci√≥n para determinar si un a√±o es bisiesto\n * Un a√±o es bisiesto si es divisible por 4, excepto aquellos divisibles por 100 \n * que no son divisibles por 400\n */\nfunction esBisiesto(year) {\n  return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);\n}\n\n/**\n * Funci√≥n para obtener el n√∫mero de d√≠as en un mes, considerando a√±os bisiestos\n */\nfunction getDiasMes(mes, a√±o) {\n  const diasPorMes = {\n    1: 31, // enero\n    2: esBisiesto(a√±o) ? 29 : 28, // febrero - ajustado para a√±o bisiesto\n    3: 31, // marzo\n    4: 30, // abril\n    5: 31, // mayo\n    6: 30, // junio\n    7: 31, // julio\n    8: 31, // agosto\n    9: 30, // septiembre\n    10: 31, // octubre\n    11: 30, // noviembre\n    12: 31  // diciembre\n  };\n  \n  return diasPorMes[mes];\n}\n\n/**\n * Funci√≥n para eliminar acentos y pasar a min√∫sculas (para buscar palabras clave sin importar tildes ni may√∫sculas).\n */\nfunction normalizarTexto(texto) {\n  if (typeof texto !== 'string') return \"\";\n  // Normaliza (NFD) y elimina diacr√≠ticos, luego pasa a min√∫sculas.\n  return texto\n    .normalize(\"NFD\")\n    .replace(/[\\u0300-\\u036f]/g, \"\") // quita acentos\n    .toLowerCase();\n}\n\n/**\n * Dada la informaci√≥n de proveedor, ordenCompra, peso, categor√≠a y unidades,\n * revisa si existe la palabra 'fuera de servicio', 'cancelado' o 'reagendado'\n * en cualquiera de esos campos. De ser as√≠, retorna ese estado especial;\n * de lo contrario, retorna 'ocupado'.\n * \n * Se ignoran may√∫sculas, min√∫sculas y tildes.\n */\nfunction determinarEstadoOcupado(proveedor, ordenCompra, peso, categoria, unidades) {\n  const conjunto = `${proveedor} ${ordenCompra} ${peso} ${categoria} ${unidades}`;\n  const texto = normalizarTexto(conjunto);\n\n  if (texto.includes(\"fuera de servicio\")) {\n    return \"fuera de servicio\";\n  }\n  if (texto.includes(\"cancelado\")) {\n    return \"cancelado\";\n  }\n  if (texto.includes(\"reagendado\")) {\n    return \"reagendado\";\n  }\n  return \"ocupado\";  \n}\n\n// -------------------------------------------------------------\n// 1) PROCESAR DATOS (Cabecera, Horas, Muelles, etc.)\n// -------------------------------------------------------------\nfunction procesarDatos(excelData) {\n  const datos = excelData.map(item => item.json);\n  \n  // A) Cabecera (T√≠tulo, A√±o, Rango)\n  datos.forEach((dato, index) => {\n    // Buscar t√≠tulo\n    if (dato.__EMPTY_2 === \"MALLA DE RECIBO CEDI KONFIE IA\") {\n      mallaEstructurada.titulo = dato.__EMPTY_2;\n      \n      // En la siguiente fila puede estar a√±o, semana, rango\n      if (index + 1 < datos.length) {\n        const datoSiguiente = datos[index + 1];\n        if (datoSiguiente) {\n          // A√±o\n          if (datoSiguiente.__EMPTY_2 && !isNaN(datoSiguiente.__EMPTY_2)) {\n            mallaEstructurada.a√±o = datoSiguiente.__EMPTY_2;\n          }\n          // Semana\n          Object.entries(datoSiguiente).forEach(([k, v]) => {\n            if (typeof v === 'string' && v.includes(\"SEMANA\")) {\n              mallaEstructurada.semana = v;\n            }\n          });\n          // Rango: p.ej. \"LUNES 31 AL VIERNES 4 DE ABRIL\"\n          Object.entries(datoSiguiente).forEach(([k, v]) => {\n            if (typeof v === 'string' && v.includes(\"LUNES\") && v.includes(\"VIERNES\")) {\n              mallaEstructurada.rangoDias = v;\n            }\n          });\n        }\n      }\n    }\n  });\n  \n  // B) Detectar franjas horarias (.__EMPTY = fracci√≥n de d√≠a)\n  const franjasHorarias = [];\n  datos.forEach(dato => {\n    if (\n      dato.__EMPTY !== undefined &&\n      typeof dato.__EMPTY === 'number' &&\n      dato.__EMPTY > 0 &&\n      dato.__EMPTY < 1\n    ) {\n      const totalMin = Math.round(dato.__EMPTY * 24 * 60);\n      const hh = Math.floor(totalMin / 60);\n      const mm = totalMin % 60;\n      \n      let periodo = \"AM\";\n      let hora12 = hh;\n      if (hh >= 12) {\n        periodo = \"PM\";\n        hora12 = (hh === 12 ? 12 : hh - 12);\n      }\n      if (hh === 0) {\n        hora12 = 12;\n      }\n      \n      const horaStr = `${hora12}:${String(mm).padStart(2, '0')} ${periodo}`;\n      franjasHorarias.push({\n        hora: horaStr,\n        indice: datos.indexOf(dato) // fila base\n      });\n    }\n  });\n  franjasHorarias.sort((a, b) => a.indice - b.indice);\n  mallaEstructurada.franjas = franjasHorarias;\n  \n  // C) Detectar muelles (col)\n  const muellesInfo = {};\n  datos.forEach(dato => {\n    Object.entries(dato).forEach(([key, value]) => {\n      if (value === \"MUELLE 01\" || value === \"MUELLE 02\") {\n        const col = parseInt(key.replace(\"__EMPTY_\", \"\"), 10);\n        const muelleKey = (value === \"MUELLE 01\") ? 'muelle1' : 'muelle2';\n        if (!muellesInfo[muelleKey]) {\n          muellesInfo[muelleKey] = [];\n        }\n        muellesInfo[muelleKey].push(col);\n      }\n    });\n  });\n  if (muellesInfo.muelle1) muellesInfo.muelle1.sort((a, b) => a - b);\n  if (muellesInfo.muelle2) muellesInfo.muelle2.sort((a, b) => a - b);\n  \n  // D) Generar los 5 d√≠as (lunes-viernes) con su fecha\n  parsearRangoDias();\n  \n  // E) Extraer Citas\n  extraerCitas(datos, muellesInfo);\n  \n  return mallaEstructurada;\n}\n\n/**\n * Parsea la cadena \"LUNES 31 AL VIERNES 4 DE ABRIL\"\n * (o \"LUNES 31 AL VIERNES 04 DE ABRIL\") y maneja el cruce de mes.\n * Ej.: si dayStart=31 y dayEnd=4, la 1¬™ fecha es 31 de MARZO,\n * luego 1,2,3,4 de ABRIL, en vez de 32,33, etc.\n */\nfunction parsearRangoDias() {\n  const texto = mallaEstructurada.rangoDias;\n  // Regex simple: p.ej. \"31 AL ... 4 DE ABRIL\"\n  // Captura: dayStart, dayEnd, mesFin\n  // Ojo: si dice \"LUNES 31 DE MARZO AL VIERNES 4 DE ABRIL\",\n  // quedar√°: dayStart=31, dayEnd=4, month=ABRIL (al final).\n  const regex = /(\\d+)\\s+AL\\s+\\D+(\\d+)\\s+DE\\s+(\\w+)/i;\n  const match = regex.exec(texto);\n  \n  // Por defecto, creamos 5 d√≠as vac√≠os sin fecha\n  diasSemana.forEach(d => {\n    mallaEstructurada.dias[d] = {\n      muelle1: {},\n      muelle2: {}\n    };\n  });\n  \n  if (!match) {\n    // Sin coincidencia, dejamos los d√≠as sin fecha\n    return;\n  }\n  \n  const dayStart = parseInt(match[1], 10); // 31\n  const dayEnd   = parseInt(match[2], 10); // 4\n  const finalMonthName = match[3].toLowerCase(); // \"abril\"\n  \n  // Convertimos a n√∫mero\n  const finalMonth = meses[finalMonthName] || 3; // fallback marzo\n  const yearNum = parseInt(mallaEstructurada.a√±o, 10) || 2025;\n  \n  // Funci√≥n para obtener la fecha formateada\n  function fechaFormateada(d, m, y) {\n    return `${d} de ${nombreMes[m]} de ${y}`;\n  }\n  \n  // Comprobamos cu√°ntos d√≠as tiene el mes final, considerando bisiestos\n  const diasMesFinal = getDiasMes(finalMonth, yearNum);\n  // y del mes previo\n  const monthPrev = (finalMonth === 1) ? 12 : finalMonth - 1;\n  const yearPrev = (finalMonth === 1) ? yearNum - 1 : yearNum;\n  \n  // Arreglo final con 5 fechas\n  const fechasDias = [];\n  \n  if (dayStart <= dayEnd) {\n    // Caso \"normal\": todo en el mismo mes\n    let d = dayStart;\n    for (let i = 0; i < 5; i++) {\n      fechasDias.push({\n        diaSem: diasSemana[i],\n        diaNum: d,\n        mesNum: finalMonth,\n        yearNum: yearNum\n      });\n      d++;\n      if (d > diasMesFinal) {\n        d = 1;\n        const nextMonth = finalMonth % 12 + 1;\n        const nextYear = (nextMonth === 1) ? yearNum + 1 : yearNum;\n        fechasDias[fechasDias.length - 1].mesNum = nextMonth;\n        fechasDias[fechasDias.length - 1].yearNum = nextYear;\n      }\n    }\n  } else {\n    // Caso \"cruza de mes\": dayStart > dayEnd\n    let d = dayStart;\n    let m = monthPrev;\n    let y = yearPrev;\n    \n    for (let i = 0; i < 5; i++) {\n      fechasDias.push({\n        diaSem: diasSemana[i],\n        diaNum: d,\n        mesNum: m,\n        yearNum: y\n      });\n      d++;\n      if (d > getDiasMes(m, y)) {\n        d = 1;\n        m = m % 12 + 1;\n        if (m === 1) {\n          y++;\n        }\n      }\n    }\n  }\n  \n  // Ahora volcamos esas 5 fechas en la estructura\n  fechasDias.forEach(fd => {\n    const { diaSem, diaNum, mesNum, yearNum } = fd;\n    mallaEstructurada.dias[diaSem] = {\n      fechaDia: fechaFormateada(diaNum, mesNum, yearNum),\n      muelle1: {},\n      muelle2: {}\n    };\n  });\n  \n  // Inicializamos las franjas a 'disponible'\n  if (mallaEstructurada.franjas.length > 0) {\n    diasSemana.forEach(d => {\n      mallaEstructurada.franjas.forEach(f => {\n        mallaEstructurada.dias[d].muelle1[f.hora] = {\n          estado: \"disponible\",\n          proveedor: \"\",\n          ordenCompra: \"\",\n          peso: \"\",\n          categoria: \"\",\n          unidades: \"\"\n        };\n        mallaEstructurada.dias[d].muelle2[f.hora] = {\n          estado: \"disponible\",\n          proveedor: \"\",\n          ordenCompra: \"\",\n          peso: \"\",\n          categoria: \"\",\n          unidades: \"\"\n        };\n      });\n    });\n  }\n}\n\n/**\n * Funci√≥n auxiliar: decide a qu√© d√≠a pertenece una columna,\n * corrigiendo 2 columnas de offset (porque 'Extract from XLSX'\n * deja todo desplazado).\n */\nfunction getDayForColumn(colNumber) {\n  // Ajuste de offset +2\n  const realCol = colNumber + 2;\n\n  // Rangos:\n  //  Lunes:      3..8\n  //  Martes:     9..14\n  //  Mi√©rcoles: 15..20\n  //  Jueves:    21..26\n  //  Viernes:   27..32\n  if (realCol >= 3 && realCol <= 8) {\n    return \"lunes\";\n  }\n  if (realCol >= 9 && realCol <= 14) {\n    return \"martes\";\n  }\n  if (realCol >= 15 && realCol <= 20) {\n    return \"mi√©rcoles\";\n  }\n  if (realCol >= 21 && realCol <= 26) {\n    return \"jueves\";\n  }\n  if (realCol >= 27 && realCol <= 32) {\n    return \"viernes\";\n  }\n  // Si nada coincide, devolvemos null\n  return null;\n}\n\n/**\n * Extraer las citas para cada franja:\n * - Para cada franja, miramos 3 filas:\n *    - Fila base => proveedor\n *    - Fila base+1 => orden\n *    - Fila base+2 => peso, categor√≠a, unidades\n */\nfunction extraerCitas(datos, muellesInfo) {\n  mallaEstructurada.franjas.forEach(franja => {\n    const indiceBase = franja.indice;\n    if (indiceBase < 0 || indiceBase + 2 >= datos.length) {\n      return; // no hay suficientes filas\n    }\n    \n    // Recorremos muelle1, muelle2 y sus columnas\n    const asignarCita = (muelleKey, cols) => {\n      cols.forEach(col => {\n        const provKey = `__EMPTY_${col}`;\n        const filaProv = datos[indiceBase];\n        \n        // Si en esta fila hay un proveedor o alg√∫n texto\n        if (\n          filaProv &&\n          typeof filaProv[provKey] === 'string' &&\n          filaProv[provKey].length > 2\n        ) {\n          // Determinar el d√≠a real\n          const diaOk = getDayForColumn(col);\n          if (!diaOk || !mallaEstructurada.dias[diaOk]) {\n            return; // si no coincide con ninguno, saltamos\n          }\n          \n          // Recuperar valores para proveedor, ordenCompra y dem√°s\n          const filaOrden = datos[indiceBase + 1];\n          const filaDet = datos[indiceBase + 2];\n          \n          const proveedor = filaProv[provKey] || \"\";\n          const ordenCompra = filaOrden && filaOrden[provKey] ? filaOrden[provKey] : \"\";\n          const peso = filaDet && filaDet[provKey] ? filaDet[provKey] : \"\";\n          const cat  = filaDet && filaDet[`__EMPTY_${col + 1}`] ? filaDet[`__EMPTY_${col + 1}`] : \"\";\n          const und  = filaDet && filaDet[`__EMPTY_${col + 2}`] ? filaDet[`__EMPTY_${col + 2}`] : \"\";\n          \n          // Antes pon√≠amos estado=\"ocupado\" directamente\n          // Ahora verificamos si el texto contiene \"reagendado\", \"cancelado\" o \"fuera de servicio\".\n          const nuevoEstado = determinarEstadoOcupado(proveedor, ordenCompra, peso, cat, und);\n          \n          // Asignamos los datos\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].estado = nuevoEstado;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].proveedor = proveedor;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].ordenCompra = ordenCompra;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].peso = peso;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].categoria = cat;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].unidades = und;\n        }\n      });\n    };\n    \n    if (muellesInfo.muelle1) {\n      asignarCita('muelle1', muellesInfo.muelle1);\n    }\n    if (muellesInfo.muelle2) {\n      asignarCita('muelle2', muellesInfo.muelle2);\n    }\n  });\n}\n\n// -------------------------------------------------------------\n// 2) FUNCIONES PARA CONSULTAR LA MALLA\n// -------------------------------------------------------------\nfunction buscarFranjasDisponibles(categoria, duracionHoras) {\n  const muelle = \"muelle1\"; // Ajusta si usas \"categoria -> muelle\" real\n  \n  const franjasDisponibles = [];\n  Object.keys(mallaEstructurada.dias).forEach(dia => {\n    const libres = [];\n    for (let i = 0; i <= mallaEstructurada.franjas.length - duracionHoras; i++) {\n      let disponible = true;\n      for (let h = 0; h < duracionHoras; h++) {\n        const idxF = i + h;\n        const horaAct = mallaEstructurada.franjas[idxF].hora;\n        if (\n          mallaEstructurada.dias[dia][muelle][horaAct].estado !== 'disponible'\n        ) {\n          disponible = false;\n          break;\n        }\n      }\n      if (disponible) {\n        libres.push({\n          horaInicio: mallaEstructurada.franjas[i].hora,\n          duracion: duracionHoras\n        });\n      }\n    }\n    if (libres.length > 0) {\n      franjasDisponibles.push({ dia, franjas: libres });\n    }\n  });\n  return franjasDisponibles;\n}\n\nfunction buscarCitasProveedor(nombreProveedor) {\n  const citas = [];\n  Object.keys(mallaEstructurada.dias).forEach(dia => {\n    const muelle1 = mallaEstructurada.dias[dia].muelle1;\n    const muelle2 = mallaEstructurada.dias[dia].muelle2;\n    mallaEstructurada.franjas.forEach(f => {\n      const hora = f.hora;\n      // muelle1\n      if (normalizarTexto(muelle1[hora].proveedor) === normalizarTexto(nombreProveedor)) {\n        citas.push({\n          dia,\n          hora,\n          muelle: \"Muelle 01\",\n          ordenCompra: muelle1[hora].ordenCompra,\n          peso: muelle1[hora].peso,\n          categoria: muelle1[hora].categoria,\n          unidades: muelle1[hora].unidades,\n          estado: muelle1[hora].estado\n        });\n      }\n      // muelle2\n      if (normalizarTexto(muelle2[hora].proveedor) === normalizarTexto(nombreProveedor)) {\n        citas.push({\n          dia,\n          hora,\n          muelle: \"Muelle 02\",\n          ordenCompra: muelle2[hora].ordenCompra,\n          peso: muelle2[hora].peso,\n          categoria: muelle2[hora].categoria,\n          unidades: muelle2[hora].unidades,\n          estado: muelle2[hora].estado\n        });\n      }\n    });\n  });\n  return citas;\n}\n\nfunction consultarFranjasDisponibles(categoria, duracionHoras) {\n  return buscarFranjasDisponibles(categoria, duracionHoras);\n}\n\nfunction consultarCitasProveedor(nombreProveedor) {\n  return buscarCitasProveedor(nombreProveedor);\n}\n\nfunction obtenerInfoMalla() {\n  return {\n    titulo: mallaEstructurada.titulo,\n    a√±o: mallaEstructurada.a√±o,\n    semana: mallaEstructurada.semana,\n    rangoDias: mallaEstructurada.rangoDias,\n    franjas: mallaEstructurada.franjas.map(f => f.hora)\n  };\n}\n\nfunction estaDisponible(dia, hora, muelle) {\n  const info = mallaEstructurada.dias[dia]?.[muelle]?.[hora];\n  return info ? (info.estado === 'disponible') : false;\n}\n\nfunction obtenerCoordenadasCita(dia, hora, muelle) {\n  // Ajustar con tu mapeo de celdas en Excel\n  return {\n    proveedor: `${dia}_${hora}_${muelle}_proveedor`,\n    ordenCompra: `${dia}_${hora}_${muelle}_ordenCompra`,\n    peso: `${dia}_${hora}_${muelle}_peso`,\n    categoria: `${dia}_${hora}_${muelle}_categoria`,\n    unidades: `${dia}_${hora}_${muelle}_unidades`\n  };\n}\n\n// -------------------------------------------------------------\n// 3) EJECUTAR TODO Y RETORNAR\n// -------------------------------------------------------------\n// Procesar todos los datos\nconst malla = procesarDatos(excelData);\n\n// Aplicar el filtro de d√≠as v√°lidos seg√∫n la hora actual\nconst diasPermitidos = diasValidosSemanaActual(diaSemanaActual, pasoLimiteDia);\nObject.keys(malla.dias).forEach(dia => {\n  if (!diasPermitidos.includes(dia)) {\n    delete malla.dias[dia]; // eliminar d√≠as no v√°lidos\n  }\n});\n\nconst resultado = {\n  datosMalla: malla,\n  funciones: {\n    consultarFranjasDisponibles,\n    consultarCitasProveedor,\n    obtenerInfoMalla,\n    estaDisponible,\n    obtenerCoordenadasCita\n  }\n};\n\nreturn [resultado];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -368,
        1168
      ],
      "id": "690346a3-9996-4de8-addd-1658c11b7e4d",
      "name": "Estructuraci√≥n, Datos, Consulta, Citas"
    },
    {
      "parameters": {
        "jsCode": "// Obtener todos los items de la entrada\nconst items = $input.all();\nconst datosProveedores = [];\n\n// Recorrer cada √≠tem de la entrada\nfor (const item of items) {\n  // Ahora sabemos exactamente c√≥mo se llaman los campos en el JSON original\n  const originalData = item.json;\n  \n  // Crear objeto con los campos normalizados\n  const nuevoObjeto = {\n    // Los campos principales que siempre deben estar presentes\n    proveedor: originalData.PROVEEDOR || \"\",\n    rotacion: originalData.ROTACION || \"\",\n    unidadesPorHora: originalData[\"UNIDADES X HORA\"] || 0,\n    \n    // Los campos que tienen espacios al final en los nombres\n    // Nota: \"Tipo de Proveedor \" tiene un espacio al final\n    tipoProveedor: originalData[\"Tipo de Proveedor \"] || \"\",\n    \n    // \"Dia \" tambi√©n tiene un espacio al final\n    dia: originalData[\"Dia \"] || \"\",\n    \n    // Este campo tiene un espacio en medio y otro al final\n    numeroDia: originalData[\"Dia _1\"] || 0,\n    \n    // Este campo no tiene espacios extras\n    hora: originalData.Hora || 0,\n    \n    // Campos adicionales que podr√≠an ser √∫tiles\n    cantidadSedes: originalData[\"Cantidad de Sedes\"] || 0\n  };\n  \n  // A√±adir el nuevo objeto al array de resultados\n  datosProveedores.push(nuevoObjeto);\n}\n\n// Retornar un √∫nico objeto que contiene el array de datos de proveedores\n// dentro de un par√°metro global llamado \"datosproveedor\"\nreturn [\n  {\n    json: {\n      datosproveedor: datosProveedores\n    }\n  }\n];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -368,
        1520
      ],
      "id": "de9151d0-2727-457c-a758-452df721620d",
      "name": "Estructuraci√≥n, Consulta, Datos Proveedor"
    },
    {
      "parameters": {
        "numberInputs": 4
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.1,
      "position": [
        -48,
        1440
      ],
      "id": "19f2d674-d61b-4a89-b03b-71a3694de2af",
      "name": "Merge datos Excel"
    },
    {
      "parameters": {
        "operation": "xlsx",
        "binaryPropertyName": "MallaFija",
        "options": {
          "sheetName": "Categorias"
        }
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -608,
        1744
      ],
      "id": "69a23486-e553-4430-9991-9bb2f75712b2",
      "name": "Extract from Categorias"
    },
    {
      "parameters": {
        "jsCode": "// Obtener todos los items de la entrada\nconst items = $input.all();\nconst categorias = [];\n\n// Mapa para verificar categor√≠as duplicadas\nconst categoriasMap = new Map();\n\n// Recorrer cada √≠tem de la entrada de categor√≠as\nfor (const item of items) {\n  // Obtener los datos originales\n  const originalData = item.json;\n  \n  // Extraer categor√≠a y muelle\n  const categoria = originalData.CATEGORIA || \"\";\n  const muelle = originalData.MUELLE || \"\";\n  \n  // Solo procesar si tanto la categor√≠a como el muelle tienen valor\n  if (categoria && muelle) {\n    // Verificar si esta categor√≠a ya existe en nuestro mapa\n    if (categoriasMap.has(categoria)) {\n      console.log(`Advertencia: La categor√≠a \"${categoria}\" est√° duplicada. Se ignorar√° la segunda aparici√≥n.`);\n      continue; // Saltar este elemento\n    }\n    \n    // Agregar al mapa para control de duplicados\n    categoriasMap.set(categoria, muelle);\n    \n    // Agregar el objeto al array de categor√≠as\n    categorias.push({\n      \"CATEGORIA\": categoria,\n      \"MUELLE\": muelle\n    });\n  } else {\n    console.log(`Advertencia: Elemento ignorado por falta de categor√≠a o muelle: ${JSON.stringify(originalData)}`);\n  }\n}\n\n// Retornar un √∫nico objeto que contiene el array de categor√≠as\n// dentro de un par√°metro global llamado \"datoscategorias\"\nreturn [\n  {\n    json: {\n      datoscategorias: categorias\n    }\n  }\n];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -368,
        1744
      ],
      "id": "243cc8e2-fb78-43d7-a5aa-fd28a56626b7",
      "name": "Estructuraci√≥n, Consulta, Datos Categorias"
    },
    {
      "parameters": {
        "jsCode": "return [{\n  json: {\n    datosMalla: $items(\"Merge datos Excel\")[0].json.datosMalla,\n    datosMallaProxSemana: $items(\"Merge datos Excel\")[1].json.datosMallaProxSemana,\n    datosproveedor: $items(\"Merge datos Excel\")[2].json.datosproveedor,\n    datoscategorias: $items(\"Merge datos Excel\")[3].json.datoscategorias,\n    hojaSeleccionada: $items(\"Merge datos Excel\")[0].json.datosMalla.semana\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        208,
        1472
      ],
      "id": "bc7c6ce8-b99d-4759-92fb-d601a688b7c2",
      "name": "Unificaci√≥n y consistencia de datos1"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -7744,
        4880
      ],
      "id": "4946572d-94b1-4b5a-94db-b0e2442f4c14",
      "name": "OpenAI Chat Model1",
      "credentials": {
        "openAiApi": {
          "id": "AD8kPcNVReuclASd",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "=define",
        "text": "=# SISTEMA\nEres un asistente especializado en log√≠stica y gesti√≥n de citas en bodega. Tu tarea es clasificar la intenci√≥n principal del mensaje recibido por un proveedor que se comunica por WhatsApp, con base en el mensaje actual y el historial completo.\nEste modelo no valida datos, solo detecta la intenci√≥n principal del mensaje, considerando el contexto previo.\n\n## REGLA DE PRIORIDAD M√ÅXIMA\n**SI EL MENSAJE CONTIENE LA PALABRA EXACTA \"ELIMINAR_MENSAJES\" EN MAY√öSCULAS, LA INTENCI√ìN ES SIEMPRE \"ELIMINAR_MENSAJES\", SIN IMPORTAR CUALQUIER OTRO CONTENIDO.**\n\n## POSIBLES INTENCIONES (en orden de prioridad)\n1.  **ELIMINAR_MENSAJES** ‚Üí Cuando el mensaje contiene exactamente la palabra \"ELIMINAR_MENSAJES\" en may√∫sculas.\n2.  **SALUDO** ‚Üí Cuando el proveedor dice \"Hola\", \"Buenos d√≠as\", etc. sin contexto adicional.\n3.  **CREAR_CITA** ‚Üí Cuando desea agendar una cita de entrega o est√° proporcionando datos para una nueva cita, **incluso si cambia de opini√≥n sobre los datos varias veces.**\n4.  **EDITAR_CITA** ‚Üí Cuando quiere modificar una cita que **ya tiene programada y menciona su ID de cita**.\n5.  **CANCELAR_CITA** ‚Üí Cuando quiere anular una cita **agendada y menciona su ID de cita**.\n6.  **CONSULTAR_MALLA** ‚Üí Cuando pregunta por disponibilidad de horarios o franjas.\n7.  **PREGUNTA_GENERAL** ‚Üí Cuando hace una pregunta no relacionada con citas.\n8.  **CONFIRMACION_CITA** ‚Üí Cuando selecciona una franja horaria espec√≠fica de opciones previamente ofrecidas.\n\n## DATOS DE ENTRADA\n**Mensaje actual del proveedor:**\n```\n{{ $json.infoMensaje.mensajeActual }}\n```\n\n**Historial completo de conversaci√≥n:**\n```\n{{ $json.infoMensaje.historialMensajes }}\n```\n\n**Historial de citas del proveedor (si aplica):**\n```\n{{ $json.infoMensajecita.historialCitas }}\n\n## INSTRUCCIONES DE CLASIFICACI√ìN\n\n### PASO 1: VERIFICACI√ìN DE ELIMINAR_MENSAJES\nBusca PRIMERO si el mensaje actual contiene exactamente \"ELIMINAR_MENSAJES\" en may√∫sculas.\n- Si la encuentra ‚Üí INTENCI√ìN: ELIMINAR_MENSAJES (termina aqu√≠)\n- Si no la encuentra ‚Üí contin√∫a con el PASO 2\n\n### PASO 2: AN√ÅLISIS CONTEXTUAL INTELIGENTE\n1. Lee TODO el historial de conversaci√≥n para establecer el contexto.\n2. **Diferencia clave:** ¬øEl usuario ha mencionado un ID de cita existente (ej: \"cita 12345\")?\n   - **Si S√ç ha mencionado un ID:** El contexto es `EDITAR_CITA` o `CANCELAR_CITA`.\n   - **Si NO ha mencionado un ID:** El contexto es `CREAR_CITA`, incluso si cambia de opini√≥n sobre la fecha/hora.\n\n### CRITERIOS ESPEC√çFICOS POR INTENCI√ìN\n\n<!-- CAMBIO CLAVE: Se redefine CREAR_CITA para ser m√°s tolerante a los cambios de opini√≥n. -->\n**CREAR_CITA:**\n- Expresa deseo de agendar una cita nueva (sin mencionar ID de cita existente).\n- Proporciona datos iniciales (nombre, categor√≠a, peso).\n- **Cambia de opini√≥n sobre la fecha, hora o cualquier otro dato durante el proceso de creaci√≥n.** Mientras no se haya confirmado una cita y generado un ID, sigue siendo parte del flujo de CREACI√ìN.\n- Completa informaci√≥n faltante para una nueva cita.\n\n**EDITAR_CITA:**\n- **REQUISITO INDISPENSABLE: El usuario debe mencionar un ID de cita existente.**\n- Proveedor solicita reprogramar/modificar una cita ya confirmada.\n- Proporciona nuevos datos (fecha/hora) para una cita existente identificada por su ID.\n- Responde a solicitudes del sistema para la reprogramaci√≥n de una cita espec√≠fica.\n\n**CONFIRMACION_CITA:**\n- SOLO cuando el sistema present√≥ una lista numerada de horarios o una √∫nica opci√≥n para confirmar.\n- El mensaje del proveedor es una elecci√≥n clara de esas opciones (ej: \"la 2\", \"confirmo\", \"s√≠, esa est√° bien\").\n- **NO es una confirmaci√≥n si el usuario propone una fecha/hora completamente nueva.**\n\n**CANCELAR_CITA:**\n- **REQUISITO INDISPENSABLE: El usuario debe mencionar un ID de cita existente.**\n- Solicita expl√≠citamente cancelar/anular una cita.\n- Menciona que no podr√° asistir a una cita programada, haciendo referencia a ella.\n\n**CONSULTAR_MALLA:**\n- Pregunta por disponibilidad sin datos espec√≠ficos.\n- Solicita ver horarios disponibles.\n\n**PREGUNTA_GENERAL:**\n- Preguntas sobre ubicaci√≥n, tel√©fono, otros procesos.\n- Cualquier tema no relacionado con citas.\n\n**SALUDO:**\n- Saludos sin contexto adicional.\n- Primera interacci√≥n sin m√°s informaci√≥n.\n\n## REGLAS IMPORTANTES\n1. La palabra \"ELIMINAR_MENSAJES\" tiene prioridad absoluta.\n2. Si el mensaje es ambiguo, usa SIEMPRE el contexto del historial para determinar si ya se est√° trabajando sobre una cita con ID (EDITAR) o si es una nueva (CREAR).\n3. **Un cambio de fecha/hora sin mencionar un ID de cita es parte de `CREAR_CITA`.**\n4. Una vez establecido un contexto (ej. reprogramar la cita 12345), mant√©n ese contexto hasta cambio expl√≠cito de tema.\n5. Solo clasifica, no valides ni interpretes emociones.\n\n## FORMATO DE RESPUESTA\nEscribe √öNICAMENTE la intenci√≥n detectada en este formato:\nINTENCION: [NOMBRE_INTENCION]\n\n### EJEMPLOS\n\n**Ejemplo 1 - ELIMINAR_MENSAJES**\nMensaje: \"Hola, necesito ELIMINAR_MENSAJES por favor\"\nRespuesta: INTENCION: ELIMINAR_MENSAJES\n\n**Ejemplo 2 - EDITAR_CITA (Correcto)**\nHistorial: Usuario dijo \"quiero reprogramar mi cita 12345\"\nMensaje actual: \"Mi orden es ABC123\"\nRespuesta: INTENCION: EDITAR_CITA\n\n<!-- CAMBIO CLAVE: Se ajusta el ejemplo para reflejar la nueva l√≥gica. -->\n**Ejemplo 3 - CREAR_CITA (con cambio de opini√≥n)**\nHistorial: Bot ofrece alternativas para el 17 de julio.\nMensaje actual: \"No mejor quiero la cita para el 18 de julio\"\nAn√°lisis: No hay ID de cita. El usuario sigue definiendo los datos para una NUEVA cita.\nRespuesta: INTENCION: CREAR_CITA\n\n**Ejemplo 4 - CONFIRMACION_CITA**\nHistorial: Sistema ofreci√≥ \"1) 9:00 AM, 2) 10:00 AM, 3) 11:00 AM\"\nMensaje actual: \"La 2\"\nRespuesta: INTENCION: CONFIRMACION_CITA\n\n**Ejemplo 5 - SALUDO**\nMensaje: \"Buenos d√≠as\"\nRespuesta: INTENCION: SALUDO\n\n## RECORDATORIO FINAL\n1. Busca PRIMERO \"ELIMINAR_MENSAJES\" en may√∫sculas.\n2. Si no est√°, analiza el contexto completo. **La presencia de un ID de cita es el factor decisivo entre CREAR y EDITAR/CANCELAR.**\n3. Clasifica seg√∫n el flujo en curso, permitiendo cambios de opini√≥n dentro del flujo de `CREAR_CITA`.\n4. Responde SOLO con el formato indicado."
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        -7648,
        4672
      ],
      "id": "ad54b474-7564-4423-8d06-c07f1c0506a1",
      "name": "Basic LLM CLASIFICADOR"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.intencionDetectada }}",
                    "rightValue": "SALUDO",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "9dcab097-7554-4462-a979-fdf8536d0486"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "SALUDO"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "e006f52b-8954-4501-a9bb-a1afd0d9ded9",
                    "leftValue": "={{ $json.intencionDetectada }}",
                    "rightValue": "CREAR_CITA",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "CREAR_CITA"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "2d70e739-97ca-4370-90d6-a54d59aa360e",
                    "leftValue": "={{ $json.intencionDetectada }}",
                    "rightValue": "CONFIRMACION_CITA",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "CONFIRMACION_CITA"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "73fa4c42-bcd5-4680-87bd-b90baa1c4fce",
                    "leftValue": "={{ $json.intencionDetectada }}",
                    "rightValue": "EDITAR_CITA",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "EDITAR_CITA"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "029fb8dc-7e9f-4dfa-bec0-a933c7d06c53",
                    "leftValue": "={{ $json.intencionDetectada }}",
                    "rightValue": "CANCELAR_CITA",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "CANCELAR_CITA"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "e38bba1f-bf89-4389-b6dc-b8093dc344e1",
                    "leftValue": "={{ $json.intencionDetectada }}",
                    "rightValue": "CONSULTAR_MALLA",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "CONSULTAR_MALLA"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "e6ea3bd9-d425-42e2-8f6b-69342b093cff",
                    "leftValue": "={{ $json.intencionDetectada }}",
                    "rightValue": "PREGUNTA_GENERAL",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "PREGUNTA_GENERAL"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "63eae036-bb70-4b9a-a67a-7fe6e2886456",
                    "leftValue": "={{ $json.intencionDetectada }}",
                    "rightValue": "ELIMINAR_MENSAJES",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "ELIMINAR_MENSAJES"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -7040,
        4592
      ],
      "id": "00d1ac3f-8dd7-48e9-8a40-891a72b29bfa",
      "name": "Switch basado en intenci√≥n"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -880,
        432
      ],
      "id": "fec56d3d-ee99-44b5-a9d3-0d259f7581d3",
      "name": "OpenAI Chat Model2",
      "credentials": {
        "openAiApi": {
          "id": "AD8kPcNVReuclASd",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "return [{\n  json: {\n    intencionDetectada: $json.text ? $json.text.replace(\"INTENCION: \", \"\").trim() : \"\"\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -7264,
        4672
      ],
      "id": "75371ad0-71cb-4617-b6dc-f7301bfd51e0",
      "name": "Almacenar la intenci√≥n detectada"
    },
    {
      "parameters": {
        "promptType": "=define",
        "text": "=### SISTEMA\n\nEres un asistente especializado en log√≠stica de bodegas, encargado de atender proveedores que escriben por WhatsApp para gestionar sus citas de descarga de mercanc√≠a.\n\nTrabajas para **Konf√≠e IA Logistics**, y tu funci√≥n es actuar como un **coordinador de citas automatizado** en la bodega, ofreciendo un servicio amable, eficiente y profesional.\n\nTu tarea es responder cuando el proveedor inicia la conversaci√≥n con un saludo (como \"Hola\", \"Buenos d√≠as\", etc.).\n\n---\n\nüïê Usa la hora del mensaje actual ({{ $('Unificaci√≥n y consistencia de datos').item.json.infoMensaje.horaMensajeActual }}) para elegir el saludo correcto:\n- Entre 06:00 y 11:59 ‚Üí \"Buenos d√≠as\"\n- Entre 12:00 y 17:59 ‚Üí \"Buenas tardes\"\n- Entre 18:00 y 05:59 ‚Üí \"Buenas noches\"\n\n---\n\nTu mensaje debe:\n\n- Saludar cordialmente seg√∫n la hora.\n- Presentarte como el **asistente virtual de Konf√≠e IA Logistics**.\n- Explicar que puedes ayudar a:\n  - Agendar una nueva cita para descarga.\n  - Consultar disponibilidad de franjas.\n  - Editar una cita ya programada.\n  - Cancelar una entrega programada.\n- Mostrarte disponible y servicial.\n- No solicitar datos todav√≠a.\n- Si el proveedor tiene **citas activas en su historial**, puedes mencionarlo suavemente:  \n  > ‚ÄúVeo que ya tienes citas agendadas. Si deseas hacer alg√∫n ajuste o consultar algo, estoy para ayudarte.‚Äù\n- Si el mensaje o el historial **sugiere** que el proveedor quiere saber disponibilidad, puedes decir algo como:  \n  > ‚ÄúSi quieres revisar disponibilidad, puedes contarme el d√≠a y la categor√≠a del producto, y con gusto te ayudar√©.‚Äù  \n  (No lo pidas directamente, solo sugi√©relo amablemente.)\n\n---\n\n### üßæ MENSAJE ACTUAL DEL PROVEEDOR:\n{{ $('Unificaci√≥n y consistencia de datos').first().json.infoMensaje.mensajeActual }}\n\n---\n\n### üóÇÔ∏è HISTORIAL DE MENSAJES:\n{{ $node[\"Unificaci√≥n y consistencia de datos\"].json[\"infoMensaje\"][\"historialMensajes\"] }}\n\n---\n\n### üìÜ HISTORIAL DE CITAS DEL PROVEEDOR:\n{{ $node[\"Unificaci√≥n y consistencia de datos\"].json[\"infoMensajecita\"][\"historialCitas\"] }}\n\n---\n\n### üß† FORMATO DE RESPUESTA (JSON v√°lido):\n```json\n{\n  \"mensajeSistema\": \"Texto cordial, humano y claro presentando al sistema, explicando qu√© puede hacer por el proveedor, y dejando la conversaci√≥n abierta para que contin√∫e.\"\n}\n"
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        -800,
        224
      ],
      "id": "9640dddc-ae54-4d52-bbaf-cd7181fd16f9",
      "name": "Basic LLM CONVERSACI√ìN (SALUDO)"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        1008,
        1648
      ],
      "id": "b44ac30f-5f4e-48d9-9290-49c8e2e6b4db",
      "name": "OpenAI Chat Model3",
      "credentials": {
        "openAiApi": {
          "id": "AD8kPcNVReuclASd",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "=define",
        "text": "=# Prompt para el Asistente de Log√≠stica de Bodegas\n\n## SISTEMA\nEres un asistente experto en log√≠stica de bodegas, especializado en comunicar informaci√≥n sobre citas de descarga de mercanc√≠a. Tu funci√≥n ahora es:\n\n1. **Interpretar los resultados de la validaci√≥n** que ya fue realizada por el nodo de c√≥digo JavaScript.\n2. **Generar mensajes humanos, claros y amables** para comunicarse con los proveedores.\n3. **NO repetir el procesamiento de validaci√≥n** ya que esto se hizo en el nodo de c√≥digo anterior.\n4. **Mantener el formato de salida JSON** requerido por el sistema.\n\n## DETECCI√ìN DE DATOS CONTRADICTORIOS\nSi detectas m√∫ltiples fechas/horas diferentes en el historial que contradicen el mensaje actual:\n- Identifica inconsistencias en los datos proporcionados\n- Prioriza SIEMPRE la informaci√≥n m√°s reciente del usuario  \n- Si hay confusi√≥n excesiva (3+ cambios de fecha), marca como \"datos_contradictorios\"\n\n---\n### üìä RESULTADOS DE LA VALIDACI√ìN:\n```json\n{{ JSON.stringify($node[\"Code RECOLECCI√ìN\"].json, null, 2) }}\n```\n\n### üìã CATEGOR√çAS DISPONIBLES (USAR SOLO ESTAS):\n```json\n{{ $items(\"Estructuraci√≥n, Consulta, Datos Categorias\")[0].json.datoscategorias.map(cat => cat.CATEGORIA) }}\n```\n\n### üßæ MENSAJE ACTUAL DEL PROVEEDOR:\n{{ $('Unificaci√≥n y consistencia de datos').first().json.infoMensaje.mensajeActual }}\n\n### üïì FECHA Y HORA ACTUAL (BOGOT√Å, COLOMBIA):\n{{ new Date().toLocaleString(\"es-CO\", { timeZone: \"America/Bogota\", hour12: true }) }}\n\n### üìù INSTRUCCIONES PARA GENERAR RESPUESTAS:\n\n#### 1. SI TODO EST√Å CORRECTO (`todoCorrecto: true`):\n- Genera un mensaje confirmando que la cita ha sido registrada exitosamente.\n- Incluye todos los detalles identificados: proveedor completo, fecha, hora, categor√≠a, peso, unidades, n√∫mero de orden.\n- Usa un tono profesional y amable, agradeciendo por la informaci√≥n completa.\n- Ejemplo: \"He registrado tu cita para SPB COLOMBIA S.A.S. el d√≠a 14 de abril a las 10:00 AM, categor√≠a ARENAS, 300 kilos, 900 unidades con n√∫mero de orden ARGM47896. Tu cita ha sido registrada con √©xito.\"\n- IMPORTANTE: NO solicites confirmaciones innecesarias cuando todos los datos est√©n correctos.\n\n#### 2. SI HAY DATOS PREVIAMENTE CONFIRMADOS (`datosPreviamenteConfirmados: true`):\n- Genera un mensaje final confirmando que la cita ha sido registrada con √©xito.\n- Incluye todos los detalles ya confirmados: proveedor, fecha, hora, etc.\n- Usa un tono de cierre, agradeciendo por la confirmaci√≥n.\n- Ejemplo: \"¬°Perfecto! He confirmado tu cita para SPB COLOMBIA S.A.S. el d√≠a 14 de abril a las 10:00 AM. Tu cita ha sido registrada con √©xito.\"\n\n#### 3. SI HAY PROVEEDORES SIMILARES QUE REQUIEREN CONFIRMACI√ìN:\n- Cuando `proveedoresSimilares` no est√© vac√≠o, genera un mensaje pidiendo confirmaci√≥n espec√≠fica del proveedor.\n- Lista las opciones de proveedores de forma clara y ordenada.\n- Incluye los dem√°s datos ya confirmados (fecha, hora, categor√≠a, etc.).\n- Ejemplo: \"He identificado varios proveedores que coinciden con tu solicitud. Por favor, confirma cu√°l deseas usar:\\n- SPB COLOMBIA S.A.S.\\n- SOPORTE PRODUCTIVO S.A.S.\\nLos dem√°s datos de tu cita (14 de abril a las 10:00 AM, categor√≠a ARENAS, 300 kilos, 900 unidades) ya est√°n registrados.\"\n\n#### 4. SI HAY CATEGOR√çAS SIMILARES QUE REQUIEREN CONFIRMACI√ìN:\n- Cuando `categoriasSimilares` no est√© vac√≠o, genera un mensaje pidiendo confirmaci√≥n espec√≠fica de la categor√≠a.\n- Lista las opciones de categor√≠as de forma clara y ordenada.\n- Incluye los dem√°s datos ya confirmados (proveedor, fecha, hora, etc.).\n\n#### 5. SI FALTAN CAMPOS OBLIGATORIOS:\n- Cuando `camposFaltantes` no est√© vac√≠o, genera un mensaje solicitando espec√≠ficamente los campos faltantes.\n- **USA EL FORMATO AMIGABLE Y ESTRUCTURADO** con lista para cada campo faltante.\n- **IMPORTANTE: SIEMPRE usa las categor√≠as del nodo de datos, NUNCA uses ejemplos hardcodeados**.\n- Proporciona ejemplos claros para cada campo.\n- Template de respuesta:\n```\nGracias por tu solicitud. Para poder agendar tu cita de entrega, necesito que me proporciones la siguiente informaci√≥n:\n[SI FALTA PROVEEDOR] ‚Ä¢ El nombre del proveedor (proporcionar el nombre lo m√°s completo posible)\n[SI FALTA CATEGOR√çA] ‚Ä¢ La categor√≠a del material (los cuales pueden ser: {{ $items(\"Estructuraci√≥n, Consulta, Datos Categorias\")[0].json.datoscategorias.map(cat => cat.CATEGORIA).map(cat => cat.toUpperCase()).join(', ') }})\n[SI FALTA FECHA] ‚Ä¢ La fecha de entrega (ejemplo: 25 de junio)\n[SI FALTA HORA] ‚Ä¢ La hora de entrega (ejemplo: 9:00 AM)\n[SI FALTA PESO] ‚Ä¢ El peso de la mercanc√≠a (ejemplo: 300 kilos)\n[SI FALTA UNIDADES] ‚Ä¢ La cantidad de unidades a descargar (ejemplo: 600 unidades)\n[SI FALTA ORDEN] ‚Ä¢ El n√∫mero de orden de compra (ejemplo: ARGM47896)\n\nPor favor, proporciona estos datos para completar tu solicitud.\n```\n\n#### 6. NUEVAS VERIFICACIONES DE FECHA Y HORA:\n- Si `fechaValida` es `false` o `horaValida` es `false`, debes comunicar al usuario el problema espec√≠fico.\n- Utiliza el mensaje que viene en `mensajeValidacionTemporal` para explicar el motivo del rechazo.\n- Solicita al usuario que proporcione una fecha u hora v√°lida seg√∫n corresponda.\n\n#### 7. SI LA FECHA SOLICITADA ES PARA UN D√çA NO H√ÅBIL:\n- Si `diaHabil` es `false`, debes informar al usuario que solo se pueden agendar citas en d√≠as h√°biles (lunes a viernes).\n- Sugiere al usuario que elija una fecha en d√≠a h√°bil cercano.\n\n#### 8. SI EL NODO DE VALIDACI√ìN DETECT√ì UNA FECHA \"MA√ëANA\" PERO LA INTERPRET√ì INCORRECTAMENTE:\n- Si el mensaje actual contiene la palabra \"ma√±ana\" pero la fecha validada no corresponde al d√≠a siguiente, debes corregirlo.\n- Verifica que, si el usuario dice \"ma√±ana\", la fecha debe ser el d√≠a siguiente al actual.\n\n### ‚ö†Ô∏è REGLAS CR√çTICAS SOBRE CATEGOR√çAS:\n\n1. **NUNCA uses categor√≠as de ejemplo o hardcodeadas**. SIEMPRE obt√©n las categor√≠as del nodo: {{ $items(\"Estructuraci√≥n, Consulta, Datos Categorias\")[0].json.datoscategorias.map(cat => cat.CATEGORIA) }}\n\n2. **Para mostrar categor√≠as en negrilla sin asteriscos visibles**, usa uno de estos formatos:\n   - En texto plano: simplemente lista las categor√≠as en MAY√öSCULAS separadas por comas\n   - Con vi√±etas: usa el s√≠mbolo ‚Ä¢ antes de cada elemento\n\n3. **Elimina TODOS los ejemplos de categor√≠as hardcodeadas** del prompt. Solo usa las categor√≠as din√°micas.\n\n### ‚ö†Ô∏è OTRAS REGLAS IMPORTANTES:\n\n1. **NUNCA pidas confirmaci√≥n cuando el nodo de c√≥digo ya determin√≥ que todo est√° correcto** (`todoCorrecto: true`).\n\n2. **NUNCA pidas confirmaci√≥n para datos que ya fueron correctamente identificados**.\n\n3. **Usa un lenguaje humano, amable y natural**, evitando tecnicismos.\n\n4. **No repitas datos innecesariamente** ni hagas preguntas redundantes.\n\n5. **No permitas citas para el mismo d√≠a con menos de 2 horas de anticipaci√≥n**.\n\n6. **Rechaza expl√≠citamente las citas para d√≠as no h√°biles** (fines de semana).\n\n7. **SIEMPRE obt√©n las categor√≠as disponibles del nodo correspondiente**.\n\n### üìã EJEMPLOS DE RESPUESTAS (IMPORTANTE: NO uses las categor√≠as de estos ejemplos):\n\n#### EJEMPLO 1 - TODO CORRECTO:\n```json\n{\n  \"todoCorrecto\": true,\n  \"datosPreviamenteConfirmados\": false,\n  \"camposFaltantes\": [],\n  \"proveedoresSimilares\": [],\n  \"categoriasSimilares\": [],\n  \"fechaSolicitada\": \"14 de abril de 2025\",\n  \"horaSolicitada\": \"10:00 AM\",\n  \"mensajeSistema\": \"He registrado tu cita para [PROVEEDOR] el d√≠a [FECHA] a las [HORA], categor√≠a [CATEGOR√çA REAL DEL NODO], con un peso de [PESO] kilos y [UNIDADES] unidades. Tu n√∫mero de orden de compra [ORDEN] ha sido registrado. Tu cita ha sido confirmada exitosamente.\",\n  \"mensajeEstado\": \"datos_completos\",\n  \"motivoRechazo\": \"\"\n}\n```\n\n#### EJEMPLO 2 - FALTA INFORMACI√ìN COMPLETA:\n```json\n{\n  \"todoCorrecto\": false,\n  \"datosPreviamenteConfirmados\": false,\n  \"camposFaltantes\": [\"proveedor\", \"categor√≠a\", \"fecha\", \"hora\", \"peso\", \"unidades\", \"orden de compra\"],\n  \"proveedoresSimilares\": [],\n  \"categoriasSimilares\": [],\n  \"fechaSolicitada\": \"\",\n  \"horaSolicitada\": \"\",\n  \"mensajeSistema\": \"Gracias por tu solicitud. Para poder agendar tu cita de entrega, necesito que me proporciones la siguiente informaci√≥n:\\n‚Ä¢ El nombre del proveedor (proporcionar el nombre lo m√°s completo posible)\\n‚Ä¢ La categor√≠a del material (los cuales pueden ser: [USAR CATEGOR√çAS REALES DEL NODO])\\n‚Ä¢ La fecha y hora de entrega (ejemplo: 25 de junio a las 9:00 AM)\\n‚Ä¢ El peso de la mercanc√≠a (ejemplo: 300 kilos)\\n‚Ä¢ La cantidad de unidades a descargar (ejemplo: 600 unidades)\\n‚Ä¢ El n√∫mero de orden de compra (ejemplo: ARGM47896)\\n\\nPor favor, proporciona estos datos para completar tu solicitud.\",\n  \"mensajeEstado\": \"datos_incompletos\",\n  \"motivoRechazo\": \"\"\n}\n```\n\n#### EJEMPLO 3 - DATOS CONTRADICTORIOS:\n```json\n{\n  \"todoCorrecto\": false,\n  \"datosPreviamenteConfirmados\": false,\n  \"camposFaltantes\": [],\n  \"proveedoresSimilares\": [],\n  \"categoriasSimilares\": [],\n  \"fechaSolicitada\": \"\",\n  \"horaSolicitada\": \"\",\n  \"mensajeSistema\": \"He detectado m√∫ltiples cambios en las fechas solicitadas. Para evitar confusiones, por favor proporciona todos los datos completos en un solo mensaje.\",\n  \"mensajeEstado\": \"datos_contradictorios\",\n  \"motivoRechazo\": \"Usuario ha proporcionado fechas contradictorias m√∫ltiples veces\"\n}\n```\n\n### üì§ FORMATO DE TU RESPUESTA:\nIMPORTANTE: Debes responder EXCLUSIVAMENTE en formato JSON con la siguiente estructura:\n\n```json\n{\n  \"todoCorrecto\": true | false,\n  \"datosPreviamenteConfirmados\": true | false,\n  \"camposFaltantes\": [\"campo1\", \"campo2\", ...],\n  \"proveedoresSimilares\": [\"Proveedor 1\", \"Proveedor 2\", ...],\n  \"categoriasSimilares\": [\"Categor√≠a 1\", \"Categor√≠a 2\", ...],\n  \"fechaSolicitada\": \"Fecha exacta que el proveedor solicit√≥\",\n  \"horaSolicitada\": \"Hora exacta que el proveedor solicit√≥\",\n  \"mensajeSistema\": \"Texto humano, amable y claro para el proveedor\",\n  \"mensajeEstado\": \"datos_completos\" | \"datos_incompletos\" | \"datos_contradictorios\",\n  \"motivoRechazo\": \"Descripci√≥n del motivo si aplica\"\n}\n```\n\nLa respuesta NO debe incluir explicaciones, razonamientos o texto adicional fuera del objeto JSON."
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        1088,
        1440
      ],
      "id": "009bd07b-79ae-4c6d-aaed-c340ec9f8b82",
      "name": "Basic LLM Chain RECOLECCI√ìN"
    },
    {
      "parameters": {
        "jsCode": "const rawText = $json.text;\n\n// Eliminar bloques ```json y otros caracteres extra si existen\nconst clean = rawText\n  .replace(/```json/g, '')\n  .replace(/```/g, '')\n  .trim();\n\nlet parsed;\ntry {\n  parsed = JSON.parse(clean);\n} catch (e) {\n  parsed = {\n    todoCorrecto: false,\n    camposFaltantes: [\"error_json\"],\n    mensajeSistema: \"Hubo un error al interpretar los datos del modelo IA.\"\n  };\n}\n\n// Detectar retractaciones y forzar reset\nif (parsed.mensajeEstado === \"datos_contradictorios\") {\n  return [{ \n    json: { \n      forzarReset: true, \n      mensaje: \"üîÑ **M√∫ltiples cambios detectados**\\n\\nPara evitar errores, proporciona todos los datos en un solo mensaje completo.\" \n    } \n  }];\n}\n\nreturn [{ json: parsed }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1440,
        1440
      ],
      "id": "6b4e1591-da57-4791-92f0-cf4c9f52a376",
      "name": "Code (Formatear JSON RECOLECCI√ìN)"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "9fb4ec76-c88a-4b6e-ac86-10bd802e5e8a",
              "leftValue": "={{ $json.todoCorrecto }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        1664,
        1440
      ],
      "id": "d19df936-d3ca-4b1d-9a4b-b2c2e04a3782",
      "name": "IF Datos Completos"
    },
    {
      "parameters": {
        "jsCode": "return [{\n  json: {\n    text: $json.mensajeSistema\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2032,
        1712
      ],
      "id": "76942388-a295-4e40-b277-64c5a1f8c6cf",
      "name": "Code Respuesta Faltantes"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "07f5d304-964c-4736-94aa-a05d439dcf6e",
              "name": "estadoConversacion",
              "value": "RECOLECCI√ìN",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        2304,
        1712
      ],
      "id": "7e1b9d73-b514-4f26-a45b-933ab8270664",
      "name": "Setear estado conversacional"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "4bfbecb3-9d4f-4425-aa76-a92abc7708fb",
              "leftValue": "={{ $('Code Respuesta Faltantes').item.json.text.length }}",
              "rightValue": 70,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        4304,
        1712
      ],
      "id": "a4c28a07-9ab1-43bb-9d82-1931d8d27b8f",
      "name": "Validaci√≥n de longitud de caracteres"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d9c2ff70-4fd1-4b93-8571-6d0ac5a0093e",
              "name": "mensaje.ia",
              "value": "={{ $('Code Respuesta Faltantes').item.json.text }}",
              "type": "string"
            },
            {
              "id": "ac8a03be-0292-4735-9580-39a385945c47",
              "name": "mensaje.longitud",
              "value": "={{ $('Code Respuesta Faltantes').item.json.text.length }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        4608,
        1712
      ],
      "id": "2469155b-0947-4539-8ee2-1d22d9beed79",
      "name": "Organiza variables del mensaje"
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n  \"partes\": [\n    \"Primera parte del mensaje\",\n    \"Segunda parte del mensaje (si aplica)\",\n    \"Tercera parte del mensaje (si aplica)\",\n    \"Cuarta parte del mensaje (si aplica)\",\n    \"Quinta parte del mensaje (si aplica)\"\n  ]\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.2,
      "position": [
        25472,
        8880
      ],
      "id": "4153f6e2-7ab8-4c8d-a74e-efb4e499e003",
      "name": "Structured Output Parser"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        25264,
        8880
      ],
      "id": "ab8419bf-0d36-486e-9167-9dc8866ae4ba",
      "name": "OpenAI Chat Model4",
      "credentials": {
        "openAiApi": {
          "id": "AD8kPcNVReuclASd",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        4784,
        1504
      ],
      "id": "dcf29770-f20a-4069-8351-20917a7b58e1",
      "name": "No Operation, do nothing2"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $('Code Respuesta Faltantes').item.json.text }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        4608,
        1504
      ],
      "id": "a984d6b4-e959-48ce-a71d-1a03517b5bc8",
      "name": "HTTP Request Enviar Mensaje por WhatsApp"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.mensaje.ia }}",
        "hasOutputParser": true,
        "messages": {
          "messageValues": [
            {
              "message": "=Divide inteligentemente mensajes largos para WhatsApp preservando coherencia y legibilidad.\n\nAN√ÅLISIS PREVIO:\n1. Identifica el tipo de contenido: confirmaci√≥n de cita, cancelaci√≥n, informaci√≥n, etc.\n2. Detecta estructura: p√°rrafos naturales, listas, citas del cliente, respuestas del sistema\n3. Respeta SIEMPRE los saltos de l√≠nea existentes (\\\\n)\n\nREGLAS ESTRICTAS:\n\nüìè L√çMITES:\n- Si ‚â§1500 caracteres ‚Üí NO dividir, devuelve el texto completo\n- Cada parte: 800-1500 caracteres (preferir ~1200)\n- M√°ximo 5 partes\n\n‚úÇÔ∏è D√ìNDE CORTAR (orden de prioridad):\n1. Entre bloques tem√°ticos diferentes (ej: solicitud del cliente / respuesta del sistema)\n2. Despu√©s de p√°rrafos completos (busca \\\\n\\\\n o doble salto)\n3. Despu√©s de puntos finales de oraciones\n4. PROHIBIDO cortar: en medio de oraciones, datos importantes, citas\n\nüîó MANTENER SIEMPRE JUNTOS:\n- Solicitud completa del cliente con TODOS sus datos\n- Confirmaci√≥n del sistema con detalles del muelle y horario\n- Advertencias o recordatorios importantes completos\n- Datos relacionados: fecha+hora+lugar+cantidades\n\nüìù FORMATO:\n- Preserva emojis, negritas (**), saltos de l√≠nea\n- NO agregues texto extra como \"Parte 1:\" o n√∫meros\n- Si una idea contin√∫a, termina con \"...\"\n- Si es continuaci√≥n, empieza naturalmente\n\nEJEMPLO REAL DE BUENA DIVISI√ìN:\n\nInput: \"Hola, deseo agendar una cita de entrega para el jueves 19, el nombre del proveedor es spb, categor√≠a arenas, con un peso de 300 kilos, a las 6 de la ma√±ana, 600 unidades, el n√∫mero de orden de compra es ARGM47896\\\\n\\\\n¬°Genial! Viendo el cronograma me registra que s√≠ hay espacio para agendar esta cita, ser√≠a para el 19 de junio de 2025, desde las 06:00 AM hasta las 08:00 AM, ya que por la cantidad de unidades y peso en promedio va a tardar 2 horas el descargue en el MUELLE 1. El sistema pide una confirmaci√≥n de tu parte para que la cita se genere en el cronograma, por favor responde confirmando la cita y recuerda que el sistema nos da 5 minutos para confirmar la cita o de lo contrario no se puede garantizar el cupo solicitado en el cronograma.\"\n\nOutput correcto:\n{\n  \"partes\": [\n    \"Hola, deseo agendar una cita de entrega para el jueves 19, el nombre del proveedor es spb, categor√≠a arenas, con un peso de 300 kilos, a las 6 de la ma√±ana, 600 unidades, el n√∫mero de orden de compra es ARGM47896\\\\n\\\\n¬°Genial! Viendo el cronograma me registra que s√≠ hay espacio para agendar esta cita, ser√≠a para el 19 de junio de 2025, desde las 06:00 AM hasta las 08:00 AM, ya que por la cantidad de unidades y peso en promedio va a tardar 2 horas el descargue en el MUELLE 1.\",\n    \"El sistema pide una confirmaci√≥n de tu parte para que la cita se genere en el cronograma, por favor responde confirmando la cita y recuerda que el sistema nos da 5 minutos para confirmar la cita o de lo contrario no se puede garantizar el cupo solicitado en el cronograma.\"\n  ]\n}\n\nRESPONDE SOLO EL JSON, sin explicaciones:\n{\n  \"partes\": [\"texto de cada parte\"]\n}\n\nTexto a dividir:\n{{ $json.mensaje.ia }}"
            }
          ]
        }
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.5,
      "position": [
        25328,
        8672
      ],
      "id": "310630f5-f39f-4b8c-9e72-346e4fc66e63",
      "name": "Basic LLM Separaci√≥n de Mensaje"
    },
    {
      "parameters": {
        "fieldToSplitOut": "output.partes",
        "options": {}
      },
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [
        25792,
        8672
      ],
      "id": "699dc012-181d-4c6a-9752-ff5750cc01b3",
      "name": "Split Out Separa el Mensaje"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        26128,
        8672
      ],
      "id": "81fce837-3705-4670-b6f3-178614d898ce",
      "name": "Loop Over Items Recorre las Partes"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "7e24e44a-14df-4559-b8f0-5a714b4e28ee",
              "name": "Mensaje",
              "value": "={{ $json['output.partes'] }}",
              "type": "string"
            },
            {
              "id": "9a3b644f-ccc6-4f2a-ac00-909990c06524",
              "name": "longitud",
              "value": "={{ $json['output.partes'].length }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        26912,
        9024
      ],
      "id": "d7858be2-d22d-4623-8c0c-eda32d096be6",
      "name": "Recuento de Caracteres"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.longitud }}",
                    "rightValue": 121,
                    "operator": {
                      "type": "number",
                      "operation": "lt"
                    },
                    "id": "b5afcf0e-93bb-4d29-9b45-faa775511ba5"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Corto"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "ddc297e5-bff7-4b9d-812d-9131fc251995",
                    "leftValue": "={{ $json.longitud }}",
                    "rightValue": 181,
                    "operator": {
                      "type": "number",
                      "operation": "lt"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Medio"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "35e399f9-47fb-4402-8e74-17602592c599",
                    "leftValue": "={{ $json.longitud }}",
                    "rightValue": 182,
                    "operator": {
                      "type": "number",
                      "operation": "gte"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Largo"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        27120,
        9024
      ],
      "id": "47711a61-41a9-4d00-8601-c468de915f9b",
      "name": "Switch"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $json.Mensaje }}"
            },
            {
              "name": "delay",
              "value": "={{3000}}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        27424,
        8768
      ],
      "id": "25b38b82-146e-48be-bd49-b356cf6e9d95",
      "name": "HTTP Request Enviar Mensaje por WhatsApp1"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $json.Mensaje }}"
            },
            {
              "name": "delay",
              "value": "={{ 4000 }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        27424,
        8992
      ],
      "id": "a7fcfe0f-da53-4707-b874-c9986a37bf4e",
      "name": "HTTP Request Enviar Mensaje por WhatsApp2"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $json.Mensaje }}"
            },
            {
              "name": "delay",
              "value": "={{ 6000 }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        27424,
        9184
      ],
      "id": "0abd7961-c7e4-4d3d-a0c6-6b985d3d1c39",
      "name": "HTTP Request Enviar Mensaje por WhatsApp3"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=INSERT INTO MensajesWhatsApp (message_id, contenido, fecha, chat_id, instance)\nVALUES (\n  '{{ $('Parametrizaci√≥n').first().json.message.id }}',\n  '{{ $json.message.conversation.replace(/'/g, \"''\") }}',\n  FORMAT(SWITCHOFFSET(GETDATE(), '-05:00'), 'yyyy-MM-dd HH:mm:ss'),\n  'agenteAI',\n  '{{ $('Parametrizaci√≥n').first().json.message.chat.instance }}'\n);"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        27728,
        8992
      ],
      "id": "490ea12c-b435-4295-91cb-2eef05765fb0",
      "name": "Microsoft SQL",
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=INSERT INTO MensajesWhatsApp (message_id, contenido, fecha, chat_id, instance)\nVALUES (\n  '{{ $('Parametrizaci√≥n').first().json.message.id }}',\n  '{{ $json.message.conversation.replace(/'/g, \"''\") }}',\n  FORMAT(SWITCHOFFSET(GETDATE(), '-05:00'), 'yyyy-MM-dd HH:mm:ss'),\n  'agenteAI',\n  '{{ $('Parametrizaci√≥n').first().json.message.chat.instance }}'\n);"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        27728,
        8768
      ],
      "id": "44948f0d-e5d6-42bc-8b72-1459495eb119",
      "name": "Microsoft SQL1",
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=INSERT INTO MensajesWhatsApp (message_id, contenido, fecha, chat_id, instance)\nVALUES (\n  '{{ $('Parametrizaci√≥n').first().json.message.id }}',\n  '{{ $json.message.conversation.replace(/'/g, \"''\") }}',\n  FORMAT(SWITCHOFFSET(GETDATE(), '-05:00'), 'yyyy-MM-dd HH:mm:ss'),\n  'agenteAI',\n  '{{ $('Parametrizaci√≥n').first().json.message.chat.instance }}'\n);"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        27728,
        9184
      ],
      "id": "eba33ba7-075d-4988-adf6-2ee099eeb69f",
      "name": "Microsoft SQL2",
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "amount": 0
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        28048,
        9232
      ],
      "id": "77f26e91-2624-4d64-9a92-c70ec9da8122",
      "name": "Wait",
      "webhookId": "2d0cc5ee-b809-403d-8de5-06a71a8a40e9"
    },
    {
      "parameters": {
        "operation": "xlsx",
        "binaryPropertyName": "ExcelMallaRecibido2025",
        "options": {
          "sheetName": "={{    (function() {     const semanaActual = $('Unificaci√≥n y consistencia de datos').item.json.hojaSeleccionada;     const numeroSemana = parseInt(semanaActual.replace(\"SEMANA \", \"\"));     return `SEMANA ${numeroSemana + 1}`;   })() }}"
        }
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -608,
        1360
      ],
      "id": "aec41712-ebe5-478d-85c7-9f402b939667",
      "name": "Extract MALLA DE RECIBO Semana Siguiente",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Si el nodo anterior no devolvi√≥ datos (por error al no existir la hoja), retornamos estructura vac√≠a con mensaje\n// Obtener los datos del Excel\nconst excelData = $input.all();\n\n// Mejora en la detecci√≥n de errores: verificar si hay error expl√≠cito o si los datos no son v√°lidos\nconst hayError = excelData.some(item => item.json && item.json.error);\nconst datosInvalidos = !excelData || excelData.length === 0 || hayError;\n\nif (datosInvalidos) {\n  return [{\n    datosMallaProxSemana: {\n      titulo: \"‚ö†Ô∏è La malla de la pr√≥xima semana no existe en el archivo Excel o a√∫n no ha sido creada.\",\n      a√±o: \"\",\n      semana: \"\",\n      rangoDias: \"\",\n      franjas: [],\n      dias: {\n        lunes: { muelle1: {}, muelle2: {} },\n        martes: { muelle1: {}, muelle2: {} },\n        mi√©rcoles: { muelle1: {}, muelle2: {} },\n        jueves: { muelle1: {}, muelle2: {} },\n        viernes: { muelle1: {}, muelle2: {} }\n      }\n    },\n    funciones: {\n      consultarFranjasDisponibles: \"function not available\",\n      consultarCitasProveedor: \"function not available\",\n      obtenerInfoMalla: \"function not available\",\n      estaDisponible: \"function not available\",\n      obtenerCoordenadasCita: \"function not available\"\n    }\n  }];\n}\n\n// El resto del c√≥digo permanece igual...\nconst hojaSeleccionada = $('Unificaci√≥n y consistencia de datos').first().json.hojaSeleccionada;\n\n// Definir estructura de la semana y los d√≠as\nconst diasSemana = ['lunes', 'martes', 'mi√©rcoles', 'jueves', 'viernes'];\n\n// Objeto para almacenar la malla estructurada\nconst mallaEstructurada = {\n  titulo: \"\",\n  a√±o: \"\",\n  semana: \"\",\n  rangoDias: \"\",\n  franjas: [],\n  dias: {}\n};\n\n// Tabla de meses y d√≠as. Ajusta si necesitas contemplar bisiestos, etc.\nconst meses = {\n  \"enero\": 1,\n  \"febrero\": 2,\n  \"marzo\": 3,\n  \"abril\": 4,\n  \"mayo\": 5,\n  \"junio\": 6,\n  \"julio\": 7,\n  \"agosto\": 8,\n  \"septiembre\": 9,\n  \"octubre\": 10,\n  \"noviembre\": 11,\n  \"diciembre\": 12\n};\n\nconst nombreMes = {\n  1: \"enero\",\n  2: \"febrero\",\n  3: \"marzo\",\n  4: \"abril\",\n  5: \"mayo\",\n  6: \"junio\",\n  7: \"julio\",\n  8: \"agosto\",\n  9: \"septiembre\",\n  10: \"octubre\",\n  11: \"noviembre\",\n  12: \"diciembre\"\n};\n\n/**\n * Funci√≥n para determinar si un a√±o es bisiesto\n * Un a√±o es bisiesto si es divisible por 4, excepto aquellos divisibles por 100 \n * que no son divisibles por 400\n */\nfunction esBisiesto(year) {\n  return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);\n}\n\n/**\n * Funci√≥n para obtener el n√∫mero de d√≠as en un mes, considerando a√±os bisiestos\n */\nfunction getDiasMes(mes, a√±o) {\n  const diasPorMes = {\n    1: 31, // enero\n    2: esBisiesto(a√±o) ? 29 : 28, // febrero - ajustado para a√±o bisiesto\n    3: 31, // marzo\n    4: 30, // abril\n    5: 31, // mayo\n    6: 30, // junio\n    7: 31, // julio\n    8: 31, // agosto\n    9: 30, // septiembre\n    10: 31, // octubre\n    11: 30, // noviembre\n    12: 31  // diciembre\n  };\n  \n  return diasPorMes[mes];\n}\n\n/**\n * Funci√≥n para eliminar acentos y pasar a min√∫sculas (para buscar palabras clave sin importar tildes ni may√∫sculas).\n */\nfunction normalizarTexto(texto) {\n  if (typeof texto !== 'string') return \"\";\n  // Normaliza (NFD) y elimina diacr√≠ticos, luego pasa a min√∫sculas.\n  return texto\n    .normalize(\"NFD\")\n    .replace(/[\\u0300-\\u036f]/g, \"\") // quita acentos\n    .toLowerCase();\n}\n\n/**\n * Dada la informaci√≥n de proveedor, ordenCompra, peso, categor√≠a y unidades,\n * revisa si existe la palabra 'fuera de servicio', 'cancelado' o 'reagendado'\n * en cualquiera de esos campos. De ser as√≠, retorna ese estado especial;\n * de lo contrario, retorna 'ocupado'.\n * \n * Se ignoran may√∫sculas, min√∫sculas y tildes.\n */\nfunction determinarEstadoOcupado(proveedor, ordenCompra, peso, categoria, unidades) {\n  const conjunto = `${proveedor} ${ordenCompra} ${peso} ${categoria} ${unidades}`;\n  const texto = normalizarTexto(conjunto);\n\n  if (texto.includes(\"fuera de servicio\")) {\n    return \"fuera de servicio\";\n  }\n  if (texto.includes(\"cancelado\")) {\n    return \"cancelado\";\n  }\n  if (texto.includes(\"reagendado\")) {\n    return \"reagendado\";\n  }\n  return \"ocupado\";  \n}\n\n// -------------------------------------------------------------\n// 1) PROCESAR DATOS (Cabecera, Horas, Muelles, etc.)\n// -------------------------------------------------------------\nfunction procesarDatos(excelData) {\n  // Verificaci√≥n adicional de datos v√°lidos\n  if (!excelData || !Array.isArray(excelData) || excelData.length === 0) {\n    return {\n      titulo: \"‚ö†Ô∏è La malla de la pr√≥xima semana no existe en el archivo Excel o a√∫n no ha sido creada.\",\n      a√±o: \"\",\n      semana: \"\",\n      rangoDias: \"\",\n      franjas: [],\n      dias: {\n        lunes: { muelle1: {}, muelle2: {} },\n        martes: { muelle1: {}, muelle2: {} },\n        mi√©rcoles: { muelle1: {}, muelle2: {} },\n        jueves: { muelle1: {}, muelle2: {} },\n        viernes: { muelle1: {}, muelle2: {} }\n      }\n    };\n  }\n  \n  // Intentar mapear datos, con manejo de errores para cada item\n  const datos = excelData.map(item => {\n    try {\n      return item.json || {};\n    } catch (e) {\n      return {};\n    }\n  });\n  \n  // A) Cabecera (T√≠tulo, A√±o, Rango)\n  datos.forEach((dato, index) => {\n    // Buscar t√≠tulo\n    if (dato.__EMPTY_2 === \"MALLA DE RECIBO CEDI KONFIE IA\") {\n      mallaEstructurada.titulo = dato.__EMPTY_2;\n      \n      // En la siguiente fila puede estar a√±o, semana, rango\n      if (index + 1 < datos.length) {\n        const datoSiguiente = datos[index + 1];\n        if (datoSiguiente) {\n          // A√±o\n          if (datoSiguiente.__EMPTY_2 && !isNaN(datoSiguiente.__EMPTY_2)) {\n            mallaEstructurada.a√±o = datoSiguiente.__EMPTY_2;\n          }\n          // Semana\n          Object.entries(datoSiguiente).forEach(([k, v]) => {\n            if (typeof v === 'string' && v.includes(\"SEMANA\")) {\n              mallaEstructurada.semana = v;\n            }\n          });\n          // Rango: p.ej. \"LUNES 31 AL VIERNES 4 DE ABRIL\"\n          Object.entries(datoSiguiente).forEach(([k, v]) => {\n            if (typeof v === 'string' && v.includes(\"LUNES\") && v.includes(\"VIERNES\")) {\n              mallaEstructurada.rangoDias = v;\n            }\n          });\n        }\n      }\n    }\n  });\n  \n  // Si despu√©s de procesar no encontramos t√≠tulo, es que no hay malla v√°lida\n  if (!mallaEstructurada.titulo) {\n    mallaEstructurada.titulo = \"‚ö†Ô∏è La malla de la pr√≥xima semana no existe en el archivo Excel o a√∫n no ha sido creada.\";\n    return mallaEstructurada;\n  }\n  \n  // B) Detectar franjas horarias (.__EMPTY = fracci√≥n de d√≠a)\n  const franjasHorarias = [];\n  datos.forEach(dato => {\n    if (\n      dato.__EMPTY !== undefined &&\n      typeof dato.__EMPTY === 'number' &&\n      dato.__EMPTY > 0 &&\n      dato.__EMPTY < 1\n    ) {\n      const totalMin = Math.round(dato.__EMPTY * 24 * 60);\n      const hh = Math.floor(totalMin / 60);\n      const mm = totalMin % 60;\n      \n      let periodo = \"AM\";\n      let hora12 = hh;\n      if (hh >= 12) {\n        periodo = \"PM\";\n        hora12 = (hh === 12 ? 12 : hh - 12);\n      }\n      if (hh === 0) {\n        hora12 = 12;\n      }\n      \n      const horaStr = `${hora12}:${String(mm).padStart(2, '0')} ${periodo}`;\n      franjasHorarias.push({\n        hora: horaStr,\n        indice: datos.indexOf(dato) // fila base\n      });\n    }\n  });\n  franjasHorarias.sort((a, b) => a.indice - b.indice);\n  mallaEstructurada.franjas = franjasHorarias;\n  \n  // C) Detectar muelles (col)\n  const muellesInfo = {};\n  datos.forEach(dato => {\n    Object.entries(dato).forEach(([key, value]) => {\n      if (value === \"MUELLE 01\" || value === \"MUELLE 02\") {\n        const col = parseInt(key.replace(\"__EMPTY_\", \"\"), 10);\n        const muelleKey = (value === \"MUELLE 01\") ? 'muelle1' : 'muelle2';\n        if (!muellesInfo[muelleKey]) {\n          muellesInfo[muelleKey] = [];\n        }\n        muellesInfo[muelleKey].push(col);\n      }\n    });\n  });\n  if (muellesInfo.muelle1) muellesInfo.muelle1.sort((a, b) => a - b);\n  if (muellesInfo.muelle2) muellesInfo.muelle2.sort((a, b) => a - b);\n  \n  // D) Generar los 5 d√≠as (lunes-viernes) con su fecha\n  parsearRangoDias();\n  \n  // E) Extraer Citas\n  extraerCitas(datos, muellesInfo);\n  \n  return mallaEstructurada;\n}\n\n/**\n * Parsea la cadena \"LUNES 31 AL VIERNES 4 DE ABRIL\"\n * (o \"LUNES 31 AL VIERNES 04 DE ABRIL\") y maneja el cruce de mes.\n * Ej.: si dayStart=31 y dayEnd=4, la 1¬™ fecha es 31 de MARZO,\n * luego 1,2,3,4 de ABRIL, en vez de 32,33, etc.\n */\nfunction parsearRangoDias() {\n  const texto = mallaEstructurada.rangoDias;\n  // Regex simple: p.ej. \"31 AL ... 4 DE ABRIL\"\n  // Captura: dayStart, dayEnd, mesFin\n  // Ojo: si dice \"LUNES 31 DE MARZO AL VIERNES 4 DE ABRIL\",\n  // quedar√°: dayStart=31, dayEnd=4, month=ABRIL (al final).\n  const regex = /(\\d+)\\s+AL\\s+\\D+(\\d+)\\s+DE\\s+(\\w+)/i;\n  const match = regex.exec(texto);\n  \n  // Por defecto, creamos 5 d√≠as vac√≠os sin fecha\n  diasSemana.forEach(d => {\n    mallaEstructurada.dias[d] = {\n      muelle1: {},\n      muelle2: {}\n    };\n  });\n  \n  if (!match) {\n    // Sin coincidencia, dejamos los d√≠as sin fecha\n    return;\n  }\n  \n  const dayStart = parseInt(match[1], 10); // 31\n  const dayEnd   = parseInt(match[2], 10); // 4\n  const finalMonthName = match[3].toLowerCase(); // \"abril\"\n  \n  // Convertimos a n√∫mero\n  const finalMonth = meses[finalMonthName] || 3; // fallback marzo\n  const yearNum = parseInt(mallaEstructurada.a√±o, 10) || 2025;\n  \n  // Funci√≥n para obtener la fecha formateada\n  function fechaFormateada(d, m, y) {\n    return `${d} de ${nombreMes[m]} de ${y}`;\n  }\n  \n  // Comprobamos cu√°ntos d√≠as tiene el mes final, considerando bisiestos\n  const diasMesFinal = getDiasMes(finalMonth, yearNum);\n  // y del mes previo\n  const monthPrev = (finalMonth === 1) ? 12 : finalMonth - 1;\n  const yearPrev = (finalMonth === 1) ? yearNum - 1 : yearNum;\n  \n  // Arreglo final con 5 fechas\n  const fechasDias = [];\n  \n  if (dayStart <= dayEnd) {\n    // Caso \"normal\": todo en el mismo mes\n    let d = dayStart;\n    for (let i = 0; i < 5; i++) {\n      fechasDias.push({\n        diaSem: diasSemana[i],\n        diaNum: d,\n        mesNum: finalMonth,\n        yearNum: yearNum\n      });\n      d++;\n      if (d > diasMesFinal) {\n        d = 1;\n        const nextMonth = finalMonth % 12 + 1;\n        const nextYear = (nextMonth === 1) ? yearNum + 1 : yearNum;\n        fechasDias[fechasDias.length - 1].mesNum = nextMonth;\n        fechasDias[fechasDias.length - 1].yearNum = nextYear;\n      }\n    }\n  } else {\n    // Caso \"cruza de mes\": dayStart > dayEnd\n    let d = dayStart;\n    let m = monthPrev;\n    let y = yearPrev;\n    \n    for (let i = 0; i < 5; i++) {\n      fechasDias.push({\n        diaSem: diasSemana[i],\n        diaNum: d,\n        mesNum: m,\n        yearNum: y\n      });\n      d++;\n      if (d > getDiasMes(m, y)) {\n        d = 1;\n        m = m % 12 + 1;\n        if (m === 1) {\n          y++;\n        }\n      }\n    }\n  }\n  \n  // Ahora volcamos esas 5 fechas en la estructura\n  fechasDias.forEach(fd => {\n    const { diaSem, diaNum, mesNum, yearNum } = fd;\n    mallaEstructurada.dias[diaSem] = {\n      fechaDia: fechaFormateada(diaNum, mesNum, yearNum),\n      muelle1: {},\n      muelle2: {}\n    };\n  });\n  \n  // Inicializamos las franjas a 'disponible'\n  if (mallaEstructurada.franjas.length > 0) {\n    diasSemana.forEach(d => {\n      mallaEstructurada.franjas.forEach(f => {\n        mallaEstructurada.dias[d].muelle1[f.hora] = {\n          estado: \"disponible\",\n          proveedor: \"\",\n          ordenCompra: \"\",\n          peso: \"\",\n          categoria: \"\",\n          unidades: \"\"\n        };\n        mallaEstructurada.dias[d].muelle2[f.hora] = {\n          estado: \"disponible\",\n          proveedor: \"\",\n          ordenCompra: \"\",\n          peso: \"\",\n          categoria: \"\",\n          unidades: \"\"\n        };\n      });\n    });\n  }\n}\n\n/**\n * Funci√≥n auxiliar: decide a qu√© d√≠a pertenece una columna,\n * corrigiendo 2 columnas de offset (porque 'Extract from XLSX'\n * deja todo desplazado).\n */\nfunction getDayForColumn(colNumber) {\n  // Ajuste de offset +2\n  const realCol = colNumber + 2;\n\n  // Rangos:\n  //  Lunes:      3..8\n  //  Martes:     9..14\n  //  Mi√©rcoles: 15..20\n  //  Jueves:    21..26\n  //  Viernes:   27..32\n  if (realCol >= 3 && realCol <= 8) {\n    return \"lunes\";\n  }\n  if (realCol >= 9 && realCol <= 14) {\n    return \"martes\";\n  }\n  if (realCol >= 15 && realCol <= 20) {\n    return \"mi√©rcoles\";\n  }\n  if (realCol >= 21 && realCol <= 26) {\n    return \"jueves\";\n  }\n  if (realCol >= 27 && realCol <= 32) {\n    return \"viernes\";\n  }\n  // Si nada coincide, devolvemos null\n  return null;\n}\n\n/**\n * Extraer las citas para cada franja:\n * - Para cada franja, miramos 3 filas:\n *    - Fila base => proveedor\n *    - Fila base+1 => orden\n *    - Fila base+2 => peso, categor√≠a, unidades\n */\nfunction extraerCitas(datos, muellesInfo) {\n  mallaEstructurada.franjas.forEach(franja => {\n    const indiceBase = franja.indice;\n    if (indiceBase < 0 || indiceBase + 2 >= datos.length) {\n      return; // no hay suficientes filas\n    }\n    \n    // Recorremos muelle1, muelle2 y sus columnas\n    const asignarCita = (muelleKey, cols) => {\n      cols.forEach(col => {\n        const provKey = `__EMPTY_${col}`;\n        const filaProv = datos[indiceBase];\n        \n        // Si en esta fila hay un proveedor o alg√∫n texto\n        if (\n          filaProv &&\n          typeof filaProv[provKey] === 'string' &&\n          filaProv[provKey].length > 2\n        ) {\n          // Determinar el d√≠a real\n          const diaOk = getDayForColumn(col);\n          if (!diaOk || !mallaEstructurada.dias[diaOk]) {\n            return; // si no coincide con ninguno, saltamos\n          }\n          \n          // Recuperar valores para proveedor, ordenCompra y dem√°s\n          const filaOrden = datos[indiceBase + 1];\n          const filaDet = datos[indiceBase + 2];\n          \n          const proveedor = filaProv[provKey] || \"\";\n          const ordenCompra = filaOrden && filaOrden[provKey] ? filaOrden[provKey] : \"\";\n          const peso = filaDet && filaDet[provKey] ? filaDet[provKey] : \"\";\n          const cat  = filaDet && filaDet[`__EMPTY_${col + 1}`] ? filaDet[`__EMPTY_${col + 1}`] : \"\";\n          const und  = filaDet && filaDet[`__EMPTY_${col + 2}`] ? filaDet[`__EMPTY_${col + 2}`] : \"\";\n          \n          // Antes pon√≠amos estado=\"ocupado\" directamente\n          // Ahora verificamos si el texto contiene \"reagendado\", \"cancelado\" o \"fuera de servicio\".\n          const nuevoEstado = determinarEstadoOcupado(proveedor, ordenCompra, peso, cat, und);\n          \n          // Asignamos los datos\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].estado = nuevoEstado;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].proveedor = proveedor;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].ordenCompra = ordenCompra;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].peso = peso;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].categoria = cat;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].unidades = und;\n        }\n      });\n    };\n    \n    if (muellesInfo.muelle1) {\n      asignarCita('muelle1', muellesInfo.muelle1);\n    }\n    if (muellesInfo.muelle2) {\n      asignarCita('muelle2', muellesInfo.muelle2);\n    }\n  });\n}\n\n// -------------------------------------------------------------\n// 2) FUNCIONES PARA CONSULTAR LA MALLA\n// -------------------------------------------------------------\nfunction buscarFranjasDisponibles(categoria, duracionHoras) {\n  const muelle = \"muelle1\"; // Ajusta si usas \"categoria -> muelle\" real\n  \n  const franjasDisponibles = [];\n  Object.keys(mallaEstructurada.dias).forEach(dia => {\n    const libres = [];\n    for (let i = 0; i <= mallaEstructurada.franjas.length - duracionHoras; i++) {\n      let disponible = true;\n      for (let h = 0; h < duracionHoras; h++) {\n        const idxF = i + h;\n        const horaAct = mallaEstructurada.franjas[idxF].hora;\n        if (\n          mallaEstructurada.dias[dia][muelle][horaAct].estado !== 'disponible'\n        ) {\n          disponible = false;\n          break;\n        }\n      }\n      if (disponible) {\n        libres.push({\n          horaInicio: mallaEstructurada.franjas[i].hora,\n          duracion: duracionHoras\n        });\n      }\n    }\n    if (libres.length > 0) {\n      franjasDisponibles.push({ dia, franjas: libres });\n    }\n  });\n  return franjasDisponibles;\n}\n\nfunction buscarCitasProveedor(nombreProveedor) {\n  const citas = [];\n  Object.keys(mallaEstructurada.dias).forEach(dia => {\n    const muelle1 = mallaEstructurada.dias[dia].muelle1;\n    const muelle2 = mallaEstructurada.dias[dia].muelle2;\n    mallaEstructurada.franjas.forEach(f => {\n      const hora = f.hora;\n      // muelle1\n      if (normalizarTexto(muelle1[hora].proveedor) === normalizarTexto(nombreProveedor)) {\n        citas.push({\n          dia,\n          hora,\n          muelle: \"Muelle 01\",\n          ordenCompra: muelle1[hora].ordenCompra,\n          peso: muelle1[hora].peso,\n          categoria: muelle1[hora].categoria,\n          unidades: muelle1[hora].unidades,\n          estado: muelle1[hora].estado\n        });\n      }\n      // muelle2\n      if (normalizarTexto(muelle2[hora].proveedor) === normalizarTexto(nombreProveedor)) {\n        citas.push({\n          dia,\n          hora,\n          muelle: \"Muelle 02\",\n          ordenCompra: muelle2[hora].ordenCompra,\n          peso: muelle2[hora].peso,\n          categoria: muelle2[hora].categoria,\n          unidades: muelle2[hora].unidades,\n          estado: muelle2[hora].estado\n        });\n      }\n    });\n  });\n  return citas;\n}\n\nfunction consultarFranjasDisponibles(categoria, duracionHoras) {\n  return buscarFranjasDisponibles(categoria, duracionHoras);\n}\n\nfunction consultarCitasProveedor(nombreProveedor) {\n  return buscarCitasProveedor(nombreProveedor);\n}\n\nfunction obtenerInfoMalla() {\n  return {\n    titulo: mallaEstructurada.titulo,\n    a√±o: mallaEstructurada.a√±o,\n    semana: mallaEstructurada.semana,\n    rangoDias: mallaEstructurada.rangoDias,\n    franjas: mallaEstructurada.franjas.map(f => f.hora)\n  };\n}\n\nfunction estaDisponible(dia, hora, muelle) {\n  const info = mallaEstructurada.dias[dia]?.[muelle]?.[hora];\n  return info ? (info.estado === 'disponible') : false;\n}\n\nfunction obtenerCoordenadasCita(dia, hora, muelle) {\n  // Ajustar con tu mapeo de celdas en Excel\n  return {\n    proveedor: `${dia}_${hora}_${muelle}_proveedor`,\n    ordenCompra: `${dia}_${hora}_${muelle}_ordenCompra`,\n    peso: `${dia}_${hora}_${muelle}_peso`,\n    categoria: `${dia}_${hora}_${muelle}_categoria`,\n    unidades: `${dia}_${hora}_${muelle}_unidades`\n  };\n}\n\n// -------------------------------------------------------------\n// 3) EJECUTAR TODO Y RETORNAR\n// -------------------------------------------------------------\nconst malla = procesarDatos(excelData);\n\nconst resultado = {\n  datosMallaProxSemana: malla,\n  funciones: {\n    consultarFranjasDisponibles,\n    consultarCitasProveedor,\n    obtenerInfoMalla,\n    estaDisponible,\n    obtenerCoordenadasCita\n  }\n};\n\nreturn [resultado];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -368,
        1360
      ],
      "id": "31a558d8-9b7b-4e41-9868-a3b8741401e6",
      "name": "Estructuraci√≥n, Datos, Consulta, Citas Proxima Semana"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        1648,
        9744
      ],
      "id": "b362d7ac-887e-4883-8322-fa47f5e60e69",
      "name": "OpenAI Chat Model6",
      "credentials": {
        "openAiApi": {
          "id": "AD8kPcNVReuclASd",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "=define",
        "text": "=### SISTEMA\nEres un asistente experto en log√≠stica de bodegas. Tu tarea es **responder cuando un proveedor consulta la disponibilidad de citas para entregar mercanc√≠a**, a trav√©s de WhatsApp. Debes ser sensible al **d√≠a y hora** en que se recibe la consulta para dar informaci√≥n precisa sobre la disponibilidad general.\n\nDebes revisar cuidadosamente:\n- El mensaje actual del proveedor.\n- El historial de mensajes recientes.\n- El historial de citas del proveedor (si lo hay).\n- **IMPORTANTE: El d√≠a y la hora actual de la consulta.**\n\nY con base en eso, generar una respuesta que sea:\n- **Amable, emp√°tica, clara y conversacional.**\n- **Breve pero informativa**, explicando correctamente la disponibilidad general **seg√∫n el momento de la consulta**.\n- Que explique que para ofrecer opciones reales y exactas se requiere **informaci√≥n clave**.\n- Que **invite de forma cordial** a compartir los datos necesarios para avanzar.\n- Que **aclare al proveedor que si desea agendar la cita**, esos datos son obligatorios.\n\n**NUEVO: Considera el d√≠a y la hora actual para determinar la disponibilidad general:**\n- **Entradas Requeridas (provistas por el sistema externo):**\n    - Hoy es `{{ new Date().toLocaleDateString(\"es-CO\", { timeZone: \"America/Bogota\", weekday: \"long\" }) }}`: D√≠a de la semana actual (Lunes, Martes, Mi√©rcoles, Jueves, Viernes, S√°bado, Domingo).\n    -La hora actual es `{{ new Date().toLocaleTimeString(\"es-CO\", { timeZone: \"America/Bogota\", hour: \"numeric\", minute: \"2-digit\", hour12: true }) }}`: Hora actual en formato HHMM (ej. 0900 para 9:00 AM, 1630 para 4:30 PM).\n- **Reglas de Disponibilidad General:**\n    - **Regla 1:** Si es **Lunes, Martes, Mi√©rcoles** O (es **Jueves** Y la hora es **antes de 1630**): Hay disponibilidad general para la semana **actual y la pr√≥xima**.\n    - **Regla 2:** Si (es **Jueves** Y la hora es **1630 o posterior**) O es **Viernes**: La disponibilidad general es solo para la **pr√≥xima semana**.\n    - **Regla 3:** Si es **S√°bado o Domingo**: La disponibilidad general es solo para la **pr√≥xima semana**.\n\n---\n### MENSAJE ACTUAL DEL PROVEEDOR:\n{{ $node[\"Unificaci√≥n y consistencia de datos\"].json[\"infoMensaje\"][\"mensajeActual\"] }}\n---\n### HISTORIAL DE MENSAJES:\n{{ $node[\"Unificaci√≥n y consistencia de datos\"].json[\"infoMensaje\"][\"historialMensajes\"] }}\n---\n### üìÜ HISTORIAL DE CITAS DEL PROVEEDOR:\n{{ $node[\"Unificaci√≥n y consistencia de datos\"].json[\"infoMensajecita\"][\"historialCitas\"] }}\n---\n### CATEGOR√çAS:\n```json\n{{ JSON.stringify($json.datoscategorias, null, 2) }}\n```\n\n## üéØ OBJETIVO\nGenera una respuesta siguiendo estos pasos:\n\n### Saluda amablemente y explica la disponibilidad general APLICANDO LAS REGLAS de d√≠a/hora:\n\n- **Si aplica la Regla 1** (Lunes-Mi√©rcoles, Jueves < 16:30): Usa una frase como:\n  > ¬°Hola! Gracias por escribirnos üòä. Te confirmo que tenemos disponibilidad general para agendar entregas tanto en la semana actual como en la pr√≥xima. Para poder mostrarte los horarios espec√≠ficos y ayudarte a programar tu cita, necesito que me confirmes algunos datos clave.\n\n- **Si aplica la Regla 2** (Jueves >= 16:30, Viernes): Usa una frase adaptada al d√≠a.\n  - Si es Jueves tarde:\n    > ¬°Hola! Gracias por escribirnos üòä. Te comento que, por la hora, la disponibilidad de citas ya es para la pr√≥xima semana. Para poder mostrarte los horarios espec√≠ficos y ayudarte a programar tu cita, necesito que me confirmes algunos datos clave.\n  - Si es Viernes:\n    > ¬°Hola! Gracias por escribirnos üòä. Te comento que, al ser hoy viernes, la disponibilidad de citas ya es para la pr√≥xima semana. Para poder mostrarte los horarios espec√≠ficos y ayudarte a programar tu cita, necesito que me confirmes algunos datos clave.\n\n- **Si aplica la Regla 3** (S√°bado, Domingo): Usa una frase como:\n  > ¬°Hola! Gracias por escribirnos üòä. Ya que nos contactas en fin de semana, la disponibilidad de citas es a partir de la pr√≥xima semana. Para poder mostrarte los horarios espec√≠ficos y ayudarte a programar tu cita, necesito que me confirmes algunos datos clave.\n\n### Despu√©s de la frase de disponibilidad, muestra en forma de mini lista amigable estructurada los datos requeridos para agendar:\n\n> üìù Por favor ind√≠came la siguiente informaci√≥n:\n> ‚Ä¢ Nombre del proveedor (En lo posible nombre completo y legible)\n> ‚Ä¢ Fecha deseada para la entrega (ej. 16 de abril)\n> ‚Ä¢ Hora de entrega (ej. 9:00 AM, 10:00 AM)\n> ‚Ä¢ Categor√≠a del producto (puedes elegir entre las siguientes disponibles: {{ $json.datoscategorias.map(cat => cat.CATEGORIA).join(', ') }})\n> ‚Ä¢ Peso estimado en kilos\n> ‚Ä¢ N√∫mero de unidades (en n√∫mero entero)\n> ‚Ä¢ N√∫mero de orden de compra\n\n### Cierra el mensaje con una frase amable que motive a continuar:\n\n> Con esta informaci√≥n, el sistema podr√° mostrarte las franjas disponibles y ayudarte a agendar tu cita r√°pidamente. Estoy aqu√≠ para ayudarte en todo el proceso. üí™\n---\n### üìå RESPUESTA FORMATO JSON\n```json\n{\n  \"mensajeSistema\": \"¬°Hola! Gracias por escribirnos üòä. Actualmente tenemos disponibilidad para agendar entregas durante esta semana y la pr√≥xima. Para poder mostrarte horarios espec√≠ficos, necesito que me confirmes algunos datos:\n\nüìù Por favor ind√≠came la siguiente informaci√≥n:\n‚Ä¢ Nombre del proveedor (En lo posible nombre completo y legible)\n‚Ä¢ Fecha deseada para la entrega (ej. 16 de abril)\n‚Ä¢ Hora de entrega (ej. 9:00 AM, 10:00 AM)\n‚Ä¢ Categor√≠a del producto (puedes elegir entre las siguientes disponibles: {{ $json.datoscategorias.map(cat => cat.CATEGORIA).join(', ') }})\n‚Ä¢ Peso estimado en kilos\n‚Ä¢ N√∫mero de unidades (en n√∫mero entero)\n‚Ä¢ N√∫mero de orden de compra\n\nCon esta informaci√≥n, el sistema podr√° mostrarte las franjas disponibles y ayudarte a agendar tu cita r√°pidamente. Estoy aqu√≠ para ayudarte en todo el proceso. üí™\"\n}\n```"
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        1728,
        9552
      ],
      "id": "f5ca91f6-5149-4761-92b4-3bcc97287269",
      "name": "Basic LLM CONSULTAR MALLA"
    },
    {
      "parameters": {
        "url": "https://graph.microsoft.com/v1.0/drives/b!hviSpWBFYk6WRh7uet16vnNAUYuuQRlGj3ZyS9kSvGVZ4DSg6c5MRqYYm2MdAER8/items/01PPLUUYTWY3753ZJ6ERAZ6LQBYUR2JOTY/content",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "microsoftOAuth2Api",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "file",
              "outputPropertyName": "MallaFija"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -2416,
        9552
      ],
      "id": "f7eed660-4c9a-4e98-b4fb-f72d71775afa",
      "name": "HTTP Request Malla Fija1",
      "credentials": {
        "microsoftOAuth2Api": {
          "id": "mh8Z8hxFvd7LDO8D",
          "name": "CuentaMy SharePoint App Desarrollador1 Konfie "
        }
      }
    },
    {
      "parameters": {
        "operation": "xlsx",
        "binaryPropertyName": "MallaFija",
        "options": {
          "sheetName": "Categorias"
        }
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        1168,
        9552
      ],
      "id": "3c6fe32e-ebc4-417b-b033-cdf427f4fda3",
      "name": "Extract from Categorias1"
    },
    {
      "parameters": {
        "jsCode": "// Obtener todos los items de la entrada\nconst items = $input.all();\nconst categorias = [];\n\n// Mapa para verificar categor√≠as duplicadas\nconst categoriasMap = new Map();\n\n// Recorrer cada √≠tem de la entrada de categor√≠as\nfor (const item of items) {\n  // Obtener los datos originales\n  const originalData = item.json;\n  \n  // Extraer categor√≠a y muelle\n  const categoria = originalData.CATEGORIA || \"\";\n  const muelle = originalData.MUELLE || \"\";\n  \n  // Solo procesar si tanto la categor√≠a como el muelle tienen valor\n  if (categoria && muelle) {\n    // Verificar si esta categor√≠a ya existe en nuestro mapa\n    if (categoriasMap.has(categoria)) {\n      console.log(`Advertencia: La categor√≠a \"${categoria}\" est√° duplicada. Se ignorar√° la segunda aparici√≥n.`);\n      continue; // Saltar este elemento\n    }\n    \n    // Agregar al mapa para control de duplicados\n    categoriasMap.set(categoria, muelle);\n    \n    // Agregar el objeto al array de categor√≠as\n    categorias.push({\n      \"CATEGORIA\": categoria,\n      \"MUELLE\": muelle\n    });\n  } else {\n    console.log(`Advertencia: Elemento ignorado por falta de categor√≠a o muelle: ${JSON.stringify(originalData)}`);\n  }\n}\n\n// Retornar un √∫nico objeto que contiene el array de categor√≠as\n// dentro de un par√°metro global llamado \"datoscategorias\"\nreturn [\n  {\n    json: {\n      datoscategorias: categorias\n    }\n  }\n];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1408,
        9552
      ],
      "id": "625f6f9e-e32a-41f4-84bc-2fe3cb74b52a",
      "name": "Estructuraci√≥n, Consulta, Datos Categorias1"
    },
    {
      "parameters": {
        "jsCode": "// Obtener la respuesta generada por el LLM\nconst entrada = $input.item.json;\n\ntry {\n  // Extraer el bloque de texto generado\n  const texto = entrada.text;\n\n  // Buscar el contenido entre los delimitadores de bloque ```json\n  const match = texto.match(/```json\\s*([\\s\\S]*?)\\s*```/);\n\n  if (match && match[1]) {\n    const jsonParsed = JSON.parse(match[1]);\n\n    return [\n      {\n        json: {\n          mensaje: jsonParsed.mensajeSistema || \"No se pudo obtener el mensaje.\"\n        }\n      }\n    ];\n  } else {\n    throw new Error(\"No se encontr√≥ contenido JSON en el texto.\");\n  }\n} catch (error) {\n  return [\n    {\n      json: {\n        mensaje: \"Ocurri√≥ un error al procesar la respuesta del asistente: \" + error.message\n      }\n    }\n  ];\n}\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2144,
        9552
      ],
      "id": "31e27914-9ea6-4ae8-868f-7b706fa313f8",
      "name": "Consistencia de datos, intenci√≥n consultar malla"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "b2110549-dd58-46b3-9707-dbbe0a5004f2",
              "leftValue": "={{ $('Consistencia de datos, intenci√≥n consultar malla').item.json.mensaje.length }}",
              "rightValue": 70,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        2368,
        9552
      ],
      "id": "2141c27c-d595-4409-8ab2-a1f9bccd3670",
      "name": "Validaci√≥n de longitud de caracteres1"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        2912,
        9472
      ],
      "id": "a30c284f-c2c4-46f5-9e5b-b537cfb04df3",
      "name": "No Operation, do nothing3"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $('Consistencia de datos, intenci√≥n consultar malla').item.json.mensaje }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        2720,
        9472
      ],
      "id": "cdf93529-004b-4e05-9768-7df6e70ad4a4",
      "name": "HTTP Request Enviar Mensaje por WhatsApp4"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d9c2ff70-4fd1-4b93-8571-6d0ac5a0093e",
              "name": "mensaje.ia",
              "value": "={{ $('Consistencia de datos, intenci√≥n consultar malla').item.json.mensaje }}",
              "type": "string"
            },
            {
              "id": "ac8a03be-0292-4735-9580-39a385945c47",
              "name": "mensaje.longitud",
              "value": "={{ $('Consistencia de datos, intenci√≥n consultar malla').item.json.mensaje.length }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        2720,
        9664
      ],
      "id": "ee5f8786-8375-468d-98a7-eb0323ba342a",
      "name": "Organiza variables del mensaje1"
    },
    {
      "parameters": {
        "jsCode": "// Estructura el mensaje generado por el modelo LLM (SALUDO)\n// Este nodo espera que el campo `text` contenga un JSON v√°lido con una clave `mensajeSistema`,\n// incluso si viene envuelto entre comillas invertidas y etiquetas de bloque tipo ```json ... ```\n\nconst items = $input.all();\nconst output = [];\n\nfor (const item of items) {\n  try {\n    let raw = item.json.text.trim();\n\n    // Elimina etiquetas de bloque Markdown ```json y ```\n    raw = raw.replace(/```json\\s*|```/g, '');\n\n    // Intenta parsear el contenido limpio como JSON\n    const respuesta = JSON.parse(raw);\n\n    output.push({\n      json: {\n        mensajeParaEnviar: respuesta.mensajeSistema || \"¬°Hola! Soy tu asistente para gesti√≥n de citas en la bodega. ¬øEn qu√© puedo ayudarte?\",\n        tipo: \"saludo\",\n        accion: \"conversacion\",\n        origen: \"intencionSaludo\"\n      }\n    });\n\n  } catch (error) {\n    output.push({\n      json: {\n        error: true,\n        mensaje: \"Error al interpretar la respuesta del modelo LLM\",\n        detalle: error.message,\n        contenidoOriginal: item.json.text\n      }\n    });\n  }\n}\n\nreturn output;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -400,
        224
      ],
      "id": "187d9e1e-07e4-433e-930c-a1b847353522",
      "name": "Estructuraci√≥n, Consulta, Datos Categorias2"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "b2110549-dd58-46b3-9707-dbbe0a5004f2",
              "leftValue": "={{ $('Estructuraci√≥n, Consulta, Datos Categorias2').item.json.mensajeParaEnviar.length }}",
              "rightValue": 70,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -64,
        224
      ],
      "id": "f818f185-c682-4ba0-a3dc-8a835cb4be0a",
      "name": "Validaci√≥n de longitud de caracteres2"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        480,
        80
      ],
      "id": "7bbc1db4-40cd-42c2-9e01-6036769f2747",
      "name": "No Operation, do nothing4"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $('Estructuraci√≥n, Consulta, Datos Categorias2').item.json.mensajeParaEnviar }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        304,
        80
      ],
      "id": "60a1c68b-5bc3-4816-8aa8-2c46ef7637a7",
      "name": "HTTP Request Enviar Mensaje por WhatsApp5"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d9c2ff70-4fd1-4b93-8571-6d0ac5a0093e",
              "name": "mensaje.ia",
              "value": "={{ $('Estructuraci√≥n, Consulta, Datos Categorias2').item.json.mensajeParaEnviar }}",
              "type": "string"
            },
            {
              "id": "ac8a03be-0292-4735-9580-39a385945c47",
              "name": "mensaje.longitud",
              "value": "={{ $('Estructuraci√≥n, Consulta, Datos Categorias2').item.json.mensajeParaEnviar.length }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        4752,
        208
      ],
      "id": "87839ef5-ceb0-4a93-a29d-e55f910424d0",
      "name": "Organiza variables del mensaje2"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        3120,
        1280
      ],
      "id": "80349380-1432-4ade-82ee-933a286110dc",
      "name": "OpenAI Chat Model7",
      "credentials": {
        "openAiApi": {
          "id": "AD8kPcNVReuclASd",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "=define",
        "text": "=### SISTEMA\nEres un asistente experto en log√≠stica de bodegas, especializado en verificar disponibilidad de franjas horarias para citas de descarga de mercanc√≠a. Tu funci√≥n es:\n\n1. **Utilizar los datos estructurados** proporcionados por el nodo anterior.  \n2. **Validar y corregir posibles inconsistencias** en los datos recibidos.  \n3. **Analizar la informaci√≥n del proveedor y sus caracter√≠sticas** (rotaci√≥n, unidades por hora, etc.).  \n4. **Verificar las franjas disponibles** y alternativas presentadas.  \n5. **Generar un mensaje claro, amable y conversacional** informando el resultado de la verificaci√≥n.  \n6. **Presentar la respuesta en una estructura JSON espec√≠fica** que ser√° procesada por el siguiente nodo.  \n\n---\n### üìå DATOS DE ENTRADA (YA PROCESADOS):\n```json\n{{JSON.stringify($node[\"Code MOSTRAR_FRANJAS\"].json.output, null, 2)}}\n```\n\nüïì FECHA Y HORA ACTUAL (BOGOT√Å, COLOMBIA):\n```\n{{new Date().toLocaleString(\"es-CO\", { timeZone: \"America/Bogota\", hour12: true })}}\n```\n\nüßÆ VALIDACI√ìN Y CORRECCI√ìN DE DATOS DE ENTRADA:\nValidar disponibilidadConfirmada: Debe ser un booleano (true/false). Si es nulo o no est√° definido, asume false.\n\nValidar fecha: Debe tener formato \"DD de mes de YYYY\". Si hay un formato diferente, mantenlo tal cual, pero aseg√∫rate de generar un mensaje coherente.\n\nValidar horas: Deben tener formato \"H:MM AM/PM\". Si hay formatos diferentes o inconsistentes entre horaInicio y horaFin, mantenlos tal cual pero genera un mensaje coherente.\n\nValidar duracionHoras: Debe ser un n√∫mero entero positivo. Si es decimal, redondea hacia arriba. Si falta, calcula aproximadamente bas√°ndote en horaInicio y horaFin.\n\nValidar muelle: Debe ser \"MUELLE X\" donde X es un n√∫mero. Si tiene otro formato, mantenlo tal cual.\n\nValidar alternativasDisponibles: Debe ser un array. Si es nulo, convi√©rtelo en array vac√≠o [].\n\nValidar restriccionHoraSuperada: Debe ser un booleano. Si es nulo, asume false.\n\nSi detectas errores graves en los datos de entrada (datos completamente faltantes o corruptos), genera un mensaje informando del problema y solicitando intentar nuevamente.\n\nSi se incluyen datos del proveedor, util√≠zalos para personalizar el mensaje mencionando el nombre del proveedor y sus caracter√≠sticas relevantes.\n\nüó£Ô∏è REGLAS PARA LA REDACCI√ìN DEL MENSAJE:\nIMPORTANTE: Siempre comunica claramente que la cita NO est√° confirmada a√∫n, sino que hay disponibilidad para agendarla pero requiere confirmaci√≥n del usuario para que se genere oficialmente en el cronograma.\n\nPara citas disponibles (disponibilidadConfirmada = true):\n- Usa expresiones como \"¬°Genial!\", \"¬°Buenas noticias!\" para iniciar el mensaje\n- Clarifica que \"hay espacio para agendar esta cita\" (NO que \"la cita est√° programada\")\n- Menciona la fecha, hora inicio, hora fin y muelle de manera clara\n- Si tienes datos sobre la duraci√≥n\"cantidad\" en horas , menciona que es el tiempo asignado para el descargue de la mercancia\n- Especifica que \"el sistema pide una confirmaci√≥n de tu parte para que la cita se genere en el cronograma\"\n- Solicita expl√≠citamente \"por favor responde confirmando la cita\"\n- Recuerda el l√≠mite de 5 minutos para confirmar, explicando que \"de lo contrario no se puede garantizar el cupo solicitado en el cronograma\"\n\nPara citas con restricci√≥n de hora (restriccionHoraSuperada = true):\n- Explica amablemente la restricci√≥n (no agendar para el d√≠a siguiente despu√©s de 4:30 PM)\n- Presenta todas las alternativas organizadas por d√≠a\n- MODIFICADO: Muestra cada alternativa en una l√≠nea separada, con emojis num√©ricos (1Ô∏è‚É£, 2Ô∏è‚É£, 3Ô∏è‚É£, etc.) para cada opci√≥n\n- Especifica horas y muelle para cada alternativa\n- Agrega un salto de l√≠nea doble despu√©s de listar todas las alternativas\n- Precede la solicitud de confirmaci√≥n con el emoji ‚úèÔ∏è\n- Aclara que se necesita confirmaci√≥n para apartar el espacio en el cronograma\n- Recuerda el l√≠mite de 5 minutos para confirmar\n\nPara citas no disponibles (disponibilidadConfirmada = false, restriccionHoraSuperada = false):\n- Lamenta que la franja solicitada no est√© disponible\n- Presenta las alternativas despu√©s de un salto de l√≠nea doble\n- MODIFICADO: Muestra cada alternativa en una l√≠nea separada, con emojis num√©ricos (1Ô∏è‚É£, 2Ô∏è‚É£, 3Ô∏è‚É£, etc.) para cada opci√≥n\n- MODIFICADO: El formato exacto para cada alternativa debe ser: \"[emoji num√©rico] [fecha], de [horaInicio] a [horaFin] en el [muelle]\"\n- Agrega un salto de l√≠nea doble despu√©s de listar todas las alternativas\n- Precede la solicitud de confirmaci√≥n con el emoji ‚úèÔ∏è\n- Aclara que se necesita confirmaci√≥n para apartar el espacio en el cronograma\n- Recuerda el l√≠mite de 5 minutos para confirmar\n\nPara citas sin alternativas disponibles:\n- Si no hay alternativas, informa claramente la situaci√≥n\n- Recomienda contactar directamente con el √°rea de log√≠stica\n- Sugiere intentar en otro momento\n- Puedes apoyarte en tu respuesta a partir de la respuesta de la recoleccion de datos \"{{ $('Code RECOLECCI√ìN').item.json.mensajeSistema }}\"\n\nPersonalizaci√≥n del mensaje:\n- Si tienes datos del proveedor, menciona su nombre\n- Si tienes informaci√≥n sobre las unidades a entregar, incl√∫yela para explicar el tiempo asignado\n- Si conoces la categor√≠a del producto, util√≠zala para contextualizar\n\nTono y estilo:\n- Usa un tono conversacional, humano y cercano\n- Incluye frases como \"viendo el cronograma me registra que...\", \"por la cantidad de unidades y peso en promedio va a tardar...\"\n- Evita frases formales o r√≠gidas como \"Se ha encontrado una franja disponible\"\n- Estruct√∫ra el mensaje para que fluya naturalmente como una conversaci√≥n\n\nMODIFICADO - EJEMPLO DE FORMATO PARA ALTERNATIVAS (cuando disponibilidadConfirmada = false):\n\"Lamentablemente, la franja solicitada para el 06 de mayo de 2025, de 08:00 AM a 10:00 AM en el MUELLE 1 no est√° disponible. Sin embargo, tengo algunas alternativas para ti:\n\n1Ô∏è‚É£ 06 de mayo de 2025, de 6:00 AM a 8:00 AM en el MUELLE 1\n2Ô∏è‚É£ 06 de mayo de 2025, de 10:00 AM a 12:00 PM en el MUELLE 1\n3Ô∏è‚É£ 06 de mayo de 2025, de 11:00 AM a 1:00 PM en el MUELLE 1\n4Ô∏è‚É£ 06 de mayo de 2025, de 12:00 PM a 2:00 PM en el MUELLE 1\n\n‚úèÔ∏è Necesito tu confirmaci√≥n para apartar el espacio en el cronograma, y recuerda que el sistema nos da 5 minutos para confirmar la cita o de lo contrario no se puede garantizar el cupo solicitado.\"\n\nüßæ ESTRUCTURA DE SALIDA REQUERIDA\nDebes devolver una estructura JSON con exactamente estos campos:\n\n```json\n{\n  \"disponibilidadConfirmada\": boolean,\n  \"fecha\": string,\n  \"horaInicio\": string,\n  \"horaFin\": string,\n  \"muelle\": string,\n  \"duracionHoras\": number,\n  \"restriccionHoraSuperada\": boolean,\n  \"alternativasDisponibles\": array,\n  \"mensajeSistema\": string\n}\n```\n\n‚úÖ VALIDACIONES FINALES ANTES DE ENVIAR LA RESPUESTA:\n- Verifica que todos los campos obligatorios est√©n presentes en tu respuesta.\n- Aseg√∫rate de que los tipos de datos sean correctos (boolean para booleanos, string para texto, number para n√∫meros, array para arreglos).\n- Comprueba que la estructura JSON sea v√°lida y est√© correctamente formateada.\n- Verifica que el campo mensajeSistema sea coherente con los dem√°s campos (ej: si disponibilidadConfirmada=true, el mensaje debe indicar que hay espacio disponible pero requiere confirmaci√≥n, NO que la cita ya est√° programada).\n- Aseg√∫rate de que alternativasDisponibles sea un array, incluso si est√° vac√≠o.\n- MODIFICADO: Verifica que cuando existen alternativas, cada una aparezca en su propia l√≠nea con el emoji num√©rico correspondiente.\n- MODIFICADO: Verifica que la solicitud de confirmaci√≥n aparezca despu√©s de un salto de l√≠nea doble y precedida por el emoji ‚úèÔ∏è.\n- Si utilizas caracteres especiales o saltos de l√≠nea en mensajeSistema, verifica que est√©n correctamente escapados en el JSON.\n- Revisa que el mensaje comunique claramente que la cita NO est√° confirmada a√∫n.\n\nIMPORTANTE:\n- NO uses bloques de c√≥digo markdown como ```json.\n- NO agregues ning√∫n texto antes ni despu√©s.\n- SOLO responde con un objeto JSON plano.\n- El contenido debe empezar directamente con `{` y terminar con `}`.\n- El JSON debe cumplir con el siguiente formato y campos obligatorios:\n\n{\n  \"disponibilidadConfirmada\": boolean,\n  \"fecha\": string,\n  \"horaInicio\": string,\n  \"horaFin\": string,\n  \"muelle\": string,\n  \"duracionHoras\": number,\n  \"restriccionHoraSuperada\": boolean,\n  \"alternativasDisponibles\": array,\n  \"mensajeSistema\": string\n}\n\n### EJEMPLO DE MENSAJE IDEAL PARA DISPONIBILIDAD CONFIRMADA:\n\"¬°Genial! Viendo el cronograma me registra que s√≠ hay espacio para agendar esta cita, ser√≠a para el 15 de abril de 2025, desde las 9:00 AM hasta las 12:00 PM ya que por la cantidad de unidades y peso en promedio va a tardar 3 horas el descargue en el MUELLE 1. El sistema pide una confirmaci√≥n de tu parte para que la cita se genere en el cronograma, por favor responde confirmando la cita y recuerda que el sistema nos da 5 minutos para confirmar la cita o de lo contrario no se puede garantizar el cupo solicitado en el cronograma.\""
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        3200,
        1088
      ],
      "id": "d4ee6f6c-7bb9-4d20-96d4-b795871ac725",
      "name": "Basic LLM Chain MOSTRAR_FRANJAS"
    },
    {
      "parameters": {
        "promptType": "=define",
        "text": "=### SISTEMA\nEres un asistente especializado en extraer datos de citas de entrega de mercanc√≠a a partir del historial de conversaciones entre un proveedor y un sistema de agendamiento. Tu funci√≥n es:\n1. **Analizar el historial completo de mensajes** entre el proveedor y el sistema.\n2. **Identificar y extraer los datos finales validados** para la cita de entrega.\n3. **Estructurar estos datos** en un formato JSON claro y consistente para su procesamiento posterior.\n---\n### üóÇÔ∏è HISTORIAL DE MENSAJES:\n{{ $node[\"Unificaci√≥n y consistencia de datos\"].json[\"infoMensaje\"][\"historialMensajes\"] }}\n\n### üì© MENSAJE DE CONFIRMACI√ìN DEL SISTEMA:\n{{ $json.mensajeSistema }}\n\n### üïì FECHA Y HORA ACTUAL (BOGOT√Å, COLOMBIA):\n{{ new Date().toLocaleString(\"es-CO\", { timeZone: \"America/Bogota\", hour12: true }) }}\n---\n### ‚úÖ DATOS A EXTRAER:\n- **Nombre del proveedor**: El nombre validado y confirmado (debe ser el nombre exacto que aparece en los registros).\n- **Fecha de la cita**: La fecha validada para la entrega (en formato \"DD de [mes] de YYYY\").\n- **Hora de la cita**: La hora validada para la entrega (en formato est√°ndar, ej. \"10:00 AM\").\n- **Categor√≠a del producto**: La categor√≠a validada y confirmada.\n- **Peso estimado**: El peso en kilos.\n- **N√∫mero de unidades**: La cantidad de unidades a entregar.\n- **N√∫mero de orden de compra**: El n√∫mero de referencia para la orden.\n\n### üîç JERARQU√çA DE FUENTES DE DATOS:\n1. **PRIORIDAD ALTA**: Usa siempre el mensaje de confirmaci√≥n del sistema (mensajeSistema) como fuente principal, ya que contiene los datos completamente validados, normalizados y oficiales.\n2. **PRIORIDAD MEDIA**: Si alg√∫n dato espec√≠fico no est√° en el mensaje de confirmaci√≥n del sistema, b√∫scalo en los √∫ltimos mensajes del historial de conversaci√≥n.\n3. **PRIORIDAD BAJA**: Solo como √∫ltimo recurso, usa los datos iniciales proporcionados por el usuario.\n\n### üîÑ ALGORITMO DE EXTRACCI√ìN:\n1. **Primero, analiza el mensaje de confirmaci√≥n del sistema** (mensajeSistema) ya que contiene los datos m√°s precisos y validados.\n2. **Extrae de all√≠ todos los datos disponibles**, prestando especial atenci√≥n a:\n   - El nombre completo y oficial del proveedor (no abreviaturas)\n   - La categor√≠a normalizada del producto\n   - Datos num√©ricos validados como peso y unidades\n3. **Solo si alg√∫n dato no est√° disponible en el mensaje de confirmaci√≥n**, revisa el historial completo de mensajes para encontrarlo.\n4. **Estructura todos los datos obtenidos** en el formato JSON requerido.\n\n### üìå RESPUESTA (EN FORMATO JSON V√ÅLIDO):\n```json\n{\n  \"proveedor\": \"Nombre exacto del proveedor validado\",\n  \"fecha\": \"DD de [mes] de YYYY\",\n  \"hora\": \"HH:MM AM/PM\",\n  \"categoria\": \"Categor√≠a validada\",\n  \"peso\": 000,\n  \"unidades\": 000,\n  \"ordenCompra\": \"C√≥digo de la orden de compra\"\n}\n```\n\n**REGLAS IMPORTANTES**:\n1. **SIEMPRE prioriza los datos del mensaje de confirmaci√≥n del sistema** sobre los datos proporcionados inicialmente por el usuario.\n2. **Para el nombre del proveedor y la categor√≠a**, usa SIEMPRE la versi√≥n completa y normalizada que aparece en el mensaje de confirmaci√≥n del sistema, ya que este contiene los nombres oficiales como est√°n registrados en la base de datos.\n3. **Convierte todas las expresiones temporales** a fechas espec√≠ficas (ej. \"ma√±ana\" ‚Üí \"15 de abril de 2025\").\n4. **Convierte valores num√©ricos** (peso, unidades) a formato num√©rico sin unidades (ej. \"300 kilos\" ‚Üí 300).\n5. **Estandariza el formato de hora** (ej. \"10 de la ma√±ana\" ‚Üí \"10:00 AM\").\n\n**EJEMPLO DE EXTRACCI√ìN CORRECTO**:\n**Mensaje del usuario**:\n```\n\"Hola, deseo agendar una cita de entrega para ma√±ana, el nombre del proveedor es spb, categor√≠a arenas, con un peso de 300 kilos, a las 9 de la ma√±ana, 900 unidades, el n√∫mero de orden de compra es ARGM47896.\"\n```\n\n**Mensaje de confirmaci√≥n del sistema**:\n```\n\"He registrado tu cita para SPB COLOMBIA S.A.S. el d√≠a 14 de abril a las 09:00 AM, categor√≠a ARENAS, con un peso de 300 kilos y 900 unidades. Tu n√∫mero de orden de compra ARGM47896 ha sido registrado. Tu cita ha sido confirmada exitosamente.\"\n```\n\n**Respuesta esperada**:\n```json\n{\n  \"proveedor\": \"SPB COLOMBIA S.A.S.\",\n  \"fecha\": \"14 de abril de 2025\",\n  \"hora\": \"09:00 AM\",\n  \"categoria\": \"ARENAS\",\n  \"peso\": 300,\n  \"unidades\": 900,\n  \"ordenCompra\": \"ARGM47896\"\n}\n```\n\nIMPORTANTE: Tu tarea es SOLO extraer y estructurar los datos validados. No agregues explicaciones fuera del JSON requerido. Estos datos ser√°n utilizados por otro nodo para verificar disponibilidad en las mallas de recibo.",
        "hasOutputParser": true
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        2080,
        1088
      ],
      "id": "d910bf45-9d0e-406c-a4ed-ec2a28caadd8",
      "name": "Basic LLM Chain EXTRACCI√ìN_DATOS_CITA"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4o-mini"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        2064,
        1280
      ],
      "id": "bdf873e9-0ec8-4400-8937-19c1bc46828d",
      "name": "OpenAI Chat Model8",
      "credentials": {
        "openAiApi": {
          "id": "AD8kPcNVReuclASd",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n  \"proveedor\": \"string\",\n  \"fecha\": \"string\",\n  \"hora\": \"string\",\n  \"categoria\": \"string\",\n  \"peso\": 0,\n  \"unidades\": 0,\n  \"ordenCompra\": \"string\"\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.2,
      "position": [
        2288,
        1344
      ],
      "id": "01e6bd01-c9e6-4872-ab3f-5d2f6b11ca3a",
      "name": "Structured Output Parser1"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=INSERT INTO MensajesWhatsApp (message_id, contenido, fecha, chat_id, instance)\nVALUES (\n  '{{ $('Parametrizaci√≥n').first().json.message.id }}',\n  '{{ JSON.stringify($node[\"Basic LLM Chain EXTRACCI√ìN_DATOS_CITA\"].json.output, null, 2).replace(/'/g, \"''\") }}',\n  FORMAT(SWITCHOFFSET(GETDATE(), '-05:00'), 'yyyy-MM-dd HH:mm:ss'),\n  'agenteAI',\n  '{{ $('Parametrizaci√≥n').first().json.message.chat.instance }}'\n); "
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        2560,
        1088
      ],
      "id": "5ba6ea60-2660-4bd7-be60-d6e0cf448590",
      "name": "Microsoft SQL Guardar EXTRACCI√ìN_DATOS_CITA",
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Extraer directamente el texto JSON desde el nodo LLM\nlet textoPlano = $node[\"Basic LLM Chain MOSTRAR_FRANJAS\"].json.text;\n\nlet llmResponse;\ntry {\n  llmResponse = JSON.parse(textoPlano.trim());\n} catch (error) {\n  throw new Error(\"‚ùå No se pudo parsear el JSON generado por el modelo. Revisa el formato.\\nTexto recibido:\\n\" + textoPlano);\n}\n\n// Convertir formato de fecha a ISO (YYYY-MM-DD)\nlet fechaFormateada = llmResponse.fecha;\nif (fechaFormateada && fechaFormateada.includes(\"de\")) {\n  const meses = {\n    \"enero\": \"01\", \"febrero\": \"02\", \"marzo\": \"03\", \"abril\": \"04\",\n    \"mayo\": \"05\", \"junio\": \"06\", \"julio\": \"07\", \"agosto\": \"08\",\n    \"septiembre\": \"09\", \"octubre\": \"10\", \"noviembre\": \"11\", \"diciembre\": \"12\"\n  };\n\n  const partes = fechaFormateada.split(\" de \");\n  if (partes.length === 3) {\n    const dia = partes[0].padStart(2, \"0\");\n    const mes = meses[partes[1].toLowerCase()];\n    const a√±o = partes[2];\n    fechaFormateada = `${a√±o}-${mes}-${dia}`;\n  }\n}\n\n// Preparar objeto estandarizado\nlet standardResponse = {\n  disponibilidadConfirmada: llmResponse.disponibilidadConfirmada,\n  fecha: llmResponse.fecha,\n  fechaFormateada: fechaFormateada,\n  horaInicio: llmResponse.horaInicio,\n  horaFin: llmResponse.horaFin,\n  muelle: llmResponse.muelle,\n  duracionHoras: llmResponse.duracionHoras,\n  alternativasDisponibles: Array.isArray(llmResponse.alternativasDisponibles) \n    ? llmResponse.alternativasDisponibles \n    : [],\n  mensajeSistema: llmResponse.mensajeSistema,\n  datosCita: {\n    proveedor: $node[\"Basic LLM Chain EXTRACCI√ìN_DATOS_CITA\"].json.output.proveedor,\n    categoria: $node[\"Basic LLM Chain EXTRACCI√ìN_DATOS_CITA\"].json.output.categoria,\n    peso: $node[\"Basic LLM Chain EXTRACCI√ìN_DATOS_CITA\"].json.output.peso,\n    unidades: $node[\"Basic LLM Chain EXTRACCI√ìN_DATOS_CITA\"].json.output.unidades,\n    ordenCompra: $node[\"Basic LLM Chain EXTRACCI√ìN_DATOS_CITA\"].json.output.ordenCompra\n  },\n  timestamp: new Date().toISOString()\n};\n\n// Normalizar hora (por si empieza con cero innecesario)\nstandardResponse.horaInicio = standardResponse.horaInicio.replace(/^0(\\d:00 [AP]M)$/, \"$1\");\n\nreturn { standardResponse };"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3648,
        1088
      ],
      "id": "e7807ea1-db62-46be-9d08-e733b6a75fdc",
      "name": "Code estandarizar respuestas MOSTRAR_FRANJAS"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO FranjasDisponiblesTemp \n(chat_id, franjas_json, timestamp_enviado, datos_cita_json, fecha_cita, hora_inicio, hora_fin) \nVALUES \n(\n    '{{$node[\"Organiza el Mensaje\"].json[\"infoMensaje\"][\"chat_id\"]}}', \n    '{{JSON.stringify($node[\"Code estandarizar respuestas MOSTRAR_FRANJAS\"].json.standardResponse).replace(/'/g, \"''\")}}', \n    GETDATE(), \n    '{{JSON.stringify($node[\"Code estandarizar respuestas MOSTRAR_FRANJAS\"].json.standardResponse.datosCita)}}', \n    CONVERT(DATETIME, '{{$node[\"Code estandarizar respuestas MOSTRAR_FRANJAS\"].json.standardResponse.fechaFormateada}}'), \n    FORMAT(CAST('{{$node[\"Code estandarizar respuestas MOSTRAR_FRANJAS\"].json.standardResponse.horaInicio}}' AS DATETIME), 'HH:mm'), \n    FORMAT(CAST('{{$node[\"Code estandarizar respuestas MOSTRAR_FRANJAS\"].json.standardResponse.horaFin}}' AS DATETIME), 'HH:mm')\n);"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        3920,
        1088
      ],
      "id": "de8c7b45-227a-4e53-b879-083790af5026",
      "name": "Microsoft SQL Guardar MOSTRAR_FRANJAS",
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// C√≥digo para verificar disponibilidad de franjas horarias en n8n\n// ‚Äî versi√≥n corregida 2025-06-17 ‚Äî Busca por fecha exacta en fechaDia\n\n// Funci√≥n ejecutada por el nodo Code\nfunction procesarVerificacionFranjas(items, runIndex) {\n  try {\n    // 0. Entradas provenientes de los nodos anteriores\n    const datosCita            = $node[\"Basic LLM Chain EXTRACCI√ìN_DATOS_CITA\"].json.output;     // datos de la cita\n    const datosMalla           = $node[\"Unificaci√≥n y consistencia de datos1\"].json.datosMalla;   // malla semana actual\n    const datosMallaProxSemana = $node[\"Unificaci√≥n y consistencia de datos1\"].json.datosMallaProxSemana;\n    const datoscategorias      = $node[\"Unificaci√≥n y consistencia de datos1\"].json.datoscategorias;\n    const datosproveedor       = $node[\"Unificaci√≥n y consistencia de datos1\"].json.datosproveedor;\n\n    // 1. Agrupamos todo en un solo objeto\n    const datosEntrada = {\n      datosCita,\n      datosMalla,\n      datosMallaProxSemana,\n      datoscategorias,\n      datosproveedor\n    };\n\n    // 2. Ejecutamos la verificaci√≥n\n    const resultado = verificarDisponibilidadFranjas(datosEntrada);\n\n    // 3. Devolvemos la salida en el formato que n8n espera\n    return [{ json: resultado }];\n  } catch (error) {\n    console.error(\"Error en procesamiento principal:\", error);\n    return [{ json: { error: error.message || \"Error en el procesamiento\" } }];\n  }\n}\n\n/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n *  FUNCI√ìN PRINCIPAL DE VERIFICACI√ìN\n * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */\nfunction verificarDisponibilidadFranjas(datosEntrada) {\n  try {\n    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 1. DATOS B√ÅSICOS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */\n    const {\n      datosCita,\n      datosMalla:        mallaActual,\n      datosMallaProxSemana: mallaProxima,\n      datoscategorias:   categorias,\n      datosproveedor:    proveedores\n    } = datosEntrada;\n\n    const fechaHoraActual = new Date();\n\n    const proveedor       = datosCita.proveedor   || \"\";\n    const fechaSolicitada = datosCita.fecha       || \"\";\n    const horaSolicitada  = datosCita.hora        || \"\";\n    const categoria       = datosCita.categoria   || \"\";\n    const unidades        = Number.parseInt(String(datosCita.unidades || \"0\"), 10);\n\n    /* Validaciones m√≠nimas */\n    if (!proveedor)       return { error: \"Proveedor no especificado\" };\n    if (!fechaSolicitada) return { error: \"Fecha no especificada\" };\n    if (!horaSolicitada)  return { error: \"Hora no especificada\" };\n    if (!categoria)       return { error: \"Categor√≠a no especificada\" };\n    if (Number.isNaN(unidades) || unidades <= 0) return { error: \"Cantidad de unidades inv√°lida\" };\n\n    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 2. PROVEEDOR ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */\n    const datosProveedor = buscarProveedor(proveedores, proveedor);\n    if (!datosProveedor) {\n      return { error: `No se encontr√≥ el proveedor \"${proveedor}\" en la base de datos` };\n    }\n\n    const unidadesPorHora = datosProveedor.unidadesPorHora;\n    if (!unidadesPorHora || unidadesPorHora <= 0) {\n      return { error: `El proveedor \"${proveedor}\" no tiene definidas unidades por hora v√°lidas` };\n    }\n\n    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 3. C√ÅLCULOS B√ÅSICOS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */\n    const horasNecesarias = Math.ceil(unidades / unidadesPorHora);\n    const restriccionHoraSuperada = verificarRestriccionHoraCitaManana(fechaHoraActual, fechaSolicitada);\n\n    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 4. HORA NORMALIZADA ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */\n    const horaNormalizada = horaSolicitada.trim();\n\n    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 5. MUELLE POR CATEGOR√çA ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */\n    const muelleAsignado = determinarMuellePorCategoria(categorias, categoria);\n    if (!muelleAsignado) {\n      return { error: `No se encontr√≥ un muelle asignado para la categor√≠a \"${categoria}\"` };\n    }\n\n    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 6. DISPONIBILIDAD / ALTERNATIVAS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */\n    let resultado;\n\n    if (restriccionHoraSuperada) {\n      // Caso: contactaron despu√©s de las 4:30 p.m. y la cita es para ma√±ana\n      const alternativas = buscarAlternativasDesdeDosDiasDespues(\n        fechaHoraActual,\n        mallaActual,\n        mallaProxima,\n        muelleAsignado,\n        horasNecesarias\n      );\n\n      resultado = {\n        disponibilidadConfirmada: false,\n        fecha:           fechaSolicitada,\n        horaInicio:      horaNormalizada,\n        horaFin:         calcularHoraFin(horaNormalizada, horasNecesarias),\n        muelle:          muelleAsignado,\n        duracionHoras:   horasNecesarias,\n        restriccionHoraSuperada: true,\n        alternativasDisponibles: alternativas.slice(0, 10)\n      };\n    } else {\n      const disponible = verificarDisponibilidadHoraSolicitada(\n        fechaSolicitada,\n        horaNormalizada,\n        muelleAsignado,\n        horasNecesarias,\n        mallaActual,\n        mallaProxima\n      );\n\n      if (disponible) {\n        resultado = {\n          disponibilidadConfirmada: true,\n          fecha:           fechaSolicitada,\n          horaInicio:      horaNormalizada,\n          horaFin:         calcularHoraFin(horaNormalizada, horasNecesarias),\n          muelle:          muelleAsignado,\n          duracionHoras:   horasNecesarias,\n          restriccionHoraSuperada: false,\n          alternativasDisponibles: []\n        };\n      } else {\n        const alternativasMismoDia = buscarAlternativasMismoDia(\n          fechaSolicitada,\n          muelleAsignado,\n          horasNecesarias,\n          mallaActual,\n          mallaProxima\n        );\n\n        const todasAlternativas = alternativasMismoDia.length > 0\n          ? alternativasMismoDia\n          : buscarAlternativasDiasPeriores(\n              fechaSolicitada,\n              muelleAsignado,\n              horasNecesarias,\n              mallaActual,\n              mallaProxima\n            );\n\n        resultado = {\n          disponibilidadConfirmada: false,\n          fecha:           fechaSolicitada,\n          horaInicio:      horaNormalizada,\n          horaFin:         calcularHoraFin(horaNormalizada, horasNecesarias),\n          muelle:          muelleAsignado,\n          duracionHoras:   horasNecesarias,\n          restriccionHoraSuperada: false,\n          alternativasDisponibles: todasAlternativas\n        };\n      }\n    }\n\n    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 7. DATOS PROVEEDOR ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */\n    resultado.datosProveedorEncontrado = {\n      nombre:           datosProveedor.proveedor,\n      unidadesPorHora:  datosProveedor.unidadesPorHora,\n      rotacion:         datosProveedor.rotacion,\n      tipoProveedor:    datosProveedor.tipoProveedor\n    };\n\n    return { output: resultado };\n  } catch (error) {\n    console.error(\"Error en verificaci√≥n de disponibilidad:\", error);\n    return { error: `Error en la verificaci√≥n: ${error.message}` };\n  }\n}\n\n/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n *  FUNCIONES DE APOYO\n * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */\n\n// (1) B√∫squeda de proveedor\nfunction buscarProveedor(listaProveedores, nombreProveedor) {\n  if (!Array.isArray(listaProveedores) || listaProveedores.length === 0) return null;\n  if (!nombreProveedor) return null;\n\n  const nombreLower = nombreProveedor.toLowerCase();\n  const exacta  = listaProveedores.find(p => (p.proveedor || \"\").toLowerCase() === nombreLower);\n  if (exacta) return exacta;\n\n  return listaProveedores.find(p => (p.proveedor || \"\").toLowerCase().includes(nombreLower));\n}\n\n// (2) Normalizador de hora para comparaciones\nfunction limpiarHora(h) {\n  return h ? h.trim().replace(/^0+/, \"\").toUpperCase() : \"\";\n}\n\n// (3) Determinar muelle por categor√≠a\nfunction determinarMuellePorCategoria(categorias, categoriaProducto) {\n  if (!Array.isArray(categorias) || categorias.length === 0) return null;\n  const catLower = categoriaProducto.toLowerCase();\n\n  const exacta = categorias.find(c => (c.CATEGORIA || \"\").toLowerCase() === catLower);\n  if (exacta) return exacta.MUELLE;\n\n  const parcial = categorias.find(c => (c.CATEGORIA || \"\").toLowerCase().includes(catLower));\n  return parcial ? parcial.MUELLE : null;\n}\n\n// (4) Calcular hora de fin\nfunction calcularHoraFin(horaInicio, horasNecesarias) {\n  if (!horaInicio) return \"\";\n  const [horaTxt, meridiano] = horaInicio.trim().split(\" \");\n  let hora = parseInt(horaTxt, 10);\n  if (meridiano === \"PM\" && hora < 12) hora += 12;\n  if (meridiano === \"AM\" && hora === 12) hora = 0;\n  hora += horasNecesarias;\n  let nuevoMeridiano = \"AM\";\n  if (hora >= 12) {\n    nuevoMeridiano = \"PM\";\n    if (hora > 12) hora -= 12;\n  }\n  if (hora === 0) { hora = 12; nuevoMeridiano = \"AM\"; }\n  return `${hora}:00 ${nuevoMeridiano}`;\n}\n\n// (5) Restricci√≥n 4:30 p.m. ‚Üí cita ma√±ana (CORREGIDO - ZONA HORARIA)\nfunction verificarRestriccionHoraCitaManana(fechaHoraActual, fechaSolicitada) {\n  // 1. Obtener la fecha y hora actual en la zona horaria de Bogot√°.\n  //    Esto es CRUCIAL para que la comparaci√≥n de las 4:30 PM funcione correctamente\n  //    independientemente de la zona horaria del servidor.\n  const ahoraEnBogota = new Date(new Date().toLocaleString(\"en-US\", { timeZone: \"America/Bogota\" }));\n\n  // 2. Verificar si la hora actual en Bogot√° es despu√©s de las 4:30 PM.\n  const horaBogota = ahoraEnBogota.getHours();\n  const minutosBogota = ahoraEnBogota.getMinutes();\n  const esDespuesDe430PM = horaBogota > 16 || (horaBogota === 16 && minutosBogota >= 30);\n\n  // 3. Parsear la fecha que el usuario solicit√≥.\n  const fechaSolicitadaObj = parsearFechaEspanol(fechaSolicitada);\n  if (!fechaSolicitadaObj || isNaN(fechaSolicitadaObj.getTime())) {\n    console.error(\"Fecha solicitada inv√°lida:\", fechaSolicitada);\n    return false;\n  }\n\n  // 4. Calcular la fecha de \"ma√±ana\" bas√°ndose en la fecha actual de Bogot√°.\n  const fechaManana = new Date(ahoraEnBogota);\n  fechaManana.setDate(fechaManana.getDate() + 1);\n  \n  // 5. Comparar si la fecha solicitada es efectivamente \"ma√±ana\".\n  //    Se compara a√±o, mes y d√≠a para evitar problemas con horas.\n  const esMa√±ana = fechaSolicitadaObj.getFullYear() === fechaManana.getFullYear() &&\n                   fechaSolicitadaObj.getMonth() === fechaManana.getMonth() &&\n                   fechaSolicitadaObj.getDate() === fechaManana.getDate();\n\n  // 6. La restricci√≥n se aplica solo si AMBAS condiciones son verdaderas.\n  return esMa√±ana && esDespuesDe430PM;\n}\n\n\n// (6) Parsear fecha \"30 de abril de 2025\"\nfunction parsearFechaEspanol(fechaTexto) {\n  const [dia, , mesTxt, , anio] = fechaTexto.split(\" \");\n  return new Date(Number(anio), obtenerNumeroMes(mesTxt), Number(dia));\n}\n\n// (7) Obtener n√∫mero de mes\nfunction obtenerNumeroMes(nombreMes) {\n  const meses = [\"enero\",\"febrero\",\"marzo\",\"abril\",\"mayo\",\"junio\",\"julio\",\"agosto\",\"septiembre\",\"octubre\",\"noviembre\",\"diciembre\"];\n  return meses.indexOf(nombreMes.toLowerCase());\n}\n\n// (8) NUEVA FUNCI√ìN: Buscar d√≠a por fecha exacta en todas las mallas\nfunction buscarDiaPorFechaExacta(fechaSolicitada, mallaActual, mallaProxima) {\n  const mallas = [\n    { malla: mallaActual, nombre: \"actual\" },\n    { malla: mallaProxima, nombre: \"proxima\" }\n  ];\n\n  for (const { malla, nombre } of mallas) {\n    if (!malla || !malla.dias) continue;\n\n    // Recorrer todos los d√≠as de la malla\n    for (const [nombreDia, datosDia] of Object.entries(malla.dias)) {\n      if (datosDia && datosDia.fechaDia === fechaSolicitada) {\n        console.log(`Fecha ${fechaSolicitada} encontrada en malla ${nombre}, d√≠a: ${nombreDia}`);\n        return {\n          malla: malla,\n          nombreDia: nombreDia,\n          datosDia: datosDia,\n          mallaUsada: nombre\n        };\n      }\n    }\n  }\n\n  console.log(`Fecha ${fechaSolicitada} NO encontrada en ninguna malla`);\n  return null;\n}\n\n// (9) Verificar disponibilidad de la hora solicitada (NUEVA L√ìGICA)\nfunction verificarDisponibilidadHoraSolicitada(\n  fechaSolicitada,\n  horaSolicitada,\n  muelle,\n  horasNecesarias,\n  mallaActual,\n  mallaProxima\n) {\n  try {\n    console.log(`Verificando disponibilidad para fecha: ${fechaSolicitada}, hora: ${horaSolicitada}, muelle: ${muelle}`);\n\n    /* ‚îÄ‚îÄ Buscar el d√≠a por fecha exacta ‚îÄ‚îÄ */\n    const resultadoBusqueda = buscarDiaPorFechaExacta(fechaSolicitada, mallaActual, mallaProxima);\n    \n    if (!resultadoBusqueda) {\n      console.log(`No se encontr√≥ la fecha ${fechaSolicitada} en ninguna malla`);\n      return false;\n    }\n\n    const { malla, nombreDia, datosDia } = resultadoBusqueda;\n\n    /* ‚îÄ‚îÄ Verificar muelle ‚îÄ‚îÄ */\n    const nombreMuelle = muelle.toLowerCase().replace(/\\s+/g, \"\"); // \"MUELLE 1\" ‚Üí \"muelle1\"\n    if (!datosDia[nombreMuelle]) {\n      console.log(`No se encontr√≥ el muelle ${nombreMuelle} para el d√≠a ${nombreDia}`);\n      console.log(`Muelles disponibles:`, Object.keys(datosDia).filter(k => k !== 'fechaDia'));\n      return false;\n    }\n\n    /* ‚îÄ‚îÄ Verificar franjas ‚îÄ‚îÄ */\n    if (!malla.franjas || !Array.isArray(malla.franjas) || malla.franjas.length === 0) {\n      console.log(\"No hay franjas definidas en la malla\");\n      return false;\n    }\n\n    const franjas = malla.franjas.map(f => f.hora);\n    const indiceInicio = franjas.findIndex(h => limpiarHora(h) === limpiarHora(horaSolicitada));\n    \n    if (indiceInicio === -1) {\n      console.log(`No se encontr√≥ la hora ${horaSolicitada} en las franjas disponibles`);\n      console.log(`Franjas disponibles:`, franjas);\n      return false;\n    }\n    \n    if (indiceInicio + horasNecesarias > franjas.length) {\n      console.log(`No hay suficientes franjas consecutivas disponibles (necesita ${horasNecesarias})`);\n      return false;\n    }\n\n    /* ‚îÄ‚îÄ Verificar disponibilidad de todas las franjas necesarias ‚îÄ‚îÄ */\n    for (let i = 0; i < horasNecesarias; i++) {\n      const horaFranja = franjas[indiceInicio + i];\n      const franja = datosDia[nombreMuelle][horaFranja];\n      \n      if (!franja) {\n        console.log(`No se encontr√≥ la franja ${horaFranja} en ${nombreMuelle}`);\n        return false;\n      }\n      \n      const estadoFranja = (franja.estado || \"\").toLowerCase().trim();\n      console.log(`Franja ${horaFranja}: estado = \"${estadoFranja}\"`);\n      \n      if (estadoFranja !== \"disponible\") {\n        console.log(`La franja ${horaFranja} no est√° disponible. Estado: ${franja.estado}`);\n        return false;\n      }\n    }\n    \n    console.log(`Todas las franjas est√°n disponibles para ${fechaSolicitada} ${horaSolicitada}`);\n    return true;\n  } catch (error) {\n    console.error(`Error verificando disponibilidad: ${error.message}`);\n    return false;\n  }\n}\n\n// (10) Formatear fecha en formato espa√±ol\nfunction formatearFechaEspanol(fecha) {\n  if (!fecha || !(fecha instanceof Date)) {\n    return \"\";\n  }\n  \n  const dia = fecha.getDate();\n  const meses = [\n    \"enero\", \"febrero\", \"marzo\", \"abril\", \"mayo\", \"junio\",\n    \"julio\", \"agosto\", \"septiembre\", \"octubre\", \"noviembre\", \"diciembre\"\n  ];\n  const mes = meses[fecha.getMonth()];\n  const anio = fecha.getFullYear();\n  \n  return `${dia} de ${mes} de ${anio}`;\n}\n\n/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */\n/* FUNCIONES PARA BUSCAR ALTERNATIVAS                                        */\n/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */\n\n// Buscar alternativas desde dos d√≠as despu√©s\nfunction buscarAlternativasDesdeDosDiasDespues(\n  fechaActual,\n  mallaActual,\n  mallaProxima,\n  muelle,\n  horasNecesarias\n) {\n  try {\n    const fechaDosDiasDespues = new Date(fechaActual);\n    fechaDosDiasDespues.setDate(fechaDosDiasDespues.getDate() + 2);\n    \n    // Ajustar si cae en fin de semana\n    if (fechaDosDiasDespues.getDay() === 0) { // Domingo\n      fechaDosDiasDespues.setDate(fechaDosDiasDespues.getDate() + 1);\n    } else if (fechaDosDiasDespues.getDay() === 6) { // S√°bado\n      fechaDosDiasDespues.setDate(fechaDosDiasDespues.getDate() + 2);\n    }\n    \n    const fechaDosDiasDespuesStr = formatearFechaEspanol(fechaDosDiasDespues);\n    const alternativas = buscarAlternativasParaDiaConFechaExacta(\n      fechaDosDiasDespuesStr,\n      muelle,\n      horasNecesarias,\n      mallaActual,\n      mallaProxima\n    );\n    \n    // Solo devolver m√°ximo 10 alternativas de ese d√≠a\n    return alternativas.slice(0, 10);\n  } catch (error) {\n    console.error(`Error buscando alternativas: ${error.message}`);\n    return [];\n  }\n}\n\n// Buscar alternativas para un d√≠a espec√≠fico usando fecha exacta\nfunction buscarAlternativasParaDiaConFechaExacta(\n  fechaTexto,\n  muelle,\n  horasNecesarias,\n  mallaActual,\n  mallaProxima\n) {\n  try {\n    const alternativas = [];\n    \n    const resultadoBusqueda = buscarDiaPorFechaExacta(fechaTexto, mallaActual, mallaProxima);\n    if (!resultadoBusqueda) {\n      return alternativas;\n    }\n\n    const { malla, datosDia } = resultadoBusqueda;\n    const nombreMuelle = muelle.toLowerCase().replace(/\\s+/g, \"\");\n    \n    if (!datosDia[nombreMuelle]) {\n      return alternativas;\n    }\n    \n    if (!malla.franjas || !Array.isArray(malla.franjas) || malla.franjas.length === 0) {\n      return alternativas;\n    }\n    \n    const franjasHorario = malla.franjas.map(f => f.hora);\n    \n    // Verificar cada posible hora de inicio\n    for (let i = 0; i <= franjasHorario.length - horasNecesarias; i++) {\n      const horaInicio = franjasHorario[i];\n      let todasDisponibles = true;\n      \n      // Verificar disponibilidad de todas las franjas consecutivas\n      for (let j = 0; j < horasNecesarias; j++) {\n        const horaActual = franjasHorario[i + j];\n        const franja = datosDia[nombreMuelle][horaActual];\n        \n        if (!franja || (franja.estado || \"\").toLowerCase().trim() !== \"disponible\") {\n          todasDisponibles = false;\n          break;\n        }\n      }\n      \n      // Si todas las franjas est√°n disponibles, agregar como alternativa\n      if (todasDisponibles) {\n        const horaFin = calcularHoraFin(horaInicio, horasNecesarias);\n        alternativas.push({\n          fecha: fechaTexto,\n          horaInicio: horaInicio,\n          horaFin: horaFin,\n          muelle: muelle\n        });\n      }\n    }\n    \n    return alternativas;\n  } catch (error) {\n    console.error(`Error buscando alternativas para d√≠a: ${error.message}`);\n    return [];\n  }\n}\n\n// Buscar alternativas en el mismo d√≠a\nfunction buscarAlternativasMismoDia(\n  fechaSolicitada,\n  muelle,\n  horasNecesarias,\n  mallaActual,\n  mallaProxima\n) {\n  const alternativas = buscarAlternativasParaDiaConFechaExacta(\n    fechaSolicitada,\n    muelle,\n    horasNecesarias,\n    mallaActual,\n    mallaProxima\n  );\n  \n  // Limitar a m√°ximo 8 alternativas del mismo d√≠a\n  return alternativas.slice(0, 8);\n}\n\n// Buscar alternativas en d√≠as posteriores\nfunction buscarAlternativasDiasPeriores(\n  fechaSolicitada,\n  muelle,\n  horasNecesarias,\n  mallaActual,\n  mallaProxima\n) {\n  try {\n    const fechaSolicitadaObj = parsearFechaEspanol(fechaSolicitada);\n    const fechaSiguiente = new Date(fechaSolicitadaObj);\n    fechaSiguiente.setDate(fechaSiguiente.getDate() + 1);\n    \n    // Solo buscar en el d√≠a siguiente\n    const fechaSiguienteStr = formatearFechaEspanol(fechaSiguiente);\n    const alternativasDiaSiguiente = buscarAlternativasParaDiaConFechaExacta(\n      fechaSiguienteStr,\n      muelle,\n      horasNecesarias,\n      mallaActual,\n      mallaProxima\n    );\n    \n    // Limitar a m√°ximo 8 alternativas del d√≠a siguiente\n    return alternativasDiaSiguiente.slice(0, 8);\n  } catch (error) {\n    console.error(`Error buscando alternativas posteriores: ${error.message}`);\n    return [];\n  }\n}\n\n// Aseguramos que n8n ejecute la funci√≥n principal\nreturn procesarVerificacionFranjas(items, 0);"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2880,
        1088
      ],
      "id": "05a1196d-4dd6-4ce0-bcd4-1cba909a8879",
      "name": "Code MOSTRAR_FRANJAS"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Sistema de Validaci√≥n de Datos para Citas de Log√≠stica\n * VERSI√ìN 5.3 ‚Äî 2025-04-25\n * - Aplana proveedores y categor√≠as que vienen dentro de \"datosproveedor\" /\n *   \"datoscategorias\"\n * - Mantiene la l√≥gica de coincidencias para abreviaturas (\"spb\") y variantes\n *   sing/plural (\"arena\"‚Üí\"ARENAS\")\n * - Incluye guard-rails para evitar undefined\n */\n\n/*‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ UTILIDAD GEN√âRICA ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*/\nfunction getNodeItems(nodeName) {\n  try {\n    return $items(nodeName).map(i => i.json) || [];\n  } catch (e) {          // ‚Üê con (e) o (error)\n    return [];\n  }\n}\n\n/*‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CARGA Y APLANADO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*/\nfunction procesarValidacionCita() {\n  try {   \n// üîÑ Carga cruda\nlet proveedoresRaw  = getNodeItems(\"Estructuraci√≥n, Consulta, Datos Proveedor\");\nlet categoriasRaw   = getNodeItems(\"Estructuraci√≥n, Consulta, Datos Categorias\");\n\n// üîÑ Aplanar proveedores\nlet datosproveedor = [];\nfor (const itm of proveedoresRaw) {\n  if (Array.isArray(itm.datosproveedor))  datosproveedor.push(...itm.datosproveedor);\n  else if (itm.proveedor)                 datosproveedor.push(itm);\n}\n\n// üîÑ Aplanar categor√≠as\nlet datoscategorias = [];\nfor (const itm of categoriasRaw) {\n  if (Array.isArray(itm.datoscategorias)) datoscategorias.push(...itm.datoscategorias);\n  else if (itm.CATEGORIA)                 datoscategorias.push(itm);\n}\n\n// Fallbacks (por compatibilidad con Merge datos Excel)\nif (!datosproveedor.length  && $node[\"Merge datos Excel\"]?.json?.datosproveedor)\n  datosproveedor  = $node[\"Merge datos Excel\"].json.datosproveedor;\nif (!datoscategorias.length && $node[\"Merge datos Excel\"]?.json?.datoscategorias)\n  datoscategorias = $node[\"Merge datos Excel\"].json.datoscategorias;\n\n/*‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ DATOS DEL LLM Y CONTEXTO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*/\nconst datosLLM          = $node[\"Basic LLM Chain RECOLECCI√ìN1\"].json.output;\nconst mensajeActual     = $('Unificaci√≥n y consistencia de datos').first().json.infoMensaje.mensajeActual;\nconst historialMensajes = $node[\"Unificaci√≥n y consistencia de datos\"].json.infoMensaje.historialMensajes;\nconst mallaProximaSemana= $('Estructuraci√≥n, Datos, Consulta, Citas Proxima Semana').first().json;\nconst mallaProximaNoExiste = verificarMallaProximaNoExiste(mallaProximaSemana);\nconst fechaActualObj    = new Date();\n    \n    // Inicializar el objeto de respuesta\n    const resultado = {\n      todoCorrecto: false,\n      datosPreviamenteConfirmados: false,\n      camposFaltantes: [],\n      proveedoresSimilares: [],\n      categoriasSimilares: [],\n      fechaSolicitada: \"\",\n      horaSolicitada: \"\",\n      proveedorIdentificado: \"\",\n      categoriaIdentificada: \"\",\n      pesoIdentificado: 0,\n      unidadesIdentificadas: 0,\n      ordenCompraIdentificada: \"\",\n      mensajeSistema: \"\",\n      mensajesCamposFaltantes: {},\n      mallaProximaDisponible: !mallaProximaNoExiste,\n      fechaValida: true,\n      horaValida: true,\n      diaHabil: true,\n      mensajeValidacionTemporal: \"\"\n    };\n\n    // Si la malla pr√≥xima no existe, agregar un mensaje informativo\n    if (mallaProximaNoExiste) {\n      resultado.mensajeSistema = \"Te informo que la malla de la pr√≥xima semana a√∫n no ha sido creada o no est√° disponible. Solo puedo mostrarte disponibilidad para la semana actual.\";\n    }\n\n    // 1. VERIFICAR SI ES UNA CONFIRMACI√ìN DIRECTA DE TODOS LOS DATOS\n    const confirmacionPrevia = verificarConfirmacionPrevia(historialMensajes, mensajeActual);\n    if (confirmacionPrevia.confirmado) {\n      resultado.datosPreviamenteConfirmados = true;\n      resultado.todoCorrecto = true;\n      resultado.proveedorIdentificado = confirmacionPrevia.proveedor;\n      resultado.fechaSolicitada = confirmacionPrevia.fecha;\n      resultado.horaSolicitada = confirmacionPrevia.hora;\n      resultado.categoriaIdentificada = confirmacionPrevia.categoria;\n      resultado.pesoIdentificado = confirmacionPrevia.peso;\n      resultado.unidadesIdentificadas = confirmacionPrevia.unidades;\n      resultado.ordenCompraIdentificada = confirmacionPrevia.ordenCompra;\n      \n      // Validar que la fecha y hora confirmadas no est√©n en el pasado\n      const validacionTemporal = validarFechaHora(resultado.fechaSolicitada, resultado.horaSolicitada, fechaActualObj);\n      resultado.fechaValida = validacionTemporal.fechaValida;\n      resultado.horaValida = validacionTemporal.horaValida;\n      resultado.diaHabil = validacionTemporal.diaHabil;\n      resultado.mensajeValidacionTemporal = validacionTemporal.mensaje;\n      \n      // Si hay problemas con la fecha/hora, la cita no est√° correcta\n      if (!validacionTemporal.fechaValida || !validacionTemporal.horaValida || !validacionTemporal.diaHabil) {\n        resultado.todoCorrecto = false;\n      }\n      \n      return resultado;\n    }\n\n    // 2. USAR DIRECTAMENTE LOS DATOS DEL LLM\n    // No intentar extraer datos del mensaje - confiar en lo que extrajo el LLM\n    resultado.fechaSolicitada = datosLLM.fecha || \"\";\n    resultado.horaSolicitada = datosLLM.hora || \"\";\n    resultado.pesoIdentificado = parseInt(datosLLM.peso) || 0;\n    resultado.unidadesIdentificadas = parseInt(datosLLM.unidades) || 0;\n    resultado.ordenCompraIdentificada = datosLLM.ordenCompra || \"\";\n\n    // 3. VALIDACI√ìN DEL PROVEEDOR\n    if (datosLLM.proveedor) {\n      const resultadoProveedor = validarProveedor(datosLLM.proveedor, datosproveedor);\n      \n      if (resultadoProveedor.coincidenciaExacta) {\n        resultado.proveedorIdentificado = resultadoProveedor.nombreCompleto;\n      } else if (resultadoProveedor.coincidenciaParcialClara) {\n        resultado.proveedorIdentificado = resultadoProveedor.nombreCompleto;\n      } else if (resultadoProveedor.coincidenciasParciales && resultadoProveedor.coincidenciasParciales.length > 0) {\n        resultado.proveedoresSimilares = resultadoProveedor.coincidenciasParciales;\n      } else {\n        resultado.camposFaltantes.push(\"proveedor\");\n        resultado.mensajesCamposFaltantes[\"proveedor\"] = \"Por favor proporciona el nombre del proveedor ya que es necesario para buscarlo en nuestra base de datos y que el sistema pueda asociar la cita a ese nombre, trata de proporcionar el nombre lo m√°s completo posible.\";\n      }\n    } else {\n      resultado.camposFaltantes.push(\"proveedor\");\n      resultado.mensajesCamposFaltantes[\"proveedor\"] = \"Por favor proporciona el nombre del proveedor ya que es necesario para buscarlo en nuestra base de datos y que el sistema pueda asociar la cita a ese nombre, trata de proporcionar el nombre lo m√°s completo posible.\";\n    }\n\n    // 4. VALIDACI√ìN DE LA CATEGOR√çA\n    if (datosLLM.categoria) {\n      const resultadoCategoria = validarCategoria(datosLLM.categoria, datoscategorias);\n      if (resultadoCategoria.coincidenciaExacta) {\n        resultado.categoriaIdentificada = resultadoCategoria.nombreCompleto;\n      } else if (resultadoCategoria.coincidenciaSimilar) {\n        // Si es \"arena\" para \"ARENAS\", por ejemplo\n        resultado.categoriaIdentificada = resultadoCategoria.nombreCompleto;\n      } else if (resultadoCategoria.categoriasSimilares && resultadoCategoria.categoriasSimilares.length > 0) {\n        resultado.categoriasSimilares = resultadoCategoria.categoriasSimilares;\n      } else {\n        resultado.camposFaltantes.push(\"categor√≠a\");\n        \n        // Preparar la lista de categor√≠as disponibles para el mensaje\n        let categoriasDisponibles = datoscategorias.map(cat => cat.CATEGORIA).join(\", \");\n        if (categoriasDisponibles.length > 100) {\n          // Si hay muchas categor√≠as, mostrar solo las primeras\n          const primerasCategorias = datoscategorias.slice(0, 5).map(cat => cat.CATEGORIA);\n          categoriasDisponibles = primerasCategorias.join(\", \") + \", entre otras...\";\n        }\n        \n        resultado.mensajesCamposFaltantes[\"categor√≠a\"] = `Por favor indica la categor√≠a del material. Las categor√≠as disponibles incluyen: ${categoriasDisponibles}`;\n      }\n    } else {\n      resultado.camposFaltantes.push(\"categor√≠a\");\n      \n      // Preparar la lista de categor√≠as disponibles para el mensaje\n      let categoriasDisponibles = datoscategorias.map(cat => cat.CATEGORIA).join(\", \");\n      if (categoriasDisponibles.length > 100) {\n        // Si hay muchas categor√≠as, mostrar solo las primeras\n        const primerasCategorias = datoscategorias.slice(0, 5).map(cat => cat.CATEGORIA);\n        categoriasDisponibles = primerasCategorias.join(\", \") + \", entre otras...\";\n      }\n      \n      resultado.mensajesCamposFaltantes[\"categor√≠a\"] = `Por favor indica la categor√≠a del material. Las categor√≠as disponibles incluyen: ${categoriasDisponibles}`;\n    }\n\n    // 5. VERIFICACI√ìN DE CAMPOS OBLIGATORIOS FALTANTES\n    if (!resultado.fechaSolicitada) {\n      resultado.camposFaltantes.push(\"fecha\");\n      resultado.mensajesCamposFaltantes[\"fecha\"] = \"Por favor es necesaria la fecha de entrega para que el sistema pueda revisar el cronograma y entregarte informaci√≥n precisa.\";\n    }\n    \n    if (!resultado.horaSolicitada) {\n      resultado.camposFaltantes.push(\"hora\");\n      resultado.mensajesCamposFaltantes[\"hora\"] = \"Por favor indica la hora preferida para la cita, es necesaria para verificar la disponibilidad en nuestro cronograma.\";\n    }\n    \n    if (!resultado.pesoIdentificado) {\n      resultado.camposFaltantes.push(\"peso\");\n      resultado.mensajesCamposFaltantes[\"peso\"] = \"Te falta el dato del peso de la mercanc√≠a. Por favor proporcionar este dato ojal√° en kilos, es necesario para que el sistema calcule la duraci√≥n del descargue de la mercanc√≠a.\";\n    }\n    \n    if (!resultado.unidadesIdentificadas) {\n      resultado.camposFaltantes.push(\"unidades\");\n      resultado.mensajesCamposFaltantes[\"unidades\"] = \"Te falt√≥ el dato de la cantidad de unidades a descargar. Este dato es importante para que el sistema pueda calcular el tiempo que se necesita para el descargue.\";\n    }\n    \n    if (!resultado.ordenCompraIdentificada) {\n      resultado.camposFaltantes.push(\"orden de compra\");\n      resultado.mensajesCamposFaltantes[\"orden de compra\"] = \"Falta el n√∫mero de la orden de compra. Por favor proporcionar este dato ya que es necesario para que la cita en el cronograma quede relacionada a esta orden de compra por temas de trazabilidad en la operaci√≥n.\";\n    }\n\n    // 6. VALIDACI√ìN: Verificar que la fecha y hora sean v√°lidas\n    if (resultado.fechaSolicitada && resultado.horaSolicitada) {\n      const validacionTemporal = validarFechaHora(resultado.fechaSolicitada, resultado.horaSolicitada, fechaActualObj);\n      resultado.fechaValida = validacionTemporal.fechaValida;\n      resultado.horaValida = validacionTemporal.horaValida;\n      resultado.diaHabil = validacionTemporal.diaHabil;\n      resultado.mensajeValidacionTemporal = validacionTemporal.mensaje;\n      \n      // Si la fecha u hora no son v√°lidas, a√±adir a campos faltantes\n      if (!validacionTemporal.fechaValida) {\n        if (!resultado.camposFaltantes.includes(\"fecha\")) {\n          resultado.camposFaltantes.push(\"fecha\");\n        }\n        resultado.mensajesCamposFaltantes[\"fecha\"] = validacionTemporal.mensaje;\n      }\n      \n      if (!validacionTemporal.horaValida) {\n        if (!resultado.camposFaltantes.includes(\"hora\")) {\n          resultado.camposFaltantes.push(\"hora\");\n        }\n        resultado.mensajesCamposFaltantes[\"hora\"] = validacionTemporal.mensaje;\n      }\n      \n      if (!validacionTemporal.diaHabil) {\n        if (!resultado.camposFaltantes.includes(\"fecha\")) {\n          resultado.camposFaltantes.push(\"fecha\");\n        }\n        resultado.mensajesCamposFaltantes[\"fecha\"] = validacionTemporal.mensaje;\n      }\n    }\n\n    // 7. DETERMINAR ESTADO FINAL\n    if (\n      resultado.camposFaltantes.length === 0 && \n      resultado.proveedoresSimilares.length === 0 && \n      resultado.categoriasSimilares.length === 0 &&\n      resultado.proveedorIdentificado && \n      resultado.categoriaIdentificada &&\n      resultado.fechaValida &&\n      resultado.horaValida &&\n      resultado.diaHabil\n    ) {\n      resultado.todoCorrecto = true;\n    }\n\n    return resultado;\n  } catch (e) {\n    console.error(\"Error en procesamiento de cita:\", e);\n    return {\n      error: e.message,\n      todoCorrecto: false,\n      mensajeSistema: \"Ocurri√≥ un error durante el procesamiento de tu solicitud. Por favor, intenta nuevamente.\"\n    };\n  }\n}\n\n/**\n * Valida que la fecha y hora solicitadas sean v√°lidas\n * (no en el pasado, d√≠a h√°bil, etc.)\n */\nfunction validarFechaHora(fechaStr, horaStr, fechaActualObj) {\n  const resultado = {\n    fechaValida: true,\n    horaValida: true,\n    diaHabil: true,\n    mensaje: \"\"\n  };\n  \n  try {\n    // Crear el objeto fecha a partir del string de fecha\n    let fechaSolicitadaObj = parsearFechaEspanol(fechaStr);\n    console.log(\"Fecha solicitada parseada:\", fechaSolicitadaObj);\n    \n    // Verificar si es un d√≠a h√°bil (L-V)\n    const diaSemana = fechaSolicitadaObj.getDay();\n    if (diaSemana === 0 || diaSemana === 6) { // 0 = domingo, 6 = s√°bado\n      resultado.diaHabil = false;\n      resultado.mensaje = \"La fecha solicitada cae en fin de semana. Por favor elige un d√≠a h√°bil (lunes a viernes).\";\n      return resultado;\n    }\n    \n    // Verificar si la fecha es hoy\n    const esHoy = esMismaFecha(fechaSolicitadaObj, fechaActualObj);\n    console.log(\"¬øEs hoy?\", esHoy);\n    \n    // Si es hoy, verificar que la hora sea futura y con al menos 2 horas de anticipaci√≥n\n    if (esHoy) {\n      // Convertir la hora solicitada a un objeto Date\n      const horaSolicitadaObj = parsearHora(horaStr, fechaSolicitadaObj);\n      console.log(\"Hora solicitada parseada:\", horaSolicitadaObj);\n      \n      // Verificar que sea futura\n      if (horaSolicitadaObj < fechaActualObj) {\n        resultado.horaValida = false;\n        resultado.mensaje = \"La hora solicitada ya pas√≥. Por favor elige una hora futura.\";\n        return resultado;\n      }\n      \n      // Verificar que haya al menos 2 horas de anticipaci√≥n\n      const diferenciaMilis = horaSolicitadaObj - fechaActualObj;\n      const diferenciaHoras = diferenciaMilis / (1000 * 60 * 60);\n      console.log(\"Diferencia en horas:\", diferenciaHoras);\n      \n      if (diferenciaHoras < 2) {\n        resultado.horaValida = false;\n        resultado.mensaje = \"Necesitamos al menos 2 horas de anticipaci√≥n para programar una cita. Por favor elige una hora posterior o una fecha futura.\";\n        return resultado;\n      }\n    }\n    \n    // Verificar que la fecha no sea pasada\n    if (fechaSolicitadaObj < fechaActualObj && !esHoy) {\n      resultado.fechaValida = false;\n      resultado.mensaje = \"La fecha solicitada ya pas√≥. Por favor elige una fecha futura.\";\n      return resultado;\n    }\n    \n    // NO HAY RESTRICCI√ìN DE HORARIO DE OPERACI√ìN\n    \n    return resultado;\n  } catch (e) {\n    console.error(\"Error en validaci√≥n de fecha/hora:\", e);\n    resultado.fechaValida = false;\n    resultado.mensaje = \"Error al validar la fecha y hora. Por favor verifica el formato.\";\n    return resultado;\n  }\n}\n\n/**\n * Parsea una fecha en espa√±ol a un objeto Date\n */\nfunction parsearFechaEspanol(fechaStr) {\n  try {\n    // Normalizar la fecha (quitar \"de\", etc.)\n    const fechaNormalizada = fechaStr.toLowerCase()\n      .replace(/\\s+de\\s+/g, \" \")\n      .replace(/\\s+del\\s+/g, \" \");\n    \n    // Mapeo de meses en espa√±ol a n√∫meros\n    const meses = {\n      \"enero\": 0, \"febrero\": 1, \"marzo\": 2, \"abril\": 3, \"mayo\": 4, \"junio\": 5,\n      \"julio\": 6, \"agosto\": 7, \"septiembre\": 8, \"octubre\": 9, \"noviembre\": 10, \"diciembre\": 11\n    };\n    \n    // Extraer d√≠a, mes, a√±o\n    const partes = fechaNormalizada.split(/\\s+/);\n    console.log(\"Partes de la fecha:\", partes);\n    \n    let dia, mes, a√±o;\n    \n    // Intentar diferentes formatos\n    if (partes.length >= 3) {\n      // Formato \"15 abril 2025\"\n      dia = parseInt(partes[0]);\n      mes = meses[partes[1].toLowerCase()];\n      a√±o = parseInt(partes[2]);\n    } else if (partes.length === 2) {\n      // Formato \"15 abril\" (asumimos a√±o actual)\n      dia = parseInt(partes[0]);\n      mes = meses[partes[1].toLowerCase()];\n      a√±o = new Date().getFullYear();\n    } else if (partes.length === 1 && /^\\d{1,2}\\/\\d{1,2}\\/\\d{2,4}$/.test(partes[0])) {\n      // Formato \"15/04/2025\"\n      const partesSlash = partes[0].split(\"/\");\n      dia = parseInt(partesSlash[0]);\n      mes = parseInt(partesSlash[1]) - 1; // Restar 1 porque en JS los meses van de 0-11\n      a√±o = parseInt(partesSlash[2]);\n      if (a√±o < 100) a√±o += 2000; // Ajustar a√±os de 2 d√≠gitos\n    }\n    \n    // Verificar que los valores sean v√°lidos\n    if (isNaN(dia) || mes === undefined || isNaN(mes) || isNaN(a√±o)) {\n      throw new Error(\"Formato de fecha no reconocido: \" + fechaStr);\n    }\n    \n    // Crear el objeto Date\n    return new Date(a√±o, mes, dia);\n  } catch (e) {\n    console.error(\"Error al parsear fecha:\", e);\n    throw e;\n  }\n}\n\n/**\n * Parsea una hora en formato espa√±ol a un objeto Date\n */\nfunction parsearHora(horaStr, fechaBase) {\n  try {\n    // Normalizar la hora\n    const horaNormalizada = horaStr.toLowerCase().trim();\n    \n    // Extraer la hora y los minutos\n    let hora, minutos;\n    let esPM = false;\n    \n    // Verificar si es PM\n    if (horaNormalizada.includes(\"pm\") || \n        horaNormalizada.includes(\"p.m.\") || \n        horaNormalizada.includes(\"tarde\") ||\n        horaNormalizada.includes(\"noche\")) {\n      esPM = true;\n    }\n    \n    // Extraer la hora y minutos num√©ricos\n    const matchHora = horaNormalizada.match(/(\\d+)(?::(\\d+))?/);\n    if (matchHora) {\n      hora = parseInt(matchHora[1]);\n      minutos = matchHora[2] ? parseInt(matchHora[2]) : 0;\n      \n      // Convertir a formato 24 horas si es PM\n      if (esPM && hora < 12) {\n        hora += 12;\n      }\n      \n      // Convertir a formato 24 horas si es AM y son las 12\n      if (!esPM && hora === 12) {\n        hora = 0;\n      }\n    } else {\n      throw new Error(\"Formato de hora no reconocido: \" + horaStr);\n    }\n    \n    // Verificar que los valores sean v√°lidos\n    if (isNaN(hora) || isNaN(minutos)) {\n      throw new Error(\"Formato de hora no reconocido: \" + horaStr);\n    }\n    \n    // Crear el objeto Date con la fecha base y la hora extra√≠da\n    const resultado = new Date(fechaBase);\n    resultado.setHours(hora, minutos, 0, 0);\n    \n    return resultado;\n  } catch (e) {\n    console.error(\"Error al parsear hora:\", e);\n    throw e;\n  }\n}\n\n/**\n * Verifica si dos fechas corresponden al mismo d√≠a\n */\nfunction esMismaFecha(fecha1, fecha2) {\n  return fecha1.getDate() === fecha2.getDate() &&\n         fecha1.getMonth() === fecha2.getMonth() &&\n         fecha1.getFullYear() === fecha2.getFullYear();\n}\n\n/**\n * Verifica si la malla de la pr√≥xima semana no existe\n */\nfunction verificarMallaProximaNoExiste(mallaProximaSemana) {\n  // Verificar si la malla pr√≥xima semana existe y tiene datos\n  if (!mallaProximaSemana || !mallaProximaSemana.datosMallaProxSemana) {\n    return true;\n  }\n  \n  // Verificar si contiene el mensaje de error espec√≠fico en el t√≠tulo\n  const titulo = mallaProximaSemana.datosMallaProxSemana.titulo;\n  if (titulo && (\n      titulo.includes(\"‚ö†Ô∏è\") && \n      (titulo.includes(\"no existe\") || titulo.includes(\"a√∫n no ha sido creada\"))\n    )) {\n    return true;\n  }\n  \n  return false;\n}\n\n/**\n * Verifica si ya hubo una confirmaci√≥n previa en el historial\n */\nfunction verificarConfirmacionPrevia(historial, mensajeActual) {\n  // Si no hay historial, no puede haber confirmaci√≥n previa\n  if (!historial) {\n    return { confirmado: false };\n  }\n\n  // Patrones para detectar solicitud de confirmaci√≥n en historial\n  const patrones = [\n    /Por favor,?\\s?confirma/i,\n    /¬øConfirmas/i,\n    /confirma si esta/i,\n    /deseas proceder/i\n  ];\n  \n  // Patrones para detectar confirmaci√≥n en mensaje actual\n  const patronesConfirmacion = [\n    /\\bsi\\b/i,\n    /confirmo/i,\n    /exacto/i,\n    /\\bese\\b/i,\n    /correcto/i,\n    /afirmativo/i,\n    /ok\\b/i,\n    /est√° bien/i\n  ];\n\n  // Buscar si hay solicitud de confirmaci√≥n en historial\n  let solicitudConfirmacionEncontrada = false;\n  let detalles = {\n    proveedor: \"\",\n    fecha: \"\",\n    hora: \"\",\n    categoria: \"\",\n    peso: 0,\n    unidades: 0,\n    ordenCompra: \"\"\n  };\n\n  // Buscar el √∫ltimo mensaje que pidi√≥ confirmaci√≥n\n  const mensajes = historial.split(/\\n+/).filter(m => m.trim());\n  \n  for (let i = mensajes.length - 1; i >= 0; i--) {\n    const mensaje = mensajes[i];\n    \n    // Verificar si este mensaje pide confirmaci√≥n\n    if (patrones.some(patron => patron.test(mensaje))) {\n      solicitudConfirmacionEncontrada = true;\n      \n      // Extraer proveedor\n      const matchProveedor = mensaje.match(/proveedor\\s+\\*?\\*?([^*\\n.]+)\\*?\\*?/i);\n      if (matchProveedor) {\n        detalles.proveedor = matchProveedor[1].trim();\n      }\n      \n      // Extraer fecha\n      const matchFecha = mensaje.match(/(el d√≠a|el|d√≠a)\\s+([^,]+?)(?=\\s+a las|\\s+con|\\s+en|\\s+y|$)/i);\n      if (matchFecha) {\n        detalles.fecha = matchFecha[2].trim();\n      }\n      \n      // Extraer hora\n      const matchHora = mensaje.match(/a las\\s+([^,]+?)(?=\\s+con|\\s+en|\\s+y|$)/i);\n      if (matchHora) {\n        detalles.hora = matchHora[1].trim();\n      }\n      \n      // Extraer categor√≠a\n      const matchCategoria = mensaje.match(/categor√≠a\\s+\\*?\\*?([^*\\n,]+)\\*?\\*?/i);\n      if (matchCategoria) {\n        detalles.categoria = matchCategoria[1].trim();\n      }\n      \n      // Extraer peso\n      const matchPeso = mensaje.match(/(\\d+)\\s+kilos/i);\n      if (matchPeso) {\n        detalles.peso = parseInt(matchPeso[1]);\n      }\n      \n      // Extraer unidades\n      const matchUnidades = mensaje.match(/(\\d+)\\s+unidades/i);\n      if (matchUnidades) {\n        detalles.unidades = parseInt(matchUnidades[1]);\n      }\n      \n      // Extraer orden de compra\n      const matchOrden = mensaje.match(/orden\\s+(?:de compra)?\\s*\\*?\\*?([^*\\n.]+)\\*?\\*?/i);\n      if (matchOrden) {\n        detalles.ordenCompra = matchOrden[1].trim();\n      }\n      \n      break;\n    }\n  }\n\n  // Si encontramos una solicitud de confirmaci√≥n, verificar si el mensaje actual es una confirmaci√≥n\n  if (solicitudConfirmacionEncontrada) {\n    const esConfirmacion = patronesConfirmacion.some(patron => patron.test(mensajeActual));\n    return {\n      confirmado: esConfirmacion,\n      proveedor: detalles.proveedor,\n      fecha: detalles.fecha,\n      hora: detalles.hora,\n      categoria: detalles.categoria,\n      peso: detalles.peso,\n      unidades: detalles.unidades,\n      ordenCompra: detalles.ordenCompra\n    };\n  }\n\n  return { confirmado: false };\n}\n\n/**\n * Valida el proveedor contra la lista de proveedores disponibles\n */\nfunction validarProveedor(proveedorInput, listaProveedores) {\n  if (!proveedorInput || !listaProveedores || listaProveedores.length === 0) {\n    return {\n      coincidenciaExacta: false,\n      coincidenciaParcialClara: false,\n      coincidenciasParciales: []\n    };\n  }\n\n  // Normalizar entrada (quitar puntos, comas, convertir a min√∫sculas)\n  const proveedorNormalizado = normalizarTexto(proveedorInput);\n  \n  // Si el input es demasiado corto y gen√©rico (menos de 3 caracteres), exigir m√°s informaci√≥n\n  if (proveedorNormalizado.length < 2) {\n    return {\n      coincidenciaExacta: false,\n      coincidenciaParcialClara: false,\n      coincidenciasParciales: []\n    };\n  }\n  \n  console.log(\"Proveedor normalizado:\", proveedorNormalizado);\n  \n  // Buscar coincidencia exacta (ignorando may√∫sculas/min√∫sculas)\n  const coincidenciaExacta = listaProveedores.find(p => \n    normalizarTexto(p.proveedor) === proveedorNormalizado\n  );\n  \n  if (coincidenciaExacta) {\n    return {\n      coincidenciaExacta: true,\n      coincidenciaParcialClara: false,\n      coincidenciasParciales: [],\n      nombreCompleto: coincidenciaExacta.proveedor\n    };\n  }\n\n  // Buscar primero coincidencias donde el input es un prefijo exacto\n  const coincidenciasPrefijo = listaProveedores\n    .filter(p => {\n      const nombreNormalizado = normalizarTexto(p.proveedor);\n      // Verificar si el nombre del proveedor comienza con el input exacto\n      return nombreNormalizado.startsWith(proveedorNormalizado);\n    })\n    .map(p => p.proveedor);\n  \n  console.log(\"Coincidencias por prefijo:\", coincidenciasPrefijo);\n    \n  // Si solo hay una coincidencia por prefijo, es una coincidencia clara\n  if (coincidenciasPrefijo.length === 1) {\n    const proveedor = listaProveedores.find(p => p.proveedor === coincidenciasPrefijo[0]);\n    return {\n      coincidenciaExacta: false,\n      coincidenciaParcialClara: true,\n      coincidenciasParciales: [],\n      nombreCompleto: proveedor.proveedor\n    };\n  }\n  \n  // Si hay m√∫ltiples coincidencias por prefijo, solicitar clarificaci√≥n espec√≠fica\n  if (coincidenciasPrefijo.length > 1) {\n    return {\n      coincidenciaExacta: false,\n      coincidenciaParcialClara: false,\n      coincidenciasParciales: coincidenciasPrefijo\n    };\n  }\n\n  // Si no hay coincidencias por prefijo, buscar coincidencias parciales m√°s generales\n  const coincidenciasParciales = listaProveedores\n    .filter(p => {\n      const nombreNormalizado = normalizarTexto(p.proveedor);\n      // Verificar si el input est√° contenido en el nombre del proveedor\n      return nombreNormalizado.includes(proveedorNormalizado) || \n             // O si las primeras palabras coinciden\n             nombreNormalizado.split(' ').some((palabra, index, arr) => {\n               if (index < 3) { // Solo considerar las primeras 3 palabras\n                 return proveedorNormalizado.includes(palabra) || \n                        palabra.includes(proveedorNormalizado);\n               }\n               return false;\n             });\n    })\n    .map(p => p.proveedor);\n\n  console.log(\"Coincidencias parciales generales:\", coincidenciasParciales);\n\n  // Si hay solo una coincidencia parcial y es claramente identificable\n  if (coincidenciasParciales.length === 1) {\n    const proveedor = listaProveedores.find(p => p.proveedor === coincidenciasParciales[0]);\n    const nombreNormalizado = normalizarTexto(proveedor.proveedor);\n    \n    // Calcular similitud\n    const palabrasInput = proveedorNormalizado.split(' ');\n    const palabrasProveedor = nombreNormalizado.split(' ');\n    \n    // Si el input tiene al menos 2 palabras y ambas est√°n en el nombre del proveedor, considerarlo como claro\n    const palabrasCoincidentes = palabrasInput.filter(palabra => \n      palabrasProveedor.some(p => p.includes(palabra))\n    );\n    \n    const esClaramenteIdentificable = \n      // Si el input es un acr√≥nimo que coincide con las iniciales del proveedor\n      (proveedorNormalizado.length <= 5 && esAcronimo(proveedorNormalizado, proveedor.proveedor)) ||\n      // O si hay suficiente coincidencia de palabras\n      (palabrasInput.length >= 2 && palabrasCoincidentes.length >= 2) ||\n      // O si el input es una parte sustancial del nombre del proveedor\n      (nombreNormalizado.startsWith(proveedorNormalizado) && proveedorNormalizado.length >= 3) ||\n      // Casos especiales para mejorar la coincidencia\n      (proveedorNormalizado.includes(\"spb\") && nombreNormalizado.includes(\"spb colombia\"));\n    \n    if (esClaramenteIdentificable) {\n      return {\n        coincidenciaExacta: false,\n        coincidenciaParcialClara: true,\n        coincidenciasParciales: [],\n        nombreCompleto: proveedor.proveedor\n      };\n    }\n  }\n\n  // En caso de m√∫ltiples coincidencias o una coincidencia no clara\n  return {\n    coincidenciaExacta: false,\n    coincidenciaParcialClara: false,\n    coincidenciasParciales: coincidenciasParciales\n  };\n}\n\n/**\n * Valida la categor√≠a contra la lista de categor√≠as disponibles\n */\nfunction validarCategoria(categoriaInput, listaCategorias) {\n  if (!categoriaInput || !listaCategorias || listaCategorias.length === 0) {\n    return {\n      coincidenciaExacta: false,\n      coincidenciaSimilar: false,\n      categoriasSimilares: []\n    };\n  }\n\n  // Normalizar entrada\n  const categoriaNormalizada = normalizarTexto(categoriaInput);\n  \n  // Buscar coincidencia exacta (ignorando may√∫sculas/min√∫sculas)\n  const coincidenciaExacta = listaCategorias.find(c => \n    normalizarTexto(c.CATEGORIA) === categoriaNormalizada\n  );\n  \n  if (coincidenciaExacta) {\n    return {\n      coincidenciaExacta: true,\n      coincidenciaSimilar: false,\n      categoriasSimilares: [],\n      nombreCompleto: coincidenciaExacta.CATEGORIA\n    };\n  }\n\n  // Caso especial para \"arena\" = \"ARENAS\"\n  if (categoriaNormalizada === \"arena\" && listaCategorias.some(c => normalizarTexto(c.CATEGORIA) === \"arenas\")) {\n    const categoriaArenas = listaCategorias.find(c => normalizarTexto(c.CATEGORIA) === \"arenas\");\n    return {\n      coincidenciaExacta: false,\n      coincidenciaSimilar: true,\n      categoriasSimilares: [],\n      nombreCompleto: categoriaArenas.CATEGORIA\n    };\n  }\n\n  // Buscar variantes similares (singular/plural)\n  for (const categoria of listaCategorias) {\n    const categoriaNombre = normalizarTexto(categoria.CATEGORIA);\n    \n    // Verificar si es una variante singular/plural\n    if (\n      // Si la categor√≠a termina en S y sin la S coincide con el input\n      (categoriaNombre.endsWith(\"s\") && categoriaNombre.slice(0, -1) === categoriaNormalizada) ||\n      // O si el input termina en S y sin la S coincide con la categor√≠a\n      (categoriaNormalizada.endsWith(\"s\") && categoriaNormalizada.slice(0, -1) === categoriaNombre)\n    ) {\n      return {\n        coincidenciaExacta: false,\n        coincidenciaSimilar: true,\n        categoriasSimilares: [],\n        nombreCompleto: categoria.CATEGORIA\n      };\n    }\n  }\n\n  // Buscar coincidencias parciales\n  const categoriasSimilares = listaCategorias\n    .filter(c => {\n      const nombreNormalizado = normalizarTexto(c.CATEGORIA);\n      return nombreNormalizado.includes(categoriaNormalizada) || \n             categoriaNormalizada.includes(nombreNormalizado);\n    })\n    .map(c => c.CATEGORIA);\n\n  // Si hay solo una coincidencia parcial, considerarla v√°lida\n  if (categoriasSimilares.length === 1) {\n    return {\n      coincidenciaExacta: false,\n      coincidenciaSimilar: true,\n      categoriasSimilares: [],\n      nombreCompleto: categoriasSimilares[0]\n    };\n  }\n\n  // En caso de m√∫ltiples coincidencias o ninguna coincidencia\n  return {\n    coincidenciaExacta: false,\n    coincidenciaSimilar: false,\n    categoriasSimilares: categoriasSimilares\n  };\n}\n\n/**\n * Funciones auxiliares\n */\n\n// Normaliza texto para comparaciones\nfunction normalizarTexto(texto) {\n  if (!texto) return \"\";\n  \n  return texto\n    .toLowerCase()\n    .normalize(\"NFD\")\n    .replace(/[\\u0300-\\u036f]/g, \"\") // Eliminar acentos\n    .replace(/[^\\w\\s]/g, \"\") // Eliminar puntuaci√≥n\n    .trim();\n}\n\n// Verifica si un texto es un acr√≥nimo de otro\nfunction esAcronimo(acronimo, textoCompleto) {\n  if (!acronimo || !textoCompleto || typeof textoCompleto !== \"string\") {\n    return false;                                   \n  }\n\n  acronimo = acronimo.replace(/\\./g, \"\").toLowerCase();\n\n  const palabras = textoCompleto.split(/\\s+/);\n  const iniciales = palabras.map(p => p.charAt(0).toLowerCase()).join(\"\");\n\n  const inicialesSignificativas = palabras\n    .filter(p => p.length > 2 && !/^(de|la|el|los|las|y|a|en|con|por|para)$/i.test(p))\n    .map(p => p.charAt(0).toLowerCase())\n    .join(\"\");\n\n  return iniciales.includes(acronimo) ||\n         inicialesSignificativas.includes(acronimo);\n}\n\n\n// Esta es la ejecuci√≥n principal\n// Debe estar al final del archivo\nreturn procesarValidacionCita();"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        864,
        1440
      ],
      "id": "4b087304-d73e-4b4c-bc66-9d7df6c516d5",
      "name": "Code RECOLECCI√ìN"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "b2110549-dd58-46b3-9707-dbbe0a5004f2",
              "leftValue": "={{ $('Code estandarizar respuestas MOSTRAR_FRANJAS').item.json.standardResponse.mensajeSistema.length }}",
              "rightValue": 70,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        4208,
        1088
      ],
      "id": "48260260-a7c6-4f7c-8a92-4f07a0eeebfe",
      "name": "Validaci√≥n de longitud de caracteres3"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        4752,
        1008
      ],
      "id": "c2ea6328-b1fb-434d-a0ea-efb3c4ec84f6",
      "name": "No Operation, do nothing5"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $('Consistencia de datos, intenci√≥n consultar malla').item.json.mensaje }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        4560,
        1008
      ],
      "id": "88c81644-2474-47ea-a409-55d1f36c56bd",
      "name": "HTTP Request Enviar Mensaje por WhatsApp6"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d9c2ff70-4fd1-4b93-8571-6d0ac5a0093e",
              "name": "mensaje.ia",
              "value": "={{ $('Code estandarizar respuestas MOSTRAR_FRANJAS').item.json.standardResponse.mensajeSistema }}",
              "type": "string"
            },
            {
              "id": "ac8a03be-0292-4735-9580-39a385945c47",
              "name": "mensaje.longitud",
              "value": "={{ $('Code estandarizar respuestas MOSTRAR_FRANJAS').item.json.standardResponse.mensajeSistema.length }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        4560,
        1200
      ],
      "id": "caecb318-b2e5-462d-be62-717be7fe753b",
      "name": "Organiza variables del mensaje3"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT TOP 1 *\nFROM FranjasDisponiblesTemp\nWHERE chat_id = '{{$node[\"Organiza el Mensaje\"].json[\"infoMensaje\"][\"chat_id\"]}}'\nORDER BY timestamp_enviado DESC;"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        -1904,
        2928
      ],
      "id": "2556ec67-e354-497e-9b30-f84698ff8e01",
      "name": "Microsoft SQL Obtener Alternativas",
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Versi√≥n corregida para la estructura real que estamos recibiendo\nconst resultadosSQL = $input.item.json;\n\n// Preparar respuesta por defecto\nlet respuesta = {\n  estado: \"error\",\n  mensaje: \"No se pudo procesar la confirmaci√≥n.\",\n  tiempoExpirado: false,\n  alternativasDisponibles: null\n};\n\n// Verificar si hay resultados v√°lidos\nif (!resultadosSQL) {\n  respuesta.mensaje = \"No encontramos alternativas disponibles para confirmar. Por favor, inicia el proceso de agendamiento nuevamente.\";\n  return { respuesta };\n}\n\ntry {\n  // Obtener timestamp enviado\n  const timestampEnviado = new Date(resultadosSQL.timestamp_enviado);\n  const ahora = new Date();\n  const tiempoTranscurrido = ahora.getTime() - timestampEnviado.getTime();\n  const tiempoLimiteMs = 5 * 60 * 1000; // 5 minutos en milisegundos\n\n  // Verificar si han pasado m√°s de 5 minutos\n  if (tiempoTranscurrido > tiempoLimiteMs) {\n    respuesta.estado = \"expirado\";\n    respuesta.tiempoExpirado = true;\n    respuesta.mensaje = \"Lo sentimos, el tiempo para confirmar ha expirado (m√°ximo 5 minutos). Por favor, iniciemos el proceso nuevamente para verificar la disponibilidad actual.\";\n    return { respuesta };\n  }\n\n  // Parsear datos de las franjas\n  const franjasJSON = resultadosSQL.franjas_json;\n  const franjas = JSON.parse(franjasJSON);\n  \n  // Todo est√° bien, actualizar la respuesta\n  respuesta.estado = \"ok\";\n  respuesta.tiempoExpirado = false;\n  respuesta.alternativasDisponibles = franjas;\n  \n  // Obtener datos adicionales importantes\n  if (resultadosSQL.datos_cita_json) {\n    respuesta.datosCita = JSON.parse(resultadosSQL.datos_cita_json);\n  }\n  \n  return { respuesta };\n} catch (error) {\n  console.log('Error al procesar datos:', error);\n  respuesta.mensaje = \"Ocurri√≥ un error al procesar los datos. Por favor, inicia el proceso nuevamente.\";\n  return { respuesta };\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1648,
        2928
      ],
      "id": "37da311a-2fec-4ec5-bf05-0d46d30d34a0",
      "name": "Code Verificar Tiempo Transcurrido"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "9f152a09-44e9-4eaf-9c88-2b0f1e377191",
              "leftValue": "={{ $json.respuesta.tiempoExpirado }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -1408,
        2928
      ],
      "id": "bc4ecec8-73c2-4c3a-81ea-17356dc0da6e",
      "name": "If Verificar Expiraci√≥n"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -144,
        2432
      ],
      "id": "2f779c99-aa8d-4cf5-b818-8c7e60415376",
      "name": "OpenAI Chat Model9",
      "credentials": {
        "openAiApi": {
          "id": "AD8kPcNVReuclASd",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "=define",
        "text": "=Eres un asistente de un sistema de agendamiento de citas. Debes notificar que el tiempo para confirmar una cita ha expirado.\n\nGenera un mensaje directo (sin saludos iniciales ni mencionar nombres) que:\n1. Indique claramente que el sistema no permite confirmar la cita porque han pasado m√°s de 5 minutos\n2. Explique brevemente que esta restricci√≥n existe para garantizar la disponibilidad real y la trazabilidad de las citas\n3. Mencione que debido a que el cronograma cambia constantemente con nuevas solicitudes, es necesario reiniciar el proceso\n4. Indique espec√≠ficamente que debe iniciar nuevamente el proceso proporcionando toda la informaci√≥n requerida\n5. Agradezca la comprensi√≥n\n\nTono: profesional pero emp√°tico, reconociendo el inconveniente pero explicando la necesidad del proceso."
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        -64,
        2224
      ],
      "id": "0b9ffbc0-b9eb-4dde-8578-632e56e74de0",
      "name": "Basic LLM Notificar No Disponibilidad"
    },
    {
      "parameters": {
        "url": "https://graph.microsoft.com/v1.0/sites/a592f886-4560-4e62-9646-1eee7add7abe/drives/b!hviSpWBFYk6WRh7uet16vnNAUYuuQRlGj3ZyS9kSvGVZ4DSg6c5MRqYYm2MdAER8/items/01PPLUUYXY5E2GK3SJ25EZLJPUYJ43H3ME/content",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "microsoftOAuth2Api",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "file",
              "outputPropertyName": "ExcelMallaRecibido2025"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1120,
        2944
      ],
      "id": "aa885fa6-868a-4d4c-a9aa-65ac3a633fdb",
      "name": "HTTP Request MALLA DE RECIBO ",
      "credentials": {
        "microsoftOAuth2Api": {
          "id": "mh8Z8hxFvd7LDO8D",
          "name": "CuentaMy SharePoint App Desarrollador1 Konfie "
        }
      }
    },
    {
      "parameters": {
        "operation": "xlsx",
        "binaryPropertyName": "ExcelMallaRecibido2025",
        "options": {
          "sheetName": "={{ $('Unificaci√≥n y consistencia de datos').item.json.hojaSeleccionada }}"
        }
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -864,
        2832
      ],
      "id": "90a8e97e-0fb8-4357-ae4f-f5a337d57711",
      "name": "Extract MALLA DE RECIBO "
    },
    {
      "parameters": {
        "jsCode": "// Obtener los datos del Excel\nconst excelData = $input.all();\nconst hojaSeleccionada = $('Unificaci√≥n y consistencia de datos').first().json.hojaSeleccionada;\n\n// Obtener hora local en Bogot√°\nconst ahora = new Date(new Date().toLocaleString(\"en-US\", { timeZone: \"America/Bogota\" }));\nconst diaSemanaActual = ahora.getDay(); // 0=domingo, 1=lunes, ..., 5=viernes\nconst horaActual = ahora.getHours();\nconst minutosActual = ahora.getMinutes();\n// Determinar si es despu√©s de las 16:30\nconst pasoLimiteDia = horaActual > 16 || (horaActual === 16 && minutosActual >= 30);\n\n// Definir estructura de la semana y los d√≠as\nconst diasSemana = ['lunes', 'martes', 'mi√©rcoles', 'jueves', 'viernes'];\n\n// Mapeo para saber qu√© d√≠as incluir si hoy es x d√≠a y pas√≥ el l√≠mite\n/**\n * Dado el d√≠a de la semana actual (0=domingo ... 6=s√°bado),\n * devuelve qu√© d√≠as de la semana actual deben incluirse seg√∫n si pas√≥ el l√≠mite.\n */\nfunction diasValidosSemanaActual(diaSemanaActual, pasoLimite) {\n  const mapa = {\n    1: ['martes', 'mi√©rcoles', 'jueves', 'viernes'],   // lunes\n    2: ['mi√©rcoles', 'jueves', 'viernes'],             // martes\n    3: ['jueves', 'viernes'],                          // mi√©rcoles\n    4: ['viernes'],                                     // jueves\n    5: []                                               // viernes (muy tarde para s√°bado)\n  };\n  if (diaSemanaActual < 1 || diaSemanaActual > 5) {\n    return []; // s√°bado o domingo no se agendan en semana actual\n  }\n  if (!pasoLimite) {\n    // a√∫n est√° antes de las 4:30 p.m., se puede incluir el d√≠a siguiente\n    const siguiente = diasSemana[diaSemanaActual];\n    return [siguiente, ...mapa[diaSemanaActual]];\n  }\n  return mapa[diaSemanaActual];\n}\n\n// Objeto para almacenar la malla estructurada\nconst mallaEstructurada = {\n  titulo: \"\",\n  a√±o: \"\",\n  semana: \"\",\n  rangoDias: \"\",\n  franjas: [],\n  dias: {}\n};\n\n// Tabla de meses y d√≠as. Ajusta si necesitas contemplar bisiestos, etc.\nconst meses = {\n  \"enero\": 1,\n  \"febrero\": 2,\n  \"marzo\": 3,\n  \"abril\": 4,\n  \"mayo\": 5,\n  \"junio\": 6,\n  \"julio\": 7,\n  \"agosto\": 8,\n  \"septiembre\": 9,\n  \"octubre\": 10,\n  \"noviembre\": 11,\n  \"diciembre\": 12\n};\n\nconst nombreMes = {\n  1: \"enero\",\n  2: \"febrero\",\n  3: \"marzo\",\n  4: \"abril\",\n  5: \"mayo\",\n  6: \"junio\",\n  7: \"julio\",\n  8: \"agosto\",\n  9: \"septiembre\",\n  10: \"octubre\",\n  11: \"noviembre\",\n  12: \"diciembre\"\n};\n\n/**\n * Funci√≥n para determinar si un a√±o es bisiesto\n * Un a√±o es bisiesto si es divisible por 4, excepto aquellos divisibles por 100 \n * que no son divisibles por 400\n */\nfunction esBisiesto(year) {\n  return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);\n}\n\n/**\n * Funci√≥n para obtener el n√∫mero de d√≠as en un mes, considerando a√±os bisiestos\n */\nfunction getDiasMes(mes, a√±o) {\n  const diasPorMes = {\n    1: 31, // enero\n    2: esBisiesto(a√±o) ? 29 : 28, // febrero - ajustado para a√±o bisiesto\n    3: 31, // marzo\n    4: 30, // abril\n    5: 31, // mayo\n    6: 30, // junio\n    7: 31, // julio\n    8: 31, // agosto\n    9: 30, // septiembre\n    10: 31, // octubre\n    11: 30, // noviembre\n    12: 31  // diciembre\n  };\n  \n  return diasPorMes[mes];\n}\n\n/**\n * Funci√≥n para eliminar acentos y pasar a min√∫sculas (para buscar palabras clave sin importar tildes ni may√∫sculas).\n */\nfunction normalizarTexto(texto) {\n  if (typeof texto !== 'string') return \"\";\n  // Normaliza (NFD) y elimina diacr√≠ticos, luego pasa a min√∫sculas.\n  return texto\n    .normalize(\"NFD\")\n    .replace(/[\\u0300-\\u036f]/g, \"\") // quita acentos\n    .toLowerCase();\n}\n\n/**\n * Dada la informaci√≥n de proveedor, ordenCompra, peso, categor√≠a y unidades,\n * revisa si existe la palabra 'fuera de servicio', 'cancelado' o 'reagendado'\n * en cualquiera de esos campos. De ser as√≠, retorna ese estado especial;\n * de lo contrario, retorna 'ocupado'.\n * \n * Se ignoran may√∫sculas, min√∫sculas y tildes.\n */\nfunction determinarEstadoOcupado(proveedor, ordenCompra, peso, categoria, unidades) {\n  const conjunto = `${proveedor} ${ordenCompra} ${peso} ${categoria} ${unidades}`;\n  const texto = normalizarTexto(conjunto);\n\n  if (texto.includes(\"fuera de servicio\")) {\n    return \"fuera de servicio\";\n  }\n  if (texto.includes(\"cancelado\")) {\n    return \"cancelado\";\n  }\n  if (texto.includes(\"reagendado\")) {\n    return \"reagendado\";\n  }\n  return \"ocupado\";  \n}\n\n// -------------------------------------------------------------\n// 1) PROCESAR DATOS (Cabecera, Horas, Muelles, etc.)\n// -------------------------------------------------------------\nfunction procesarDatos(excelData) {\n  const datos = excelData.map(item => item.json);\n  \n  // A) Cabecera (T√≠tulo, A√±o, Rango)\n  datos.forEach((dato, index) => {\n    // Buscar t√≠tulo\n    if (dato.__EMPTY_2 === \"MALLA DE RECIBO CEDI KONFIE IA\") {\n      mallaEstructurada.titulo = dato.__EMPTY_2;\n      \n      // En la siguiente fila puede estar a√±o, semana, rango\n      if (index + 1 < datos.length) {\n        const datoSiguiente = datos[index + 1];\n        if (datoSiguiente) {\n          // A√±o\n          if (datoSiguiente.__EMPTY_2 && !isNaN(datoSiguiente.__EMPTY_2)) {\n            mallaEstructurada.a√±o = datoSiguiente.__EMPTY_2;\n          }\n          // Semana\n          Object.entries(datoSiguiente).forEach(([k, v]) => {\n            if (typeof v === 'string' && v.includes(\"SEMANA\")) {\n              mallaEstructurada.semana = v;\n            }\n          });\n          // Rango: p.ej. \"LUNES 31 AL VIERNES 4 DE ABRIL\"\n          Object.entries(datoSiguiente).forEach(([k, v]) => {\n            if (typeof v === 'string' && v.includes(\"LUNES\") && v.includes(\"VIERNES\")) {\n              mallaEstructurada.rangoDias = v;\n            }\n          });\n        }\n      }\n    }\n  });\n  \n  // B) Detectar franjas horarias (.__EMPTY = fracci√≥n de d√≠a)\n  const franjasHorarias = [];\n  datos.forEach(dato => {\n    if (\n      dato.__EMPTY !== undefined &&\n      typeof dato.__EMPTY === 'number' &&\n      dato.__EMPTY > 0 &&\n      dato.__EMPTY < 1\n    ) {\n      const totalMin = Math.round(dato.__EMPTY * 24 * 60);\n      const hh = Math.floor(totalMin / 60);\n      const mm = totalMin % 60;\n      \n      let periodo = \"AM\";\n      let hora12 = hh;\n      if (hh >= 12) {\n        periodo = \"PM\";\n        hora12 = (hh === 12 ? 12 : hh - 12);\n      }\n      if (hh === 0) {\n        hora12 = 12;\n      }\n      \n      const horaStr = `${hora12}:${String(mm).padStart(2, '0')} ${periodo}`;\n      franjasHorarias.push({\n        hora: horaStr,\n        indice: datos.indexOf(dato) // fila base\n      });\n    }\n  });\n  franjasHorarias.sort((a, b) => a.indice - b.indice);\n  mallaEstructurada.franjas = franjasHorarias;\n  \n  // C) Detectar muelles (col)\n  const muellesInfo = {};\n  datos.forEach(dato => {\n    Object.entries(dato).forEach(([key, value]) => {\n      if (value === \"MUELLE 01\" || value === \"MUELLE 02\") {\n        const col = parseInt(key.replace(\"__EMPTY_\", \"\"), 10);\n        const muelleKey = (value === \"MUELLE 01\") ? 'muelle1' : 'muelle2';\n        if (!muellesInfo[muelleKey]) {\n          muellesInfo[muelleKey] = [];\n        }\n        muellesInfo[muelleKey].push(col);\n      }\n    });\n  });\n  if (muellesInfo.muelle1) muellesInfo.muelle1.sort((a, b) => a - b);\n  if (muellesInfo.muelle2) muellesInfo.muelle2.sort((a, b) => a - b);\n  \n  // D) Generar los 5 d√≠as (lunes-viernes) con su fecha\n  parsearRangoDias();\n  \n  // E) Extraer Citas\n  extraerCitas(datos, muellesInfo);\n  \n  return mallaEstructurada;\n}\n\n/**\n * Parsea la cadena \"LUNES 31 AL VIERNES 4 DE ABRIL\"\n * (o \"LUNES 31 AL VIERNES 04 DE ABRIL\") y maneja el cruce de mes.\n * Ej.: si dayStart=31 y dayEnd=4, la 1¬™ fecha es 31 de MARZO,\n * luego 1,2,3,4 de ABRIL, en vez de 32,33, etc.\n */\nfunction parsearRangoDias() {\n  const texto = mallaEstructurada.rangoDias;\n  // Regex simple: p.ej. \"31 AL ... 4 DE ABRIL\"\n  // Captura: dayStart, dayEnd, mesFin\n  // Ojo: si dice \"LUNES 31 DE MARZO AL VIERNES 4 DE ABRIL\",\n  // quedar√°: dayStart=31, dayEnd=4, month=ABRIL (al final).\n  const regex = /(\\d+)\\s+AL\\s+\\D+(\\d+)\\s+DE\\s+(\\w+)/i;\n  const match = regex.exec(texto);\n  \n  // Por defecto, creamos 5 d√≠as vac√≠os sin fecha\n  diasSemana.forEach(d => {\n    mallaEstructurada.dias[d] = {\n      muelle1: {},\n      muelle2: {}\n    };\n  });\n  \n  if (!match) {\n    // Sin coincidencia, dejamos los d√≠as sin fecha\n    return;\n  }\n  \n  const dayStart = parseInt(match[1], 10); // 31\n  const dayEnd   = parseInt(match[2], 10); // 4\n  const finalMonthName = match[3].toLowerCase(); // \"abril\"\n  \n  // Convertimos a n√∫mero\n  const finalMonth = meses[finalMonthName] || 3; // fallback marzo\n  const yearNum = parseInt(mallaEstructurada.a√±o, 10) || 2025;\n  \n  // Funci√≥n para obtener la fecha formateada\n  function fechaFormateada(d, m, y) {\n    return `${d} de ${nombreMes[m]} de ${y}`;\n  }\n  \n  // Comprobamos cu√°ntos d√≠as tiene el mes final, considerando bisiestos\n  const diasMesFinal = getDiasMes(finalMonth, yearNum);\n  // y del mes previo\n  const monthPrev = (finalMonth === 1) ? 12 : finalMonth - 1;\n  const yearPrev = (finalMonth === 1) ? yearNum - 1 : yearNum;\n  \n  // Arreglo final con 5 fechas\n  const fechasDias = [];\n  \n  if (dayStart <= dayEnd) {\n    // Caso \"normal\": todo en el mismo mes\n    let d = dayStart;\n    for (let i = 0; i < 5; i++) {\n      fechasDias.push({\n        diaSem: diasSemana[i],\n        diaNum: d,\n        mesNum: finalMonth,\n        yearNum: yearNum\n      });\n      d++;\n      if (d > diasMesFinal) {\n        d = 1;\n        const nextMonth = finalMonth % 12 + 1;\n        const nextYear = (nextMonth === 1) ? yearNum + 1 : yearNum;\n        fechasDias[fechasDias.length - 1].mesNum = nextMonth;\n        fechasDias[fechasDias.length - 1].yearNum = nextYear;\n      }\n    }\n  } else {\n    // Caso \"cruza de mes\": dayStart > dayEnd\n    let d = dayStart;\n    let m = monthPrev;\n    let y = yearPrev;\n    \n    for (let i = 0; i < 5; i++) {\n      fechasDias.push({\n        diaSem: diasSemana[i],\n        diaNum: d,\n        mesNum: m,\n        yearNum: y\n      });\n      d++;\n      if (d > getDiasMes(m, y)) {\n        d = 1;\n        m = m % 12 + 1;\n        if (m === 1) {\n          y++;\n        }\n      }\n    }\n  }\n  \n  // Ahora volcamos esas 5 fechas en la estructura\n  fechasDias.forEach(fd => {\n    const { diaSem, diaNum, mesNum, yearNum } = fd;\n    mallaEstructurada.dias[diaSem] = {\n      fechaDia: fechaFormateada(diaNum, mesNum, yearNum),\n      muelle1: {},\n      muelle2: {}\n    };\n  });\n  \n  // Inicializamos las franjas a 'disponible'\n  if (mallaEstructurada.franjas.length > 0) {\n    diasSemana.forEach(d => {\n      mallaEstructurada.franjas.forEach(f => {\n        mallaEstructurada.dias[d].muelle1[f.hora] = {\n          estado: \"disponible\",\n          proveedor: \"\",\n          ordenCompra: \"\",\n          peso: \"\",\n          categoria: \"\",\n          unidades: \"\"\n        };\n        mallaEstructurada.dias[d].muelle2[f.hora] = {\n          estado: \"disponible\",\n          proveedor: \"\",\n          ordenCompra: \"\",\n          peso: \"\",\n          categoria: \"\",\n          unidades: \"\"\n        };\n      });\n    });\n  }\n}\n\n/**\n * Funci√≥n auxiliar: decide a qu√© d√≠a pertenece una columna,\n * corrigiendo 2 columnas de offset (porque 'Extract from XLSX'\n * deja todo desplazado).\n */\nfunction getDayForColumn(colNumber) {\n  // Ajuste de offset +2\n  const realCol = colNumber + 2;\n\n  // Rangos:\n  //  Lunes:      3..8\n  //  Martes:     9..14\n  //  Mi√©rcoles: 15..20\n  //  Jueves:    21..26\n  //  Viernes:   27..32\n  if (realCol >= 3 && realCol <= 8) {\n    return \"lunes\";\n  }\n  if (realCol >= 9 && realCol <= 14) {\n    return \"martes\";\n  }\n  if (realCol >= 15 && realCol <= 20) {\n    return \"mi√©rcoles\";\n  }\n  if (realCol >= 21 && realCol <= 26) {\n    return \"jueves\";\n  }\n  if (realCol >= 27 && realCol <= 32) {\n    return \"viernes\";\n  }\n  // Si nada coincide, devolvemos null\n  return null;\n}\n\n/**\n * Extraer las citas para cada franja:\n * - Para cada franja, miramos 3 filas:\n *    - Fila base => proveedor\n *    - Fila base+1 => orden\n *    - Fila base+2 => peso, categor√≠a, unidades\n */\nfunction extraerCitas(datos, muellesInfo) {\n  mallaEstructurada.franjas.forEach(franja => {\n    const indiceBase = franja.indice;\n    if (indiceBase < 0 || indiceBase + 2 >= datos.length) {\n      return; // no hay suficientes filas\n    }\n    \n    // Recorremos muelle1, muelle2 y sus columnas\n    const asignarCita = (muelleKey, cols) => {\n      cols.forEach(col => {\n        const provKey = `__EMPTY_${col}`;\n        const filaProv = datos[indiceBase];\n        \n        // Si en esta fila hay un proveedor o alg√∫n texto\n        if (\n          filaProv &&\n          typeof filaProv[provKey] === 'string' &&\n          filaProv[provKey].length > 2\n        ) {\n          // Determinar el d√≠a real\n          const diaOk = getDayForColumn(col);\n          if (!diaOk || !mallaEstructurada.dias[diaOk]) {\n            return; // si no coincide con ninguno, saltamos\n          }\n          \n          // Recuperar valores para proveedor, ordenCompra y dem√°s\n          const filaOrden = datos[indiceBase + 1];\n          const filaDet = datos[indiceBase + 2];\n          \n          const proveedor = filaProv[provKey] || \"\";\n          const ordenCompra = filaOrden && filaOrden[provKey] ? filaOrden[provKey] : \"\";\n          const peso = filaDet && filaDet[provKey] ? filaDet[provKey] : \"\";\n          const cat  = filaDet && filaDet[`__EMPTY_${col + 1}`] ? filaDet[`__EMPTY_${col + 1}`] : \"\";\n          const und  = filaDet && filaDet[`__EMPTY_${col + 2}`] ? filaDet[`__EMPTY_${col + 2}`] : \"\";\n          \n          // Antes pon√≠amos estado=\"ocupado\" directamente\n          // Ahora verificamos si el texto contiene \"reagendado\", \"cancelado\" o \"fuera de servicio\".\n          const nuevoEstado = determinarEstadoOcupado(proveedor, ordenCompra, peso, cat, und);\n          \n          // Asignamos los datos\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].estado = nuevoEstado;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].proveedor = proveedor;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].ordenCompra = ordenCompra;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].peso = peso;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].categoria = cat;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].unidades = und;\n        }\n      });\n    };\n    \n    if (muellesInfo.muelle1) {\n      asignarCita('muelle1', muellesInfo.muelle1);\n    }\n    if (muellesInfo.muelle2) {\n      asignarCita('muelle2', muellesInfo.muelle2);\n    }\n  });\n}\n\n// -------------------------------------------------------------\n// 2) FUNCIONES PARA CONSULTAR LA MALLA\n// -------------------------------------------------------------\nfunction buscarFranjasDisponibles(categoria, duracionHoras) {\n  const muelle = \"muelle1\"; // Ajusta si usas \"categoria -> muelle\" real\n  \n  const franjasDisponibles = [];\n  Object.keys(mallaEstructurada.dias).forEach(dia => {\n    const libres = [];\n    for (let i = 0; i <= mallaEstructurada.franjas.length - duracionHoras; i++) {\n      let disponible = true;\n      for (let h = 0; h < duracionHoras; h++) {\n        const idxF = i + h;\n        const horaAct = mallaEstructurada.franjas[idxF].hora;\n        if (\n          mallaEstructurada.dias[dia][muelle][horaAct].estado !== 'disponible'\n        ) {\n          disponible = false;\n          break;\n        }\n      }\n      if (disponible) {\n        libres.push({\n          horaInicio: mallaEstructurada.franjas[i].hora,\n          duracion: duracionHoras\n        });\n      }\n    }\n    if (libres.length > 0) {\n      franjasDisponibles.push({ dia, franjas: libres });\n    }\n  });\n  return franjasDisponibles;\n}\n\nfunction buscarCitasProveedor(nombreProveedor) {\n  const citas = [];\n  Object.keys(mallaEstructurada.dias).forEach(dia => {\n    const muelle1 = mallaEstructurada.dias[dia].muelle1;\n    const muelle2 = mallaEstructurada.dias[dia].muelle2;\n    mallaEstructurada.franjas.forEach(f => {\n      const hora = f.hora;\n      // muelle1\n      if (normalizarTexto(muelle1[hora].proveedor) === normalizarTexto(nombreProveedor)) {\n        citas.push({\n          dia,\n          hora,\n          muelle: \"Muelle 01\",\n          ordenCompra: muelle1[hora].ordenCompra,\n          peso: muelle1[hora].peso,\n          categoria: muelle1[hora].categoria,\n          unidades: muelle1[hora].unidades,\n          estado: muelle1[hora].estado\n        });\n      }\n      // muelle2\n      if (normalizarTexto(muelle2[hora].proveedor) === normalizarTexto(nombreProveedor)) {\n        citas.push({\n          dia,\n          hora,\n          muelle: \"Muelle 02\",\n          ordenCompra: muelle2[hora].ordenCompra,\n          peso: muelle2[hora].peso,\n          categoria: muelle2[hora].categoria,\n          unidades: muelle2[hora].unidades,\n          estado: muelle2[hora].estado\n        });\n      }\n    });\n  });\n  return citas;\n}\n\nfunction consultarFranjasDisponibles(categoria, duracionHoras) {\n  return buscarFranjasDisponibles(categoria, duracionHoras);\n}\n\nfunction consultarCitasProveedor(nombreProveedor) {\n  return buscarCitasProveedor(nombreProveedor);\n}\n\nfunction obtenerInfoMalla() {\n  return {\n    titulo: mallaEstructurada.titulo,\n    a√±o: mallaEstructurada.a√±o,\n    semana: mallaEstructurada.semana,\n    rangoDias: mallaEstructurada.rangoDias,\n    franjas: mallaEstructurada.franjas.map(f => f.hora)\n  };\n}\n\nfunction estaDisponible(dia, hora, muelle) {\n  const info = mallaEstructurada.dias[dia]?.[muelle]?.[hora];\n  return info ? (info.estado === 'disponible') : false;\n}\n\nfunction obtenerCoordenadasCita(dia, hora, muelle) {\n  // Ajustar con tu mapeo de celdas en Excel\n  return {\n    proveedor: `${dia}_${hora}_${muelle}_proveedor`,\n    ordenCompra: `${dia}_${hora}_${muelle}_ordenCompra`,\n    peso: `${dia}_${hora}_${muelle}_peso`,\n    categoria: `${dia}_${hora}_${muelle}_categoria`,\n    unidades: `${dia}_${hora}_${muelle}_unidades`\n  };\n}\n\n// -------------------------------------------------------------\n// 3) EJECUTAR TODO Y RETORNAR\n// -------------------------------------------------------------\n// Procesar todos los datos\nconst malla = procesarDatos(excelData);\n\n// Aplicar el filtro de d√≠as v√°lidos seg√∫n la hora actual\nconst diasPermitidos = diasValidosSemanaActual(diaSemanaActual, pasoLimiteDia);\nObject.keys(malla.dias).forEach(dia => {\n  if (!diasPermitidos.includes(dia)) {\n    delete malla.dias[dia]; // eliminar d√≠as no v√°lidos\n  }\n});\n\nconst resultado = {\n  datosMalla: malla,\n  funciones: {\n    consultarFranjasDisponibles,\n    consultarCitasProveedor,\n    obtenerInfoMalla,\n    estaDisponible,\n    obtenerCoordenadasCita\n  }\n};\n\nreturn [resultado];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -624,
        2832
      ],
      "id": "bd5a3ed1-67cf-4979-ab09-7dbdf679afd7",
      "name": "Estructuraci√≥n, Datos, Consulta, Citas1"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.1,
      "position": [
        -304,
        2928
      ],
      "id": "e1f0db9b-257a-46e7-bc68-c65abfa5453e",
      "name": "Merge datos Excel1"
    },
    {
      "parameters": {
        "jsCode": "return [{\n  json: {\n    datosMalla: $items(\"Merge datos Excel1\")[0].json.datosMalla,\n    datosMallaProxSemana: $items(\"Merge datos Excel1\")[1].json.datosMallaProxSemana,\n    hojaSeleccionada: $items(\"Merge datos Excel1\")[0].json.datosMalla.semana\n  }\n}];\n\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -48,
        2928
      ],
      "id": "a38e66d0-c1eb-4998-bda0-10810660f3aa",
      "name": "Unificaci√≥n y consistencia de datos2"
    },
    {
      "parameters": {
        "operation": "xlsx",
        "binaryPropertyName": "ExcelMallaRecibido2025",
        "options": {
          "sheetName": "={{    (function() {     const semanaActual = $('Unificaci√≥n y consistencia de datos').item.json.hojaSeleccionada;     const numeroSemana = parseInt(semanaActual.replace(\"SEMANA \", \"\"));     return `SEMANA ${numeroSemana + 1}`;   })() }}"
        }
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -864,
        3024
      ],
      "id": "a33594a9-c616-4100-8bf2-346707792f12",
      "name": "Extract MALLA DE RECIBO Semana Siguiente1",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Si el nodo anterior no devolvi√≥ datos (por error al no existir la hoja), retornamos estructura vac√≠a con mensaje\n// Obtener los datos del Excel\nconst excelData = $input.all();\n\n// Mejora en la detecci√≥n de errores: verificar si hay error expl√≠cito o si los datos no son v√°lidos\nconst hayError = excelData.some(item => item.json && item.json.error);\nconst datosInvalidos = !excelData || excelData.length === 0 || hayError;\n\nif (datosInvalidos) {\n  return [{\n    datosMallaProxSemana: {\n      titulo: \"‚ö†Ô∏è La malla de la pr√≥xima semana no existe en el archivo Excel o a√∫n no ha sido creada.\",\n      a√±o: \"\",\n      semana: \"\",\n      rangoDias: \"\",\n      franjas: [],\n      dias: {\n        lunes: { muelle1: {}, muelle2: {} },\n        martes: { muelle1: {}, muelle2: {} },\n        mi√©rcoles: { muelle1: {}, muelle2: {} },\n        jueves: { muelle1: {}, muelle2: {} },\n        viernes: { muelle1: {}, muelle2: {} }\n      }\n    },\n    funciones: {\n      consultarFranjasDisponibles: \"function not available\",\n      consultarCitasProveedor: \"function not available\",\n      obtenerInfoMalla: \"function not available\",\n      estaDisponible: \"function not available\",\n      obtenerCoordenadasCita: \"function not available\"\n    }\n  }];\n}\n\n// El resto del c√≥digo permanece igual...\nconst hojaSeleccionada = $('Unificaci√≥n y consistencia de datos').first().json.hojaSeleccionada;\n\n// Definir estructura de la semana y los d√≠as\nconst diasSemana = ['lunes', 'martes', 'mi√©rcoles', 'jueves', 'viernes'];\n\n// Objeto para almacenar la malla estructurada\nconst mallaEstructurada = {\n  titulo: \"\",\n  a√±o: \"\",\n  semana: \"\",\n  rangoDias: \"\",\n  franjas: [],\n  dias: {}\n};\n\n// Tabla de meses y d√≠as. Ajusta si necesitas contemplar bisiestos, etc.\nconst meses = {\n  \"enero\": 1,\n  \"febrero\": 2,\n  \"marzo\": 3,\n  \"abril\": 4,\n  \"mayo\": 5,\n  \"junio\": 6,\n  \"julio\": 7,\n  \"agosto\": 8,\n  \"septiembre\": 9,\n  \"octubre\": 10,\n  \"noviembre\": 11,\n  \"diciembre\": 12\n};\n\nconst nombreMes = {\n  1: \"enero\",\n  2: \"febrero\",\n  3: \"marzo\",\n  4: \"abril\",\n  5: \"mayo\",\n  6: \"junio\",\n  7: \"julio\",\n  8: \"agosto\",\n  9: \"septiembre\",\n  10: \"octubre\",\n  11: \"noviembre\",\n  12: \"diciembre\"\n};\n\n/**\n * Funci√≥n para determinar si un a√±o es bisiesto\n * Un a√±o es bisiesto si es divisible por 4, excepto aquellos divisibles por 100 \n * que no son divisibles por 400\n */\nfunction esBisiesto(year) {\n  return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);\n}\n\n/**\n * Funci√≥n para obtener el n√∫mero de d√≠as en un mes, considerando a√±os bisiestos\n */\nfunction getDiasMes(mes, a√±o) {\n  const diasPorMes = {\n    1: 31, // enero\n    2: esBisiesto(a√±o) ? 29 : 28, // febrero - ajustado para a√±o bisiesto\n    3: 31, // marzo\n    4: 30, // abril\n    5: 31, // mayo\n    6: 30, // junio\n    7: 31, // julio\n    8: 31, // agosto\n    9: 30, // septiembre\n    10: 31, // octubre\n    11: 30, // noviembre\n    12: 31  // diciembre\n  };\n  \n  return diasPorMes[mes];\n}\n\n/**\n * Funci√≥n para eliminar acentos y pasar a min√∫sculas (para buscar palabras clave sin importar tildes ni may√∫sculas).\n */\nfunction normalizarTexto(texto) {\n  if (typeof texto !== 'string') return \"\";\n  // Normaliza (NFD) y elimina diacr√≠ticos, luego pasa a min√∫sculas.\n  return texto\n    .normalize(\"NFD\")\n    .replace(/[\\u0300-\\u036f]/g, \"\") // quita acentos\n    .toLowerCase();\n}\n\n/**\n * Dada la informaci√≥n de proveedor, ordenCompra, peso, categor√≠a y unidades,\n * revisa si existe la palabra 'fuera de servicio', 'cancelado' o 'reagendado'\n * en cualquiera de esos campos. De ser as√≠, retorna ese estado especial;\n * de lo contrario, retorna 'ocupado'.\n * \n * Se ignoran may√∫sculas, min√∫sculas y tildes.\n */\nfunction determinarEstadoOcupado(proveedor, ordenCompra, peso, categoria, unidades) {\n  const conjunto = `${proveedor} ${ordenCompra} ${peso} ${categoria} ${unidades}`;\n  const texto = normalizarTexto(conjunto);\n\n  if (texto.includes(\"fuera de servicio\")) {\n    return \"fuera de servicio\";\n  }\n  if (texto.includes(\"cancelado\")) {\n    return \"cancelado\";\n  }\n  if (texto.includes(\"reagendado\")) {\n    return \"reagendado\";\n  }\n  return \"ocupado\";  \n}\n\n// -------------------------------------------------------------\n// 1) PROCESAR DATOS (Cabecera, Horas, Muelles, etc.)\n// -------------------------------------------------------------\nfunction procesarDatos(excelData) {\n  // Verificaci√≥n adicional de datos v√°lidos\n  if (!excelData || !Array.isArray(excelData) || excelData.length === 0) {\n    return {\n      titulo: \"‚ö†Ô∏è La malla de la pr√≥xima semana no existe en el archivo Excel o a√∫n no ha sido creada.\",\n      a√±o: \"\",\n      semana: \"\",\n      rangoDias: \"\",\n      franjas: [],\n      dias: {\n        lunes: { muelle1: {}, muelle2: {} },\n        martes: { muelle1: {}, muelle2: {} },\n        mi√©rcoles: { muelle1: {}, muelle2: {} },\n        jueves: { muelle1: {}, muelle2: {} },\n        viernes: { muelle1: {}, muelle2: {} }\n      }\n    };\n  }\n  \n  // Intentar mapear datos, con manejo de errores para cada item\n  const datos = excelData.map(item => {\n    try {\n      return item.json || {};\n    } catch (e) {\n      return {};\n    }\n  });\n  \n  // A) Cabecera (T√≠tulo, A√±o, Rango)\n  datos.forEach((dato, index) => {\n    // Buscar t√≠tulo\n    if (dato.__EMPTY_2 === \"MALLA DE RECIBO CEDI KONFIE IA\") {\n      mallaEstructurada.titulo = dato.__EMPTY_2;\n      \n      // En la siguiente fila puede estar a√±o, semana, rango\n      if (index + 1 < datos.length) {\n        const datoSiguiente = datos[index + 1];\n        if (datoSiguiente) {\n          // A√±o\n          if (datoSiguiente.__EMPTY_2 && !isNaN(datoSiguiente.__EMPTY_2)) {\n            mallaEstructurada.a√±o = datoSiguiente.__EMPTY_2;\n          }\n          // Semana\n          Object.entries(datoSiguiente).forEach(([k, v]) => {\n            if (typeof v === 'string' && v.includes(\"SEMANA\")) {\n              mallaEstructurada.semana = v;\n            }\n          });\n          // Rango: p.ej. \"LUNES 31 AL VIERNES 4 DE ABRIL\"\n          Object.entries(datoSiguiente).forEach(([k, v]) => {\n            if (typeof v === 'string' && v.includes(\"LUNES\") && v.includes(\"VIERNES\")) {\n              mallaEstructurada.rangoDias = v;\n            }\n          });\n        }\n      }\n    }\n  });\n  \n  // Si despu√©s de procesar no encontramos t√≠tulo, es que no hay malla v√°lida\n  if (!mallaEstructurada.titulo) {\n    mallaEstructurada.titulo = \"‚ö†Ô∏è La malla de la pr√≥xima semana no existe en el archivo Excel o a√∫n no ha sido creada.\";\n    return mallaEstructurada;\n  }\n  \n  // B) Detectar franjas horarias (.__EMPTY = fracci√≥n de d√≠a)\n  const franjasHorarias = [];\n  datos.forEach(dato => {\n    if (\n      dato.__EMPTY !== undefined &&\n      typeof dato.__EMPTY === 'number' &&\n      dato.__EMPTY > 0 &&\n      dato.__EMPTY < 1\n    ) {\n      const totalMin = Math.round(dato.__EMPTY * 24 * 60);\n      const hh = Math.floor(totalMin / 60);\n      const mm = totalMin % 60;\n      \n      let periodo = \"AM\";\n      let hora12 = hh;\n      if (hh >= 12) {\n        periodo = \"PM\";\n        hora12 = (hh === 12 ? 12 : hh - 12);\n      }\n      if (hh === 0) {\n        hora12 = 12;\n      }\n      \n      const horaStr = `${hora12}:${String(mm).padStart(2, '0')} ${periodo}`;\n      franjasHorarias.push({\n        hora: horaStr,\n        indice: datos.indexOf(dato) // fila base\n      });\n    }\n  });\n  franjasHorarias.sort((a, b) => a.indice - b.indice);\n  mallaEstructurada.franjas = franjasHorarias;\n  \n  // C) Detectar muelles (col)\n  const muellesInfo = {};\n  datos.forEach(dato => {\n    Object.entries(dato).forEach(([key, value]) => {\n      if (value === \"MUELLE 01\" || value === \"MUELLE 02\") {\n        const col = parseInt(key.replace(\"__EMPTY_\", \"\"), 10);\n        const muelleKey = (value === \"MUELLE 01\") ? 'muelle1' : 'muelle2';\n        if (!muellesInfo[muelleKey]) {\n          muellesInfo[muelleKey] = [];\n        }\n        muellesInfo[muelleKey].push(col);\n      }\n    });\n  });\n  if (muellesInfo.muelle1) muellesInfo.muelle1.sort((a, b) => a - b);\n  if (muellesInfo.muelle2) muellesInfo.muelle2.sort((a, b) => a - b);\n  \n  // D) Generar los 5 d√≠as (lunes-viernes) con su fecha\n  parsearRangoDias();\n  \n  // E) Extraer Citas\n  extraerCitas(datos, muellesInfo);\n  \n  return mallaEstructurada;\n}\n\n/**\n * Parsea la cadena \"LUNES 31 AL VIERNES 4 DE ABRIL\"\n * (o \"LUNES 31 AL VIERNES 04 DE ABRIL\") y maneja el cruce de mes.\n * Ej.: si dayStart=31 y dayEnd=4, la 1¬™ fecha es 31 de MARZO,\n * luego 1,2,3,4 de ABRIL, en vez de 32,33, etc.\n */\nfunction parsearRangoDias() {\n  const texto = mallaEstructurada.rangoDias;\n  // Regex simple: p.ej. \"31 AL ... 4 DE ABRIL\"\n  // Captura: dayStart, dayEnd, mesFin\n  // Ojo: si dice \"LUNES 31 DE MARZO AL VIERNES 4 DE ABRIL\",\n  // quedar√°: dayStart=31, dayEnd=4, month=ABRIL (al final).\n  const regex = /(\\d+)\\s+AL\\s+\\D+(\\d+)\\s+DE\\s+(\\w+)/i;\n  const match = regex.exec(texto);\n  \n  // Por defecto, creamos 5 d√≠as vac√≠os sin fecha\n  diasSemana.forEach(d => {\n    mallaEstructurada.dias[d] = {\n      muelle1: {},\n      muelle2: {}\n    };\n  });\n  \n  if (!match) {\n    // Sin coincidencia, dejamos los d√≠as sin fecha\n    return;\n  }\n  \n  const dayStart = parseInt(match[1], 10); // 31\n  const dayEnd   = parseInt(match[2], 10); // 4\n  const finalMonthName = match[3].toLowerCase(); // \"abril\"\n  \n  // Convertimos a n√∫mero\n  const finalMonth = meses[finalMonthName] || 3; // fallback marzo\n  const yearNum = parseInt(mallaEstructurada.a√±o, 10) || 2025;\n  \n  // Funci√≥n para obtener la fecha formateada\n  function fechaFormateada(d, m, y) {\n    return `${d} de ${nombreMes[m]} de ${y}`;\n  }\n  \n  // Comprobamos cu√°ntos d√≠as tiene el mes final, considerando bisiestos\n  const diasMesFinal = getDiasMes(finalMonth, yearNum);\n  // y del mes previo\n  const monthPrev = (finalMonth === 1) ? 12 : finalMonth - 1;\n  const yearPrev = (finalMonth === 1) ? yearNum - 1 : yearNum;\n  \n  // Arreglo final con 5 fechas\n  const fechasDias = [];\n  \n  if (dayStart <= dayEnd) {\n    // Caso \"normal\": todo en el mismo mes\n    let d = dayStart;\n    for (let i = 0; i < 5; i++) {\n      fechasDias.push({\n        diaSem: diasSemana[i],\n        diaNum: d,\n        mesNum: finalMonth,\n        yearNum: yearNum\n      });\n      d++;\n      if (d > diasMesFinal) {\n        d = 1;\n        const nextMonth = finalMonth % 12 + 1;\n        const nextYear = (nextMonth === 1) ? yearNum + 1 : yearNum;\n        fechasDias[fechasDias.length - 1].mesNum = nextMonth;\n        fechasDias[fechasDias.length - 1].yearNum = nextYear;\n      }\n    }\n  } else {\n    // Caso \"cruza de mes\": dayStart > dayEnd\n    let d = dayStart;\n    let m = monthPrev;\n    let y = yearPrev;\n    \n    for (let i = 0; i < 5; i++) {\n      fechasDias.push({\n        diaSem: diasSemana[i],\n        diaNum: d,\n        mesNum: m,\n        yearNum: y\n      });\n      d++;\n      if (d > getDiasMes(m, y)) {\n        d = 1;\n        m = m % 12 + 1;\n        if (m === 1) {\n          y++;\n        }\n      }\n    }\n  }\n  \n  // Ahora volcamos esas 5 fechas en la estructura\n  fechasDias.forEach(fd => {\n    const { diaSem, diaNum, mesNum, yearNum } = fd;\n    mallaEstructurada.dias[diaSem] = {\n      fechaDia: fechaFormateada(diaNum, mesNum, yearNum),\n      muelle1: {},\n      muelle2: {}\n    };\n  });\n  \n  // Inicializamos las franjas a 'disponible'\n  if (mallaEstructurada.franjas.length > 0) {\n    diasSemana.forEach(d => {\n      mallaEstructurada.franjas.forEach(f => {\n        mallaEstructurada.dias[d].muelle1[f.hora] = {\n          estado: \"disponible\",\n          proveedor: \"\",\n          ordenCompra: \"\",\n          peso: \"\",\n          categoria: \"\",\n          unidades: \"\"\n        };\n        mallaEstructurada.dias[d].muelle2[f.hora] = {\n          estado: \"disponible\",\n          proveedor: \"\",\n          ordenCompra: \"\",\n          peso: \"\",\n          categoria: \"\",\n          unidades: \"\"\n        };\n      });\n    });\n  }\n}\n\n/**\n * Funci√≥n auxiliar: decide a qu√© d√≠a pertenece una columna,\n * corrigiendo 2 columnas de offset (porque 'Extract from XLSX'\n * deja todo desplazado).\n */\nfunction getDayForColumn(colNumber) {\n  // Ajuste de offset +2\n  const realCol = colNumber + 2;\n\n  // Rangos:\n  //  Lunes:      3..8\n  //  Martes:     9..14\n  //  Mi√©rcoles: 15..20\n  //  Jueves:    21..26\n  //  Viernes:   27..32\n  if (realCol >= 3 && realCol <= 8) {\n    return \"lunes\";\n  }\n  if (realCol >= 9 && realCol <= 14) {\n    return \"martes\";\n  }\n  if (realCol >= 15 && realCol <= 20) {\n    return \"mi√©rcoles\";\n  }\n  if (realCol >= 21 && realCol <= 26) {\n    return \"jueves\";\n  }\n  if (realCol >= 27 && realCol <= 32) {\n    return \"viernes\";\n  }\n  // Si nada coincide, devolvemos null\n  return null;\n}\n\n/**\n * Extraer las citas para cada franja:\n * - Para cada franja, miramos 3 filas:\n *    - Fila base => proveedor\n *    - Fila base+1 => orden\n *    - Fila base+2 => peso, categor√≠a, unidades\n */\nfunction extraerCitas(datos, muellesInfo) {\n  mallaEstructurada.franjas.forEach(franja => {\n    const indiceBase = franja.indice;\n    if (indiceBase < 0 || indiceBase + 2 >= datos.length) {\n      return; // no hay suficientes filas\n    }\n    \n    // Recorremos muelle1, muelle2 y sus columnas\n    const asignarCita = (muelleKey, cols) => {\n      cols.forEach(col => {\n        const provKey = `__EMPTY_${col}`;\n        const filaProv = datos[indiceBase];\n        \n        // Si en esta fila hay un proveedor o alg√∫n texto\n        if (\n          filaProv &&\n          typeof filaProv[provKey] === 'string' &&\n          filaProv[provKey].length > 2\n        ) {\n          // Determinar el d√≠a real\n          const diaOk = getDayForColumn(col);\n          if (!diaOk || !mallaEstructurada.dias[diaOk]) {\n            return; // si no coincide con ninguno, saltamos\n          }\n          \n          // Recuperar valores para proveedor, ordenCompra y dem√°s\n          const filaOrden = datos[indiceBase + 1];\n          const filaDet = datos[indiceBase + 2];\n          \n          const proveedor = filaProv[provKey] || \"\";\n          const ordenCompra = filaOrden && filaOrden[provKey] ? filaOrden[provKey] : \"\";\n          const peso = filaDet && filaDet[provKey] ? filaDet[provKey] : \"\";\n          const cat  = filaDet && filaDet[`__EMPTY_${col + 1}`] ? filaDet[`__EMPTY_${col + 1}`] : \"\";\n          const und  = filaDet && filaDet[`__EMPTY_${col + 2}`] ? filaDet[`__EMPTY_${col + 2}`] : \"\";\n          \n          // Antes pon√≠amos estado=\"ocupado\" directamente\n          // Ahora verificamos si el texto contiene \"reagendado\", \"cancelado\" o \"fuera de servicio\".\n          const nuevoEstado = determinarEstadoOcupado(proveedor, ordenCompra, peso, cat, und);\n          \n          // Asignamos los datos\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].estado = nuevoEstado;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].proveedor = proveedor;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].ordenCompra = ordenCompra;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].peso = peso;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].categoria = cat;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].unidades = und;\n        }\n      });\n    };\n    \n    if (muellesInfo.muelle1) {\n      asignarCita('muelle1', muellesInfo.muelle1);\n    }\n    if (muellesInfo.muelle2) {\n      asignarCita('muelle2', muellesInfo.muelle2);\n    }\n  });\n}\n\n// -------------------------------------------------------------\n// 2) FUNCIONES PARA CONSULTAR LA MALLA\n// -------------------------------------------------------------\nfunction buscarFranjasDisponibles(categoria, duracionHoras) {\n  const muelle = \"muelle1\"; // Ajusta si usas \"categoria -> muelle\" real\n  \n  const franjasDisponibles = [];\n  Object.keys(mallaEstructurada.dias).forEach(dia => {\n    const libres = [];\n    for (let i = 0; i <= mallaEstructurada.franjas.length - duracionHoras; i++) {\n      let disponible = true;\n      for (let h = 0; h < duracionHoras; h++) {\n        const idxF = i + h;\n        const horaAct = mallaEstructurada.franjas[idxF].hora;\n        if (\n          mallaEstructurada.dias[dia][muelle][horaAct].estado !== 'disponible'\n        ) {\n          disponible = false;\n          break;\n        }\n      }\n      if (disponible) {\n        libres.push({\n          horaInicio: mallaEstructurada.franjas[i].hora,\n          duracion: duracionHoras\n        });\n      }\n    }\n    if (libres.length > 0) {\n      franjasDisponibles.push({ dia, franjas: libres });\n    }\n  });\n  return franjasDisponibles;\n}\n\nfunction buscarCitasProveedor(nombreProveedor) {\n  const citas = [];\n  Object.keys(mallaEstructurada.dias).forEach(dia => {\n    const muelle1 = mallaEstructurada.dias[dia].muelle1;\n    const muelle2 = mallaEstructurada.dias[dia].muelle2;\n    mallaEstructurada.franjas.forEach(f => {\n      const hora = f.hora;\n      // muelle1\n      if (normalizarTexto(muelle1[hora].proveedor) === normalizarTexto(nombreProveedor)) {\n        citas.push({\n          dia,\n          hora,\n          muelle: \"Muelle 01\",\n          ordenCompra: muelle1[hora].ordenCompra,\n          peso: muelle1[hora].peso,\n          categoria: muelle1[hora].categoria,\n          unidades: muelle1[hora].unidades,\n          estado: muelle1[hora].estado\n        });\n      }\n      // muelle2\n      if (normalizarTexto(muelle2[hora].proveedor) === normalizarTexto(nombreProveedor)) {\n        citas.push({\n          dia,\n          hora,\n          muelle: \"Muelle 02\",\n          ordenCompra: muelle2[hora].ordenCompra,\n          peso: muelle2[hora].peso,\n          categoria: muelle2[hora].categoria,\n          unidades: muelle2[hora].unidades,\n          estado: muelle2[hora].estado\n        });\n      }\n    });\n  });\n  return citas;\n}\n\nfunction consultarFranjasDisponibles(categoria, duracionHoras) {\n  return buscarFranjasDisponibles(categoria, duracionHoras);\n}\n\nfunction consultarCitasProveedor(nombreProveedor) {\n  return buscarCitasProveedor(nombreProveedor);\n}\n\nfunction obtenerInfoMalla() {\n  return {\n    titulo: mallaEstructurada.titulo,\n    a√±o: mallaEstructurada.a√±o,\n    semana: mallaEstructurada.semana,\n    rangoDias: mallaEstructurada.rangoDias,\n    franjas: mallaEstructurada.franjas.map(f => f.hora)\n  };\n}\n\nfunction estaDisponible(dia, hora, muelle) {\n  const info = mallaEstructurada.dias[dia]?.[muelle]?.[hora];\n  return info ? (info.estado === 'disponible') : false;\n}\n\nfunction obtenerCoordenadasCita(dia, hora, muelle) {\n  // Ajustar con tu mapeo de celdas en Excel\n  return {\n    proveedor: `${dia}_${hora}_${muelle}_proveedor`,\n    ordenCompra: `${dia}_${hora}_${muelle}_ordenCompra`,\n    peso: `${dia}_${hora}_${muelle}_peso`,\n    categoria: `${dia}_${hora}_${muelle}_categoria`,\n    unidades: `${dia}_${hora}_${muelle}_unidades`\n  };\n}\n\n// -------------------------------------------------------------\n// 3) EJECUTAR TODO Y RETORNAR\n// -------------------------------------------------------------\nconst malla = procesarDatos(excelData);\n\nconst resultado = {\n  datosMallaProxSemana: malla,\n  funciones: {\n    consultarFranjasDisponibles,\n    consultarCitasProveedor,\n    obtenerInfoMalla,\n    estaDisponible,\n    obtenerCoordenadasCita\n  }\n};\n\nreturn [resultado];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -624,
        3024
      ],
      "id": "5b339af4-9900-4d7a-82be-570d2270692d",
      "name": "Estructuraci√≥n, Datos, Consulta, Citas Proxima Semana1"
    },
    {
      "parameters": {
        "jsCode": "// =========  VALIDACI√ìN DE CITA EN CRONOGRAMA  =========\n// Valida que la franja siga libre justo despu√©s de la confirmaci√≥n del proveedor\n\n// NUEVO: Detectar retractaci√≥n al inicio\nconst validacionSeleccion = $input.first().json.output;\n\nif (validacionSeleccion.esRetractacion === true) {\n  return [{\n    json: {\n      franjaDisponible: false,\n      esRetractacion: true,\n      forzarReset: true,\n      motivoRetractacion: validacionSeleccion.motivoRetractacion,\n      mensajeReset: \"üîÑ **Proceso reiniciado por cambios m√∫ltiples**\\n\\nPara evitar errores, cuando te presento opciones, por favor elige una de la lista.\\n\\nüìù Proporciona todos los datos completos en un solo mensaje:\\n‚Ä¢ Proveedor\\n‚Ä¢ Fecha\\n‚Ä¢ Hora\\n‚Ä¢ Categor√≠a\\n‚Ä¢ Peso\\n‚Ä¢ Unidades\\n‚Ä¢ Orden de compra\"\n    }\n  }];\n}\n\nfunction validarDisponibilidadCitaEnCronograma(items) {\n  try {\n    /* 1. --- Datos que vienen del nodo de verificaci√≥n de tiempo --- */\n    const resp = $node[\"Code Verificar Tiempo Transcurrido\"].json.respuesta.alternativasDisponibles;\n    if (!resp) {\n      return [{ json:{ franjaDisponible:false, mensaje:\"No se encontr√≥ la cita a validar.\" } }];\n    }\n\n    /* 2. --- ¬øEl proveedor eligi√≥ una alternativa? ------------------ */\n    const salidaLLM      = items[0].json.output ?? items[0].json;   // el LLM suele venir como root\n    const tieneAlt       = salidaLLM?.seleccionaAlternativa === true;\n    const datosValidar   = tieneAlt && salidaLLM.datosSeleccionados\n      ? salidaLLM.datosSeleccionados\n      : {\n          fecha           : resp.fecha,\n          fechaFormateada : resp.fechaFormateada,\n          horaInicio      : resp.horaInicio,\n          horaFin         : resp.horaFin,\n          muelle          : resp.muelle,\n          duracionHoras   : resp.duracionHoras       // puede venir undefined\n        };\n\n    /* --- Si no lleg√≥ duracionHoras, la calculamos ------------------ */\n    if (!datosValidar.duracionHoras) {\n      datosValidar.duracionHoras = calcularDuracionAproximada(\n        datosValidar.horaInicio, datosValidar.horaFin\n      );\n    }\n\n    /* 3. --- Mallas de la semana actual y pr√≥xima ------------------- */\n    const nodoDatos = $node[\"Unificaci√≥n y consistencia de datos2\"].json;\n    const datosMalla = nodoDatos.datosMalla;\n    const datosMallaProxSemana = nodoDatos.datosMallaProxSemana;\n    \n    if (!datosMalla || !datosMallaProxSemana) {\n      return [{ json:{ franjaDisponible:false, mensaje:\"No lleg√≥ la malla horaria.\" } }];\n    }\n\n    /* 4. --- Validaci√≥n propiamente dicha --------------------------- */\n    // Variable para almacenar qu√© malla se utiliz√≥ en la verificaci√≥n\n  let mallaUtilizada = null;\n  \n  const disponible = verificarDisponibilidadHoraSolicitada(\n      datosValidar.fecha,\n      datosValidar.horaInicio,\n      datosValidar.muelle,\n      datosValidar.duracionHoras,\n      datosMalla,\n      datosMallaProxSemana,\n      (malla) => { mallaUtilizada = malla; } // Callback para capturar la malla usada\n    );\n\n    // Obtener el n√∫mero de semana de la malla utilizada para la validaci√≥n\n    const nombreHoja = disponible && mallaUtilizada ? mallaUtilizada.semana : null;\n    \n    const respuesta = {\n      franjaDisponible : disponible,\n      mensaje : disponible\n        ? `¬°Genial! Hay espacio para el ${datosValidar.fecha}, de ` +\n          `${datosValidar.horaInicio} a ${datosValidar.horaFin} en ${datosValidar.muelle}.`\n        : \"Lo siento, la franja horaria seleccionada ya no est√° disponible. \" +\n          \"Por favor elige otra opci√≥n.\",\n      datosValidados : {\n        ...datosValidar,\n        disponibilidadConfirmada : disponible\n      },\n      nombreHoja : nombreHoja // Agregamos el nombre de la hoja donde se debe insertar la cita\n    };\n\n    return [{ json: respuesta }];\n\n  } catch (err) {\n    console.error(\"Error en validaci√≥n:\", err);\n    return [{ json:{ franjaDisponible:false, mensaje:`Error al validar: ${err.message}` } }];\n  }\n}\n\n/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n *  UTILIDADES \n * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */\n\nfunction verificarDisponibilidadHoraSolicitada(\n  fechaSolicitada, horaSolicitada, muelle, horasNecesarias,\n  mallaActual, mallaProxima, callbackMalla = null\n){\n  try {\n    // --- Normalizamos -------------------------------------------------\n    if (!fechaSolicitada || !horaSolicitada || !muelle) return false;\n\n    const fechaObj  = parsearFechaEspanol(fechaSolicitada);\n    const malla     = seleccionarMallaParaFecha(fechaObj, mallaActual, mallaProxima);\n    if (!malla) return false;\n    \n    // Si se proporcion√≥ una funci√≥n callback, llamarla con la malla seleccionada\n    if (typeof callbackMalla === 'function') {\n      callbackMalla(malla);\n    }\n\n    const diaSem    = obtenerDiaSemanaEspanol(fechaObj);\n    const keyMuelle = normalizarMuelle(muelle);\n\n    if (!malla.dias[diaSem] || !malla.dias[diaSem][keyMuelle]) return false;\n\n    if (!malla.franjas || !Array.isArray(malla.franjas)) return false;\n    const franjas   = malla.franjas.map(f => f.hora);\n    const idxInicio = franjas.findIndex(h => limpiarHora(h) === limpiarHora(horaSolicitada));\n    \n    if (idxInicio === -1 || idxInicio + horasNecesarias > franjas.length) return false;\n\n    for (let i = 0; i < horasNecesarias; i++) {\n      const hora = franjas[idxInicio + i];\n      const fr   = malla.dias[diaSem][keyMuelle][hora];\n      if (!fr || (fr.estado ?? \"\").toLowerCase() !== \"disponible\") return false;\n    }\n    return true;\n  } catch(e){ \n    console.error(\"Error en verificarDisponibilidadHoraSolicitada:\", e); \n    return false; \n  }\n}\n\n/* ---------- Helpers de normalizaci√≥n ------------------------------ */\nconst limpiarHora = h => h.trim().replace(/^0+(?=\\d)/, \"\").toUpperCase();\n\nfunction normalizarMuelle(txt = \"\") {\n  return txt\n    .toLowerCase()\n    .normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\") // sin tildes\n    .replace(/\\s+/g, \"\");\n}\n\n/* ---- FIX: elegir malla correcta cuando el rango cruza de mes ----- */\nfunction seleccionarMallaParaFecha(fechaObj, mallaActual, mallaProxima){\n  const dentro = (malla) => {\n    if (!malla) return false;\n    const r = rangoDesdeDias(malla);\n    if (!r) return false;\n    \n    // Simplificar comparaci√≥n ignorando horas/minutos/segundos\n    const fechaSimple = new Date(fechaObj.getFullYear(), fechaObj.getMonth(), fechaObj.getDate());\n    const inicioSimple = new Date(r.inicio.getFullYear(), r.inicio.getMonth(), r.inicio.getDate());\n    const finSimple = new Date(r.fin.getFullYear(), r.fin.getMonth(), r.fin.getDate());\n    \n    return fechaSimple >= inicioSimple && fechaSimple <= finSimple;\n  };\n  \n  if (dentro(mallaActual)) return mallaActual;\n  if (dentro(mallaProxima)) return mallaProxima;\n  return null;\n}\n\n/* Rango basado en las fechas reales de cada d√≠a (m√≠n-m√°x) */\nfunction rangoDesdeDias(malla){\n  if (!malla || !malla.dias) return null;\n  let min=null, max=null;\n  for (const d of Object.values(malla.dias)){\n    if (d && d.fechaDia){\n      const f = parsearFechaEspanol(d.fechaDia);\n      if (!min || f < min) min=f;\n      if (!max || f > max) max=f;\n    }\n  }\n  return (min && max) ? {inicio:min, fin:max} : null;\n}\n\n// Funci√≥n para calcular la duraci√≥n aproximada en horas basada en las horas de inicio y fin\nfunction calcularDuracionAproximada(horaInicio, horaFin) {\n  try {\n    if (!horaInicio || !horaFin) {\n      return 3; // Valor por defecto si no se puede calcular\n    }\n    \n    // Verificar si las horas est√°n en formato AM/PM\n    const esFormatoAMPM = /AM|PM/i.test(horaInicio) && /AM|PM/i.test(horaFin);\n    \n    if (esFormatoAMPM) {\n      // Convertir horas de formato AM/PM a 24 horas\n      const horaInicioObj = convertirHoraAMPMA24H(horaInicio);\n      const horaFinObj = convertirHoraAMPMA24H(horaFin);\n      \n      // Calcular diferencia en horas\n      let diferenciaHoras = horaFinObj.hora - horaInicioObj.hora;\n      \n      // Ajustar por diferencia en minutos\n      if (horaFinObj.minutos < horaInicioObj.minutos) {\n        diferenciaHoras--;\n      }\n      \n      // Si la diferencia es negativa, asumimos que cruza la medianoche\n      if (diferenciaHoras < 0) {\n        diferenciaHoras += 24;\n      }\n      \n      return diferenciaHoras;\n    } else {\n      // Formato 24 horas\n      const [horasInicio] = horaInicio.split(':').map(Number);\n      const [horasFin] = horaFin.split(':').map(Number);\n      \n      let diferenciaHoras = horasFin - horasInicio;\n      if (diferenciaHoras < 0) {\n        diferenciaHoras += 24;\n      }\n      \n      return diferenciaHoras;\n    }\n  } catch (error) {\n    console.error(`Error calculando duraci√≥n:`, error);\n    return 3; // Valor por defecto\n  }\n}\n\n// Funci√≥n auxiliar para convertir hora de formato AM/PM a formato 24 horas\nfunction convertirHoraAMPMA24H(horaAMPM) {\n  try {\n    const [tiempo, periodo] = horaAMPM.split(/\\s+/);\n    let [horas, minutos] = tiempo.split(':').map(Number);\n    \n    // Ajustar horas para formato de 24 horas\n    if (periodo.toUpperCase() === 'PM' && horas < 12) {\n      horas += 12;\n    } else if (periodo.toUpperCase() === 'AM' && horas === 12) {\n      horas = 0;\n    }\n    \n    return {\n      hora: horas,\n      minutos: minutos || 0\n    };\n  } catch (error) {\n    console.error(`Error convirtiendo hora:`, error);\n    return { hora: 0, minutos: 0 }; // Fallback\n  }\n}\n\n// Funci√≥n auxiliar para calcular la hora de fin basada en la hora de inicio y la duraci√≥n\nfunction calcularHoraFin(horaInicio, duracionHoras) {\n  try {\n    // Verificar si la hora de inicio tiene formato AM/PM\n    const esFormatoAMPM = /AM|PM/i.test(horaInicio);\n    \n    if (esFormatoAMPM) {\n      // Convertir hora formato AM/PM\n      const [tiempo, periodo] = horaInicio.split(/\\s+/);\n      let [horas, minutos] = tiempo.split(':').map(Number);\n      \n      // Ajustar horas para formato de 24 horas\n      if (periodo.toUpperCase() === 'PM' && horas < 12) {\n        horas += 12;\n      } else if (periodo.toUpperCase() === 'AM' && horas === 12) {\n        horas = 0;\n      }\n      \n      // A√±adir duraci√≥n\n      horas += duracionHoras;\n      \n      // Convertir de vuelta a AM/PM\n      let nuevoPeriodo = 'AM';\n      if (horas >= 12) {\n        nuevoPeriodo = 'PM';\n        if (horas > 12) {\n          horas -= 12;\n        }\n      }\n      if (horas === 0) {\n        horas = 12;\n        nuevoPeriodo = 'AM';\n      }\n      \n      // Formatear resultado\n      return `${horas}:${minutos.toString().padStart(2, '0')} ${nuevoPeriodo}`;\n    } else {\n      // Formato 24 horas\n      const [horas, minutos] = horaInicio.split(':').map(Number);\n      const nuevasHoras = (horas + duracionHoras) % 24;\n      return `${nuevasHoras}:${minutos.toString().padStart(2, '0')}`;\n    }\n  } catch (error) {\n    console.error(`Error calculando hora fin:`, error);\n    return \"\"; // Fallback\n  }\n}\n\n// Convertir fecha en formato espa√±ol a formato ISO (YYYY-MM-DD)\nfunction convertirFechaAFormatoISO(fechaTexto) {\n  try {\n    if (!fechaTexto || typeof fechaTexto !== 'string') {\n      throw new Error(\"Texto de fecha inv√°lido\");\n    }\n    \n    // Formato esperado: \"dd de mes de yyyy\"\n    const partes = fechaTexto.split(\" de \");\n    if (partes.length !== 3) {\n      throw new Error(`Formato de fecha inv√°lido: ${fechaTexto}`);\n    }\n    \n    const dia = parseInt(partes[0], 10);\n    if (isNaN(dia) || dia < 1 || dia > 31) {\n      throw new Error(`D√≠a inv√°lido: ${partes[0]}`);\n    }\n    \n    const mes = obtenerNumeroMes(partes[1]);\n    if (mes === -1) {\n      throw new Error(`Mes inv√°lido: ${partes[1]}`);\n    }\n    \n    const anio = parseInt(partes[2], 10);\n    if (isNaN(anio) || anio < 2000 || anio > 2100) {\n      throw new Error(`A√±o inv√°lido: ${partes[2]}`);\n    }\n    \n    // Formatear como YYYY-MM-DD\n    const mesStr = (mes + 1).toString().padStart(2, '0');\n    const diaStr = dia.toString().padStart(2, '0');\n    \n    return `${anio}-${mesStr}-${diaStr}`;\n  } catch (error) {\n    console.error(`Error convirtiendo fecha: ${error.message}`);\n    return \"\"; // Cadena vac√≠a como fallback\n  }\n}\n\n// Obtener n√∫mero de mes a partir del nombre en espa√±ol\nfunction obtenerNumeroMes(nombreMes) {\n  if (!nombreMes || typeof nombreMes !== 'string') {\n    return -1;\n  }\n  \n  const nombreMesLower = nombreMes.toLowerCase();\n  const meses = [\n    \"enero\", \"febrero\", \"marzo\", \"abril\", \"mayo\", \"junio\",\n    \"julio\", \"agosto\", \"septiembre\", \"octubre\", \"noviembre\", \"diciembre\"\n  ];\n  \n  return meses.indexOf(nombreMesLower);\n}\n\n// Convertir fecha en formato espa√±ol a objeto Date\nfunction parsearFechaEspanol(fechaTexto) {\n  try {\n    if (!fechaTexto || typeof fechaTexto !== 'string') {\n      throw new Error(\"Texto de fecha inv√°lido\");\n    }\n    \n    // Formato esperado: \"dd de mes de yyyy\"\n    const partes = fechaTexto.split(\" de \");\n    if (partes.length !== 3) {\n      throw new Error(`Formato de fecha inv√°lido: ${fechaTexto}`);\n    }\n    \n    const dia = parseInt(partes[0], 10);\n    if (isNaN(dia) || dia < 1 || dia > 31) {\n      throw new Error(`D√≠a inv√°lido: ${partes[0]}`);\n    }\n    \n    const mes = obtenerNumeroMes(partes[1]);\n    if (mes === -1) {\n      throw new Error(`Mes inv√°lido: ${partes[1]}`);\n    }\n    \n    const anio = parseInt(partes[2], 10);\n    if (isNaN(anio) || anio < 2000 || anio > 2100) {\n      throw new Error(`A√±o inv√°lido: ${partes[2]}`);\n    }\n    \n    return new Date(anio, mes, dia);\n  } catch (error) {\n    console.error(`Error parseando fecha: ${error.message}`);\n    return new Date(); // Fecha actual como fallback\n  }\n}\n\n// Obtener d√≠a de la semana en espa√±ol\nfunction obtenerDiaSemanaEspanol(fecha) {\n  if (!fecha || !(fecha instanceof Date)) {\n    console.error(\"Fecha inv√°lida para obtener d√≠a de semana\");\n    return \"\";\n  }\n  \n  const diaSemana = fecha.getDay();\n  \n  // El c√≥digo original usa d√≠as laborables (lunes a viernes)\n  // 0 = domingo, 1 = lunes, ..., 6 = s√°bado\n  if (diaSemana === 0 || diaSemana === 6) {\n    console.error(\"La fecha corresponde a un fin de semana (s√°bado o domingo)\");\n    return \"\";\n  }\n  \n  const diasSemana = [\"domingo\", \"lunes\", \"martes\", \"mi√©rcoles\", \"jueves\", \"viernes\", \"s√°bado\"];\n  return diasSemana[diaSemana];\n}\n\n// Parsear rango de d√≠as de una malla\nfunction parsearRangoDias(rangoTexto) {\n  try {\n    if (!rangoTexto || typeof rangoTexto !== 'string') {\n      throw new Error(\"Texto de rango inv√°lido\");\n    }\n    \n    // Formato esperado: \"LUNES DD AL VIERNES DD DE MES\"\n    const partes = rangoTexto.toUpperCase().split(\" \");\n    \n    // Buscar d√≠a inicial\n    let diaInicio = null;\n    let indexAL = -1;\n    \n    for (let i = 0; i < partes.length; i++) {\n      if (partes[i] === \"AL\") {\n        indexAL = i;\n        break;\n      }\n      \n      // Intentar convertir a n√∫mero\n      const posibleDia = parseInt(partes[i], 10);\n      if (!isNaN(posibleDia)) {\n        diaInicio = posibleDia;\n      }\n    }\n    \n    if (diaInicio === null || indexAL === -1) {\n      throw new Error(\"No se pudo identificar el d√≠a de inicio o la palabra 'AL'\");\n    }\n    \n    // Buscar d√≠a final\n    let diaFin = null;\n    let mesIndex = -1;\n    \n    for (let i = indexAL + 1; i < partes.length; i++) {\n      if (partes[i] === \"DE\") {\n        mesIndex = i;\n        break;\n      }\n      \n      // Intentar convertir a n√∫mero\n      const posibleDia = parseInt(partes[i], 10);\n      if (!isNaN(posibleDia)) {\n        diaFin = posibleDia;\n      }\n    }\n    \n    if (diaFin === null || mesIndex === -1 || mesIndex + 1 >= partes.length) {\n      throw new Error(\"No se pudo identificar el d√≠a final o el mes\");\n    }\n    \n    const nombreMes = partes[mesIndex + 1].toLowerCase();\n    const mes = obtenerNumeroMes(nombreMes);\n    \n    if (mes === -1) {\n      throw new Error(`Mes inv√°lido: ${nombreMes}`);\n    }\n    \n    const anio = new Date().getFullYear();\n    \n    return {\n      inicio: new Date(anio, mes, diaInicio),\n      fin: new Date(anio, mes, diaFin)\n    };\n  } catch (error) {\n    console.error(`Error parseando rango: ${error.message}`);\n    \n    // Rango amplio como fallback\n    const hoy = new Date();\n    const finDeMes = new Date(hoy.getFullYear(), hoy.getMonth() + 1, 0);\n    \n    return {\n      inicio: hoy,\n      fin: finDeMes\n    };\n  }\n}\n\n// Devolver la funci√≥n principal para n8n\nreturn validarDisponibilidadCitaEnCronograma(items);"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        608,
        2928
      ],
      "id": "2ec9cfa9-74f5-483b-a8e7-d170faae2cb7",
      "name": "Code VALIDACI√ìN DE CITA EN CRONOGRAMA"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "15af6812-2871-4888-9658-c24f185bcbd4",
              "leftValue": "={{ $json.franjaDisponible }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            },
            {
              "id": "032ef339-3304-444d-89eb-26aa314e06b8",
              "leftValue": "={{ $json.forzarReset }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "false",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        848,
        2928
      ],
      "id": "d5e167cf-0877-49b0-99ed-f767a89432d2",
      "name": "If CREACION DE CITA EN CRONOGRAMA"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        2112,
        3472
      ],
      "id": "d9d69d22-d8ec-4b2f-a45c-4e9a9316beee",
      "name": "OpenAI Chat Model10",
      "credentials": {
        "openAiApi": {
          "id": "AD8kPcNVReuclASd",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "=define",
        "text": "=Eres un asistente de un sistema de agendamiento de citas para la entrega de mercanc√≠a en la bodega. Debes notificar que, mientras el cliente decid√≠a confirmar la cita, otro proveedor ocup√≥ esa franja horaria.\n\nGenera un mensaje directo (sin saludos iniciales ni mencionar nombres) que:\n\nIndique claramente que la cita no pudo confirmarse porque la franja se asign√≥ a otro proveedor.\n\nExplique brevemente que esto sucede debido a que las franjas se confirman en tiempo real y pueden cambiar constantemente.\n\nMencione que, para revisar nuevas opciones, es necesario reiniciar el proceso y volver a proporcionar los datos solicitados.\n\nDestaque la importancia de contar con informaci√≥n actualizada para garantizar disponibilidad y trazabilidad.\n\nAgradezca la comprensi√≥n.\n\nTono: profesional pero emp√°tico, reconociendo el inconveniente y explicando la necesidad de reiniciar el proceso."
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        2192,
        3264
      ],
      "id": "9ad2c03a-0503-4232-9aed-373ecf4609ed",
      "name": "Basic LLM Notificar No Disponibilidad1"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "4bfbecb3-9d4f-4425-aa76-a92abc7708fb",
              "leftValue": "={{ $('Basic LLM Notificar No Disponibilidad').item.json.text.length }}",
              "rightValue": 70,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        1040,
        2208
      ],
      "id": "bc65af13-b36d-487d-b9cd-d409eadf2ca9",
      "name": "Validaci√≥n de longitud de caracteres4"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d9c2ff70-4fd1-4b93-8571-6d0ac5a0093e",
              "name": "mensaje.ia",
              "value": "={{ $('Basic LLM Notificar No Disponibilidad').item.json.text }}",
              "type": "string"
            },
            {
              "id": "ac8a03be-0292-4735-9580-39a385945c47",
              "name": "mensaje.longitud",
              "value": "={{ $('Basic LLM Notificar No Disponibilidad').item.json.text.length }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        4160,
        2032
      ],
      "id": "348eeb30-7fdd-49eb-a827-43d922d57860",
      "name": "Organiza variables del mensaje4"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        1520,
        2000
      ],
      "id": "f719b455-77d7-45df-862c-d6de44f794db",
      "name": "No Operation, do nothing6"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $('Code Respuesta Faltantes').item.json.text }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1344,
        2000
      ],
      "id": "8bb1e044-3f8e-4a20-a270-ef6eb8f09252",
      "name": "HTTP Request Enviar Mensaje por WhatsApp7"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "4bfbecb3-9d4f-4425-aa76-a92abc7708fb",
              "leftValue": "={{ $('Basic LLM Notificar No Disponibilidad1').item.json.text.length }}",
              "rightValue": 70,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        4048,
        3488
      ],
      "id": "a93e850d-69a7-4107-8a55-d82474673156",
      "name": "Validaci√≥n de longitud de caracteres5"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d9c2ff70-4fd1-4b93-8571-6d0ac5a0093e",
              "name": "mensaje.ia",
              "value": "={{ $('Basic LLM Notificar No Disponibilidad1').item.json.text }}",
              "type": "string"
            },
            {
              "id": "ac8a03be-0292-4735-9580-39a385945c47",
              "name": "mensaje.longitud",
              "value": "={{ $('Basic LLM Notificar No Disponibilidad1').item.json.text.length }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        5264,
        3520
      ],
      "id": "c0730cba-e320-4bf6-a59a-29d1c53f9ecd",
      "name": "Organiza variables del mensaje5"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        4528,
        3280
      ],
      "id": "ae05e732-2382-4838-a2ac-8171fc988e33",
      "name": "No Operation, do nothing7"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $('Code Respuesta Faltantes').item.json.text }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        4352,
        3280
      ],
      "id": "8ed601b8-5a12-4c4d-888d-24b3248b2138",
      "name": "HTTP Request Enviar Mensaje por WhatsApp8"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        144,
        3120
      ],
      "id": "fab1dc80-a22f-49fe-b9e5-1b519f2914e6",
      "name": "OpenAI Chat Model11",
      "credentials": {
        "openAiApi": {
          "id": "AD8kPcNVReuclASd",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "=define",
        "text": "=## Prompt para nodo \"Basic LLM\" - Validaci√≥n de selecci√≥n de alternativa\n\n## ROL Y CONTEXTO\nEres un asistente especializado en interpretar mensajes de usuarios para un sistema de agendamiento de citas log√≠sticas. Tu tarea es determinar si el usuario est√° eligiendo una alternativa de horario cuando la cita original no est√° disponible, o si est√° haciendo algo diferente (como retractarse o cambiar de opini√≥n).\n\n## CONTEXTO DEL SISTEMA\nEl sistema de agendamiento funciona as√≠:\n1. El sistema verifica si un horario solicitado est√° disponible\n2. Si est√° disponible, muestra un mensaje de confirmaci√≥n\n3. Si NO est√° disponible, presenta alternativas numeradas\n4. El usuario debe responder eligiendo una de esas alternativas\n5. El formato de elecci√≥n puede variar: \"elijo la 1\", \"opci√≥n 2\", \"la primera\", \"la del 17 de julio a las 7am\", etc.\n\n## DATOS DISPONIBLES\n\n### Respuesta del sistema y alternativas presentadas:\n```json\n{{ JSON.stringify($node[\"Code Verificar Tiempo Transcurrido\"].json.respuesta.alternativasDisponibles, null, 2) }}\n```\n\n### Mensaje actual del usuario:\n```\n{{ $('Unificaci√≥n y consistencia de datos').first().json.infoMensaje.mensajeActual }}\n```\n\n### Historial de conversaci√≥n:\n```\n{{ $('Unificaci√≥n y consistencia de datos').first().json.infoMensaje.historialMensajes }}\n```\n\n## L√ìGICA DE AN√ÅLISIS\n\n### PASO 1: VERIFICACI√ìN DE DISPONIBILIDAD CONFIRMADA\nPrimero, verifica el campo \"disponibilidadConfirmada\" en los datos disponibles:\n- Si **disponibilidadConfirmada = true**: El horario original estaba disponible y se confirm√≥. El usuario solo debe confirmar (ej: \"s√≠\", \"ok\", \"perfecto\").\n- Si **disponibilidadConfirmada = false**: El horario no estaba disponible y se presentaron alternativas numeradas.\n\n### PASO 2: DETECCI√ìN CR√çTICA DE RETRACTACIONES\nAntes de analizar cualquier selecci√≥n, detecta si el usuario est√°:\n\n#### ‚úÖ COMPORTAMIENTO ESPERADO:\n- Confirmando la opci√≥n principal cuando disponibilidadConfirmada = true\n- Eligiendo una alternativa numerada cuando se presentaron opciones\n- Usando frases como: \"la 1\", \"opci√≥n 2\", \"la primera\", \"elijo la del 17 a las 7am\"\n\n#### ‚ùå RETRACTACI√ìN DETECTADA:\n- Usuario menciona fecha/hora diferente a las opciones presentadas\n- Usuario dice \"mejor el [otra fecha]\", \"cambio de opini√≥n\", \"prefiero el [otra fecha]\"\n- Usuario proporciona datos completamente nuevos (nuevo proveedor, nueva categor√≠a, etc.)\n- Usuario contradice las opciones que acaba de recibir del sistema\n\n### PASO 3: AN√ÅLISIS CONTEXTUAL\nRevisa el historial para detectar patrones de indecisi√≥n:\n- ¬øHa cambiado de fecha m√∫ltiples veces?\n- ¬øLas fechas mencionadas coinciden con las opciones presentadas?\n- ¬øEl mensaje actual es consistente con las alternativas ofrecidas?\n\n## FORMATO DE RESPUESTA\n\n### Para disponibilidadConfirmada = true (confirmaci√≥n directa):\n```json\n{\n  \"seleccionaAlternativa\": false,\n  \"indiceSeleccionado\": null,\n  \"esRetractacion\": false,\n  \"tipoRespuesta\": \"confirmacion_directa\",\n  \"datosSeleccionados\": null,\n  \"motivoRetractacion\": null\n}\n```\n\n### Para selecci√≥n v√°lida de alternativa:\n```json\n{\n  \"seleccionaAlternativa\": true,\n  \"indiceSeleccionado\": 2,\n  \"esRetractacion\": false,\n  \"tipoRespuesta\": \"seleccion_alternativa\",\n  \"datosSeleccionados\": {\n    \"fecha\": \"17 de julio de 2025\",\n    \"fechaFormateada\": \"2025-07-17\",\n    \"horaInicio\": \"09:00 AM\",\n    \"horaFin\": \"1:00 PM\",\n    \"muelle\": \"MUELLE 2\",\n    \"duracionHoras\": 4\n  },\n  \"motivoRetractacion\": null\n}\n```\n\n### Para retractaci√≥n detectada:\n```json\n{\n  \"seleccionaAlternativa\": false,\n  \"indiceSeleccionado\": null,\n  \"esRetractacion\": true,\n  \"tipoRespuesta\": \"retractacion\",\n  \"datosSeleccionados\": null,\n  \"motivoRetractacion\": \"Usuario mencion√≥ fecha diferente a las opciones presentadas\"\n}\n```\n\n### Para respuesta ambigua o no clara:\n```json\n{\n  \"seleccionaAlternativa\": false,\n  \"indiceSeleccionado\": null,\n  \"esRetractacion\": false,\n  \"tipoRespuesta\": \"respuesta_unclear\",\n  \"datosSeleccionados\": null,\n  \"motivoRetractacion\": null\n}\n```\n\n## REGLAS IMPORTANTES\n\n1. **Para calcular duracionHoras**: Extrae el tiempo en horas entre horaInicio y horaFin. Si no puedes calcularlo con precisi√≥n, usa 4 como valor predeterminado.\n\n2. **Para fechaFormateada**: Convierte siempre al formato \"YYYY-MM-DD\".\n\n3. **Para indiceSeleccionado**: Usa base 1 (la primera alternativa es 1, no 0).\n\n4. **Detecci√≥n de retractaci√≥n**: Si el usuario menciona fechas que NO est√°n en las alternativas presentadas, marca `esRetractacion: true`.\n\n5. **Campo motivoRetractacion**: Solo llenar cuando `esRetractacion: true`, explicar brevemente el motivo.\n\n6. **Prioridad de detecci√≥n**: \n   - Primero: ¬øEs retractaci√≥n?\n   - Segundo: ¬øEs confirmaci√≥n directa?\n   - Tercero: ¬øEs selecci√≥n de alternativa?\n\n## EJEMPLOS\n\n### Ejemplo 1 - Selecci√≥n v√°lida:\n**Alternativas presentadas**: 1) 17 de julio 9:00 AM, 2) 17 de julio 10:00 AM\n**Mensaje usuario**: \"elijo la 2\"\n**Respuesta**: \n```json\n{\n  \"seleccionaAlternativa\": true,\n  \"indiceSeleccionado\": 2,\n  \"esRetractacion\": false,\n  \"tipoRespuesta\": \"seleccion_alternativa\",\n  \"datosSeleccionados\": {...},\n  \"motivoRetractacion\": null\n}\n```\n\n### Ejemplo 2 - Retractaci√≥n:\n**Alternativas presentadas**: 1) 17 de julio 9:00 AM, 2) 17 de julio 10:00 AM  \n**Mensaje usuario**: \"mejor para el 18 de julio\"\n**Respuesta**: \n```json\n{\n  \"seleccionaAlternativa\": false,\n  \"indiceSeleccionado\": null,\n  \"esRetractacion\": true,\n  \"tipoRespuesta\": \"retractacion\",\n  \"datosSeleccionados\": null,\n  \"motivoRetractacion\": \"Usuario solicita fecha diferente (18 de julio) a las opciones presentadas\"\n}\n```\n\n### Ejemplo 3 - Confirmaci√≥n directa:\n**disponibilidadConfirmada**: true\n**Mensaje usuario**: \"perfecto, confirmo\"\n**Respuesta**: \n```json\n{\n  \"seleccionaAlternativa\": false,\n  \"indiceSeleccionado\": null,\n  \"esRetractacion\": false,\n  \"tipoRespuesta\": \"confirmacion_directa\",\n  \"datosSeleccionados\": null,\n  \"motivoRetractacion\": null\n}\n```\n\n## INSTRUCCIONES FINALES\n1. Analiza cuidadosamente el contexto antes de responder\n2. Prioriza la detecci√≥n de retractaciones para evitar loops de indecisi√≥n\n3. Solo devuelve el objeto JSON v√°lido, sin explicaciones adicionales\n4. Aseg√∫rate de incluir todos los campos requeridos en cada respuesta",
        "hasOutputParser": true
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        224,
        2928
      ],
      "id": "73925d8f-ea09-42fd-a458-ee5f0a5404da",
      "name": "Basic LLM Validar selecci√≥n alternativa"
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"seleccionaAlternativa\": {\n      \"type\": \"boolean\",\n      \"description\": \"Indica si el usuario seleccion√≥ una alternativa\"\n    },\n    \"indiceSeleccionado\": {\n      \"type\": [\"number\", \"null\"],\n      \"description\": \"√çndice de la alternativa seleccionada (1-basado) o null\"\n    },\n    \"esRetractacion\": {\n      \"type\": \"boolean\",\n      \"description\": \"Indica si el usuario est√° retract√°ndose o cambiando de opini√≥n\"\n    },\n    \"tipoRespuesta\": {\n      \"type\": \"string\",\n      \"description\": \"Tipo de respuesta del usuario\",\n      \"enum\": [\"confirmacion_directa\", \"seleccion_alternativa\", \"retractacion\", \"respuesta_unclear\"]\n    },\n    \"datosSeleccionados\": {\n      \"type\": [\"object\", \"null\"],\n      \"properties\": {\n        \"fecha\": {\n          \"type\": \"string\",\n          \"description\": \"Fecha en formato texto (dd de mes de yyyy)\"\n        },\n        \"fechaFormateada\": {\n          \"type\": \"string\",\n          \"description\": \"Fecha en formato ISO (YYYY-MM-DD)\"\n        },\n        \"horaInicio\": {\n          \"type\": \"string\",\n          \"description\": \"Hora de inicio de la cita\"\n        },\n        \"horaFin\": {\n          \"type\": \"string\",\n          \"description\": \"Hora de fin de la cita\"\n        },\n        \"muelle\": {\n          \"type\": \"string\",\n          \"description\": \"Identificador del muelle\"\n        },\n        \"duracionHoras\": {\n          \"type\": \"number\",\n          \"description\": \"Duraci√≥n de la cita en horas\"\n        }\n      },\n      \"description\": \"Datos de la alternativa seleccionada o null\"\n    },\n    \"motivoRetractacion\": {\n      \"type\": [\"string\", \"null\"],\n      \"description\": \"Descripci√≥n del motivo de la retractaci√≥n si aplica\"\n    }\n  },\n  \"required\": [\"seleccionaAlternativa\", \"indiceSeleccionado\", \"esRetractacion\", \"tipoRespuesta\", \"datosSeleccionados\"]\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.2,
      "position": [
        368,
        3152
      ],
      "id": "cff2f048-ebb1-49f5-871b-c51654107811",
      "name": "Structured Output Parser2"
    },
    {
      "parameters": {
        "jsCode": "// C√≥digo para preparar la actualizaci√≥n de Excel con citas\n// Este nodo SOLO prepara el formato para enviarlos a Microsoft Graph\n\n// Obtener datos de entrada: datos validados y datos de la cita\nconst datosValidados = $input.first().json.datosValidados;\nconst datosCita = $('Code Verificar Tiempo Transcurrido').first().json.respuesta.datosCita;\nconst datosMalla = $('Unificaci√≥n y consistencia de datos2').first().json.datosMalla;\n\n// Extraer la informaci√≥n relevante\nconst {\n  fecha,\n  fechaFormateada,\n  horaInicio,\n  horaFin,\n  muelle,\n  duracionHoras\n} = datosValidados;\n\nconst {\n  proveedor = \"\",\n  ordenCompra = \"\",\n  peso = \"\",\n  categoria = \"\",\n  unidades = \"\"\n} = datosCita;\n\n// Obtener el d√≠a de la semana a partir de la fecha\nfunction obtenerDiaSemana(fechaStr) {\n  // Extrae el d√≠a, mes y a√±o de la cadena\n  const regex = /(\\d+)\\s+de\\s+(\\w+)\\s+de\\s+(\\d+)/;\n  const match = regex.exec(fechaStr);\n  \n  if (!match) return null;\n  \n  const dia = parseInt(match[1], 10);\n  const mesStr = match[2].toLowerCase();\n  const a√±o = parseInt(match[3], 10);\n  \n  // Mapeo de nombres de meses a n√∫meros\n  const meses = {\n    \"enero\": 0,\n    \"febrero\": 1,\n    \"marzo\": 2,\n    \"abril\": 3,\n    \"mayo\": 4,\n    \"junio\": 5,\n    \"julio\": 6,\n    \"agosto\": 7,\n    \"septiembre\": 8,\n    \"octubre\": 9,\n    \"noviembre\": 10,\n    \"diciembre\": 11\n  };\n  \n  const mesNum = meses[mesStr];\n  \n  if (mesNum === undefined) return null;\n  \n  // Crear objeto Date\n  const fecha = new Date(a√±o, mesNum, dia);\n  \n  // Obtener d√≠a de la semana (0=domingo, 1=lunes, ..., 6=s√°bado)\n  const diaSemana = fecha.getDay();\n  \n  // Convertir a nombre en espa√±ol\n  const diasSemana = [\"domingo\", \"lunes\", \"martes\", \"mi√©rcoles\", \"jueves\", \"viernes\"];\n  \n  return diasSemana[diaSemana];\n}\n\n// Determinar el d√≠a de la semana\nconst diaSemana = obtenerDiaSemana(fecha);\n\n// Determinar el muelle (muelle1 o muelle2)\nconst muelleKey = muelle.toLowerCase().includes(\"1\") ? \"muelle1\" : \"muelle2\";\n\n// Mapeo correcto de columnas para cada d√≠a y muelle seg√∫n lo proporcionado\nconst mapeoColumnas = {\n  'lunes': {\n    'muelle1': 'C', \n    'muelle2': 'F' \n  },\n  'martes': {\n    'muelle1': 'I', \n    'muelle2': 'L'  \n  },\n  'mi√©rcoles': {\n    'muelle1': 'O', \n    'muelle2': 'R'  \n  },\n  'jueves': {\n    'muelle1': 'U', \n    'muelle2': 'X' \n  },\n  'viernes': {\n    'muelle1': 'AA', \n    'muelle2': 'AD'  \n  }\n};\n\n// Verificar si tenemos mapeo para este d√≠a\nif (!mapeoColumnas[diaSemana]) {\n  console.log(`D√≠a no soportado: ${diaSemana}`);\n  return {\n    json: {\n      success: false,\n      mensaje: `D√≠a no soportado: ${diaSemana}`,\n      error: \"DIA_NO_SOPORTADO\"\n    }\n  };\n}\n\n// Obtener la columna base para el d√≠a y muelle espec√≠ficos\nconst columnaBase = mapeoColumnas[diaSemana][muelleKey];\nif (!columnaBase) {\n  console.log(`Configuraci√≥n no soportada: d√≠a=${diaSemana}, muelle=${muelleKey}`);\n  return {\n    json: {\n      success: false,\n      mensaje: `Configuraci√≥n no soportada: d√≠a=${diaSemana}, muelle=${muelleKey}`,\n      error: \"CONFIGURACION_NO_SOPORTADA\"\n    }\n  };\n}\n\n// Calcular la siguiente columna en Excel\nfunction siguienteColumna(columna) {\n  if (columna.length === 1) {\n    // Para columnas de una letra (A-Z)\n    return String.fromCharCode(columna.charCodeAt(0) + 1);\n  } else {\n    // Para columnas de dos letras (AA-ZZ)\n    const primerChar = columna.charAt(0);\n    const segundoChar = columna.charAt(1);\n    \n    if (segundoChar === 'Z') {\n      // Si es 'Z', pasar a la siguiente letra para el primer car√°cter\n      return String.fromCharCode(primerChar.charCodeAt(0) + 1) + 'A';\n    } else {\n      // Incrementar solo el segundo car√°cter\n      return primerChar + String.fromCharCode(segundoChar.charCodeAt(0) + 1);\n    }\n  }\n}\n\n// Funci√≥n para comparar horas de forma flexible\nfunction horasIguales(h1, h2) {\n  const normalizar = (h) =>\n    h\n      .toString()\n      .trim()\n      .toLowerCase()\n      .replace(/\\./g, '')            // quita puntos (por si viene \"a.m.\")\n      .replace(/\\s+/g, '')           // quita espacios\n      .replace(/^0+/, '');           // quita ceros a la izquierda\n  return normalizar(h1) === normalizar(h2);\n}\n\n// Ordenar franjas por hora\nfunction obtenerFranjasOrdenadas(franjas) {\n  return [...franjas].sort((a, b) => {\n    // Convertir horas a formato comparable (n√∫mero de minutos desde medianoche)\n    function horaAMinutos(hora) {\n      const match = hora.match(/(\\d+):(\\d+)\\s*([AP]M)/i);\n      if (!match) return 0;\n      \n      let horas = parseInt(match[1], 10);\n      const minutos = parseInt(match[2], 10);\n      const periodo = match[3].toUpperCase();\n      \n      // Convertir a formato 24 horas\n      if (periodo === 'PM' && horas !== 12) {\n        horas += 12;\n      } else if (periodo === 'AM' && horas === 12) {\n        horas = 0;\n      }\n      \n      return horas * 60 + minutos;\n    }\n    \n    return horaAMinutos(a.hora) - horaAMinutos(b.hora);\n  });\n}\n\n// Obtener la posici√≥n de la franja en el array ordenado\nfunction obtenerPosicionFranja(hora, franjas) {\n  const franjasOrdenadas = obtenerFranjasOrdenadas(franjas);\n  return franjasOrdenadas.findIndex(f => horasIguales(f.hora, hora));\n}\n\n// Funci√≥n corregida para calcular la fila Excel basada en la posici√≥n de la franja\nfunction calcularFilaExcel(hora, franjas) {\n  const posicion = obtenerPosicionFranja(hora, franjas);\n  \n  if (posicion === -1) {\n    console.log(`No se encontr√≥ la posici√≥n para la hora ${hora}`);\n    return null;\n  }\n  \n  // Mapeo de posiciones a filas base en Excel\n  // Basado en las observaciones del Excel:\n  const FILA_PRIMERA_FRANJA = 12;  // 6:00 AM\n  const INCREMENTO_ESTANDAR = 3;   // Incremento est√°ndar entre franjas\n  \n  // Caso especial para 9:00 AM\n  if (posicion === 3) {\n    return 21;  // Fila exacta para 9:00 AM\n  } else if (posicion === 4) {\n    return 24;  // Fila exacta para 10:00 AM\n  } else if (posicion === 5) {\n    return 27;  // Fila exacta para 11:00 AM\n  } else if (posicion < 3) {\n    // Para posiciones antes de 9:00 AM, usamos el incremento est√°ndar\n    return FILA_PRIMERA_FRANJA + (posicion * INCREMENTO_ESTANDAR);\n  } else {\n    // Para posiciones despu√©s de 11:00 AM, calculamos a partir de 11:00 AM\n    return 27 + ((posicion - 5) * INCREMENTO_ESTANDAR);\n  }\n}\n\n// Funci√≥n para encontrar la franja horaria siguiente\nfunction encontrarSiguienteFranja(horaActual, franjas) {\n  const franjasOrdenadas = obtenerFranjasOrdenadas(franjas);\n  const posicionActual = franjasOrdenadas.findIndex(f => horasIguales(f.hora, horaActual));\n  \n  if (posicionActual === -1 || posicionActual >= franjasOrdenadas.length - 1) {\n    return null; // No hay siguiente franja\n  }\n  \n  return franjasOrdenadas[posicionActual + 1];\n}\n\n// Encontrar informaci√≥n de la franja horaria inicial en los datos de la malla\nconst franjaInicio = datosMalla.franjas.find(f => horasIguales(f.hora, horaInicio));\nif (!franjaInicio) {\n  console.log(`No se encontr√≥ la franja de inicio: ${horaInicio}`);\n  return {\n    json: {\n      success: false,\n      mensaje: `No se encontr√≥ la franja de inicio: ${horaInicio}`,\n      error: \"FRANJA_NO_ENCONTRADA\"\n    }\n  };\n}\n\n// Array para almacenar todas las actualizaciones\nlet todasLasActualizaciones = [];\n\n// Procesar cada hora de la cita (seg√∫n duracionHoras)\nlet horaActual = horaInicio;\nlet horasRestantes = duracionHoras;\n\nwhile (horasRestantes > 0) {\n  // Encontrar la franja actual\n  const franjaActual = datosMalla.franjas.find(f => horasIguales(f.hora, horaActual));\n  \n  if (!franjaActual) {\n    console.log(`No se encontr√≥ informaci√≥n para la franja: ${horaActual}`);\n    break;\n  }\n  \n  // Calcular la fila base de forma din√°mica\n  const filaBase = calcularFilaExcel(horaActual, datosMalla.franjas);\n  \n  if (!filaBase) {\n    console.log(`No se pudo determinar la fila para la franja: ${horaActual}`);\n    break;\n  }\n  \n  console.log(`Calculando celdas para: ${horaActual}, fila base: ${filaBase}`);\n  \n  const columnaLineas = siguienteColumna(columnaBase);\n  const columnaUnd = siguienteColumna(columnaLineas);\n  \n  // Calcular las celdas para esta franja\n  const rangoCeldas = {\n    proveedor: `${columnaBase}${filaBase}`,\n    ordenCompra: `${columnaBase}${filaBase + 1}`,\n    peso: `${columnaBase}${filaBase + 2}`,\n    categoria: `${columnaLineas}${filaBase + 2}`,\n    unidades: `${columnaUnd}${filaBase + 2}`\n  };\n  \n  console.log(`Celdas para ${horaActual}, ${diaSemana}, ${muelleKey}:`, JSON.stringify(rangoCeldas));\n  \n  // Agregar actualizaciones para esta franja horaria\n  todasLasActualizaciones.push(\n    {\n      celda: rangoCeldas.proveedor,\n      valor: proveedor\n    },\n    {\n      celda: rangoCeldas.ordenCompra,\n      valor: ordenCompra\n    },\n    {\n      celda: rangoCeldas.peso,\n      valor: peso\n    },\n    {\n      celda: rangoCeldas.categoria,\n      valor: categoria\n    },\n    {\n      celda: rangoCeldas.unidades,\n      valor: unidades\n    }\n  );\n  \n  // Preparar para la siguiente hora\n  horasRestantes--;\n  \n  if (horasRestantes > 0) {\n    const siguienteFranja = encontrarSiguienteFranja(horaActual, datosMalla.franjas);\n    \n    if (siguienteFranja) {\n      horaActual = siguienteFranja.hora;\n    } else {\n      console.log(`No se encontr√≥ la siguiente franja horaria despu√©s de ${horaActual}`);\n      break;\n    }\n  }\n}\n\n// Preparar el formato final para la petici√≥n a Microsoft Graph\nconst actualizacionesGraph = todasLasActualizaciones.map(act => ({\n  address: act.celda,\n  values: [[act.valor]]\n}));\n\n// Usar el nombre correcto de la hoja desde datosMalla\nconst nombreHojaExcel = $('Code VALIDACI√ìN DE CITA EN CRONOGRAMA').first().json.nombreHoja;\n\n// Preparar el resultado para el siguiente nodo\nreturn {\n  json: {\n    success: true,\n    mensaje: `Preparadas ${todasLasActualizaciones.length} actualizaciones para la cita del ${fecha} de ${horaInicio} a ${horaFin} en ${muelle} (${duracionHoras} horas)`,\n    nombreHoja: nombreHojaExcel,\n    // Datos para Microsoft Graph API\n    graphRequestData: {\n      updates: actualizacionesGraph\n    },\n    // Informaci√≥n m√°s detallada para debugging o uso interno\n    detalles: {\n      actualizacionesDetalladas: todasLasActualizaciones,\n      diaSemana,\n      informacionCita: {\n        fecha,\n        horaInicio,\n        horaFin,\n        muelle,\n        proveedor,\n        ordenCompra,\n        peso,\n        categoria,\n        unidades,\n        duracionHoras\n      }\n    }\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1344,
        2592
      ],
      "id": "9c34efcd-985f-461b-bffe-818b932f6947",
      "name": "Code (Preparar Cuerpo de Petici√≥n)"
    },
    {
      "parameters": {
        "jsCode": "// C√≥digo modificado para \"Code Agrupar Franjas\"\n// Ahora devuelve los valores individuales en lugar de franjas agrupadas\n// pero conservando la informaci√≥n de indice, nombreHoja e informacionCita\nconst input = $input.first().json;\n\n// Verificar que tenemos la estructura esperada\nif (!input || !input.graphRequestData || !input.graphRequestData.updates) {\n  console.log('Estructura de datos de entrada no v√°lida');\n  return {\n    json: {\n      error: \"FORMATO_INVALIDO\",\n      mensaje: \"La estructura de datos de entrada no es v√°lida\"\n    }\n  };\n}\n\nconst updates = input.graphRequestData.updates;\nconst UPDATES_PER_FRANJA = 5;\nconst numFranjas = Math.ceil(updates.length / UPDATES_PER_FRANJA);\nconst resultados = [];\n\n// Primero, creamos todas las franjas como en el c√≥digo original\nconst franjas = [];\nfor (let i = 0; i < numFranjas; i++) {\n  const inicio = i * UPDATES_PER_FRANJA;\n  const fin = Math.min(inicio + UPDATES_PER_FRANJA, updates.length);\n  \n  // Obtener las actualizaciones de esta franja\n  const actualizacionesFranja = updates.slice(inicio, fin);\n  \n  franjas.push({\n    indice: i + 1,\n    nombreHoja: input.nombreHoja,\n    updates: actualizacionesFranja,\n    informacionCita: input.detalles?.informacionCita\n  });\n}\n\n// Ahora, recorremos cada franja y extraemos los valores individuales\n// pero conservando la informaci√≥n adicional\nfranjas.forEach(franja => {\n  franja.updates.forEach(update => {\n    if (update.values && update.values.length > 0 && update.values[0].length > 0) {\n      const valor = update.values[0][0];\n      \n      // Creamos un objeto que contiene el valor y la informaci√≥n adicional\n      resultados.push({\n        json: {\n          valor: valor,\n          indice: franja.indice,\n          nombreHoja: franja.nombreHoja,\n          address: update.address,\n          informacionCita: franja.informacionCita\n        }\n      });\n    }\n  });\n});\n\nconsole.log(`Se extrajeron ${resultados.length} valores individuales para inserci√≥n en orden`);\nreturn resultados;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1552,
        2592
      ],
      "id": "b44c0ef2-e6f8-4a3a-bf56-73842b77883a",
      "name": "Code Agrupar Franjas"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        1840,
        2592
      ],
      "id": "5ba55d1f-4129-4ce8-982f-6ae96db33299",
      "name": "Loop Over Uno a Uno"
    },
    {
      "parameters": {
        "jsCode": "// C√≥digo para preparar cada inserci√≥n para Microsoft Graph API mediante $batch\n// Basado en el flujo de trabajo original y adaptado para procesar elementos individuales\nconst input = $input.first().json;\n\n// Constantes para los IDs de SharePoint/OneDrive\nconst siteId = \"gexpresscargo.sharepoint.com,a592f886-4560-4e62-9646-1eee7add7abe,8b514073-41ae-4619-8f76-724bd912bc65\";\nconst driveId = \"b!hviSpWBFYk6WRh7uet16vnNAUYuuQRlGj3ZyS9kSvGVZ4DSg6c5MRqYYm2MdAER8\";\nconst itemId = \"01PPLUUYXY5E2GK3SJ25EZLJPUYJ43H3ME\";\n\n// Verificar que tenemos la estructura esperada\nif (!input || input.valor === undefined || !input.address || !input.nombreHoja) {\n  console.log('Estructura de datos de entrada no v√°lida para la inserci√≥n');\n  return {\n    json: {\n      error: \"FORMATO_INVALIDO\",\n      mensaje: \"La estructura de datos de entrada no es v√°lida para la inserci√≥n\"\n    }\n  };\n}\n\n// Preparar el valor para la actualizaci√≥n seg√∫n su tipo\nlet valorFormateado;\nif (typeof input.valor === 'number') {\n  valorFormateado = [[input.valor]]; // Para n√∫meros mantenemos el tipo\n} else {\n  valorFormateado = [[input.valor.toString()]]; // Para otros tipos convertimos a string\n}\n\n// Generar un ID √∫nico para esta solicitud\nconst requestId = `${input.address}_${input.indice}_${Date.now()}`;\n\n// Crear la estructura de solicitud para Microsoft Graph $batch\nconst requestBody = {\n  requests: [\n    {\n      id: requestId,\n      method: \"PATCH\",\n      url: `/sites/${siteId}/drives/${driveId}/items/${itemId}/workbook/worksheets/${encodeURIComponent(input.nombreHoja)}/range(address='${input.address}')`,\n      body: {\n        values: valorFormateado\n      },\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    }\n  ],\n  _metadata: {\n    celda: input.address,\n    valor: input.valor,\n    indice: input.indice,\n    informacionCita: input.informacionCita || {}\n  }\n};\n\nconsole.log(`Preparada solicitud ${requestId} para insertar valor \"${input.valor}\" en la celda ${input.address} de la hoja \"${input.nombreHoja}\"`);\n\n// Retornar el objeto request listo para ser enviado a Microsoft Graph $batch\nreturn {\n  json: requestBody\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2112,
        2688
      ],
      "id": "d167aacb-1e73-4ce4-98a1-7fcc0e2c54d5",
      "name": "Code Preparar cada Insercion"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://graph.microsoft.com/v1.0/$batch",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "microsoftOAuth2Api",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        2368,
        2688
      ],
      "id": "8ac4fbfe-f4b0-405a-b5ec-b7902d883c6f",
      "name": "HTTP Request Actualizar Excel1",
      "credentials": {
        "microsoftOAuth2Api": {
          "id": "mh8Z8hxFvd7LDO8D",
          "name": "CuentaMy SharePoint App Desarrollador1 Konfie "
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// C√≥digo para verificar si la inserci√≥n fue exitosa (sin acciones correctivas)\nconst input = $input.first().json;\n\n// Verificar que tenemos la estructura esperada en la respuesta\nif (!input || !input.responses || !Array.isArray(input.responses) || input.responses.length === 0) {\n  console.log('Estructura de datos de respuesta no v√°lida');\n  return {\n    json: {\n      error: \"RESPUESTA_INVALIDA\",\n      mensaje: \"La estructura de datos de la respuesta no es v√°lida\",\n      exito: false\n    }\n  };\n}\n\n// Obtener la primera respuesta\nconst response = input.responses[0];\n\n// Extraer informaci√≥n de la solicitud original del ID\n// El formato del ID es: \"CELDA_INDICE_TIMESTAMP\"\nconst idPartes = response.id.split('_');\nconst celdaOriginal = idPartes[0];\nconst indice = idPartes[1];\n\n// Verificar que la respuesta tiene un cuerpo\nif (!response.body || !response.body.address) {\n  console.log(`Error: La respuesta no contiene informaci√≥n sobre la direcci√≥n de celda`);\n  return {\n    json: {\n      error: \"RESPUESTA_SIN_DIRECCION\",\n      mensaje: \"La respuesta no incluye informaci√≥n sobre la direcci√≥n de celda\",\n      requestId: response.id,\n      status: response.status,\n      celdaOriginal: celdaOriginal,\n      exito: false\n    }\n  };\n}\n\n// Extraer la direcci√≥n de celda de la respuesta\nlet direccionRespuesta = \"\";\nif (response.body && response.body.address) {\n  const partesDireccion = response.body.address.split('!');\n  if (partesDireccion.length > 1) {\n    direccionRespuesta = partesDireccion[1];\n  }\n}\n\n// Obtener el valor insertado de la respuesta\nconst valorInsertado = response.body.values && response.body.values[0] && response.body.values[0][0];\n\n// Verificar si la inserci√≥n se realiz√≥ en la celda correcta\nconst insercionCorrecta = direccionRespuesta === celdaOriginal;\n\n// Verificar el c√≥digo de estado HTTP\nconst estadoExitoso = response.status >= 200 && response.status < 300;\n\n// Crear objeto para almacenar el resultado de la verificaci√≥n\nconst resultado = {\n  exito: insercionCorrecta && estadoExitoso,\n  celdaOriginal: celdaOriginal,\n  celdaInsertada: direccionRespuesta,\n  valorInsertado: valorInsertado,\n  statusCode: response.status,\n  requestId: response.id,\n  indice: indice,\n  celdasDiferentes: !insercionCorrecta && estadoExitoso,\n  falloEstado: !estadoExitoso\n};\n\nconst chatId = $('Organiza el Mensaje').first().json.infoMensaje.chat_id;\n\nif (!insercionCorrecta || !estadoExitoso) {\n  console.log(`Error en inserci√≥n: celda original=${celdaOriginal}, celda insertada=${direccionRespuesta}, status=${response.status}`);\n} else {\n  console.log(`Inserci√≥n correcta en celda ${celdaOriginal} con valor \"${valorInsertado}\"`);\n}\n\n// Incluir la respuesta original para tener toda la informaci√≥n\nresultado.respuestaOriginal = response;\n\n// Retornar el resultado de la verificaci√≥n\nreturn {\n  json: resultado, \n  chat_id: chatId\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2592,
        2688
      ],
      "id": "4a397c2c-e8ff-45ea-9b69-f0477f4db531",
      "name": "Code Verificar Inserci√≥n"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "fb1eda05-eb5e-4683-8556-1cf2b5b8e4d5",
              "leftValue": "={{ $json.exito }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        2832,
        2752
      ],
      "id": "bb7749d5-c0cf-40a2-9350-fe2c2cd2f31b",
      "name": "If Verificar Inserci√≥n"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "15a95144-dd82-4ea5-b9ba-9eb924d2ae5c",
              "leftValue": "={{ $json.celdasDiferentes }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        3040,
        2832
      ],
      "id": "18e93177-70d0-4632-95d7-5871176b4eb9",
      "name": "If Diferente Caso"
    },
    {
      "parameters": {
        "jsCode": "// C√≥digo para limpiar una celda donde se insert√≥ incorrectamente un valor\nconst input = $input.first().json;\n\n// Constantes para los IDs de SharePoint/OneDrive\nconst siteId = \"gexpresscargo.sharepoint.com,a592f886-4560-4e62-9646-1eee7add7abe,8b514073-41ae-4619-8f76-724bd912bc65\";\nconst driveId = \"b!hviSpWBFYk6WRh7uet16vnNAUYuuQRlGj3ZyS9kSvGVZ4DSg6c5MRqYYm2MdAER8\";\nconst itemId = \"01PPLUUYXY5E2GK3SJ25EZLJPUYJ43H3ME\";\n\n// Verificar que tenemos la informaci√≥n necesaria\nif (!input || !input.celdaInsertada || !input.respuestaOriginal) {\n  console.log('Informaci√≥n insuficiente para limpiar la celda incorrecta');\n  return {\n    json: {\n      error: \"INFORMACION_INSUFICIENTE\",\n      mensaje: \"No hay suficiente informaci√≥n para limpiar la celda incorrecta\"\n    }\n  };\n}\n\n// Obtener la celda a limpiar y la informaci√≥n de la hoja\nconst celdaALimpiar = input.celdaInsertada;\nlet hojaExcel = input.nombreHoja || \"\"; // Usar el nombreHoja del input\n\n// Intentar extraer el nombre de la hoja de la direcci√≥n en la respuesta si no est√° disponible\nif ((!hojaExcel || hojaExcel === \"\") && input.respuestaOriginal.body && input.respuestaOriginal.body.address) {\n  const direccionCompleta = input.respuestaOriginal.body.address;\n  hojaExcel = direccionCompleta.split('!')[0].replace(/'/g, '');\n}\n\nconsole.log(`Limpiando celda incorrecta ${celdaALimpiar} en hoja ${hojaExcel}`);\n\n// Crear la solicitud para limpiar la celda\nconst requestBody = {\n  requests: [\n    {\n      id: `Limpiar_${celdaALimpiar}_${Date.now()}`,\n      method: \"PATCH\",\n      url: `/sites/${siteId}/drives/${driveId}/items/${itemId}/workbook/worksheets/${encodeURIComponent(hojaExcel)}/range(address='${celdaALimpiar}')`,\n      body: {\n        values: [[\"\"]] // Valor vac√≠o para limpiar la celda\n      },\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    }\n  ],\n  _metadata: {\n    accion: \"limpiar\",\n    celda: celdaALimpiar,\n    hoja: hojaExcel,\n    datoOriginal: input\n  }\n};\n\n// Retornar el request para limpiar la celda\nreturn {\n  json: requestBody\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3344,
        2640
      ],
      "id": "187fb975-f471-4de9-a23f-d9d8a657e32a",
      "name": "Code Limpiar Celda Incorrecta",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://graph.microsoft.com/v1.0/$batch",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "microsoftOAuth2Api",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        3568,
        2640
      ],
      "id": "7d2a80d0-fe7d-4ccf-a27a-b7ceb03ed931",
      "name": "HTTP Request Limpiar Celda",
      "credentials": {
        "microsoftOAuth2Api": {
          "id": "mh8Z8hxFvd7LDO8D",
          "name": "CuentaMy SharePoint App Desarrollador1 Konfie "
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "e570827e-13d0-4d6f-b23e-184ca2d3368c",
              "leftValue": "={{ $json.falloEstado }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        3504,
        3024
      ],
      "id": "a5bd8cf0-c9b1-4930-8dfc-c550d356662b",
      "name": "If fallo Estado"
    },
    {
      "parameters": {
        "jsCode": "// C√≥digo para reintentar la inserci√≥n en la celda correcta\nconst input = $input.first().json;\n\n// Constantes para los IDs de SharePoint/OneDrive\nconst siteId = \"gexpresscargo.sharepoint.com,a592f886-4560-4e62-9646-1eee7add7abe,8b514073-41ae-4619-8f76-724bd912bc65\";\nconst driveId = \"b!hviSpWBFYk6WRh7uet16vnNAUYuuQRlGj3ZyS9kSvGVZ4DSg6c5MRqYYm2MdAER8\";\nconst itemId = \"01PPLUUYXY5E2GK3SJ25EZLJPUYJ43H3ME\";\n\n// Si el input viene del nodo anterior de limpiar celda, extraer el dato original\nconst datoOriginal = input._metadata?.datoOriginal || input;\n\n// Verificar que tenemos la informaci√≥n necesaria\nif (!datoOriginal || !datoOriginal.celdaOriginal) {\n  console.log('Informaci√≥n insuficiente para reintentar la inserci√≥n');\n  return {\n    json: {\n      error: \"INFORMACION_INSUFICIENTE\",\n      mensaje: \"No hay suficiente informaci√≥n para reintentar la inserci√≥n\"\n    }\n  };\n}\n\n// Obtener la celda correcta donde insertar y el valor a insertar\nconst celdaCorrecta = datoOriginal.celdaOriginal;\n\n// Intentar obtener el valor correcto a insertar\nlet valorAInsertar;\n\n// Primero, verificar si tenemos el valor de la respuesta original\nif (datoOriginal.valorInsertado !== undefined) {\n  valorAInsertar = datoOriginal.valorInsertado;\n} \n// Si no, intentar obtenerlo del body de la respuesta\nelse if (datoOriginal.respuestaOriginal?.body?.values?.[0]?.[0] !== undefined) {\n  valorAInsertar = datoOriginal.respuestaOriginal.body.values[0][0];\n} \n// Como √∫ltimo recurso, usar un valor vac√≠o\nelse {\n  valorAInsertar = \"\";\n  console.log('No se pudo determinar el valor a insertar, usando valor vac√≠o');\n}\n\n// Determinar el tipo de valor y formatearlo adecuadamente\nlet valorFormateado;\nif (typeof valorAInsertar === 'number') {\n  valorFormateado = [[valorAInsertar]]; // Mantener el tipo num√©rico\n} else {\n  valorFormateado = [[valorAInsertar.toString()]]; // Convertir a string para otros tipos\n}\n\n// Obtener la hoja de Excel - primero del dato original\nlet hojaExcel = datoOriginal.nombreHoja || \"\"; \n\n// Si no est√° disponible en el objeto principal, intentar obtenerlo de otros lugares\nif (!hojaExcel || hojaExcel === \"\") {\n  // Verificar si est√° en el _metadata\n  hojaExcel = input._metadata?.hoja || \"\";\n  \n  // Como √∫ltimo recurso, extraer de la direcci√≥n en la respuesta\n  if ((!hojaExcel || hojaExcel === \"\") && datoOriginal.respuestaOriginal?.body?.address) {\n    const direccionCompleta = datoOriginal.respuestaOriginal.body.address;\n    hojaExcel = direccionCompleta.split('!')[0].replace(/'/g, '');\n  }\n}\n\nconsole.log(`Reintentando inserci√≥n en celda ${celdaCorrecta} de la hoja ${hojaExcel} con valor \"${valorAInsertar}\"`);\n\n// Crear la solicitud para reintentar la inserci√≥n\nconst requestBody = {\n  requests: [\n    {\n      id: `Reintento_${celdaCorrecta}_${Date.now()}`,\n      method: \"PATCH\",\n      url: `/sites/${siteId}/drives/${driveId}/items/${itemId}/workbook/worksheets/${encodeURIComponent(hojaExcel)}/range(address='${celdaCorrecta}')`,\n      body: {\n        values: valorFormateado\n      },\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    }\n  ],\n  _metadata: {\n    accion: \"reintentar\",\n    celda: celdaCorrecta,\n    hoja: hojaExcel,\n    valor: valorAInsertar,\n    datoOriginal: datoOriginal,\n    intentos: (datoOriginal._metadata?.intentos || 0) + 1\n  }\n};\n\n// Retornar el request para reintentar la inserci√≥n\nreturn {\n  json: requestBody\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3840,
        2704
      ],
      "id": "f5b7872c-f7e0-486b-b651-09d002e71888",
      "name": "Code Reintentar Inserci√≥n",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://graph.microsoft.com/v1.0/$batch",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "microsoftOAuth2Api",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        4080,
        2832
      ],
      "id": "433ccf3b-c920-46e3-8d0b-da0c2ce80d71",
      "name": "HTTP Request Reintentar Inserci√≥n",
      "credentials": {
        "microsoftOAuth2Api": {
          "id": "mh8Z8hxFvd7LDO8D",
          "name": "CuentaMy SharePoint App Desarrollador1 Konfie "
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// C√≥digo para verificar si la inserci√≥n fue exitosa (sin acciones correctivas)\nconst input = $input.first().json;\n\n// Verificar que tenemos la estructura esperada en la respuesta\nif (!input || !input.responses || !Array.isArray(input.responses) || input.responses.length === 0) {\n  console.log('Estructura de datos de respuesta no v√°lida');\n  return {\n    json: {\n      error: \"RESPUESTA_INVALIDA\",\n      mensaje: \"La estructura de datos de la respuesta no es v√°lida\",\n      exito: false\n    }\n  };\n}\n\n// Obtener la primera respuesta\nconst response = input.responses[0];\n\n// Extraer informaci√≥n de la solicitud original del ID\n// El formato del ID es: \"CELDA_INDICE_TIMESTAMP\"\nconst idPartes = response.id.split('_');\nconst celdaOriginal = idPartes[0];\nconst indice = idPartes[1];\n\n// Verificar que la respuesta tiene un cuerpo\nif (!response.body || !response.body.address) {\n  console.log(`Error: La respuesta no contiene informaci√≥n sobre la direcci√≥n de celda`);\n  return {\n    json: {\n      error: \"RESPUESTA_SIN_DIRECCION\",\n      mensaje: \"La respuesta no incluye informaci√≥n sobre la direcci√≥n de celda\",\n      requestId: response.id,\n      status: response.status,\n      celdaOriginal: celdaOriginal,\n      exito: false\n    }\n  };\n}\n\n// Extraer la direcci√≥n de celda de la respuesta\nlet direccionRespuesta = \"\";\nif (response.body && response.body.address) {\n  const partesDireccion = response.body.address.split('!');\n  if (partesDireccion.length > 1) {\n    direccionRespuesta = partesDireccion[1];\n  }\n}\n\n// Obtener el valor insertado de la respuesta\nconst valorInsertado = response.body.values && response.body.values[0] && response.body.values[0][0];\n\n// Verificar si la inserci√≥n se realiz√≥ en la celda correcta\nconst insercionCorrecta = direccionRespuesta === celdaOriginal;\n\n// Verificar el c√≥digo de estado HTTP\nconst estadoExitoso = response.status >= 200 && response.status < 300;\n\n// Crear objeto para almacenar el resultado de la verificaci√≥n\nconst resultado = {\n  exito: insercionCorrecta && estadoExitoso,\n  celdaOriginal: celdaOriginal,\n  celdaInsertada: direccionRespuesta,\n  valorInsertado: valorInsertado,\n  statusCode: response.status,\n  requestId: response.id,\n  indice: indice,\n  celdasDiferentes: !insercionCorrecta && estadoExitoso,\n  falloEstado: !estadoExitoso\n};\n\nif (!insercionCorrecta || !estadoExitoso) {\n  console.log(`Error en inserci√≥n: celda original=${celdaOriginal}, celda insertada=${direccionRespuesta}, status=${response.status}`);\n} else {\n  console.log(`Inserci√≥n correcta en celda ${celdaOriginal} con valor \"${valorInsertado}\"`);\n}\n\n// Incluir la respuesta original para tener toda la informaci√≥n\nresultado.respuestaOriginal = response;\n\n// Retornar el resultado de la verificaci√≥n\nreturn {\n  json: resultado\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4304,
        2832
      ],
      "id": "fea0acb4-eadd-4f2c-a632-ddd282e8c652",
      "name": "Code Volver a validar Inserci√≥n",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "f7205e4e-147c-4e77-8fa8-08d082980b48",
              "leftValue": "={{ $json.exito }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        4528,
        2832
      ],
      "id": "cee901b9-bb1b-4566-a8d0-00c730b156b7",
      "name": "If Verificar Inserci√≥n 2"
    },
    {
      "parameters": {
        "amount": 3
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        3424,
        2832
      ],
      "id": "3bd67a78-1bb7-429a-a11c-d69e3233b4b2",
      "name": "Wait2",
      "webhookId": "a4bbf2b1-ea0c-4b02-af2c-64b29f2bdb5c"
    },
    {
      "parameters": {
        "amount": 3
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        4832,
        3008
      ],
      "id": "f13143cc-54ab-4c1b-8415-0e8a3d12949a",
      "name": "Wait3",
      "webhookId": "9d944db7-9c4f-439e-9990-d9937f2fb18e"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        5264,
        3360
      ],
      "id": "d29804c3-c5eb-4fd0-94f3-1ea92aa0b7e8",
      "name": "OpenAI Chat Model12",
      "credentials": {
        "openAiApi": {
          "id": "AD8kPcNVReuclASd",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "=define",
        "text": "=Eres un asistente de un sistema de agendamiento de citas para la entrega de mercanc√≠a en bodega. Debes notificar al cliente que ha ocurrido un error en el sistema durante el proceso de inserci√≥n de la cita en el sistema de Excel.\n\nGenera un mensaje directo (sin saludos iniciales ni mencionar nombres) que:\n\n1. Comunique claramente que se produjo un error t√©cnico al intentar registrar la cita en el sistema.\n\n2. Indique que es urgente que se comunique con el √°rea de bodega en los pr√≥ximos 5 minutos para que puedan agendar la cita manualmente.\n\n4. Mencione que, de no establecer contacto en ese tiempo, existe el riesgo de perder la franja horaria seleccionada debido a la alta demanda de los muelles.\n\n5. Aclare que esta situaci√≥n es poco com√∫n y se debe a un inconveniente t√©cnico en el sistema de agendamiento.\n\n6. Pida disculpas por los inconvenientes ocasionados y agradezca la comprensi√≥n.\n\nTono: urgente pero profesional, enfatizando la importancia de la acci√≥n inmediata para mantener la franja horaria seleccionada.\n"
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        5344,
        3152
      ],
      "id": "d993680f-680d-4c63-b9ca-fb64fd686c1b",
      "name": "Basic LLM Notificar No Disponibilidad2",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "4bfbecb3-9d4f-4425-aa76-a92abc7708fb",
              "leftValue": "={{ $('Basic LLM Notificar No Disponibilidad2').item.json.text.length }}",
              "rightValue": 70,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        5744,
        3328
      ],
      "id": "87d4330e-e806-49b2-b48d-54930e03f033",
      "name": "Validaci√≥n de longitud de caracteres6"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d9c2ff70-4fd1-4b93-8571-6d0ac5a0093e",
              "name": "mensaje.ia",
              "value": "={{ $('Basic LLM Notificar No Disponibilidad2').item.json.text }}",
              "type": "string"
            },
            {
              "id": "ac8a03be-0292-4735-9580-39a385945c47",
              "name": "mensaje.longitud",
              "value": "={{ $('Basic LLM Notificar No Disponibilidad2').item.json.text.length }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        6048,
        3344
      ],
      "id": "4d8acd7f-465a-4ae5-99c8-f98bb9981f20",
      "name": "Organiza variables del mensaje6"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        6224,
        3120
      ],
      "id": "2fe744a4-6a14-4ff4-aa2c-9b77a19acc17",
      "name": "No Operation, do nothing8"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $('Code Respuesta Faltantes').item.json.text }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        6048,
        3120
      ],
      "id": "f88bb707-1579-44b3-9173-55e8d8c6328d",
      "name": "HTTP Request Enviar Mensaje por WhatsApp9"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        368,
        1680
      ],
      "id": "42205aea-c40a-46ff-8058-d8c019ac79b6",
      "name": "OpenAI Chat Model",
      "credentials": {
        "openAiApi": {
          "id": "AD8kPcNVReuclASd",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "=define",
        "text": "=# Extracci√≥n de informaci√≥n para citas de log√≠stica\n\nAnaliza TODOS los mensajes de la conversaci√≥n (tanto el mensaje actual como el historial completo) para extraer la informaci√≥n necesaria para agendar una cita de log√≠stica. \n\n## Contexto \nLos usuarios pueden proporcionar informaci√≥n de forma parcial a lo largo de varios mensajes. Tu tarea es acumular y consolidar toda esta informaci√≥n. Debes extraer cualquier dato relevante sin importar en qu√© mensaje aparezca (actual o hist√≥rico).\n\n## Campos a extraer\n- Nombre del proveedor\n- Fecha de entrega (formato: DD de MMMM de YYYY)\n- Hora de entrega (formato: HH:MM AM/PM)\n- Categor√≠a del material\n- Peso en kilos (n√∫mero entero)\n- N√∫mero de unidades (n√∫mero entero)\n- N√∫mero de orden de compra\n\n## Fuentes de informaci√≥n\n- Mensaje actual: {{ $('Unificaci√≥n y consistencia de datos').first().json.infoMensaje.mensajeActual }}\n- Historial de mensajes: {{$node[\"Unificaci√≥n y consistencia de datos\"].json.infoMensaje.historialMensajes}}\n- Hora actual: {{$node[\"Organiza el Mensaje\"].json.infoMensaje.horaMensajeActual}}\n- Fecha actual: {{$node[\"Organiza el Mensaje\"].json.infoMensaje.fechaMensajeActual}}\n\n## Instrucciones espec√≠ficas para interpretaci√≥n de fechas\n1. NUNCA interpretes fechas que est√©n en el pasado. Toda fecha debe ser igual o posterior a la fecha actual.\n\n2. Para fechas espec√≠ficas num√©ricas:\n   - Si el usuario menciona \"30 de abril\" o \"el 30 de abril\", usa exactamente esa fecha.\n   - Si el usuario dice algo como \"para el 28\", interpreta como el d√≠a 28 del mes actual seg√∫n la fecha del sistema.\n\n3. Para fechas con d√≠a de la semana y fecha num√©rica (ej: \"mi√©rcoles 30 de abril\"):\n   - Prioriza SIEMPRE la fecha num√©rica (30 de abril) aunque el d√≠a de la semana mencionado sea incorrecto.\n\n4. Para fechas que solo mencionan el d√≠a de la semana (ej: \"el martes\"):\n   - Si ese d√≠a ya pas√≥ en la semana actual, asume que se refiere a la pr√≥xima semana.\n   - Ejemplo: Si hoy es jueves y dicen \"el mi√©rcoles\", debe interpretarse como el mi√©rcoles de la pr√≥xima semana.\n\n5. Para expresiones relativas:\n   - \"hoy\" = fecha actual del sistema\n   - \"ma√±ana\" = fecha actual + 1 d√≠a\n   - \"pasado ma√±ana\" = fecha actual + 2 d√≠as\n\n6. Si hay informaci√≥n contradictoria sobre la fecha en diferentes mensajes, prioriza la informaci√≥n del mensaje m√°s reciente.\n\n## Instrucciones generales\n1. Analiza PRIMERO el historial de mensajes completo, luego el mensaje actual.\n2. Si un dato aparece en m√∫ltiples mensajes, prioriza la versi√≥n m√°s reciente (mensaje actual).\n3. Si encuentras un mensaje que parece ser una respuesta directa a una pregunta sobre un dato espec√≠fico (ej. \"¬øCu√°l es el peso?\" ‚Üí \"300 kilos\"), considera esto como informaci√≥n v√°lida.\n4. NO generes ni inventes informaci√≥n que no est√© presente en los mensajes.\n5. Extrae solo la informaci√≥n factual, no interpretes intenciones o deseos del usuario.\n6. NO incluyas notas, explicaciones o campos adicionales en el JSON final.\n7. Si un dato no se encuentra en ninguna parte de la conversaci√≥n, d√©jalo en blanco o como valor predeterminado (0 para valores num√©ricos, \"\" para texto).\n\n## Formato de respuesta\nDevuelve √öNICAMENTE un objeto JSON limpio con el siguiente formato exacto:\n\n{\n  \"proveedor\": \"\",\n  \"fecha\": \"\",\n  \"hora\": \"\",\n  \"categoria\": \"\",\n  \"peso\": 0,\n  \"unidades\": 0,\n  \"ordenCompra\": \"\"\n}",
        "hasOutputParser": true
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        464,
        1472
      ],
      "id": "61288306-668f-4b43-abb2-7dc47cae2e5f",
      "name": "Basic LLM Chain RECOLECCI√ìN1"
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n  \"proveedor\": \"SPB COLOMBIA S.A.S.\",\n  \"fecha\": \"30 de abril de 2025\",\n  \"hora\": \"08:00 AM\",\n  \"categoria\": \"ARENAS\",\n  \"peso\": 300,\n  \"unidades\": 600,\n  \"ordenCompra\": \"ARGM47896\"\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.2,
      "position": [
        560,
        1680
      ],
      "id": "cbcabd4e-919b-411f-b32c-5bd9cf7f2650",
      "name": "Structured Output Parser3"
    },
    {
      "parameters": {
        "jsCode": "/*\n===========================================================\n  Nodo Code - VALIDAR INSERCIONES EN EXCEL (n8n)\n  ‚Ä¢ Analiza la salida del ‚ÄúLoop Over Uno a Uno‚Äù.\n  ‚Ä¢ Agrupa los √≠tems por franja (campo `indice` si existe;\n    de lo contrario, cada bloque de 5 √≠tems forma una franja).\n  ‚Ä¢ Verifica que cada inserci√≥n tenga:\n        exito === true\n        statusCode === 200\n        falloEstado === false\n  ‚Ä¢ Devuelve un √∫nico objeto JSON con:\n        ‚Äì Resumen global.\n        ‚Äì Detalle por franja (√©xitos / fallos y celdas con error).\n===========================================================\n*/\n\n// 1) Obtener todos los √≠tems que llegan al nodo\nconst items = $input.all();\n\n// 2) Funci√≥n auxiliar para determinar el identificador de la franja\nfunction obtenerIdFranja(item, idx) {\n  // Si existe 'indice', √∫salo; de lo contrario agrupa cada 5 √≠tems\n  if (item.json && item.json.indice !== undefined && item.json.indice !== null) {\n    return String(item.json.indice).trim();\n  }\n  // +1 para que las franjas queden 1-basadas\n  return String(Math.floor(idx / 5) + 1);\n}\n\n// 3) Agrupar √≠tems por franja\nconst franjas = {};\nitems.forEach((item, idx) => {\n  const idFranja = obtenerIdFranja(item, idx);\n  if (!franjas[idFranja]) {\n    franjas[idFranja] = { id: idFranja, items: [] };\n  }\n  franjas[idFranja].items.push(item.json);\n});\n\n// 4) Analizar cada franja y construir el detalle\nconst detallesPorFranja = Object.values(franjas).map(franja => {\n  const totalOps   = franja.items.length;\n  const exitosas   = franja.items.filter(i =>\n    i.exito === true &&\n    i.statusCode === 200 &&\n    i.falloEstado === false\n  ).length;\n\n  const fallidas   = totalOps - exitosas;\n  const exitoTotal = fallidas === 0;\n\n  // Celdas con error para un diagn√≥stico claro\n  const celdasFallidas = franja.items\n    .filter(i => !(i.exito && i.statusCode === 200 && !i.falloEstado))\n    .map(i => ({\n      celdaOriginal   : i.celdaOriginal,\n      celdaInsertada  : i.celdaInsertada,\n      statusCode      : i.statusCode,\n      falloEstado     : i.falloEstado,\n      celdasDiferentes: i.celdasDiferentes,\n      mensaje         : 'Inserci√≥n fallida'\n    }));\n\n  return {\n    idFranja                : franja.id,\n    exitoFranja             : exitoTotal,\n    operacionesTotales      : totalOps,\n    operacionesExitosas     : exitosas,\n    operacionesFallidas     : fallidas,\n    porcentajeExitosas      : ((exitosas / totalOps) * 100).toFixed(2) + '%',\n    celdasFallidas\n  };\n});\n\n// 5) Resumen global\nconst operacionesTotales   = items.length;\nconst operacionesExitosas  = detallesPorFranja.reduce((sum, f) => sum + f.operacionesExitosas, 0);\nconst operacionesFallidas  = operacionesTotales - operacionesExitosas;\n\nconst franjasTotales   = detallesPorFranja.length;\nconst franjasExitosas  = detallesPorFranja.filter(f => f.exitoFranja).length;\nconst franjasFallidas  = franjasTotales - franjasExitosas;\n\n\nconst resumen = {\n  estadoGeneral              : franjasFallidas === 0 ? '√âXITO_COMPLETO' : '√âXITO_PARCIAL',\n  franjasTotales,\n  franjasExitosas,\n  franjasFallidas,\n  porcentajeFranjasExitosas  : ((franjasExitosas / franjasTotales) * 100).toFixed(2) + '%',\n  operacionesTotales,\n  operacionesExitosas,\n  operacionesFallidas,\n  porcentajeOperacionesExitosas : ((operacionesExitosas / operacionesTotales) * 100).toFixed(2) + '%',\n  detallesPorFranja\n};\n\n// 6) Devolver un √∫nico √≠tem con el resumen\nreturn [\n  {\n    json: resumen\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2224,
        2480
      ],
      "id": "44aed98c-4e35-4652-92a4-999b85b52611",
      "name": "Code Validar inserciones"
    },
    {
      "parameters": {
        "jsCode": "// 1) Leer chat_id una sola vez\nconst chatId = $node[\"Organiza el Mensaje\"].json.infoMensaje.chat_id;\n\n// 2) Tomamos los datos de informacionCita una sola vez\nconst cita = $input.first().json.informacionCita || {};\nconst historialMensajes = $('Unificaci√≥n y consistencia de datos').first().json.infoMensaje.historialMensajes;\n\n// Funci√≥n para convertir fechas en formato \"06 de mayo de 2025\" a \"YYYY-MM-DD HH:mm:ss\"\nfunction convertirFecha(fechaTexto) {\n  const meses = {\n    enero: '01', febrero: '02', marzo: '03', abril: '04', mayo: '05',\n    junio: '06', julio: '07', agosto: '08', septiembre: '09',\n    octubre: '10', noviembre: '11', diciembre: '12'\n  };\n\n  // Dividir la fecha y mapear el mes\n  const [dia, de, mes, deNuevo, anio] = fechaTexto.split(' ');\n  const mesNumerico = meses[mes.toLowerCase()]; // Convertir el mes a n√∫mero\n  return `${anio}-${mesNumerico}-${dia.padStart(2, '0')} 00:00:00`; // Formato DATETIME\n}\n\n// Convertimos la fecha aqu√≠\nconst fechaCitaConvertida = convertirFecha(cita.fecha);\n\n// 3) Retornamos un solo objeto con todos los datos necesarios\nreturn {\n  json: {\n    chat_id: chatId,\n    proveedor: cita.proveedor,\n    orden_compra: cita.ordenCompra,\n    peso: cita.peso,\n    unidades: cita.unidades,\n    categoria: cita.categoria,\n    muelle: cita.muelle,\n    fecha_cita: fechaCitaConvertida, // Fecha ya convertida\n    hora_inicio: cita.horaInicio,\n    hora_fin: cita.horaFin,\n    chat_historial: historialMensajes,\n    // Incluimos cualquier otro dato que necesites\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1968,
        2368
      ],
      "id": "f71ffeca-d713-46cd-b6b2-9d8ef2cf1881",
      "name": "Code Datos Insert Cita"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT id, chat_id, franjas_json\nFROM FranjasDisponiblesTemp\nWHERE chat_id = '{{ $json.chat_id }}'\nORDER BY timestamp_enviado ASC;\n"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        2224,
        2288
      ],
      "id": "b073055a-f252-4e65-9082-b88025465064",
      "name": "Microsoft SQL Franjas Temporales",
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "8c501d95-bdf3-4635-a037-224926c2528d",
              "leftValue": "={{ $json.estadoGeneral }}",
              "rightValue": "√âXITO_COMPLETO",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        2560,
        2480
      ],
      "id": "f82a4ef3-c73e-4af7-839e-b3c160138a2c",
      "name": "If Validar inserciones"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.1,
      "position": [
        2864,
        2368
      ],
      "id": "23ed1ec0-a925-4cc6-92b9-9a4bc7f4479c",
      "name": "Merge"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Nodo Code ‚Äì ‚ÄúUnir Franjas en Historial‚Äù\n * Coloca este nodo inmediatamente despu√©s de ‚ÄúMicrosoft SQL Franjas Temporales‚Äù.\n * No requiere par√°metros adicionales.\n */\n\n// 1) Tomamos todos los √≠tems que llegan desde el nodo SQL\nconst items = $input.all();   // ‚Üê cada item = { id, chat_id, franjas_json }\n\n// 2) Armamos la cadena tipo historial:  \"Franja 1: {...}\\n\\nFranja 2: {...}\\n\\n‚Ä¶\"\nlet historial = '';\nitems.forEach((item, idx) => {\n  const numero = idx + 1;                                 // 1, 2, 3, ‚Ä¶\n  const cuerpoFranja = JSON.stringify(JSON.parse(item.json.franjas_json), null, 2);    // viene como string desde SQL\n  historial += `Franja ${numero}: ${cuerpoFranja}\\n\\n`;\n});\n\n// 3) (Opcional) quitamos el √∫ltimo salto de l√≠nea doble\nhistorial = historial.trimEnd();\n\n// 4) Devolvemos **UN** √≠tem con **UNA** propiedad (ajusta el nombre si quieres)\nreturn [\n  {\n    json: {\n      franjas_historial: historial            // ‚Üê cadena final\n    }\n  }\n];\n\n/* -------------------------------------------------------------------------\n   Ejemplo de salida cuando hay 3 filas:\n\n   {\n     \"franjas_historial\": \"Franja 1: {\\\"disponibilidadConfirmada\\\":false,...}\\n\\n\n                           Franja 2: {\\\"disponibilidadConfirmada\\\":true,...}\\n\\n\n                           Franja 3: {...}\"\n   }\n--------------------------------------------------------------------------- */\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2560,
        2288
      ],
      "id": "654df55c-89f3-4680-8adf-687d67540860",
      "name": "Code Estructuraci√≥n de franjas temporales"
    },
    {
      "parameters": {
        "numberInputs": 3
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.1,
      "position": [
        5712,
        2800
      ],
      "id": "aa45954b-a282-4b0a-8eab-bfae3cd75da9",
      "name": "Merge1"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO CitasRecepcion\n(\n    chat_id,\n    nombre,              \n    orden_compra,\n    peso,\n    unidades,\n    horas_entrega,\n    categoria,\n    muelle,\n    fecha_cita,\n    hora_inicio,\n    hora_fin,\n    estado,\n    fecha_creacion,\n    fecha_modificacion,\n    chat_historial,\n    chat_historial_datos\n)\n/* ‚îÄ‚îÄ‚îÄ AQU√ç ‚îÄ‚îÄ‚îÄ */\nOUTPUT INSERTED.id          --  ‚Üê  devolver√° el IDENTITY de la fila reci√©n insertada\nVALUES\n(\n    '{{ $('Code Datos Insert Cita').first().json.chat_id }}',\n    '{{ $('Code Datos Insert Cita').first().json.proveedor }}',\n    '{{ $('Code Datos Insert Cita').first().json.orden_compra }}',\n     {{ $('Code Datos Insert Cita').first().json.peso }},              \n     {{ $('Code Datos Insert Cita').first().json.unidades }},          {{ $('Code Agrupar Franjas').first().json.informacionCita.duracionHoras }},\n    '{{ $('Code Datos Insert Cita').first().json.categoria }}',\n    '{{ $('Code Datos Insert Cita').first().json.muelle }}',\n    '{{ $('Code Datos Insert Cita').first().json.fecha_cita }}',\n    '{{ $('Code Datos Insert Cita').first().json.hora_inicio }}',      \n    '{{ $('Code Datos Insert Cita').first().json.hora_fin }}',   \n      'PROGRAMADA',                   \n    (SYSDATETIMEOFFSET() AT TIME ZONE 'SA Pacific Standard Time'), \n    NULL,                            \n    '{{ $items(\"Code Datos Insert Cita\")\n        .map(i => i.json.chat_historial)\n        .join(\"\\n\")\n        .replace(/'/g,\"''\") }}',\n    '{{ $items('Merge')\n        .map(i => i.json.franjas_historial)\n        .join('\\n')\n        .replace(/'/g, \"''\") }}'\n);\n\n"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        4272,
        2512
      ],
      "id": "2821fa79-8da7-4745-999c-c5e7c6390ec7",
      "name": "Microsoft SQL Insertar Cita",
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "BEGIN TRANSACTION;\n\nDELETE FROM MensajesWhatsApp\nWHERE chat_id = '{{ $('Unificaci√≥n y consistencia de datos').first().json.infoMensaje.chat_id }}'\n   OR (chat_id = 'agenteAI'\n       AND message_id IN (\n           SELECT message_id \n           FROM MensajesWhatsApp\n           WHERE chat_id = '{{ $('Unificaci√≥n y consistencia de datos').first().json.infoMensaje.chat_id }}'\n       )\n   );\n\nDELETE FROM FranjasDisponiblesTemp \nWHERE chat_id = '{{ $('Unificaci√≥n y consistencia de datos').first().json.infoMensaje.chat_id }}';\n\nCOMMIT;"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        28128,
        7632
      ],
      "id": "15301a26-7cae-4fa4-b842-37526c390a6a",
      "name": "Microsoft SQL Eliminar Mensajes",
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        6032,
        2912
      ],
      "id": "9827be40-84c5-4d99-8e8a-b9d943f9f46e",
      "name": "OpenAI Chat Model13",
      "credentials": {
        "openAiApi": {
          "id": "AD8kPcNVReuclASd",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "4bfbecb3-9d4f-4425-aa76-a92abc7708fb",
              "leftValue": "={{ $('Basic LLM Notificar Cita Exitosa').item.json.text.length }}",
              "rightValue": 70,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        6560,
        2864
      ],
      "id": "dbafacfd-691e-4e48-be38-bac480521747",
      "name": "Validaci√≥n de longitud de caracteres7"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d9c2ff70-4fd1-4b93-8571-6d0ac5a0093e",
              "name": "mensaje.ia",
              "value": "={{ $('Basic LLM Notificar Cita Exitosa').item.json.text }}",
              "type": "string"
            },
            {
              "id": "ac8a03be-0292-4735-9580-39a385945c47",
              "name": "mensaje.longitud",
              "value": "={{ $('Basic LLM Notificar Cita Exitosa').item.json.text.length }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        6864,
        2992
      ],
      "id": "ae5abed8-3275-4f1b-83f7-53ef56187a07",
      "name": "Organiza variables del mensaje7"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        7024,
        2768
      ],
      "id": "6c4468ce-cb7c-4b4a-b989-0b39e34aa9be",
      "name": "No Operation, do nothing9"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $('Code Respuesta Faltantes').item.json.text }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        6848,
        2768
      ],
      "id": "ba3fb535-55f3-4b78-8909-7f91ab290e9a",
      "name": "HTTP Request Enviar Mensaje por WhatsApp10"
    },
    {
      "parameters": {
        "promptType": "=define",
        "text": "=# Rol\nEres el asistente virtual de Konf√≠e¬†Logistics.  \nTu objetivo es notificar al proveedor que su cita se registr√≥ con √©xito en el cronograma.\n\n# Datos disponibles\n- idCita           = {{ $(\"Microsoft SQL Insertar Cita\").first().json.id }}\n- fechaCita        = {{ $(\"Code Datos Insert Cita\").first().json.fecha_cita }}\n- horaInicio       = {{ $(\"Code Datos Insert Cita\").first().json.hora_inicio }}\n- horaFin          = {{ $(\"Code Datos Insert Cita\").first().json.hora_fin }}\n- muelle           = {{ $(\"Code Datos Insert Cita\").first().json.muelle }}\n- ordenCompra      = {{ $(\"Code Datos Insert Cita\").first().json.orden_compra }}\n- categoria        = {{ $(\"Code Datos Insert Cita\").first().json.categoria }}\n- pesoKg           = {{ $(\"Code Datos Insert Cita\").first().json.peso }}\n- unidades         = {{ $(\"Code Datos Insert Cita\").first().json.unidades }}\n\n# Instrucciones de redacci√≥n\n1. Mant√©n un tono profesional, cordial y positivo (feliz pero sin exagerar).\n2. Empieza con una breve expresi√≥n de entusiasmo por la confirmaci√≥n exitosa (ej.: ‚Äú¬°Excelente!‚Äù o ‚Äú¬°Cita confirmada!‚Äù).\n3. Muestra los detalles de la cita en una lista con vi√±etas y emojis apropiados:\n   ‚Ä¢ üÜî **N√∫mero de cita:** res√°ltalo con el emoji üîñ antes del `idCita` ‚Üí üîñ‚ÄØ{{ $(\"Microsoft SQL Insertar Cita\").first().json.id }}\n   ‚Ä¢ üìÖ **Fecha:** {{ $(\"Code Datos Insert Cita\").first().json.fecha_cita.split(\" \")[0] }}\n   ‚Ä¢ ‚è∞ **Horario:** {{ $(\"Code Datos Insert Cita\").first().json.hora_inicio }}‚ÄØ‚Äì‚ÄØ{{ $(\"Code Datos Insert Cita\").first().json.hora_fin }} \n   ‚Ä¢ üö© **Muelle:** {{ $(\"Code Datos Insert Cita\").first().json.muelle }} \n   ‚Ä¢ üè∑Ô∏è **O/C:** {{ $(\"Code Datos Insert Cita\").first().json.orden_compra }} \n   ‚Ä¢ üì¶ **Categor√≠a:** {{ $(\"Code Datos Insert Cita\").first().json.categoria }}\n   ‚Ä¢ ‚öñÔ∏è **Peso:** {{ $(\"Code Datos Insert Cita\").first().json.peso }}‚ÄØkg  \n   ‚Ä¢ üì¶ **Unidades:** {{ $(\"Code Datos Insert Cita\").first().json.unidades }}\n4. Reitera el n√∫mero de cita con el emoji üîñ y aclara que con ese n√∫mero el proveedor podr√° **modificar o cancelar** la cita.\n5. Explica claramente la pol√≠tica: ‚ÄúLas modificaciones o cancelaciones deben solicitarse **hasta un‚ÄØd√≠a h√°bil antes** y **antes de las‚ÄØ4:30‚ÄØp.‚ÄØm.**; despu√©s de ese plazo no podremos realizar cambios.‚Äù\n6. Cierra agradeciendo su colaboraci√≥n y confirmando que estaremos atentos a su llegada.\n7. Devuelve **solo** el mensaje final, sin encabezados ni explicaciones adicionales.\n\n# Salida esperada (ejemplo de estilo)\n¬°Excelente! üéâ  \nüîñ Numero de la Cita:‚ÄØ12345  \nüìÖ El‚ÄØ06‚ÄØde‚ÄØmayo‚ÄØde‚ÄØ2025  \n‚è∞‚ÄØA las 08:00‚ÄØ‚Äì‚ÄØ10:00  \nüö©‚ÄØEn el Muelle‚ÄØ1  \nüè∑Ô∏è‚ÄØO/C‚ÄØARGM47896  \nüì¶‚ÄØCategor√≠a‚ÄØArenas  \n‚öñÔ∏è‚ÄØ300‚ÄØkg | üì¶‚ÄØ600‚ÄØu\n\nGuarda tu n√∫mero de cita üîñ‚ÄØ12345 para futuras gestiones ya sea reprogramar o cancelar.  \nPodr√°s modificarla o cancelarla hasta un d√≠a h√°bil antes y antes de las‚ÄØ4:30‚ÄØp.‚ÄØm.  \n¬°Muchas gracias por tu confianza!\n"
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        6128,
        2720
      ],
      "id": "1e478623-80a6-46a3-b1b3-03ce8bad93c3",
      "name": "Basic LLM Notificar Cita Exitosa",
      "alwaysOutputData": true,
      "executeOnce": true
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "BEGIN TRANSACTION;\n\nDELETE FROM MensajesWhatsApp\nWHERE chat_id = '{{ $('Unificaci√≥n y consistencia de datos').first().json.infoMensaje.chat_id }}'\n   OR (chat_id = 'agenteAI'\n       AND message_id IN (\n           SELECT message_id \n           FROM MensajesWhatsApp\n           WHERE chat_id = '{{ $('Unificaci√≥n y consistencia de datos').first().json.infoMensaje.chat_id }}'\n       )\n   );\n\nDELETE FROM FranjasDisponiblesTemp \nWHERE chat_id = '{{ $('Unificaci√≥n y consistencia de datos').first().json.infoMensaje.chat_id }}';\n\nCOMMIT;\n"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        5152,
        3024
      ],
      "id": "9cb3b3a3-d3cc-452c-ae11-2e9f75aa6b1f",
      "name": "Microsoft SQL Eliminar Mensajes2",
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -1856,
        5344
      ],
      "id": "dfce32db-801f-42c3-8569-f1044ddfe66c",
      "name": "OpenAI Chat Model14",
      "credentials": {
        "openAiApi": {
          "id": "AD8kPcNVReuclASd",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n\"idCita\": \"\",\n\"ordenCompra\": \"\",\n\"nuevaFecha\": \"\",\n\"nuevaHora\": \"\",\n\"camposFaltantes\": [],\n\"fechaActual\": \"\",\n\"horaActual\": \"\"\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.2,
      "position": [
        -1696,
        5344
      ],
      "id": "076ba17f-ee1d-4300-8d56-09458da9143a",
      "name": "Structured Output Parser4"
    },
    {
      "parameters": {
        "promptType": "=define",
        "text": "=# Extracci√≥n de datos para edici√≥n de citas\n\n## SISTEMA\nEres un asistente especializado en interpretar mensajes de usuarios para reprogramaci√≥n de citas log√≠sticas. Tu funci√≥n es extraer los datos necesarios para reprogramar una cita existente (ID de cita, orden de compra, nueva fecha, nueva hora) y validar que sean coherentes.\n\n**Tu √∫nica responsabilidad es extraer datos, no validarlos ni tomar decisiones.**\n\n## DETECCI√ìN DE RETRACTACIONES EN EDICI√ìN\nSi detectas m√∫ltiples cambios de fecha/hora contradictorios en el historial:\n- Verifica si el usuario ha mencionado diferentes fechas para la reprogramaci√≥n\n- Si encuentra fechas contradictorias, marca como rechazado con motivo \"retractaciones_multiples\"\n- Sugiere reiniciar el proceso\n\n## Datos a extraer\n- ID de la cita (por ejemplo, \"Cita 12345\", \"N√∫mero 12345\", etc.)\n- N√∫mero de orden de compra asociado a la cita\n- Nueva fecha deseada\n- Nueva hora deseada\n\n## Fuentes de datos a analizar\n- Mensaje actual: {{ $('Unificaci√≥n y consistencia de datos').first().json.infoMensaje.mensajeActual }}\n- Historial de mensajes: {{ $node[\"Unificaci√≥n y consistencia de datos\"].json[\"infoMensaje\"][\"historialMensajes\"] }}\n- Hora actual: {{$node[\"Organiza el Mensaje\"].json.infoMensaje.horaMensajeActual}}\n- Fecha actual: {{$node[\"Organiza el Mensaje\"].json.infoMensaje.fechaMensajeActual}}\n\n## Procesamiento del historial completo de mensajes\n1. IMPORTANTE: Analiza el historial COMPLETO de mensajes como una conversaci√≥n\n2. Busca informaci√≥n relevante a lo largo de TODOS los mensajes, no solo en el mensaje actual\n3. Considera que la informaci√≥n puede estar distribuida en varios mensajes (por ejemplo, ID en un mensaje, orden de compra en otro, fecha en otro, hora en otro)\n4. Une la informaci√≥n proporcionada en mensajes separados para construir la solicitud completa\n5. Si el mensaje actual contiene solo un dato (como \"a las 7am\"), con√©ctalo con datos previos de mensajes anteriores\n\n## Detecci√≥n de retractaciones espec√≠fica\n6. CR√çTICO: Detecta si el usuario ha proporcionado fechas contradictorias para la reprogramaci√≥n:\n   - Ejemplo: Primer mensaje \"reprogramar para el 17 de julio\", segundo mensaje \"mejor para el 18 de julio\"\n   - Si detectas esto, marca motivoRechazo como \"retractaciones_multiples\"\n\n## Instrucciones espec√≠ficas\n1. Busca PRIMERO el ID de la cita en formato num√©rico en CUALQUIER mensaje previo\n2. Busca el n√∫mero de orden de compra en CUALQUIER mensaje previo\n3. Si encuentras ID y orden de compra, busca la fecha nueva que desea el proveedor en CUALQUIER mensaje previo o actual\n4. Si encuentras ID, orden de compra y fecha, busca la hora nueva que desea el proveedor en CUALQUIER mensaje previo o actual\n5. Si un mensaje solo menciona la hora (por ejemplo, \"7am\"), con√©ctalo con la fecha mencionada en mensajes anteriores\n6. Si un mensaje solo menciona una fecha (por ejemplo, \"jueves 8 de mayo\"), busca si hay informaci√≥n sobre la hora en otros mensajes\n7. Considera expresiones como \"para ma√±ana\", \"para el lunes\", \"para el 20\", etc. encontradas en CUALQUIER mensaje\n8. Normaliza la fecha al formato \"DD de [mes] de YYYY\" (usando el a√±o actual si no se especifica)\n9. Normaliza la hora al formato \"HH:MM AM/PM\"\n10. NUEVO: Verifica si hay fechas contradictorias en diferentes mensajes del historial\n\n## Reglas de validaci√≥n temporal\n1. Si la nueva fecha es anterior a la fecha actual ‚Üí motivoRechazo: \"fecha_pasada\"\n2. Si la nueva fecha es para el mismo d√≠a despu√©s de las 4:30 PM ‚Üí motivoRechazo: \"mismo_dia_tarde\"\n3. Si la nueva fecha es para el d√≠a siguiente y son m√°s de las 4:30 PM ‚Üí motivoRechazo: \"dia_siguiente_tarde\"\n4. Si hay m√∫ltiples fechas contradictorias ‚Üí motivoRechazo: \"retractaciones_multiples\"\n\n## Formato de respuesta (JSON)\n```json\n{\n  \"idCita\": \"12345\",\n  \"ordenCompra\": \"ARGM47896\", \n  \"nuevaFecha\": \"20 de mayo de 2025\",\n  \"nuevaHora\": \"10:00 AM\",\n  \"camposFaltantes\": [],\n  \"fechaActual\": \"19 de mayo de 2025\",\n  \"horaActual\": \"14:30\",\n  \"motivoRechazo\": \"retractaciones_multiples\",\n  \"mensajeUsuario\": \"Usuario ha proporcionado fechas contradictorias para reprogramaci√≥n\"\n}\n```\n\n## Ejemplos de campos faltantes\n- Si no hay ID: camposFaltantes: [\"idCita\"]  \n- Si no hay orden: camposFaltantes: [\"ordenCompra\"]\n- Si no hay fecha: camposFaltantes: [\"nuevaFecha\"]\n- Si no hay hora: camposFaltantes: [\"nuevaHora\"]\n\n## Casos especiales de retractaci√≥n\n- Usuario dice: \"reprogramar mi cita 123 para el 17\", luego \"mejor para el 18\" ‚Üí motivoRechazo: \"retractaciones_multiples\"\n- Usuario cambia fecha m√∫ltiples veces en la misma conversaci√≥n ‚Üí motivoRechazo: \"retractaciones_multiples\"\n\nIMPORTANTE: Solo extrae datos, no valides fechas pasadas ni horarios de oficina. Esa validaci√≥n la hace otro nodo.",
        "hasOutputParser": true
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        -1776,
        5152
      ],
      "id": "b47377c9-3122-4d88-a9b1-ed1c135ceb67",
      "name": "Basic LLM Extracci√≥n y Validacion de Datos Editar Cita"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "f0ba0488-a2ee-439f-ac12-ff4f15d14c58",
              "leftValue": "={{ $json.todoCorrecto }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -1184,
        5152
      ],
      "id": "d3422d5a-3029-430c-8cc8-d1c0404d6c21",
      "name": "If Validar si la operaci√≥n es posible (todoCorrecto)"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "b8d93581-02fd-4502-8346-e5f35dd7a430",
              "leftValue": "={{ $json.output.intentaModificarDatos }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -784,
        5328
      ],
      "id": "a1d4a86f-9f3b-4fd8-9d90-03fd9af9ea54",
      "name": "If Verificar si se intenta modificar datos no permitidos"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "17546f72-2b59-46c3-b92b-e87f10cf0799",
              "leftValue": "={{ $json.output.rechazoTemporal }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -528,
        5552
      ],
      "id": "03943517-6538-4e62-92f9-5797ea22af43",
      "name": "If Verificar si es un rechazo por motivos temporales"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "46e5638b-d64b-47e5-9cac-984fb79f107c",
              "leftValue": "={{ $json.output.camposFaltantes.length }}",
              "rightValue": 0,
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -256,
        5760
      ],
      "id": "216a0047-d0d3-4c10-95fd-2c1fe2e0bd82",
      "name": "If Verificar si faltan datos"
    },
    {
      "parameters": {
        "jsCode": "// Create a generic error message\nconst errorMessage = {\n  output: {\n    mensajeSistema: \"Lo sentimos, ha ocurrido un error interno. Por favor, vuelva a empezar nuevamente con su solicitud de reprogramaci√≥n de cita.\"\n  }\n};\n\n// Return the formatted message that can be used by your response node\nreturn errorMessage;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -48,
        6000
      ],
      "id": "fd1018fe-17a5-455d-bfb4-ea71c3120211",
      "name": "Code Mensaje Error"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "b2110549-dd58-46b3-9707-dbbe0a5004f2",
              "leftValue": "={{ $('Basic LLM Extracci√≥n y Validacion de Datos Editar Cita').first().json.output.mensajeSistema.length }}",
              "rightValue": 70,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            },
            {
              "id": "f250763e-e4ab-4054-8bf5-84d61e39f87b",
              "leftValue": "={{ $json.output.mensajeSistema.length }}",
              "rightValue": 70,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        384,
        5408
      ],
      "id": "0dbc3642-d50f-4099-99ea-54e7a7cb073c",
      "name": "Validaci√≥n de longitud de caracteres8"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        880,
        5344
      ],
      "id": "8e84b2ae-4fec-42d9-b064-4b28465e3158",
      "name": "No Operation, do nothing11"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $('Consistencia de datos, intenci√≥n consultar malla').item.json.mensaje }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        704,
        5344
      ],
      "id": "316aa510-a251-4d4f-9d37-ebee509601eb",
      "name": "HTTP Request Enviar Mensaje por WhatsApp11"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d9c2ff70-4fd1-4b93-8571-6d0ac5a0093e",
              "name": "mensaje.ia",
              "value": "={{ $json.output.mensajeSistema }}",
              "type": "string"
            },
            {
              "id": "ac8a03be-0292-4735-9580-39a385945c47",
              "name": "mensaje.longitud",
              "value": "={{ $json.output.mensajeSistema.length }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        704,
        5552
      ],
      "id": "8505465f-1e9e-473f-862e-b075c9a7d936",
      "name": "Organiza variables del mensaje8"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "DECLARE @Id INT = {{ $json.idCita }};\n\nIF EXISTS (SELECT 1\n           FROM   CitasRecepcion\n           WHERE  id = @Id\n             AND  estado = 'PROGRAMADA')\nBEGIN\n    SELECT *\n    FROM   CitasRecepcion\n    WHERE  id = @Id\n      AND  estado = 'PROGRAMADA';\nEND\nELSE\nBEGIN\n    -- C√≥digo 50001 y nivel 16: error de aplicaci√≥n personalizado\n    THROW 50001, 'La cita no se encuentra en estado PROGRAMADA.', 16;\nEND"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        -960,
        5040
      ],
      "id": "5c6db51a-bda4-404e-9be1-5beee311f7f0",
      "name": "Microsoft SQL Obtener Cita",
      "alwaysOutputData": true,
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "0c011567-205a-4ff9-a41a-5c1cd00a6f04",
              "leftValue": "={{ $json.id }}",
              "rightValue": "",
              "operator": {
                "type": "number",
                "operation": "exists",
                "singleValue": true
              }
            },
            {
              "id": "07596852-0256-421d-be90-26f9e2e932ba",
              "leftValue": "={{ $json.chat_id }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "exists",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -736,
        5040
      ],
      "id": "9d878665-caec-4568-b784-aad6237d5b25",
      "name": "If existe cita"
    },
    {
      "parameters": {
        "jsCode": "// Create a generic error message\nconst errorMessage = {\n  output: {\n    mensajeSistema: \"El n√∫mero de identificaci√≥n de la cita proporcionado no existe en el cronograma. O es una cita ya cancelada o reprogramada, por motivos de trazabilidad, es necesario reiniciar el proceso de reprogramaci√≥n. Por favor, proporciona nuevamente todos los datos, asegur√°ndote de que sean correctos. Gracias por tu colaboraci√≥n.\"\n  }\n};\n\n// Return the formatted message that can be used by your response node\nreturn errorMessage;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -304,
        5168
      ],
      "id": "b2fb292f-1552-4125-8e8b-0c7ba4b005bb",
      "name": "Code Mensaje Error1"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.1,
      "position": [
        27264,
        7632
      ],
      "id": "42e2e349-4fcf-4ee0-a2b9-12e90a59364e",
      "name": "Merge2"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        28320,
        7632
      ],
      "id": "c066539a-29bd-4377-bd12-64abf1519b42",
      "name": "No Operation, do nothing10"
    },
    {
      "parameters": {
        "jsCode": "// Obtener todos los datos de entrada\nconst datosEntrada = $input.all();\n// Filtrar solo los objetos que contienen un mensaje, descartando estad√≠sticas\nconst mensajes = datosEntrada.filter(item => item.json.message_id);\n\n// Extraer chat_id del primer mensaje del usuario (no del agente)\nconst userMessage = mensajes.find(item => item.json.chat_id !== 'agenteAI');\nconst chat_id = userMessage ? userMessage.json.chat_id : \"No hay chat_id disponible\";\n\n// Funci√≥n para convertir la fecha a formato Colombia (UTC-5) en formato de 12 horas\nfunction convertirHoraColombia(fechaUTC) {\n    if (!fechaUTC) return \"[Hora no encontrada]\";\n    let fecha = new Date(fechaUTC);\n    fecha.setHours(fecha.getHours()); // Convertir a UTC-5\n    return fecha.toLocaleTimeString('es-CO', { hour: '2-digit', minute: '2-digit', hour12: true });\n}\n// Funci√≥n para dar formato de fecha en espa√±ol sin hora\nfunction formatearFecha(fechaUTC) {\n    if (!fechaUTC) return \"[Fecha no encontrada]\";\n    let fecha = new Date(fechaUTC);\n    return fecha.toLocaleDateString('es-CO', { year: 'numeric', month: 'long', day: 'numeric' });\n}\n// Estructurar los mensajes en un formato claro para el agente IA\nconst mensajesEstructurados = mensajes.map((mensaje, index) => {\n    let fecha = mensaje.json.fecha ? formatearFecha(mensaje.json.fecha) : \"[Fecha no encontrada]\";\n    let hora = mensaje.json.fecha ? convertirHoraColombia(mensaje.json.fecha) : \"[Hora no encontrada]\";\n    let contenido = mensaje.json.contenido || \"[Sin contenido]\";\n    \n    // Determinar si el mensaje es del usuario o del agente IA\n    let remitente = mensaje.json.chat_id === 'agenteAI' ? 'El Agente ChatBot IA dice:' : 'El usuario dice:';\n    \n    return `Mensaje ${index + 1} enviado el ${fecha} a las ${hora}.\\n${remitente} \"${contenido}\".`;\n});\n// Unir todos los mensajes en un solo texto estructurado\nconst historialMensajes = mensajesEstructurados.join('\\n\\n');\n// Retornar los datos estructurados incluyendo chat_id\nreturn [{ chat_id, historialMensajes }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        27680,
        7632
      ],
      "id": "35828507-619d-49ec-8866-a7e3c9cdd986",
      "name": "Code integracion de mensajes"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT * FROM MensajesWhatsApp\nWHERE chat_id = '{{ $('Unificaci√≥n y consistencia de datos').first().json.infoMensaje.chat_id }}'\n   OR (chat_id = 'agenteAI' AND message_id IN (\n       SELECT message_id \n       FROM MensajesWhatsApp \n       WHERE chat_id = '{{ $('Unificaci√≥n y consistencia de datos').first().json.infoMensaje.chat_id }}'\n   ))\nORDER BY fecha ASC;"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        27472,
        7632
      ],
      "id": "88f6fc6d-f543-435a-b525-440528feb532",
      "name": "Recupera todos los mensajes1",
      "alwaysOutputData": true,
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE CitasRecepcion\nSET chat_historial = '{{ \n  $items(\"Code integracion de mensajes\")\n    .map(i => i.json.historialMensajes)\n    .join(\"\\n\")\n    .replace(/'/g, \"''\")\n}}'\nWHERE id = '{{ \n  $('Microsoft SQL Insertar Cita').isExecuted\n    ? $('Microsoft SQL Insertar Cita').first().json.id\n    : $('Microsoft SQL Insertar Cita1').isExecuted\n      ? $('Microsoft SQL Insertar Cita1').first().json.id\n      : $('Microsoft SQL Obtener Cita').isExecuted\n        ? $('Microsoft SQL Obtener Cita').first().json.id\n        : $('Code Datos Cancelar Cita').first().json.id \n}}';"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        27904,
        7632
      ],
      "id": "d7b37ea1-5239-43cf-874e-c40a3468d093",
      "name": "Microsoft SQL Actualiza la Cita",
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Nodo Code: Validaci√≥n de datos para reprogramaci√≥n de citas\n// Recibe los datos extra√≠dos del nodo LLM y aplica las validaciones de negocio\n\n// Obtener los datos del nodo anterior usando la ruta espec√≠fica\nconst datosExtraidos = $('Basic LLM Extracci√≥n y Validacion de Datos Editar Cita').first().json.output;\n\n// Mostrar datos extra√≠dos para debug\nconsole.log(\"Datos recibidos del nodo anterior:\", JSON.stringify(datosExtraidos, null, 2));\n\n// Funci√≥n principal que procesa los datos de entrada\nfunction procesarDatosReprogramacion(datos) {\n  try {\n    // Estructura de respuesta final (siguiendo el formato del prompt original)\n    const respuesta = {\n      todoCorrecto: false,\n      datosPreviamenteConfirmados: false,\n      idCita: datos.idCita || \"\",\n      ordenCompra: datos.ordenCompra || \"\",\n      nuevaFecha: datos.nuevaFecha || \"\",\n      nuevaHora: datos.nuevaHora || \"\",\n      camposFaltantes: datos.camposFaltantes || [],\n      mensajeSistema: \"\",\n      rechazoTemporal: false,\n      motivoRechazo: \"\",\n      intentaModificarDatos: false\n    };\n\n    console.log(\"Datos iniciales en respuesta:\", JSON.stringify(respuesta, null, 2));\n\n    // 1. Verificar si hay campos faltantes\n    if (respuesta.camposFaltantes && respuesta.camposFaltantes.length > 0) {\n      respuesta.todoCorrecto = false;\n      respuesta.mensajeSistema = generarMensajeCamposFaltantes(respuesta.camposFaltantes);\n      return respuesta;\n    }\n\n    // 2. Validar las fechas y reglas temporales\n    const validacionTemporal = validarReglasTemporales(respuesta.nuevaFecha, datos.fechaActual, datos.horaActual);\n    console.log(\"Resultado de validaci√≥n temporal:\", JSON.stringify(validacionTemporal, null, 2));\n    \n    if (validacionTemporal.esValido === false) {\n      respuesta.todoCorrecto = false;\n      respuesta.rechazoTemporal = true;\n      respuesta.motivoRechazo = validacionTemporal.motivoRechazo;\n      respuesta.mensajeSistema = validacionTemporal.mensaje;\n      return respuesta;\n    }\n\n    // 3. Si todo est√° correcto, preparar mensaje de confirmaci√≥n\n    respuesta.todoCorrecto = true;\n    respuesta.mensajeSistema = `Entendido. Est√°s solicitando reprogramar la cita üîñ ${respuesta.idCita} con orden de compra ${respuesta.ordenCompra} para el ${respuesta.nuevaFecha} a las ${respuesta.nuevaHora}. Verificar√© la disponibilidad para este horario.`;\n    \n    return respuesta;\n  } catch (error) {\n    console.error(\"Error al procesar datos de reprogramaci√≥n:\", error);\n    return {\n      todoCorrecto: false,\n      datosPreviamenteConfirmados: false,\n      idCita: datos.idCita || \"\",\n      ordenCompra: datos.ordenCompra || \"\",\n      nuevaFecha: datos.nuevaFecha || \"\",\n      nuevaHora: datos.nuevaHora || \"\",\n      camposFaltantes: [\"error_procesamiento\"],\n      mensajeSistema: \"Ha ocurrido un error al procesar tu solicitud. Por favor, intenta nuevamente proporcionando todos los datos necesarios.\",\n      rechazoTemporal: false,\n      motivoRechazo: \"error_sistema\",\n      intentaModificarDatos: false\n    };\n  }\n}\n\n// Genera mensaje para campos faltantes\nfunction generarMensajeCamposFaltantes(camposFaltantes) {\n  let mensaje = \"Para poder reprogramar tu cita, necesito \";\n  \n  if (camposFaltantes.includes(\"idCita\")) {\n    mensaje += \"el n√∫mero de cita üîñ que aparece en tu confirmaci√≥n anterior, \";\n  }\n  \n  if (camposFaltantes.includes(\"ordenCompra\")) {\n    mensaje += \"el n√∫mero de orden de compra para verificaci√≥n, \";\n  }\n  \n  if (camposFaltantes.includes(\"nuevaFecha\")) {\n    mensaje += \"la nueva fecha que prefieres, \";\n  }\n  \n  if (camposFaltantes.includes(\"nuevaHora\")) {\n    mensaje += \"la nueva hora que prefieres, \";\n  }\n  \n  mensaje = mensaje.slice(0, -2) + \". \";\n  mensaje += \"Por ejemplo: 'Quiero reprogramar mi cita 12345 con orden de compra ARGM47896 para el 20 de mayo a las 10:00 AM'.\";\n  \n  return mensaje;\n}\n\n// Validar reglas temporales (mismo d√≠a, d√≠a siguiente, etc.)\nfunction validarReglasTemporales(nuevaFecha, fechaActual, horaActual) {\n  try {\n    console.log(`Validando fechas - Nueva: ${nuevaFecha}, Actual: ${fechaActual}, Hora: ${horaActual}`);\n    \n    // Convertir fechas a objetos Date para comparaci√≥n\n    const fechaNueva = parsearFecha(nuevaFecha);\n    const fechaHoy = parsearFechaActual(fechaActual);\n    \n    console.log(`Fechas parseadas - Nueva: ${fechaNueva.toISOString()}, Hoy: ${fechaHoy.toISOString()}`);\n    \n    // Calcular fecha de ma√±ana\n    const fechaManana = new Date(fechaHoy);\n    fechaManana.setDate(fechaManana.getDate() + 1);\n    console.log(`Fecha ma√±ana: ${fechaManana.toISOString()}`);\n    \n    // 1. Validar si es el mismo d√≠a\n    if (\n      fechaNueva.getFullYear() === fechaHoy.getFullYear() &&\n      fechaNueva.getMonth() === fechaHoy.getMonth() &&\n      fechaNueva.getDate() === fechaHoy.getDate()\n    ) {\n      console.log(\"Es el mismo d√≠a - RECHAZADO\");\n      return {\n        esValido: false,\n        motivoRechazo: \"mismo_dia\",\n        mensaje: \"Lo siento, pero no es posible reprogramar citas para el mismo d√≠a. Por pol√≠ticas internas, las modificaciones deben hacerse con al menos un d√≠a de anticipaci√≥n. Por favor, selecciona una fecha futura a partir de ma√±ana.\"\n      };\n    }\n    \n    // 2. Validar si es el d√≠a siguiente y es despu√©s de las 4:30 PM\n    const esMa√±ana = \n      fechaNueva.getFullYear() === fechaManana.getFullYear() &&\n      fechaNueva.getMonth() === fechaManana.getMonth() &&\n      fechaNueva.getDate() === fechaManana.getDate();\n    \n    const esTarde = esHoraPosteriorA430PM(horaActual);\n    \n    console.log(`Es ma√±ana: ${esMa√±ana}, Es tarde (post 4:30pm): ${esTarde}`);\n    \n    if (esMa√±ana && esTarde) {\n      console.log(\"Es para ma√±ana despu√©s de las 4:30 PM - RECHAZADO\");\n      return {\n        esValido: false,\n        motivoRechazo: \"tarde_para_manana\",\n        mensaje: `Lo siento, pero no es posible reprogramar citas para ma√±ana despu√©s de las 4:30 PM del d√≠a actual. Por favor, selecciona una fecha a partir del ${formatearFecha(new Date(fechaManana.getTime() + 86400000))}. Las modificaciones para el d√≠a siguiente solo pueden realizarse antes de las 4:30 PM.`\n      };\n    }\n    \n    // Si pasa todas las validaciones\n    console.log(\"Validaci√≥n temporal APROBADA\");\n    return {\n      esValido: true\n    };\n  } catch (error) {\n    console.error(\"Error al validar reglas temporales:\", error);\n    return {\n      esValido: true // En caso de error, permitimos continuar para no bloquear al usuario\n    };\n  }\n}\n\n// Funciones auxiliares para manipulaci√≥n de fechas\n\n// Parsea una fecha en formato \"DD de mes de YYYY\"\nfunction parsearFecha(fechaStr) {\n  try {\n    console.log(`Parseando fecha: \"${fechaStr}\"`);\n    const partes = fechaStr.split(\" de \");\n    \n    if (partes.length < 3) {\n      console.error(`Formato de fecha incorrecto: \"${fechaStr}\"`);\n      return new Date(); // Devolver fecha actual en caso de error de formato\n    }\n    \n    const dia = parseInt(partes[0], 10);\n    \n    const meses = {\n      \"enero\": 0, \"febrero\": 1, \"marzo\": 2, \"abril\": 3, \"mayo\": 4, \"junio\": 5,\n      \"julio\": 6, \"agosto\": 7, \"septiembre\": 8, \"octubre\": 9, \"noviembre\": 10, \"diciembre\": 11\n    };\n    \n    const mes = meses[partes[1].toLowerCase()];\n    const anio = parseInt(partes[2], 10);\n    \n    console.log(`D√≠a: ${dia}, Mes: ${mes}, A√±o: ${anio}`);\n    \n    if (isNaN(dia) || mes === undefined || isNaN(anio)) {\n      console.error(`Valores de fecha inv√°lidos: d√≠a=${dia}, mes=${mes}, a√±o=${anio}`);\n      return new Date();\n    }\n    \n    return new Date(anio, mes, dia);\n  } catch (error) {\n    console.error(\"Error al parsear fecha:\", error);\n    return new Date(); // Devuelve fecha actual en caso de error\n  }\n}\n\n// Parsea la fecha actual en formato YYYY-MM-DD\nfunction parsearFechaActual(fechaStr) {\n  try {\n    console.log(`Parseando fecha actual: \"${fechaStr}\"`);\n    \n    if (!fechaStr || typeof fechaStr !== 'string') {\n      console.error(`Formato de fecha actual inv√°lido: \"${fechaStr}\"`);\n      return new Date();\n    }\n    \n    const [anio, mes, dia] = fechaStr.split(\"-\").map(num => parseInt(num, 10));\n    \n    if (isNaN(anio) || isNaN(mes) || isNaN(dia)) {\n      console.error(`Valores de fecha actual inv√°lidos: a√±o=${anio}, mes=${mes}, d√≠a=${dia}`);\n      return new Date();\n    }\n    \n    return new Date(anio, mes - 1, dia); // Restar 1 al mes porque en JS los meses van de 0-11\n  } catch (error) {\n    console.error(\"Error al parsear fecha actual:\", error);\n    return new Date(); // Devuelve fecha actual en caso de error\n  }\n}\n\n// Verifica si la hora es posterior a las 4:30 PM\nfunction esHoraPosteriorA430PM(horaStr) {\n  try {\n    console.log(`Verificando si hora es posterior a 4:30 PM: \"${horaStr}\"`);\n    \n    if (!horaStr || typeof horaStr !== 'string') {\n      console.error(`Formato de hora inv√°lido: \"${horaStr}\"`);\n      return false;\n    }\n    \n    // Convierte la hora a minutos para facilitar la comparaci√≥n\n    let horas = 0;\n    let minutos = 0;\n    \n    // Manejar varios formatos posibles de hora\n    if (horaStr.includes(\":\")) {\n      // Formato HH:MM (am/pm)\n      const [hora, resto] = horaStr.split(\":\");\n      horas = parseInt(hora, 10);\n      \n      // Extraer minutos y posible AM/PM\n      if (resto.toLowerCase().includes(\"p.m.\") || resto.toLowerCase().includes(\"pm\")) {\n        if (horas !== 12) horas += 12; // Convertir a formato 24h\n        minutos = parseInt(resto.replace(/[^\\d]/g, \"\"), 10);\n      } else {\n        if (horas === 12) horas = 0; // Mediod√≠a en formato 12h es 0 en formato 24h\n        minutos = parseInt(resto.replace(/[^\\d]/g, \"\"), 10);\n      }\n    } else {\n      // Intentar otros formatos\n      const match = horaStr.match(/(\\d+)(?:\\D+)(\\d*)\\s*([ap]\\.?m\\.?)?/i);\n      if (match) {\n        horas = parseInt(match[1], 10);\n        minutos = match[2] ? parseInt(match[2], 10) : 0;\n        \n        const periodo = match[3] ? match[3].toLowerCase() : \"\";\n        if (periodo.includes(\"p\")) {\n          if (horas !== 12) horas += 12;\n        } else if (periodo.includes(\"a\") && horas === 12) {\n          horas = 0;\n        }\n      }\n    }\n    \n    // Convertir todo a minutos\n    const totalMinutos = horas * 60 + minutos;\n    console.log(`Hora convertida a minutos: ${totalMinutos} (${horas}:${minutos})`);\n    \n    // 4:30 PM = 16:30 = 990 minutos\n    return totalMinutos > 990;\n    \n  } catch (error) {\n    console.error(\"Error al evaluar la hora:\", error);\n    return false; // En caso de error, asumimos que no es despu√©s de las 4:30 PM\n  }\n}\n\n// Formatea una fecha como \"DD de mes de YYYY\"\nfunction formatearFecha(fecha) {\n  try {\n    const dia = fecha.getDate();\n    \n    const meses = [\n      \"enero\", \"febrero\", \"marzo\", \"abril\", \"mayo\", \"junio\",\n      \"julio\", \"agosto\", \"septiembre\", \"octubre\", \"noviembre\", \"diciembre\"\n    ];\n    \n    const mes = meses[fecha.getMonth()];\n    const anio = fecha.getFullYear();\n    \n    return `${dia} de ${mes} de ${anio}`;\n  } catch (error) {\n    console.error(\"Error al formatear fecha:\", error);\n    return \"\"; // Devuelve string vac√≠o en caso de error\n  }\n}\n\n// Aplicar la funci√≥n principal a los datos extra√≠dos\nconst resultado = procesarDatosReprogramacion(datosExtraidos);\nconsole.log(\"Resultado final:\", JSON.stringify(resultado, null, 2));\n\n// Devolver el resultado procesado\nreturn resultado;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1408,
        5152
      ],
      "id": "22d14df6-ab88-4533-9e7c-ce9e8e7a989b",
      "name": "Code Validaci√≥n de datos para reprogramaci√≥n de citas"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.1,
      "position": [
        27392,
        7888
      ],
      "id": "08032ca1-6a9c-437f-a437-9aa8abe52c03",
      "name": "Merge3"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "BEGIN TRANSACTION;\n\nDELETE FROM MensajesWhatsApp\nWHERE chat_id = '{{ $('Unificaci√≥n y consistencia de datos').first().json.infoMensaje.chat_id }}'\n   OR (chat_id = 'agenteAI'\n       AND message_id IN (\n           SELECT message_id \n           FROM MensajesWhatsApp\n           WHERE chat_id = '{{ $('Unificaci√≥n y consistencia de datos').first().json.infoMensaje.chat_id }}'\n       )\n   );\n\nDELETE FROM FranjasDisponiblesTemp \nWHERE chat_id = '{{ $('Unificaci√≥n y consistencia de datos').first().json.infoMensaje.chat_id }}';\n\nCOMMIT;"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        27600,
        7888
      ],
      "id": "508d17cd-be11-470e-acc7-52f4543be083",
      "name": "Microsoft SQL Eliminar Mensajes3",
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        27824,
        7888
      ],
      "id": "73ee652d-63d5-44a8-99e9-67e58fb75828",
      "name": "No Operation, do nothing12"
    },
    {
      "parameters": {
        "url": "https://graph.microsoft.com/v1.0/sites/a592f886-4560-4e62-9646-1eee7add7abe/drives/b!hviSpWBFYk6WRh7uet16vnNAUYuuQRlGj3ZyS9kSvGVZ4DSg6c5MRqYYm2MdAER8/items/01PPLUUYXY5E2GK3SJ25EZLJPUYJ43H3ME/content",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "microsoftOAuth2Api",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "file",
              "outputPropertyName": "ExcelMallaRecibido2025"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -400,
        4912
      ],
      "id": "c61b3de8-b930-4d2e-8232-426badf7ab3b",
      "name": "HTTP Request MALLA DE RECIBO 2",
      "credentials": {
        "microsoftOAuth2Api": {
          "id": "mh8Z8hxFvd7LDO8D",
          "name": "CuentaMy SharePoint App Desarrollador1 Konfie "
        }
      }
    },
    {
      "parameters": {
        "operation": "xlsx",
        "binaryPropertyName": "ExcelMallaRecibido2025",
        "options": {
          "sheetName": "={{ $('Unificaci√≥n y consistencia de datos').item.json.hojaSeleccionada }}"
        }
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -144,
        4784
      ],
      "id": "a7aa3072-7f66-460c-95c2-d5883446ad63",
      "name": "Extract MALLA DE RECIBO 2"
    },
    {
      "parameters": {
        "jsCode": "// Obtener los datos del Excel\nconst excelData = $input.all();\nconst hojaSeleccionada = $('Unificaci√≥n y consistencia de datos').first().json.hojaSeleccionada;\n\n// Obtener hora local en Bogot√°\nconst ahora = new Date(new Date().toLocaleString(\"en-US\", { timeZone: \"America/Bogota\" }));\nconst diaSemanaActual = ahora.getDay(); // 0=domingo, 1=lunes, ..., 5=viernes\nconst horaActual = ahora.getHours();\nconst minutosActual = ahora.getMinutes();\n// Determinar si es despu√©s de las 16:30\nconst pasoLimiteDia = horaActual > 16 || (horaActual === 16 && minutosActual >= 30);\n\n// Definir estructura de la semana y los d√≠as\nconst diasSemana = ['lunes', 'martes', 'mi√©rcoles', 'jueves', 'viernes'];\n\n// Mapeo para saber qu√© d√≠as incluir si hoy es x d√≠a y pas√≥ el l√≠mite\n/**\n * Dado el d√≠a de la semana actual (0=domingo ... 6=s√°bado),\n * devuelve qu√© d√≠as de la semana actual deben incluirse seg√∫n si pas√≥ el l√≠mite.\n */\nfunction diasValidosSemanaActual(diaSemanaActual, pasoLimite) {\n  const mapa = {\n    1: ['martes', 'mi√©rcoles', 'jueves', 'viernes'],   // lunes\n    2: ['mi√©rcoles', 'jueves', 'viernes'],             // martes\n    3: ['jueves', 'viernes'],                          // mi√©rcoles\n    4: ['viernes'],                                     // jueves\n    5: []                                               // viernes (muy tarde para s√°bado)\n  };\n  if (diaSemanaActual < 1 || diaSemanaActual > 5) {\n    return []; // s√°bado o domingo no se agendan en semana actual\n  }\n  if (!pasoLimite) {\n    // a√∫n est√° antes de las 4:30 p.m., se puede incluir el d√≠a siguiente\n    const siguiente = diasSemana[diaSemanaActual];\n    return [siguiente, ...mapa[diaSemanaActual]];\n  }\n  return mapa[diaSemanaActual];\n}\n\n// Objeto para almacenar la malla estructurada\nconst mallaEstructurada = {\n  titulo: \"\",\n  a√±o: \"\",\n  semana: \"\",\n  rangoDias: \"\",\n  franjas: [],\n  dias: {}\n};\n\n// Tabla de meses y d√≠as. Ajusta si necesitas contemplar bisiestos, etc.\nconst meses = {\n  \"enero\": 1,\n  \"febrero\": 2,\n  \"marzo\": 3,\n  \"abril\": 4,\n  \"mayo\": 5,\n  \"junio\": 6,\n  \"julio\": 7,\n  \"agosto\": 8,\n  \"septiembre\": 9,\n  \"octubre\": 10,\n  \"noviembre\": 11,\n  \"diciembre\": 12\n};\n\nconst nombreMes = {\n  1: \"enero\",\n  2: \"febrero\",\n  3: \"marzo\",\n  4: \"abril\",\n  5: \"mayo\",\n  6: \"junio\",\n  7: \"julio\",\n  8: \"agosto\",\n  9: \"septiembre\",\n  10: \"octubre\",\n  11: \"noviembre\",\n  12: \"diciembre\"\n};\n\n/**\n * Funci√≥n para determinar si un a√±o es bisiesto\n * Un a√±o es bisiesto si es divisible por 4, excepto aquellos divisibles por 100 \n * que no son divisibles por 400\n */\nfunction esBisiesto(year) {\n  return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);\n}\n\n/**\n * Funci√≥n para obtener el n√∫mero de d√≠as en un mes, considerando a√±os bisiestos\n */\nfunction getDiasMes(mes, a√±o) {\n  const diasPorMes = {\n    1: 31, // enero\n    2: esBisiesto(a√±o) ? 29 : 28, // febrero - ajustado para a√±o bisiesto\n    3: 31, // marzo\n    4: 30, // abril\n    5: 31, // mayo\n    6: 30, // junio\n    7: 31, // julio\n    8: 31, // agosto\n    9: 30, // septiembre\n    10: 31, // octubre\n    11: 30, // noviembre\n    12: 31  // diciembre\n  };\n  \n  return diasPorMes[mes];\n}\n\n/**\n * Funci√≥n para eliminar acentos y pasar a min√∫sculas (para buscar palabras clave sin importar tildes ni may√∫sculas).\n */\nfunction normalizarTexto(texto) {\n  if (typeof texto !== 'string') return \"\";\n  // Normaliza (NFD) y elimina diacr√≠ticos, luego pasa a min√∫sculas.\n  return texto\n    .normalize(\"NFD\")\n    .replace(/[\\u0300-\\u036f]/g, \"\") // quita acentos\n    .toLowerCase();\n}\n\n/**\n * Dada la informaci√≥n de proveedor, ordenCompra, peso, categor√≠a y unidades,\n * revisa si existe la palabra 'fuera de servicio', 'cancelado' o 'reagendado'\n * en cualquiera de esos campos. De ser as√≠, retorna ese estado especial;\n * de lo contrario, retorna 'ocupado'.\n * \n * Se ignoran may√∫sculas, min√∫sculas y tildes.\n */\nfunction determinarEstadoOcupado(proveedor, ordenCompra, peso, categoria, unidades) {\n  const conjunto = `${proveedor} ${ordenCompra} ${peso} ${categoria} ${unidades}`;\n  const texto = normalizarTexto(conjunto);\n\n  if (texto.includes(\"fuera de servicio\")) {\n    return \"fuera de servicio\";\n  }\n  if (texto.includes(\"cancelado\")) {\n    return \"cancelado\";\n  }\n  if (texto.includes(\"reagendado\")) {\n    return \"reagendado\";\n  }\n  return \"ocupado\";  \n}\n\n// -------------------------------------------------------------\n// 1) PROCESAR DATOS (Cabecera, Horas, Muelles, etc.)\n// -------------------------------------------------------------\nfunction procesarDatos(excelData) {\n  const datos = excelData.map(item => item.json);\n  \n  // A) Cabecera (T√≠tulo, A√±o, Rango)\n  datos.forEach((dato, index) => {\n    // Buscar t√≠tulo\n    if (dato.__EMPTY_2 === \"MALLA DE RECIBO CEDI KONFIE IA\") {\n      mallaEstructurada.titulo = dato.__EMPTY_2;\n      \n      // En la siguiente fila puede estar a√±o, semana, rango\n      if (index + 1 < datos.length) {\n        const datoSiguiente = datos[index + 1];\n        if (datoSiguiente) {\n          // A√±o\n          if (datoSiguiente.__EMPTY_2 && !isNaN(datoSiguiente.__EMPTY_2)) {\n            mallaEstructurada.a√±o = datoSiguiente.__EMPTY_2;\n          }\n          // Semana\n          Object.entries(datoSiguiente).forEach(([k, v]) => {\n            if (typeof v === 'string' && v.includes(\"SEMANA\")) {\n              mallaEstructurada.semana = v;\n            }\n          });\n          // Rango: p.ej. \"LUNES 31 AL VIERNES 4 DE ABRIL\"\n          Object.entries(datoSiguiente).forEach(([k, v]) => {\n            if (typeof v === 'string' && v.includes(\"LUNES\") && v.includes(\"VIERNES\")) {\n              mallaEstructurada.rangoDias = v;\n            }\n          });\n        }\n      }\n    }\n  });\n  \n  // B) Detectar franjas horarias (.__EMPTY = fracci√≥n de d√≠a)\n  const franjasHorarias = [];\n  datos.forEach(dato => {\n    if (\n      dato.__EMPTY !== undefined &&\n      typeof dato.__EMPTY === 'number' &&\n      dato.__EMPTY > 0 &&\n      dato.__EMPTY < 1\n    ) {\n      const totalMin = Math.round(dato.__EMPTY * 24 * 60);\n      const hh = Math.floor(totalMin / 60);\n      const mm = totalMin % 60;\n      \n      let periodo = \"AM\";\n      let hora12 = hh;\n      if (hh >= 12) {\n        periodo = \"PM\";\n        hora12 = (hh === 12 ? 12 : hh - 12);\n      }\n      if (hh === 0) {\n        hora12 = 12;\n      }\n      \n      const horaStr = `${hora12}:${String(mm).padStart(2, '0')} ${periodo}`;\n      franjasHorarias.push({\n        hora: horaStr,\n        indice: datos.indexOf(dato) // fila base\n      });\n    }\n  });\n  franjasHorarias.sort((a, b) => a.indice - b.indice);\n  mallaEstructurada.franjas = franjasHorarias;\n  \n  // C) Detectar muelles (col)\n  const muellesInfo = {};\n  datos.forEach(dato => {\n    Object.entries(dato).forEach(([key, value]) => {\n      if (value === \"MUELLE 01\" || value === \"MUELLE 02\") {\n        const col = parseInt(key.replace(\"__EMPTY_\", \"\"), 10);\n        const muelleKey = (value === \"MUELLE 01\") ? 'muelle1' : 'muelle2';\n        if (!muellesInfo[muelleKey]) {\n          muellesInfo[muelleKey] = [];\n        }\n        muellesInfo[muelleKey].push(col);\n      }\n    });\n  });\n  if (muellesInfo.muelle1) muellesInfo.muelle1.sort((a, b) => a - b);\n  if (muellesInfo.muelle2) muellesInfo.muelle2.sort((a, b) => a - b);\n  \n  // D) Generar los 5 d√≠as (lunes-viernes) con su fecha\n  parsearRangoDias();\n  \n  // E) Extraer Citas\n  extraerCitas(datos, muellesInfo);\n  \n  return mallaEstructurada;\n}\n\n/**\n * Parsea la cadena \"LUNES 31 AL VIERNES 4 DE ABRIL\"\n * (o \"LUNES 31 AL VIERNES 04 DE ABRIL\") y maneja el cruce de mes.\n * Ej.: si dayStart=31 y dayEnd=4, la 1¬™ fecha es 31 de MARZO,\n * luego 1,2,3,4 de ABRIL, en vez de 32,33, etc.\n */\nfunction parsearRangoDias() {\n  const texto = mallaEstructurada.rangoDias;\n  // Regex simple: p.ej. \"31 AL ... 4 DE ABRIL\"\n  // Captura: dayStart, dayEnd, mesFin\n  // Ojo: si dice \"LUNES 31 DE MARZO AL VIERNES 4 DE ABRIL\",\n  // quedar√°: dayStart=31, dayEnd=4, month=ABRIL (al final).\n  const regex = /(\\d+)\\s+AL\\s+\\D+(\\d+)\\s+DE\\s+(\\w+)/i;\n  const match = regex.exec(texto);\n  \n  // Por defecto, creamos 5 d√≠as vac√≠os sin fecha\n  diasSemana.forEach(d => {\n    mallaEstructurada.dias[d] = {\n      muelle1: {},\n      muelle2: {}\n    };\n  });\n  \n  if (!match) {\n    // Sin coincidencia, dejamos los d√≠as sin fecha\n    return;\n  }\n  \n  const dayStart = parseInt(match[1], 10); // 31\n  const dayEnd   = parseInt(match[2], 10); // 4\n  const finalMonthName = match[3].toLowerCase(); // \"abril\"\n  \n  // Convertimos a n√∫mero\n  const finalMonth = meses[finalMonthName] || 3; // fallback marzo\n  const yearNum = parseInt(mallaEstructurada.a√±o, 10) || 2025;\n  \n  // Funci√≥n para obtener la fecha formateada\n  function fechaFormateada(d, m, y) {\n    return `${d} de ${nombreMes[m]} de ${y}`;\n  }\n  \n  // Comprobamos cu√°ntos d√≠as tiene el mes final, considerando bisiestos\n  const diasMesFinal = getDiasMes(finalMonth, yearNum);\n  // y del mes previo\n  const monthPrev = (finalMonth === 1) ? 12 : finalMonth - 1;\n  const yearPrev = (finalMonth === 1) ? yearNum - 1 : yearNum;\n  \n  // Arreglo final con 5 fechas\n  const fechasDias = [];\n  \n  if (dayStart <= dayEnd) {\n    // Caso \"normal\": todo en el mismo mes\n    let d = dayStart;\n    for (let i = 0; i < 5; i++) {\n      fechasDias.push({\n        diaSem: diasSemana[i],\n        diaNum: d,\n        mesNum: finalMonth,\n        yearNum: yearNum\n      });\n      d++;\n      if (d > diasMesFinal) {\n        d = 1;\n        const nextMonth = finalMonth % 12 + 1;\n        const nextYear = (nextMonth === 1) ? yearNum + 1 : yearNum;\n        fechasDias[fechasDias.length - 1].mesNum = nextMonth;\n        fechasDias[fechasDias.length - 1].yearNum = nextYear;\n      }\n    }\n  } else {\n    // Caso \"cruza de mes\": dayStart > dayEnd\n    let d = dayStart;\n    let m = monthPrev;\n    let y = yearPrev;\n    \n    for (let i = 0; i < 5; i++) {\n      fechasDias.push({\n        diaSem: diasSemana[i],\n        diaNum: d,\n        mesNum: m,\n        yearNum: y\n      });\n      d++;\n      if (d > getDiasMes(m, y)) {\n        d = 1;\n        m = m % 12 + 1;\n        if (m === 1) {\n          y++;\n        }\n      }\n    }\n  }\n  \n  // Ahora volcamos esas 5 fechas en la estructura\n  fechasDias.forEach(fd => {\n    const { diaSem, diaNum, mesNum, yearNum } = fd;\n    mallaEstructurada.dias[diaSem] = {\n      fechaDia: fechaFormateada(diaNum, mesNum, yearNum),\n      muelle1: {},\n      muelle2: {}\n    };\n  });\n  \n  // Inicializamos las franjas a 'disponible'\n  if (mallaEstructurada.franjas.length > 0) {\n    diasSemana.forEach(d => {\n      mallaEstructurada.franjas.forEach(f => {\n        mallaEstructurada.dias[d].muelle1[f.hora] = {\n          estado: \"disponible\",\n          proveedor: \"\",\n          ordenCompra: \"\",\n          peso: \"\",\n          categoria: \"\",\n          unidades: \"\"\n        };\n        mallaEstructurada.dias[d].muelle2[f.hora] = {\n          estado: \"disponible\",\n          proveedor: \"\",\n          ordenCompra: \"\",\n          peso: \"\",\n          categoria: \"\",\n          unidades: \"\"\n        };\n      });\n    });\n  }\n}\n\n/**\n * Funci√≥n auxiliar: decide a qu√© d√≠a pertenece una columna,\n * corrigiendo 2 columnas de offset (porque 'Extract from XLSX'\n * deja todo desplazado).\n */\nfunction getDayForColumn(colNumber) {\n  // Ajuste de offset +2\n  const realCol = colNumber + 2;\n\n  // Rangos:\n  //  Lunes:      3..8\n  //  Martes:     9..14\n  //  Mi√©rcoles: 15..20\n  //  Jueves:    21..26\n  //  Viernes:   27..32\n  if (realCol >= 3 && realCol <= 8) {\n    return \"lunes\";\n  }\n  if (realCol >= 9 && realCol <= 14) {\n    return \"martes\";\n  }\n  if (realCol >= 15 && realCol <= 20) {\n    return \"mi√©rcoles\";\n  }\n  if (realCol >= 21 && realCol <= 26) {\n    return \"jueves\";\n  }\n  if (realCol >= 27 && realCol <= 32) {\n    return \"viernes\";\n  }\n  // Si nada coincide, devolvemos null\n  return null;\n}\n\n/**\n * Extraer las citas para cada franja:\n * - Para cada franja, miramos 3 filas:\n *    - Fila base => proveedor\n *    - Fila base+1 => orden\n *    - Fila base+2 => peso, categor√≠a, unidades\n */\nfunction extraerCitas(datos, muellesInfo) {\n  mallaEstructurada.franjas.forEach(franja => {\n    const indiceBase = franja.indice;\n    if (indiceBase < 0 || indiceBase + 2 >= datos.length) {\n      return; // no hay suficientes filas\n    }\n    \n    // Recorremos muelle1, muelle2 y sus columnas\n    const asignarCita = (muelleKey, cols) => {\n      cols.forEach(col => {\n        const provKey = `__EMPTY_${col}`;\n        const filaProv = datos[indiceBase];\n        \n        // Si en esta fila hay un proveedor o alg√∫n texto\n        if (\n          filaProv &&\n          typeof filaProv[provKey] === 'string' &&\n          filaProv[provKey].length > 2\n        ) {\n          // Determinar el d√≠a real\n          const diaOk = getDayForColumn(col);\n          if (!diaOk || !mallaEstructurada.dias[diaOk]) {\n            return; // si no coincide con ninguno, saltamos\n          }\n          \n          // Recuperar valores para proveedor, ordenCompra y dem√°s\n          const filaOrden = datos[indiceBase + 1];\n          const filaDet = datos[indiceBase + 2];\n          \n          const proveedor = filaProv[provKey] || \"\";\n          const ordenCompra = filaOrden && filaOrden[provKey] ? filaOrden[provKey] : \"\";\n          const peso = filaDet && filaDet[provKey] ? filaDet[provKey] : \"\";\n          const cat  = filaDet && filaDet[`__EMPTY_${col + 1}`] ? filaDet[`__EMPTY_${col + 1}`] : \"\";\n          const und  = filaDet && filaDet[`__EMPTY_${col + 2}`] ? filaDet[`__EMPTY_${col + 2}`] : \"\";\n          \n          // Antes pon√≠amos estado=\"ocupado\" directamente\n          // Ahora verificamos si el texto contiene \"reagendado\", \"cancelado\" o \"fuera de servicio\".\n          const nuevoEstado = determinarEstadoOcupado(proveedor, ordenCompra, peso, cat, und);\n          \n          // Asignamos los datos\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].estado = nuevoEstado;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].proveedor = proveedor;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].ordenCompra = ordenCompra;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].peso = peso;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].categoria = cat;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].unidades = und;\n        }\n      });\n    };\n    \n    if (muellesInfo.muelle1) {\n      asignarCita('muelle1', muellesInfo.muelle1);\n    }\n    if (muellesInfo.muelle2) {\n      asignarCita('muelle2', muellesInfo.muelle2);\n    }\n  });\n}\n\n// -------------------------------------------------------------\n// 2) FUNCIONES PARA CONSULTAR LA MALLA\n// -------------------------------------------------------------\nfunction buscarFranjasDisponibles(categoria, duracionHoras) {\n  const muelle = \"muelle1\"; // Ajusta si usas \"categoria -> muelle\" real\n  \n  const franjasDisponibles = [];\n  Object.keys(mallaEstructurada.dias).forEach(dia => {\n    const libres = [];\n    for (let i = 0; i <= mallaEstructurada.franjas.length - duracionHoras; i++) {\n      let disponible = true;\n      for (let h = 0; h < duracionHoras; h++) {\n        const idxF = i + h;\n        const horaAct = mallaEstructurada.franjas[idxF].hora;\n        if (\n          mallaEstructurada.dias[dia][muelle][horaAct].estado !== 'disponible'\n        ) {\n          disponible = false;\n          break;\n        }\n      }\n      if (disponible) {\n        libres.push({\n          horaInicio: mallaEstructurada.franjas[i].hora,\n          duracion: duracionHoras\n        });\n      }\n    }\n    if (libres.length > 0) {\n      franjasDisponibles.push({ dia, franjas: libres });\n    }\n  });\n  return franjasDisponibles;\n}\n\nfunction buscarCitasProveedor(nombreProveedor) {\n  const citas = [];\n  Object.keys(mallaEstructurada.dias).forEach(dia => {\n    const muelle1 = mallaEstructurada.dias[dia].muelle1;\n    const muelle2 = mallaEstructurada.dias[dia].muelle2;\n    mallaEstructurada.franjas.forEach(f => {\n      const hora = f.hora;\n      // muelle1\n      if (normalizarTexto(muelle1[hora].proveedor) === normalizarTexto(nombreProveedor)) {\n        citas.push({\n          dia,\n          hora,\n          muelle: \"Muelle 01\",\n          ordenCompra: muelle1[hora].ordenCompra,\n          peso: muelle1[hora].peso,\n          categoria: muelle1[hora].categoria,\n          unidades: muelle1[hora].unidades,\n          estado: muelle1[hora].estado\n        });\n      }\n      // muelle2\n      if (normalizarTexto(muelle2[hora].proveedor) === normalizarTexto(nombreProveedor)) {\n        citas.push({\n          dia,\n          hora,\n          muelle: \"Muelle 02\",\n          ordenCompra: muelle2[hora].ordenCompra,\n          peso: muelle2[hora].peso,\n          categoria: muelle2[hora].categoria,\n          unidades: muelle2[hora].unidades,\n          estado: muelle2[hora].estado\n        });\n      }\n    });\n  });\n  return citas;\n}\n\nfunction consultarFranjasDisponibles(categoria, duracionHoras) {\n  return buscarFranjasDisponibles(categoria, duracionHoras);\n}\n\nfunction consultarCitasProveedor(nombreProveedor) {\n  return buscarCitasProveedor(nombreProveedor);\n}\n\nfunction obtenerInfoMalla() {\n  return {\n    titulo: mallaEstructurada.titulo,\n    a√±o: mallaEstructurada.a√±o,\n    semana: mallaEstructurada.semana,\n    rangoDias: mallaEstructurada.rangoDias,\n    franjas: mallaEstructurada.franjas.map(f => f.hora)\n  };\n}\n\nfunction estaDisponible(dia, hora, muelle) {\n  const info = mallaEstructurada.dias[dia]?.[muelle]?.[hora];\n  return info ? (info.estado === 'disponible') : false;\n}\n\nfunction obtenerCoordenadasCita(dia, hora, muelle) {\n  // Ajustar con tu mapeo de celdas en Excel\n  return {\n    proveedor: `${dia}_${hora}_${muelle}_proveedor`,\n    ordenCompra: `${dia}_${hora}_${muelle}_ordenCompra`,\n    peso: `${dia}_${hora}_${muelle}_peso`,\n    categoria: `${dia}_${hora}_${muelle}_categoria`,\n    unidades: `${dia}_${hora}_${muelle}_unidades`\n  };\n}\n\n// -------------------------------------------------------------\n// 3) EJECUTAR TODO Y RETORNAR\n// -------------------------------------------------------------\n// Procesar todos los datos\nconst malla = procesarDatos(excelData);\n\n// Aplicar el filtro de d√≠as v√°lidos seg√∫n la hora actual\nconst diasPermitidos = diasValidosSemanaActual(diaSemanaActual, pasoLimiteDia);\nObject.keys(malla.dias).forEach(dia => {\n  if (!diasPermitidos.includes(dia)) {\n    delete malla.dias[dia]; // eliminar d√≠as no v√°lidos\n  }\n});\n\nconst resultado = {\n  datosMalla: malla,\n  funciones: {\n    consultarFranjasDisponibles,\n    consultarCitasProveedor,\n    obtenerInfoMalla,\n    estaDisponible,\n    obtenerCoordenadasCita\n  }\n};\n\nreturn [resultado];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        112,
        4784
      ],
      "id": "0535bccb-d477-415f-8a9f-eb77909f1f6f",
      "name": "Estructuraci√≥n, Datos, Consulta, Citas3"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.1,
      "position": [
        432,
        4880
      ],
      "id": "0ee800df-960b-4d8d-96a8-9a8d513a341e",
      "name": "Merge datos Excel3"
    },
    {
      "parameters": {
        "jsCode": "return [{\n  json: {\n    datosMalla: $items(\"Merge datos Excel3\")[0].json.datosMalla,\n    datosMallaProxSemana: $items(\"Merge datos Excel3\")[1].json.datosMallaProxSemana,\n    hojaSeleccionada: $items(\"Merge datos Excel3\")[0].json.datosMalla.semana\n  }\n}];\n\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        672,
        4880
      ],
      "id": "ac45f266-355d-490e-a9c7-f4aa83f717d1",
      "name": "Unificaci√≥n y consistencia de datos4"
    },
    {
      "parameters": {
        "operation": "xlsx",
        "binaryPropertyName": "ExcelMallaRecibido2025",
        "options": {
          "sheetName": "={{    (function() {     const semanaActual = $('Unificaci√≥n y consistencia de datos').item.json.hojaSeleccionada;     const numeroSemana = parseInt(semanaActual.replace(\"SEMANA \", \"\"));     return `SEMANA ${numeroSemana + 1}`;   })() }}"
        }
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -144,
        4992
      ],
      "id": "ec0ef9e6-0117-4025-a29a-60df93346ad5",
      "name": "Extract MALLA DE RECIBO Semana Siguiente3",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Si el nodo anterior no devolvi√≥ datos (por error al no existir la hoja), retornamos estructura vac√≠a con mensaje\n// Obtener los datos del Excel\nconst excelData = $input.all();\n\n// Mejora en la detecci√≥n de errores: verificar si hay error expl√≠cito o si los datos no son v√°lidos\nconst hayError = excelData.some(item => item.json && item.json.error);\nconst datosInvalidos = !excelData || excelData.length === 0 || hayError;\n\nif (datosInvalidos) {\n  return [{\n    datosMallaProxSemana: {\n      titulo: \"‚ö†Ô∏è La malla de la pr√≥xima semana no existe en el archivo Excel o a√∫n no ha sido creada.\",\n      a√±o: \"\",\n      semana: \"\",\n      rangoDias: \"\",\n      franjas: [],\n      dias: {\n        lunes: { muelle1: {}, muelle2: {} },\n        martes: { muelle1: {}, muelle2: {} },\n        mi√©rcoles: { muelle1: {}, muelle2: {} },\n        jueves: { muelle1: {}, muelle2: {} },\n        viernes: { muelle1: {}, muelle2: {} }\n      }\n    },\n    funciones: {\n      consultarFranjasDisponibles: \"function not available\",\n      consultarCitasProveedor: \"function not available\",\n      obtenerInfoMalla: \"function not available\",\n      estaDisponible: \"function not available\",\n      obtenerCoordenadasCita: \"function not available\"\n    }\n  }];\n}\n\n// El resto del c√≥digo permanece igual...\nconst hojaSeleccionada = $('Unificaci√≥n y consistencia de datos').first().json.hojaSeleccionada;\n\n// Definir estructura de la semana y los d√≠as\nconst diasSemana = ['lunes', 'martes', 'mi√©rcoles', 'jueves', 'viernes'];\n\n// Objeto para almacenar la malla estructurada\nconst mallaEstructurada = {\n  titulo: \"\",\n  a√±o: \"\",\n  semana: \"\",\n  rangoDias: \"\",\n  franjas: [],\n  dias: {}\n};\n\n// Tabla de meses y d√≠as. Ajusta si necesitas contemplar bisiestos, etc.\nconst meses = {\n  \"enero\": 1,\n  \"febrero\": 2,\n  \"marzo\": 3,\n  \"abril\": 4,\n  \"mayo\": 5,\n  \"junio\": 6,\n  \"julio\": 7,\n  \"agosto\": 8,\n  \"septiembre\": 9,\n  \"octubre\": 10,\n  \"noviembre\": 11,\n  \"diciembre\": 12\n};\n\nconst nombreMes = {\n  1: \"enero\",\n  2: \"febrero\",\n  3: \"marzo\",\n  4: \"abril\",\n  5: \"mayo\",\n  6: \"junio\",\n  7: \"julio\",\n  8: \"agosto\",\n  9: \"septiembre\",\n  10: \"octubre\",\n  11: \"noviembre\",\n  12: \"diciembre\"\n};\n\n/**\n * Funci√≥n para determinar si un a√±o es bisiesto\n * Un a√±o es bisiesto si es divisible por 4, excepto aquellos divisibles por 100 \n * que no son divisibles por 400\n */\nfunction esBisiesto(year) {\n  return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);\n}\n\n/**\n * Funci√≥n para obtener el n√∫mero de d√≠as en un mes, considerando a√±os bisiestos\n */\nfunction getDiasMes(mes, a√±o) {\n  const diasPorMes = {\n    1: 31, // enero\n    2: esBisiesto(a√±o) ? 29 : 28, // febrero - ajustado para a√±o bisiesto\n    3: 31, // marzo\n    4: 30, // abril\n    5: 31, // mayo\n    6: 30, // junio\n    7: 31, // julio\n    8: 31, // agosto\n    9: 30, // septiembre\n    10: 31, // octubre\n    11: 30, // noviembre\n    12: 31  // diciembre\n  };\n  \n  return diasPorMes[mes];\n}\n\n/**\n * Funci√≥n para eliminar acentos y pasar a min√∫sculas (para buscar palabras clave sin importar tildes ni may√∫sculas).\n */\nfunction normalizarTexto(texto) {\n  if (typeof texto !== 'string') return \"\";\n  // Normaliza (NFD) y elimina diacr√≠ticos, luego pasa a min√∫sculas.\n  return texto\n    .normalize(\"NFD\")\n    .replace(/[\\u0300-\\u036f]/g, \"\") // quita acentos\n    .toLowerCase();\n}\n\n/**\n * Dada la informaci√≥n de proveedor, ordenCompra, peso, categor√≠a y unidades,\n * revisa si existe la palabra 'fuera de servicio', 'cancelado' o 'reagendado'\n * en cualquiera de esos campos. De ser as√≠, retorna ese estado especial;\n * de lo contrario, retorna 'ocupado'.\n * \n * Se ignoran may√∫sculas, min√∫sculas y tildes.\n */\nfunction determinarEstadoOcupado(proveedor, ordenCompra, peso, categoria, unidades) {\n  const conjunto = `${proveedor} ${ordenCompra} ${peso} ${categoria} ${unidades}`;\n  const texto = normalizarTexto(conjunto);\n\n  if (texto.includes(\"fuera de servicio\")) {\n    return \"fuera de servicio\";\n  }\n  if (texto.includes(\"cancelado\")) {\n    return \"cancelado\";\n  }\n  if (texto.includes(\"reagendado\")) {\n    return \"reagendado\";\n  }\n  return \"ocupado\";  \n}\n\n// -------------------------------------------------------------\n// 1) PROCESAR DATOS (Cabecera, Horas, Muelles, etc.)\n// -------------------------------------------------------------\nfunction procesarDatos(excelData) {\n  // Verificaci√≥n adicional de datos v√°lidos\n  if (!excelData || !Array.isArray(excelData) || excelData.length === 0) {\n    return {\n      titulo: \"‚ö†Ô∏è La malla de la pr√≥xima semana no existe en el archivo Excel o a√∫n no ha sido creada.\",\n      a√±o: \"\",\n      semana: \"\",\n      rangoDias: \"\",\n      franjas: [],\n      dias: {\n        lunes: { muelle1: {}, muelle2: {} },\n        martes: { muelle1: {}, muelle2: {} },\n        mi√©rcoles: { muelle1: {}, muelle2: {} },\n        jueves: { muelle1: {}, muelle2: {} },\n        viernes: { muelle1: {}, muelle2: {} }\n      }\n    };\n  }\n  \n  // Intentar mapear datos, con manejo de errores para cada item\n  const datos = excelData.map(item => {\n    try {\n      return item.json || {};\n    } catch (e) {\n      return {};\n    }\n  });\n  \n  // A) Cabecera (T√≠tulo, A√±o, Rango)\n  datos.forEach((dato, index) => {\n    // Buscar t√≠tulo\n    if (dato.__EMPTY_2 === \"MALLA DE RECIBO CEDI KONFIE IA\") {\n      mallaEstructurada.titulo = dato.__EMPTY_2;\n      \n      // En la siguiente fila puede estar a√±o, semana, rango\n      if (index + 1 < datos.length) {\n        const datoSiguiente = datos[index + 1];\n        if (datoSiguiente) {\n          // A√±o\n          if (datoSiguiente.__EMPTY_2 && !isNaN(datoSiguiente.__EMPTY_2)) {\n            mallaEstructurada.a√±o = datoSiguiente.__EMPTY_2;\n          }\n          // Semana\n          Object.entries(datoSiguiente).forEach(([k, v]) => {\n            if (typeof v === 'string' && v.includes(\"SEMANA\")) {\n              mallaEstructurada.semana = v;\n            }\n          });\n          // Rango: p.ej. \"LUNES 31 AL VIERNES 4 DE ABRIL\"\n          Object.entries(datoSiguiente).forEach(([k, v]) => {\n            if (typeof v === 'string' && v.includes(\"LUNES\") && v.includes(\"VIERNES\")) {\n              mallaEstructurada.rangoDias = v;\n            }\n          });\n        }\n      }\n    }\n  });\n  \n  // Si despu√©s de procesar no encontramos t√≠tulo, es que no hay malla v√°lida\n  if (!mallaEstructurada.titulo) {\n    mallaEstructurada.titulo = \"‚ö†Ô∏è La malla de la pr√≥xima semana no existe en el archivo Excel o a√∫n no ha sido creada.\";\n    return mallaEstructurada;\n  }\n  \n  // B) Detectar franjas horarias (.__EMPTY = fracci√≥n de d√≠a)\n  const franjasHorarias = [];\n  datos.forEach(dato => {\n    if (\n      dato.__EMPTY !== undefined &&\n      typeof dato.__EMPTY === 'number' &&\n      dato.__EMPTY > 0 &&\n      dato.__EMPTY < 1\n    ) {\n      const totalMin = Math.round(dato.__EMPTY * 24 * 60);\n      const hh = Math.floor(totalMin / 60);\n      const mm = totalMin % 60;\n      \n      let periodo = \"AM\";\n      let hora12 = hh;\n      if (hh >= 12) {\n        periodo = \"PM\";\n        hora12 = (hh === 12 ? 12 : hh - 12);\n      }\n      if (hh === 0) {\n        hora12 = 12;\n      }\n      \n      const horaStr = `${hora12}:${String(mm).padStart(2, '0')} ${periodo}`;\n      franjasHorarias.push({\n        hora: horaStr,\n        indice: datos.indexOf(dato) // fila base\n      });\n    }\n  });\n  franjasHorarias.sort((a, b) => a.indice - b.indice);\n  mallaEstructurada.franjas = franjasHorarias;\n  \n  // C) Detectar muelles (col)\n  const muellesInfo = {};\n  datos.forEach(dato => {\n    Object.entries(dato).forEach(([key, value]) => {\n      if (value === \"MUELLE 01\" || value === \"MUELLE 02\") {\n        const col = parseInt(key.replace(\"__EMPTY_\", \"\"), 10);\n        const muelleKey = (value === \"MUELLE 01\") ? 'muelle1' : 'muelle2';\n        if (!muellesInfo[muelleKey]) {\n          muellesInfo[muelleKey] = [];\n        }\n        muellesInfo[muelleKey].push(col);\n      }\n    });\n  });\n  if (muellesInfo.muelle1) muellesInfo.muelle1.sort((a, b) => a - b);\n  if (muellesInfo.muelle2) muellesInfo.muelle2.sort((a, b) => a - b);\n  \n  // D) Generar los 5 d√≠as (lunes-viernes) con su fecha\n  parsearRangoDias();\n  \n  // E) Extraer Citas\n  extraerCitas(datos, muellesInfo);\n  \n  return mallaEstructurada;\n}\n\n/**\n * Parsea la cadena \"LUNES 31 AL VIERNES 4 DE ABRIL\"\n * (o \"LUNES 31 AL VIERNES 04 DE ABRIL\") y maneja el cruce de mes.\n * Ej.: si dayStart=31 y dayEnd=4, la 1¬™ fecha es 31 de MARZO,\n * luego 1,2,3,4 de ABRIL, en vez de 32,33, etc.\n */\nfunction parsearRangoDias() {\n  const texto = mallaEstructurada.rangoDias;\n  // Regex simple: p.ej. \"31 AL ... 4 DE ABRIL\"\n  // Captura: dayStart, dayEnd, mesFin\n  // Ojo: si dice \"LUNES 31 DE MARZO AL VIERNES 4 DE ABRIL\",\n  // quedar√°: dayStart=31, dayEnd=4, month=ABRIL (al final).\n  const regex = /(\\d+)\\s+AL\\s+\\D+(\\d+)\\s+DE\\s+(\\w+)/i;\n  const match = regex.exec(texto);\n  \n  // Por defecto, creamos 5 d√≠as vac√≠os sin fecha\n  diasSemana.forEach(d => {\n    mallaEstructurada.dias[d] = {\n      muelle1: {},\n      muelle2: {}\n    };\n  });\n  \n  if (!match) {\n    // Sin coincidencia, dejamos los d√≠as sin fecha\n    return;\n  }\n  \n  const dayStart = parseInt(match[1], 10); // 31\n  const dayEnd   = parseInt(match[2], 10); // 4\n  const finalMonthName = match[3].toLowerCase(); // \"abril\"\n  \n  // Convertimos a n√∫mero\n  const finalMonth = meses[finalMonthName] || 3; // fallback marzo\n  const yearNum = parseInt(mallaEstructurada.a√±o, 10) || 2025;\n  \n  // Funci√≥n para obtener la fecha formateada\n  function fechaFormateada(d, m, y) {\n    return `${d} de ${nombreMes[m]} de ${y}`;\n  }\n  \n  // Comprobamos cu√°ntos d√≠as tiene el mes final, considerando bisiestos\n  const diasMesFinal = getDiasMes(finalMonth, yearNum);\n  // y del mes previo\n  const monthPrev = (finalMonth === 1) ? 12 : finalMonth - 1;\n  const yearPrev = (finalMonth === 1) ? yearNum - 1 : yearNum;\n  \n  // Arreglo final con 5 fechas\n  const fechasDias = [];\n  \n  if (dayStart <= dayEnd) {\n    // Caso \"normal\": todo en el mismo mes\n    let d = dayStart;\n    for (let i = 0; i < 5; i++) {\n      fechasDias.push({\n        diaSem: diasSemana[i],\n        diaNum: d,\n        mesNum: finalMonth,\n        yearNum: yearNum\n      });\n      d++;\n      if (d > diasMesFinal) {\n        d = 1;\n        const nextMonth = finalMonth % 12 + 1;\n        const nextYear = (nextMonth === 1) ? yearNum + 1 : yearNum;\n        fechasDias[fechasDias.length - 1].mesNum = nextMonth;\n        fechasDias[fechasDias.length - 1].yearNum = nextYear;\n      }\n    }\n  } else {\n    // Caso \"cruza de mes\": dayStart > dayEnd\n    let d = dayStart;\n    let m = monthPrev;\n    let y = yearPrev;\n    \n    for (let i = 0; i < 5; i++) {\n      fechasDias.push({\n        diaSem: diasSemana[i],\n        diaNum: d,\n        mesNum: m,\n        yearNum: y\n      });\n      d++;\n      if (d > getDiasMes(m, y)) {\n        d = 1;\n        m = m % 12 + 1;\n        if (m === 1) {\n          y++;\n        }\n      }\n    }\n  }\n  \n  // Ahora volcamos esas 5 fechas en la estructura\n  fechasDias.forEach(fd => {\n    const { diaSem, diaNum, mesNum, yearNum } = fd;\n    mallaEstructurada.dias[diaSem] = {\n      fechaDia: fechaFormateada(diaNum, mesNum, yearNum),\n      muelle1: {},\n      muelle2: {}\n    };\n  });\n  \n  // Inicializamos las franjas a 'disponible'\n  if (mallaEstructurada.franjas.length > 0) {\n    diasSemana.forEach(d => {\n      mallaEstructurada.franjas.forEach(f => {\n        mallaEstructurada.dias[d].muelle1[f.hora] = {\n          estado: \"disponible\",\n          proveedor: \"\",\n          ordenCompra: \"\",\n          peso: \"\",\n          categoria: \"\",\n          unidades: \"\"\n        };\n        mallaEstructurada.dias[d].muelle2[f.hora] = {\n          estado: \"disponible\",\n          proveedor: \"\",\n          ordenCompra: \"\",\n          peso: \"\",\n          categoria: \"\",\n          unidades: \"\"\n        };\n      });\n    });\n  }\n}\n\n/**\n * Funci√≥n auxiliar: decide a qu√© d√≠a pertenece una columna,\n * corrigiendo 2 columnas de offset (porque 'Extract from XLSX'\n * deja todo desplazado).\n */\nfunction getDayForColumn(colNumber) {\n  // Ajuste de offset +2\n  const realCol = colNumber + 2;\n\n  // Rangos:\n  //  Lunes:      3..8\n  //  Martes:     9..14\n  //  Mi√©rcoles: 15..20\n  //  Jueves:    21..26\n  //  Viernes:   27..32\n  if (realCol >= 3 && realCol <= 8) {\n    return \"lunes\";\n  }\n  if (realCol >= 9 && realCol <= 14) {\n    return \"martes\";\n  }\n  if (realCol >= 15 && realCol <= 20) {\n    return \"mi√©rcoles\";\n  }\n  if (realCol >= 21 && realCol <= 26) {\n    return \"jueves\";\n  }\n  if (realCol >= 27 && realCol <= 32) {\n    return \"viernes\";\n  }\n  // Si nada coincide, devolvemos null\n  return null;\n}\n\n/**\n * Extraer las citas para cada franja:\n * - Para cada franja, miramos 3 filas:\n *    - Fila base => proveedor\n *    - Fila base+1 => orden\n *    - Fila base+2 => peso, categor√≠a, unidades\n */\nfunction extraerCitas(datos, muellesInfo) {\n  mallaEstructurada.franjas.forEach(franja => {\n    const indiceBase = franja.indice;\n    if (indiceBase < 0 || indiceBase + 2 >= datos.length) {\n      return; // no hay suficientes filas\n    }\n    \n    // Recorremos muelle1, muelle2 y sus columnas\n    const asignarCita = (muelleKey, cols) => {\n      cols.forEach(col => {\n        const provKey = `__EMPTY_${col}`;\n        const filaProv = datos[indiceBase];\n        \n        // Si en esta fila hay un proveedor o alg√∫n texto\n        if (\n          filaProv &&\n          typeof filaProv[provKey] === 'string' &&\n          filaProv[provKey].length > 2\n        ) {\n          // Determinar el d√≠a real\n          const diaOk = getDayForColumn(col);\n          if (!diaOk || !mallaEstructurada.dias[diaOk]) {\n            return; // si no coincide con ninguno, saltamos\n          }\n          \n          // Recuperar valores para proveedor, ordenCompra y dem√°s\n          const filaOrden = datos[indiceBase + 1];\n          const filaDet = datos[indiceBase + 2];\n          \n          const proveedor = filaProv[provKey] || \"\";\n          const ordenCompra = filaOrden && filaOrden[provKey] ? filaOrden[provKey] : \"\";\n          const peso = filaDet && filaDet[provKey] ? filaDet[provKey] : \"\";\n          const cat  = filaDet && filaDet[`__EMPTY_${col + 1}`] ? filaDet[`__EMPTY_${col + 1}`] : \"\";\n          const und  = filaDet && filaDet[`__EMPTY_${col + 2}`] ? filaDet[`__EMPTY_${col + 2}`] : \"\";\n          \n          // Antes pon√≠amos estado=\"ocupado\" directamente\n          // Ahora verificamos si el texto contiene \"reagendado\", \"cancelado\" o \"fuera de servicio\".\n          const nuevoEstado = determinarEstadoOcupado(proveedor, ordenCompra, peso, cat, und);\n          \n          // Asignamos los datos\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].estado = nuevoEstado;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].proveedor = proveedor;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].ordenCompra = ordenCompra;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].peso = peso;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].categoria = cat;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].unidades = und;\n        }\n      });\n    };\n    \n    if (muellesInfo.muelle1) {\n      asignarCita('muelle1', muellesInfo.muelle1);\n    }\n    if (muellesInfo.muelle2) {\n      asignarCita('muelle2', muellesInfo.muelle2);\n    }\n  });\n}\n\n// -------------------------------------------------------------\n// 2) FUNCIONES PARA CONSULTAR LA MALLA\n// -------------------------------------------------------------\nfunction buscarFranjasDisponibles(categoria, duracionHoras) {\n  const muelle = \"muelle1\"; // Ajusta si usas \"categoria -> muelle\" real\n  \n  const franjasDisponibles = [];\n  Object.keys(mallaEstructurada.dias).forEach(dia => {\n    const libres = [];\n    for (let i = 0; i <= mallaEstructurada.franjas.length - duracionHoras; i++) {\n      let disponible = true;\n      for (let h = 0; h < duracionHoras; h++) {\n        const idxF = i + h;\n        const horaAct = mallaEstructurada.franjas[idxF].hora;\n        if (\n          mallaEstructurada.dias[dia][muelle][horaAct].estado !== 'disponible'\n        ) {\n          disponible = false;\n          break;\n        }\n      }\n      if (disponible) {\n        libres.push({\n          horaInicio: mallaEstructurada.franjas[i].hora,\n          duracion: duracionHoras\n        });\n      }\n    }\n    if (libres.length > 0) {\n      franjasDisponibles.push({ dia, franjas: libres });\n    }\n  });\n  return franjasDisponibles;\n}\n\nfunction buscarCitasProveedor(nombreProveedor) {\n  const citas = [];\n  Object.keys(mallaEstructurada.dias).forEach(dia => {\n    const muelle1 = mallaEstructurada.dias[dia].muelle1;\n    const muelle2 = mallaEstructurada.dias[dia].muelle2;\n    mallaEstructurada.franjas.forEach(f => {\n      const hora = f.hora;\n      // muelle1\n      if (normalizarTexto(muelle1[hora].proveedor) === normalizarTexto(nombreProveedor)) {\n        citas.push({\n          dia,\n          hora,\n          muelle: \"Muelle 01\",\n          ordenCompra: muelle1[hora].ordenCompra,\n          peso: muelle1[hora].peso,\n          categoria: muelle1[hora].categoria,\n          unidades: muelle1[hora].unidades,\n          estado: muelle1[hora].estado\n        });\n      }\n      // muelle2\n      if (normalizarTexto(muelle2[hora].proveedor) === normalizarTexto(nombreProveedor)) {\n        citas.push({\n          dia,\n          hora,\n          muelle: \"Muelle 02\",\n          ordenCompra: muelle2[hora].ordenCompra,\n          peso: muelle2[hora].peso,\n          categoria: muelle2[hora].categoria,\n          unidades: muelle2[hora].unidades,\n          estado: muelle2[hora].estado\n        });\n      }\n    });\n  });\n  return citas;\n}\n\nfunction consultarFranjasDisponibles(categoria, duracionHoras) {\n  return buscarFranjasDisponibles(categoria, duracionHoras);\n}\n\nfunction consultarCitasProveedor(nombreProveedor) {\n  return buscarCitasProveedor(nombreProveedor);\n}\n\nfunction obtenerInfoMalla() {\n  return {\n    titulo: mallaEstructurada.titulo,\n    a√±o: mallaEstructurada.a√±o,\n    semana: mallaEstructurada.semana,\n    rangoDias: mallaEstructurada.rangoDias,\n    franjas: mallaEstructurada.franjas.map(f => f.hora)\n  };\n}\n\nfunction estaDisponible(dia, hora, muelle) {\n  const info = mallaEstructurada.dias[dia]?.[muelle]?.[hora];\n  return info ? (info.estado === 'disponible') : false;\n}\n\nfunction obtenerCoordenadasCita(dia, hora, muelle) {\n  // Ajustar con tu mapeo de celdas en Excel\n  return {\n    proveedor: `${dia}_${hora}_${muelle}_proveedor`,\n    ordenCompra: `${dia}_${hora}_${muelle}_ordenCompra`,\n    peso: `${dia}_${hora}_${muelle}_peso`,\n    categoria: `${dia}_${hora}_${muelle}_categoria`,\n    unidades: `${dia}_${hora}_${muelle}_unidades`\n  };\n}\n\n// -------------------------------------------------------------\n// 3) EJECUTAR TODO Y RETORNAR\n// -------------------------------------------------------------\nconst malla = procesarDatos(excelData);\n\nconst resultado = {\n  datosMallaProxSemana: malla,\n  funciones: {\n    consultarFranjasDisponibles,\n    consultarCitasProveedor,\n    obtenerInfoMalla,\n    estaDisponible,\n    obtenerCoordenadasCita\n  }\n};\n\nreturn [resultado];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        112,
        4992
      ],
      "id": "4d1273fa-97cd-4bf8-8f96-a541782e9034",
      "name": "Estructuraci√≥n, Datos, Consulta, Citas Proxima Semana3"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Validaci√≥n de reprogramaci√≥n de citas - SOLUCI√ìN CORREGIDA\n * \n * Correcciones aplicadas:\n * 1. Referencias din√°micas en lugar de hardcodeadas (SEMANA 20/21)\n * 2. Permite reprogramaci√≥n cuando es la misma cita\n * 3. Normalizaci√≥n flexible de fechas (06 ‚Üî 6)\n * 4. Normalizaci√≥n flexible de horas (09:00 AM ‚Üî 9:00 AM)\n */\n\n// Funci√≥n principal\ntry {\n    // 1. Obtener datos necesarios\n    const datosReprogramacion = $node[\"Code Validaci√≥n de datos para reprogramaci√≥n de citas\"].json;\n    const citaOriginal = $node[\"Microsoft SQL Obtener Cita\"].json;\n    const mallas = $node[\"Unificaci√≥n y consistencia de datos4\"].json;\n    \n    // Extraer los datos importantes\n    const idCita = datosReprogramacion.idCita;\n    const ordenCompra = datosReprogramacion.ordenCompra;\n    const nuevaFecha = datosReprogramacion.nuevaFecha; // \"06 de junio de 2025\"\n    const nuevaHoraConFormato = datosReprogramacion.nuevaHora; // \"10:00 AM\"\n    \n    // Normalizar el formato de hora para que coincida con las mallas\n    const nuevaHora = normalizarHora(nuevaHoraConFormato);\n    \n    console.log(`Hora original: \"${nuevaHoraConFormato}\", hora normalizada: \"${nuevaHora}\"`);\n    \n    // Extraer datos de la cita original\n    const idCitaDB = citaOriginal.id;\n    const ordenCompraDB = citaOriginal.orden_compra;\n    const horasEntrega = parseInt(citaOriginal.horas_entrega);\n    const muelleOriginal = citaOriginal.muelle;\n    const horaInicioOriginal = citaOriginal.hora_inicio;\n    const horaFinOriginal = citaOriginal.hora_fin;\n    const proveedorOriginal = citaOriginal.nombre; // Para verificar si es la misma cita\n    \n    // Normalizar n√∫mero de muelle\n    let numeroMuelle = 1;\n    if (muelleOriginal && muelleOriginal.toLowerCase().includes(\"muelle\")) {\n        const match = muelleOriginal.match(/\\d+/);\n        if (match) numeroMuelle = parseInt(match[0]);\n    }\n    \n    // 2. Validar coincidencia de ID y orden de compra\n    if (idCita != idCitaDB || ordenCompra !== ordenCompraDB) {\n        return [{\n            json: {\n                franjaDisponible: false,\n                mensaje: `La informaci√≥n de la cita no coincide. ID Cita proporcionado: ${idCita}, ID en sistema: ${idCitaDB}. Orden de compra proporcionada: ${ordenCompra}, Orden en sistema: ${ordenCompraDB}.`\n            }\n        }];\n    }\n    \n    // 3. Buscar la fecha en AMBAS mallas usando normalizaci√≥n flexible\n    let fechaEncontrada = false;\n    let nombreHoja = null;\n    let diaSemana = null;\n    let datosDia = null;\n    \n    // Buscar primero en la malla principal\n    for (const dia in mallas.datosMalla.dias) {\n        if (compararFechasFlexible(mallas.datosMalla.dias[dia].fechaDia, nuevaFecha)) {\n            console.log(`Fecha encontrada en ${mallas.datosMalla.semana} (${dia})`);\n            fechaEncontrada = true;\n            diaSemana = dia;\n            datosDia = mallas.datosMalla.dias[dia];\n            nombreHoja = mallas.datosMalla.semana;\n            break;\n        }\n    }\n    \n    // Si no se encuentra en la malla principal, buscar en la pr√≥xima semana\n    if (!fechaEncontrada) {\n        for (const dia in mallas.datosMallaProxSemana.dias) {\n            if (compararFechasFlexible(mallas.datosMallaProxSemana.dias[dia].fechaDia, nuevaFecha)) {\n                console.log(`Fecha encontrada en ${mallas.datosMallaProxSemana.semana} (${dia})`);\n                fechaEncontrada = true;\n                diaSemana = dia;\n                datosDia = mallas.datosMallaProxSemana.dias[dia];\n                nombreHoja = mallas.datosMallaProxSemana.semana;\n                break;\n            }\n        }\n    }\n    \n    // Si la fecha no se encuentra en ninguna malla\n    if (!fechaEncontrada) {\n        return [{\n            json: {\n                franjaDisponible: false,\n                mensaje: `La fecha ${nuevaFecha} no se encuentra en la programaci√≥n disponible.`\n            }\n        }];\n    }\n    \n    // 4. Verificar disponibilidad en la malla correcta\n    // Verificar que exista el muelle para ese d√≠a\n    const muelleKey = `muelle${numeroMuelle}`;\n    if (!datosDia[muelleKey]) {\n        return [{\n            json: {\n                franjaDisponible: false,\n                mensaje: `No existe el muelle ${numeroMuelle} para el d√≠a ${diaSemana}.`\n            }\n        }];\n    }\n    \n    // Verificar que la hora exista en el muelle\n    const muelle = datosDia[muelleKey];\n    \n    console.log(`Verificando hora: ${nuevaHora} en muelle ${numeroMuelle}`);\n    console.log(`Estado: ${muelle[nuevaHora]?.estado || 'no definido'}`);\n    \n    if (!muelle[nuevaHora]) {\n        return [{\n            json: {\n                franjaDisponible: false,\n                mensaje: `La hora ${nuevaHoraConFormato} no est√° definida para el d√≠a ${diaSemana}.`\n            }\n        }];\n    }\n    \n    // Verificar disponibilidad para horas consecutivas\n    let disponible = true;\n    let franjasNoDisponibles = [];\n    let esMismaCita = false; // Nueva bandera para verificar si es reprogramaci√≥n de la misma cita\n    \n    // Encontrar la hora en las franjas\n    const franjas = nombreHoja === mallas.datosMalla.semana \n        ? mallas.datosMalla.franjas \n        : mallas.datosMallaProxSemana.franjas;\n    \n    let indiceInicio = -1;\n    \n    // Buscar usando normalizaci√≥n flexible de horas\n    for (let i = 0; i < franjas.length; i++) {\n        if (compararHorasFlexible(franjas[i].hora, nuevaHora)) {\n            indiceInicio = i;\n            console.log(`¬°Coincidencia encontrada en √≠ndice ${i}!`);\n            break;\n        }\n    }\n    \n    if (indiceInicio === -1) {\n        console.log(\"No se encontr√≥ la hora en las franjas\");\n        return [{\n            json: {\n                franjaDisponible: false,\n                mensaje: `La hora ${nuevaHoraConFormato} no se encuentra en las franjas horarias disponibles.`\n            }\n        }];\n    }\n    \n    // Verificar disponibilidad para cada hora necesaria\n    for (let i = 0; i < horasEntrega; i++) {\n        if (indiceInicio + i >= franjas.length) {\n            disponible = false;\n            console.log(\"No hay suficientes horas disponibles en el d√≠a\");\n            break;\n        }\n        \n        const franja = franjas[indiceInicio + i];\n        const estadoFranja = muelle[franja.hora];\n        \n        console.log(`Verificando franja ${franja.hora}: ${estadoFranja?.estado || 'no definido'}`);\n        \n        if (!estadoFranja) {\n            disponible = false;\n            franjasNoDisponibles.push(franja.hora);\n        } else if (estadoFranja.estado === \"disponible\") {\n            // Franja disponible, todo bien\n            continue;\n        } else if (estadoFranja.estado === \"ocupado\") {\n            // Verificar si est√° ocupada por la misma cita\n            if (estadoFranja.ordenCompra === ordenCompra && \n                estadoFranja.proveedor === proveedorOriginal) {\n                console.log(`Franja ${franja.hora} ocupada por la misma cita - permitir reprogramaci√≥n`);\n                esMismaCita = true;\n                continue;\n            } else {\n                // Ocupada por otra cita\n                disponible = false;\n                franjasNoDisponibles.push(franja.hora);\n            }\n        } else {\n            // Fuera de servicio u otro estado\n            disponible = false;\n            franjasNoDisponibles.push(franja.hora);\n        }\n    }\n    \n    // C√ÅLCULO PRECISO DEL nombreHoja PARA LA CITA ORIGINAL\n    let nombreHojaOriginal = calcularNombreHojaOriginal(citaOriginal.fecha_cita, mallas);\n    \n    // Si hay disponibilidad o es reprogramaci√≥n de la misma cita, retornar respuesta positiva\n    if (disponible || esMismaCita) {\n        const horaFin = calcularHoraFin(nuevaHoraConFormato, horasEntrega);\n        const fechaFormateada = convertirFechaAFormatoISO(nuevaFecha);\n        \n        // Normalizar horaInicio para la respuesta (quitar cero inicial si existe)\n        const horaInicioNormalizada = nuevaHoraConFormato.replace(/^0(\\d:00 [AP]M)$/, \"$1\");\n        \n        const tipoOperacion = esMismaCita ? \"reprogramaci√≥n\" : \"nueva programaci√≥n\";\n        \n        const respuesta = {\n            franjaDisponible: true,\n            mensaje: `¬°Genial! Hay espacio para la ${tipoOperacion} el ${nuevaFecha}, de ${horaInicioNormalizada} a ${horaFin} en MUELLE ${numeroMuelle}.`,\n            datosValidados: {\n                fecha: nuevaFecha,\n                fechaFormateada: fechaFormateada,\n                horaInicio: horaInicioNormalizada,\n                horaFin: horaFin,\n                muelle: `MUELLE ${numeroMuelle}`,\n                duracionHoras: horasEntrega,\n                disponibilidadConfirmada: true,\n                tipoOperacion: tipoOperacion\n            },\n            nombreHoja: nombreHoja,\n            citaAntigua: {\n                id: idCitaDB,\n                fechaFormateada: citaOriginal.fecha_cita ? citaOriginal.fecha_cita.split('T')[0] : \"\",\n                horaInicio: horaInicioOriginal,\n                horaFin: horaFinOriginal,\n                muelle: muelleOriginal,\n                nombreHoja: nombreHojaOriginal || nombreHoja // Usar valor calculado o default\n            }\n        };\n        \n        return [{ json: respuesta }];\n    } else {\n        // Si no hay disponibilidad, buscar alternativas\n        const franjasSemana = nombreHoja === mallas.datosMalla.semana \n            ? mallas.datosMalla.franjas \n            : mallas.datosMallaProxSemana.franjas;\n            \n        const alternativas = buscarAlternativasParaDia(\n            datosDia,\n            franjasSemana,\n            horasEntrega,\n            numeroMuelle\n        );\n        \n        let mensajeAlternativas = `Lo siento, la franja horaria seleccionada ya no est√° disponible. `;\n        \n        if (alternativas.length > 0) {\n            mensajeAlternativas += `Aqu√≠ hay algunas alternativas disponibles en el muelle ${numeroMuelle}:\\n\\n`;\n            \n            alternativas.forEach((alt, index) => {\n                mensajeAlternativas += `Opci√≥n ${index + 1}: ${alt.fecha} - Muelle ${alt.muelle} - De ${alt.horaInicio} a ${alt.horaFin}\\n`;\n            });\n            \n            mensajeAlternativas += \"\\nSi desea elegir una de estas alternativas, por favor env√≠e un nuevo mensaje con todos los datos de reprogramaci√≥n. Este chat se reiniciar√° para evitar confusiones con mensajes anteriores.\";\n        } else {\n            mensajeAlternativas += `No se encontraron horarios alternativos disponibles para el muelle ${numeroMuelle} en las pr√≥ximas fechas. Por favor, intente con otra fecha u horario. Este chat se reiniciar√° para evitar confusiones con mensajes anteriores.`;\n        }\n        \n        return [{\n            json: {\n                franjaDisponible: false,\n                mensaje: mensajeAlternativas,\n                alternativas: alternativas\n            }\n        }];\n    }\n} catch (error) {\n    console.error(\"Error en la validaci√≥n:\", error);\n    return [{\n        json: {\n            franjaDisponible: false,\n            mensaje: \"Error en el proceso de validaci√≥n: \" + error.message\n        }\n    }];\n}\n\n// FUNCIONES AUXILIARES MEJORADAS\n\n// Funci√≥n para normalizar horas (maneja ambas direcciones)\nfunction normalizarHora(hora) {\n    if (!hora) return hora;\n    \n    // Convertir a string si no lo es\n    const horaStr = hora.toString().trim();\n    \n    // Patr√≥n para capturar horas con posible cero inicial\n    const patron = /^(0?)(\\d{1,2}):(\\d{2})\\s*([AP]M)$/i;\n    const match = horaStr.match(patron);\n    \n    if (match) {\n        const [, ceroInicial, hora, minutos, periodo] = match;\n        // Quitar cero inicial si existe y la hora es de un d√≠gito\n        const horaSinCero = parseInt(hora, 10);\n        return `${horaSinCero}:${minutos} ${periodo.toUpperCase()}`;\n    }\n    \n    return horaStr;\n}\n\n// Funci√≥n para comparar horas de manera flexible\nfunction compararHorasFlexible(hora1, hora2) {\n    const horaNormalizada1 = normalizarHora(hora1);\n    const horaNormalizada2 = normalizarHora(hora2);\n    \n    console.log(`Comparando horas: \"${horaNormalizada1}\" con \"${horaNormalizada2}\"`);\n    \n    return horaNormalizada1 === horaNormalizada2;\n}\n\n// Funci√≥n para normalizar fechas (maneja ambas direcciones)\nfunction normalizarFecha(fecha) {\n    if (!fecha) return fecha;\n    \n    const fechaStr = fecha.toString().trim();\n    \n    // Patr√≥n para capturar fecha con posible cero inicial en el d√≠a\n    const patron = /^(0?)(\\d{1,2})\\s+de\\s+(\\w+)(?:\\s+de\\s+(\\d{4}))?$/i;\n    const match = fechaStr.match(patron);\n    \n    if (match) {\n        const [, ceroInicial, dia, mes, a√±o] = match;\n        // Quitar cero inicial si existe\n        const diaSinCero = parseInt(dia, 10);\n        \n        if (a√±o) {\n            return `${diaSinCero} de ${mes.toLowerCase()} de ${a√±o}`;\n        } else {\n            return `${diaSinCero} de ${mes.toLowerCase()}`;\n        }\n    }\n    \n    return fechaStr;\n}\n\n// Funci√≥n para comparar fechas de manera flexible\nfunction compararFechasFlexible(fecha1, fecha2) {\n    const fechaNormalizada1 = normalizarFecha(fecha1);\n    const fechaNormalizada2 = normalizarFecha(fecha2);\n    \n    console.log(`Comparando fechas: \"${fechaNormalizada1}\" con \"${fechaNormalizada2}\"`);\n    \n    // Comparaci√≥n exacta\n    if (fechaNormalizada1 === fechaNormalizada2) {\n        return true;\n    }\n    \n    // Comparaci√≥n sin a√±o (para casos donde una tiene a√±o y otra no)\n    const fecha1SinA√±o = fechaNormalizada1.replace(/\\s+de\\s+\\d{4}$/, '');\n    const fecha2SinA√±o = fechaNormalizada2.replace(/\\s+de\\s+\\d{4}$/, '');\n    \n    return fecha1SinA√±o === fecha2SinA√±o;\n}\n\n// Funci√≥n para calcular el nombreHoja de la cita original\nfunction calcularNombreHojaOriginal(fechaCitaOriginal, mallas) {\n    if (!fechaCitaOriginal) return null;\n    \n    const formatosFechaOriginal = convertirFechaISOaLegible(fechaCitaOriginal);\n    console.log(\"Formatos de fecha original:\", formatosFechaOriginal);\n    \n    // Buscar en malla principal\n    for (const dia in mallas.datosMalla.dias) {\n        const fechaDiaMalla = mallas.datosMalla.dias[dia].fechaDia;\n        \n        if (compararFechasFlexible(fechaDiaMalla, formatosFechaOriginal.conA√±o) || \n            compararFechasFlexible(fechaDiaMalla, formatosFechaOriginal.sinA√±o)) {\n            console.log(`¬°Cita original encontrada en ${mallas.datosMalla.semana}!`);\n            return mallas.datosMalla.semana;\n        }\n    }\n    \n    // Buscar en pr√≥xima semana\n    for (const dia in mallas.datosMallaProxSemana.dias) {\n        const fechaDiaMalla = mallas.datosMallaProxSemana.dias[dia].fechaDia;\n        \n        if (compararFechasFlexible(fechaDiaMalla, formatosFechaOriginal.conA√±o) || \n            compararFechasFlexible(fechaDiaMalla, formatosFechaOriginal.sinA√±o)) {\n            console.log(`¬°Cita original encontrada en ${mallas.datosMallaProxSemana.semana}!`);\n            return mallas.datosMallaProxSemana.semana;\n        }\n    }\n    \n    // M√©todo adicional: por d√≠a de la semana y rango de fechas\n    const fechaISO = new Date(fechaCitaOriginal);\n    const diaNumerico = fechaISO.getDate();\n    const mes = fechaISO.getMonth();\n    \n    // Funci√≥n para extraer rango de d√≠as de un string como \"LUNES 02 AL VIERNES 06 DE JUNIO\"\n    function extraerRangoDias(rango) {\n        const partes = rango.split(\" \");\n        let diaInicio = null;\n        let diaFin = null;\n        let mesTexto = null;\n        \n        for (let i = 0; i < partes.length; i++) {\n            if (/^\\d+$/.test(partes[i])) {\n                if (diaInicio === null) {\n                    diaInicio = parseInt(partes[i]);\n                } else {\n                    diaFin = parseInt(partes[i]);\n                }\n            }\n            if (i > 0 && partes[i-1] === \"DE\") {\n                mesTexto = partes[i].toLowerCase();\n            }\n        }\n        \n        const meses = {\n            'enero': 0, 'febrero': 1, 'marzo': 2, 'abril': 3, 'mayo': 4, 'junio': 5,\n            'julio': 6, 'agosto': 7, 'septiembre': 8, 'octubre': 9, 'noviembre': 10, 'diciembre': 11\n        };\n        \n        return { diaInicio, diaFin, mes: meses[mesTexto] };\n    }\n    \n    // Verificar rangos\n    const rangoMallaPrincipal = extraerRangoDias(mallas.datosMalla.rangoDias);\n    console.log(\"Rango malla principal:\", rangoMallaPrincipal);\n    \n    if (mes === rangoMallaPrincipal.mes && \n        diaNumerico >= rangoMallaPrincipal.diaInicio && \n        diaNumerico <= rangoMallaPrincipal.diaFin) {\n        console.log(`Cita original en rango de ${mallas.datosMalla.semana}`);\n        return mallas.datosMalla.semana;\n    }\n    \n    const rangoProxSemana = extraerRangoDias(mallas.datosMallaProxSemana.rangoDias);\n    console.log(\"Rango pr√≥xima semana:\", rangoProxSemana);\n    \n    if (mes === rangoProxSemana.mes && \n        diaNumerico >= rangoProxSemana.diaInicio && \n        diaNumerico <= rangoProxSemana.diaFin) {\n        console.log(`Cita original en rango de ${mallas.datosMallaProxSemana.semana}`);\n        return mallas.datosMallaProxSemana.semana;\n    }\n    \n    console.log(`No se pudo determinar la hoja original, usando default: ${mallas.datosMalla.semana}`);\n    return mallas.datosMalla.semana;\n}\n\n// Funci√≥n para convertir una fecha ISO a un formato legible\nfunction convertirFechaISOaLegible(fechaISO) {\n    const fechaObj = new Date(fechaISO);\n    const dia = fechaObj.getDate();\n    const meses = ['enero', 'febrero', 'marzo', 'abril', 'mayo', 'junio', 'julio', 'agosto', 'septiembre', 'octubre', 'noviembre', 'diciembre'];\n    const mes = meses[fechaObj.getMonth()];\n    const a√±o = fechaObj.getFullYear();\n    \n    return {\n        conA√±o: `${dia} de ${mes} de ${a√±o}`,\n        sinA√±o: `${dia} de ${mes}`\n    };\n}\n\n// Funci√≥n para calcular la hora final\nfunction calcularHoraFin(horaInicio, horasNecesarias) {\n    try {\n        const partes = horaInicio.trim().split(/\\s+/);\n        const horaMinutos = partes[0].split(':');\n        const periodo = partes[1]; // AM o PM\n        \n        let hora = parseInt(horaMinutos[0], 10);\n        let minutos = parseInt(horaMinutos[1] || \"0\", 10);\n        \n        // Convertir a formato 24 horas para el c√°lculo\n        if (periodo.toUpperCase() === \"PM\" && hora < 12) {\n            hora += 12;\n        } else if (periodo.toUpperCase() === \"AM\" && hora === 12) {\n            hora = 0;\n        }\n        \n        // Sumar las horas necesarias\n        hora = (hora + horasNecesarias) % 24;\n        \n        // Convertir de nuevo a formato 12 horas\n        let nuevoPeriodo = \"AM\";\n        if (hora >= 12) {\n            nuevoPeriodo = \"PM\";\n            if (hora > 12) {\n                hora -= 12;\n            }\n        }\n        if (hora === 0) {\n            hora = 12;\n        }\n        \n        return `${hora}:${minutos.toString().padStart(2, '0')} ${nuevoPeriodo}`;\n    } catch (error) {\n        console.error(\"Error al calcular hora fin:\", error);\n        return \"Hora desconocida\";\n    }\n}\n\n// Funci√≥n para convertir fecha a formato ISO\nfunction convertirFechaAFormatoISO(fechaTexto) {\n    try {\n        const partes = fechaTexto.split(\" de \");\n        const dia = parseInt(partes[0], 10);\n        const mes = partes[1].toLowerCase();\n        \n        const meses = {\n            'enero': 0, 'febrero': 1, 'marzo': 2, 'abril': 3, 'mayo': 4, 'junio': 5,\n            'julio': 6, 'agosto': 7, 'septiembre': 8, 'octubre': 9, 'noviembre': 10, 'diciembre': 11\n        };\n        \n        const mesNum = meses[mes];\n        if (mesNum === undefined) {\n            throw new Error(`Mes no v√°lido: ${mes}`);\n        }\n        \n        let anio = new Date().getFullYear();\n        if (partes.length > 2) {\n            anio = parseInt(partes[2], 10);\n        }\n        \n        return `${anio}-${(mesNum + 1).toString().padStart(2, '0')}-${dia.toString().padStart(2, '0')}`;\n    } catch (error) {\n        console.error(\"Error al convertir fecha a formato ISO:\", error);\n        return \"\";\n    }\n}\n\n// Funci√≥n para buscar alternativas en un d√≠a\nfunction buscarAlternativasParaDia(datoDia, franjas, horasNecesarias, numeroMuelle) {\n    const alternativas = [];\n    const muelleKey = `muelle${numeroMuelle}`;\n    const muelle = datoDia[muelleKey];\n    \n    if (!muelle) return alternativas;\n    \n    // Para cada posible hora de inicio\n    for (let i = 0; i <= franjas.length - horasNecesarias; i++) {\n        let disponible = true;\n        \n        // Verificar franjas consecutivas\n        for (let j = 0; j < horasNecesarias; j++) {\n            const franja = franjas[i + j];\n            if (!muelle[franja.hora] || muelle[franja.hora].estado !== \"disponible\") {\n                disponible = false;\n                break;\n            }\n        }\n        \n        if (disponible) {\n            const horaInicio = franjas[i].hora;\n            const horaFin = calcularHoraFin(horaInicio, horasNecesarias);\n            \n            alternativas.push({\n                fecha: datoDia.fechaDia,\n                muelle: numeroMuelle,\n                horaInicio: horaInicio,\n                horaFin: horaFin,\n                franjasHorarias: franjas.slice(i, i + horasNecesarias).map(f => f.hora)\n            });\n        }\n    }\n    \n    return alternativas;\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        912,
        4880
      ],
      "id": "2e195964-a7d1-4248-adde-43846c64888d",
      "name": "Code Validacion de Cita en cronograma para reprogramaci√≥n"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "de7a1d59-037e-48c1-8ef4-b5667443ca11",
              "leftValue": "={{ $json.franjaDisponible }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        1120,
        4880
      ],
      "id": "a85c3727-d324-4d9b-9452-bed800a76f98",
      "name": "If validacion de reprogramacion"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "4bfbecb3-9d4f-4425-aa76-a92abc7708fb",
              "leftValue": "={{ $('Code Validacion de Cita en cronograma para reprogramaci√≥n').first().json.mensaje.length }}",
              "rightValue": 70,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        1568,
        4960
      ],
      "id": "b3fc3d5e-ba5f-4c6c-ac88-b8da8db7fa34",
      "name": "Validaci√≥n de longitud de caracteres9"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d9c2ff70-4fd1-4b93-8571-6d0ac5a0093e",
              "name": "mensaje.ia",
              "value": "={{ $('Code Validacion de Cita en cronograma para reprogramaci√≥n').first().json.mensaje }}",
              "type": "string"
            },
            {
              "id": "ac8a03be-0292-4735-9580-39a385945c47",
              "name": "mensaje.longitud",
              "value": "={{ $('Code Validacion de Cita en cronograma para reprogramaci√≥n').first().json.mensaje.length }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1840,
        5024
      ],
      "id": "38e5f9f6-2385-460d-8d24-bf4d904bbd0f",
      "name": "Organiza variables del mensaje9"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        2032,
        4832
      ],
      "id": "bd44260d-95b1-4653-9f5c-cf722bcb9d95",
      "name": "No Operation, do nothing13"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $('Code Respuesta Faltantes').item.json.text }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1840,
        4832
      ],
      "id": "3237b3d6-f1de-4012-81d7-2e1362f80892",
      "name": "HTTP Request Enviar Mensaje por WhatsApp12"
    },
    {
      "parameters": {
        "jsCode": "// C√≥digo optimizado para el nodo \"Code (Preparar Cuerpo de Petici√≥n)1\"\nconst datosValidados = $input.first().json.datosValidados;\nconst datosCita = $('Microsoft SQL Obtener Cita').first().json;\nconst datosMalla = $('Unificaci√≥n y consistencia de datos4').first().json.datosMalla;\nconst citaAntigua = $input.first().json.citaAntigua || null;\nconst nombreHojaActual = $input.first().json.nombreHoja || \"\";\n\n// Extraer la informaci√≥n relevante para la nueva cita\nconst {\n  fecha,\n  fechaFormateada,\n  horaInicio,\n  horaFin,\n  muelle,\n  duracionHoras\n} = datosValidados;\n\n// Mapear correctamente los campos del nodo \"Microsoft SQL Obtener Cita\"\nconst {\n  nombre: proveedor = \"\",\n  orden_compra: ordenCompra = \"\",\n  peso = \"\",\n  categoria = \"\",\n  unidades = \"\"\n} = datosCita;\n\n// **NUEVA FUNCIONALIDAD: Optimizaci√≥n de franjas cruzadas**\nfunction calcularFranjasOptimizadas() {\n  if (!citaAntigua) {\n    // Si no hay cita antigua, proceder normalmente\n    return {\n      franjasAEliminar: [],\n      franjasAInsertar: generarFranjasNuevas(),\n      optimizacionAplicada: false,\n      tipoOperacion: \"nueva_cita\"\n    };\n  }\n\n  // Verificar si es el mismo d√≠a\n  const fechaNueva = new Date(fechaFormateada);\n  const fechaAntigua = new Date(citaAntigua.fechaFormateada);\n  \n  const esMismoDia = fechaNueva.toDateString() === fechaAntigua.toDateString();\n  \n  if (!esMismoDia) {\n    // D√≠as diferentes: eliminar todas las antiguas, insertar todas las nuevas\n    return {\n      franjasAEliminar: generarFranjasAntiguas(),\n      franjasAInsertar: generarFranjasNuevas(),\n      optimizacionAplicada: false,\n      tipoOperacion: \"cambio_dia\"\n    };\n  }\n\n  // **MISMO D√çA: Aplicar optimizaci√≥n**\n  const franjasAntiguas = generarFranjasAntiguas();\n  const franjasNuevas = generarFranjasNuevas();\n  \n  // Calcular intersecci√≥n (franjas que se cruzan)\n  const franjasAntiguasSet = new Set(franjasAntiguas.map(f => f.hora));\n  const franjasNuevasSet = new Set(franjasNuevas.map(f => f.hora));\n  \n  const franjasComunes = franjasAntiguas.filter(f => franjasNuevasSet.has(f.hora));\n  const franjasComnesSet = new Set(franjasComunes.map(f => f.hora));\n  \n  // Calcular operaciones optimizadas\n  const franjasAEliminar = franjasAntiguas.filter(f => !franjasComnesSet.has(f.hora));\n  const franjasAInsertar = franjasNuevas.filter(f => !franjasComnesSet.has(f.hora));\n  \n  console.log(`Optimizaci√≥n aplicada:\n    - Franjas antiguas: ${franjasAntiguas.length}\n    - Franjas nuevas: ${franjasNuevas.length}\n    - Franjas comunes (mantenidas): ${franjasComunes.length}\n    - Franjas a eliminar: ${franjasAEliminar.length}\n    - Franjas a insertar: ${franjasAInsertar.length}\n    - Operaciones evitadas: ${franjasComunes.length * 2}`);\n\n  return {\n    franjasAEliminar,\n    franjasAInsertar,\n    franjasComunes,\n    optimizacionAplicada: true,\n    tipoOperacion: \"mismo_dia_optimizado\",\n    estadisticas: {\n      operacionesEvitadas: franjasComunes.length * 2,\n      eficiencia: ((franjasComunes.length * 2) / (franjasAntiguas.length + franjasNuevas.length) * 100).toFixed(2) + '%'\n    }\n  };\n}\n\nfunction generarFranjasNuevas() {\n  const franjas = [];\n  let horaActual = horaInicio;\n  let horasRestantes = duracionHoras;\n  \n  while (horasRestantes > 0) {\n    const franjaActual = datosMalla.franjas.find(f => horasIguales(f.hora, horaActual));\n    \n    if (!franjaActual) {\n      console.log(`No se encontr√≥ informaci√≥n para la franja: ${horaActual}`);\n      break;\n    }\n    \n    const filaBase = calcularFilaExcel(horaActual, datosMalla.franjas);\n    if (!filaBase) {\n      console.log(`No se pudo determinar la fila para la franja: ${horaActual}`);\n      break;\n    }\n\n    franjas.push({\n      hora: horaActual,\n      fila: filaBase,\n      datos: {\n        proveedor,\n        ordenCompra,\n        peso,\n        categoria,\n        unidades\n      }\n    });\n    \n    horasRestantes--;\n    if (horasRestantes > 0) {\n      const siguienteFranja = encontrarSiguienteFranja(horaActual, datosMalla.franjas);\n      if (siguienteFranja) {\n        horaActual = siguienteFranja.hora;\n      } else {\n        break;\n      }\n    }\n  }\n  \n  return franjas;\n}\n\nfunction generarFranjasAntiguas() {\n  if (!citaAntigua) return [];\n  \n  const franjas = [];\n  let horaActual = citaAntigua.horaInicio;\n  let horasRestantes = duracionHoras; // Usar la misma duraci√≥n\n  \n  while (horasRestantes > 0) {\n    const franjaActual = datosMalla.franjas.find(f => horasIguales(f.hora, horaActual));\n    \n    if (!franjaActual) {\n      console.log(`No se encontr√≥ informaci√≥n para la franja antigua: ${horaActual}`);\n      break;\n    }\n    \n    const filaBase = calcularFilaExcel(horaActual, datosMalla.franjas);\n    if (!filaBase) {\n      console.log(`No se pudo determinar la fila para la franja antigua: ${horaActual}`);\n      break;\n    }\n\n    franjas.push({\n      hora: horaActual,\n      fila: filaBase,\n      datos: {\n        proveedor: \"\",\n        ordenCompra: \"\",\n        peso: \"\",\n        categoria: \"\",\n        unidades: \"\"\n      }\n    });\n    \n    horasRestantes--;\n    if (horasRestantes > 0) {\n      const siguienteFranja = encontrarSiguienteFranja(horaActual, datosMalla.franjas);\n      if (siguienteFranja) {\n        horaActual = siguienteFranja.hora;\n      } else {\n        break;\n      }\n    }\n  }\n  \n  return franjas;\n}\n\n// Funciones auxiliares (mantener las existentes)\nfunction obtenerDiaSemanaDesdeTexto(fechaStr) {\n  const regex = /(\\d+)\\s+de\\s+(\\w+)\\s+de\\s+(\\d+)/;\n  const match = regex.exec(fechaStr);\n  \n  if (!match) return null;\n  \n  const dia = parseInt(match[1], 10);\n  const mesStr = match[2].toLowerCase();\n  const a√±o = parseInt(match[3], 10);\n  \n  const meses = {\n    \"enero\": 0, \"febrero\": 1, \"marzo\": 2, \"abril\": 3, \"mayo\": 4, \"junio\": 5,\n    \"julio\": 6, \"agosto\": 7, \"septiembre\": 8, \"octubre\": 9, \"noviembre\": 10, \"diciembre\": 11\n  };\n  \n  const mesNum = meses[mesStr];\n  if (mesNum === undefined) return null;\n  \n  const fecha = new Date(a√±o, mesNum, dia);\n  const diaSemana = fecha.getDay();\n  const diasSemana = [\"domingo\", \"lunes\", \"martes\", \"mi√©rcoles\", \"jueves\", \"viernes\", \"s√°bado\"];\n  \n  return diasSemana[diaSemana];\n}\n\nfunction horasIguales(h1, h2) {\n  const normalizar = (h) =>\n    h.toString().trim().toLowerCase().replace(/\\./g, '').replace(/\\s+/g, '').replace(/^0+/, '');\n  return normalizar(h1) === normalizar(h2);\n}\n\nfunction calcularFilaExcel(hora, franjas) {\n  const franjasOrdenadas = [...franjas].sort((a, b) => {\n    function horaAMinutos(hora) {\n      const match = hora.match(/(\\d+):(\\d+)\\s*([AP]M)/i);\n      if (!match) return 0;\n      \n      let horas = parseInt(match[1], 10);\n      const minutos = parseInt(match[2], 10);\n      const periodo = match[3].toUpperCase();\n      \n      if (periodo === 'PM' && horas !== 12) {\n        horas += 12;\n      } else if (periodo === 'AM' && horas === 12) {\n        horas = 0;\n      }\n      \n      return horas * 60 + minutos;\n    }\n    \n    return horaAMinutos(a.hora) - horaAMinutos(b.hora);\n  });\n  \n  const posicion = franjasOrdenadas.findIndex(f => horasIguales(f.hora, hora));\n  \n  if (posicion === -1) {\n    console.log(`No se encontr√≥ la posici√≥n para la hora ${hora}`);\n    return null;\n  }\n  \n  const FILA_PRIMERA_FRANJA = 12;\n  const INCREMENTO_ESTANDAR = 3;\n  \n  if (posicion === 3) {\n    return 21;\n  } else if (posicion === 4) {\n    return 24;\n  } else if (posicion === 5) {\n    return 27;\n  } else if (posicion < 3) {\n    return FILA_PRIMERA_FRANJA + (posicion * INCREMENTO_ESTANDAR);\n  } else {\n    return 27 + ((posicion - 5) * INCREMENTO_ESTANDAR);\n  }\n}\n\nfunction encontrarSiguienteFranja(horaActual, franjas) {\n  const franjasOrdenadas = [...franjas].sort((a, b) => {\n    function horaAMinutos(hora) {\n      const match = hora.match(/(\\d+):(\\d+)\\s*([AP]M)/i);\n      if (!match) return 0;\n      \n      let horas = parseInt(match[1], 10);\n      const minutos = parseInt(match[2], 10);\n      const periodo = match[3].toUpperCase();\n      \n      if (periodo === 'PM' && horas !== 12) {\n        horas += 12;\n      } else if (periodo === 'AM' && horas === 12) {\n        horas = 0;\n      }\n      \n      return horas * 60 + minutos;\n    }\n    \n    return horaAMinutos(a.hora) - horaAMinutos(b.hora);\n  });\n  \n  const posicionActual = franjasOrdenadas.findIndex(f => horasIguales(f.hora, horaActual));\n  \n  if (posicionActual === -1 || posicionActual >= franjasOrdenadas.length - 1) {\n    return null;\n  }\n  \n  return franjasOrdenadas[posicionActual + 1];\n}\n\n// **EJECUTAR OPTIMIZACI√ìN**\nconst resultadoOptimizacion = calcularFranjasOptimizadas();\n\nfunction procesarFranjas(franjas, nombreHoja, operacion) {\n  let actualizaciones = [];\n  \n  // Resto del c√≥digo para procesar las franjas (mantener la l√≥gica existente)\n  const diaSemana = obtenerDiaSemanaDesdeTexto(fecha);\n  const muelleKey = muelle.toLowerCase().includes(\"1\") ? \"muelle1\" : \"muelle2\";\n  \n  const mapeoColumnas = {\n    'lunes': { 'muelle1': 'C', 'muelle2': 'F' },\n    'martes': { 'muelle1': 'I', 'muelle2': 'L' },\n    'mi√©rcoles': { 'muelle1': 'O', 'muelle2': 'R' },\n    'jueves': { 'muelle1': 'U', 'muelle2': 'X' },\n    'viernes': { 'muelle1': 'AA', 'muelle2': 'AD' }\n  };\n  \n  if (!mapeoColumnas[diaSemana] || !mapeoColumnas[diaSemana][muelleKey]) {\n    console.log(`No hay mapeo para: d√≠a=${diaSemana}, muelle=${muelleKey}`);\n    return [];\n  }\n  \n  const columnaBase = mapeoColumnas[diaSemana][muelleKey];\n  \n  function siguienteColumna(columna) {\n    if (columna.length === 1) {\n      return String.fromCharCode(columna.charCodeAt(0) + 1);\n    } else {\n      const primerChar = columna.charAt(0);\n      const segundoChar = columna.charAt(1);\n      \n      if (segundoChar === 'Z') {\n        return String.fromCharCode(primerChar.charCodeAt(0) + 1) + 'A';\n      } else {\n        return primerChar + String.fromCharCode(segundoChar.charCodeAt(0) + 1);\n      }\n    }\n  }\n  \n  franjas.forEach(franja => {\n    const filaBase = franja.fila;\n    const columnaLineas = siguienteColumna(columnaBase);\n    const columnaUnd = siguienteColumna(columnaLineas);\n    \n    const rangoCeldas = {\n      proveedor: `${columnaBase}${filaBase}`,\n      ordenCompra: `${columnaBase}${filaBase + 1}`,\n      peso: `${columnaBase}${filaBase + 2}`,\n      categoria: `${columnaLineas}${filaBase + 2}`,\n      unidades: `${columnaUnd}${filaBase + 2}`\n    };\n    \n    actualizaciones.push(\n      { celda: rangoCeldas.proveedor, valor: franja.datos.proveedor, nombreHoja },\n      { celda: rangoCeldas.ordenCompra, valor: franja.datos.ordenCompra, nombreHoja },\n      { celda: rangoCeldas.peso, valor: franja.datos.peso, nombreHoja },\n      { celda: rangoCeldas.categoria, valor: franja.datos.categoria, nombreHoja },\n      { celda: rangoCeldas.unidades, valor: franja.datos.unidades, nombreHoja }\n    );\n  });\n  \n  return actualizaciones;\n}\n\n// Procesar las operaciones optimizadas\nconst actualizacionesNuevaCita = procesarFranjas(resultadoOptimizacion.franjasAInsertar, nombreHojaActual, \"insercion\");\nconst actualizacionesCitaAntigua = citaAntigua ? \n  procesarFranjas(resultadoOptimizacion.franjasAEliminar, citaAntigua.nombreHoja || nombreHojaActual, \"eliminacion\") : [];\n\n// Combinar todas las actualizaciones\nconst todasLasActualizaciones = [...actualizacionesNuevaCita, ...actualizacionesCitaAntigua];\n\n// Preparar el formato final para la petici√≥n a Microsoft Graph\nconst actualizacionesGraph = todasLasActualizaciones.map(act => ({\n  address: act.celda,\n  values: [[act.valor]],\n  nombreHoja: act.nombreHoja\n}));\n\n// Preparar el resultado para el siguiente nodo\nreturn {\n  json: {\n    success: true,\n    mensaje: `Preparadas ${todasLasActualizaciones.length} actualizaciones optimizadas para la cita del ${fecha} de ${horaInicio} a ${horaFin} en ${muelle} (${duracionHoras} horas)`,\n    nombreHoja: nombreHojaActual,\n    optimizacion: resultadoOptimizacion,\n    graphRequestData: {\n      updates: actualizacionesGraph\n    },\n    detalles: {\n      actualizacionesDetalladas: todasLasActualizaciones,\n      diaSemana: obtenerDiaSemanaDesdeTexto(fecha),\n      informacionCita: {\n        fecha, horaInicio, horaFin, muelle, proveedor, ordenCompra, peso, categoria, unidades, duracionHoras\n      }\n    }\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1584,
        4064
      ],
      "id": "5b43a820-a05c-4844-ba17-a962b7bbad69",
      "name": "Code (Preparar Cuerpo de Petici√≥n)1"
    },
    {
      "parameters": {
        "jsCode": "// C√≥digo optimizado para \"Code Agrupar Franjas2\"\nconst input = $input.first().json;\n\n// Verificar que tenemos la estructura esperada\nif (!input || !input.graphRequestData || !input.graphRequestData.updates) {\n  console.log('Estructura de datos de entrada no v√°lida');\n  return {\n    json: {\n      error: \"FORMATO_INVALIDO\",\n      mensaje: \"La estructura de datos de entrada no es v√°lida\"\n    }\n  };\n}\n\nconst updates = input.graphRequestData.updates;\nconst optimizacion = input.optimizacion || {};\n\nconsole.log(`Procesando con optimizaci√≥n: ${optimizacion.optimizacionAplicada ? 'S√ç' : 'NO'}`);\nif (optimizacion.optimizacionAplicada) {\n  console.log(`Tipo de operaci√≥n: ${optimizacion.tipoOperacion}`);\n  console.log(`Estad√≠sticas: ${JSON.stringify(optimizacion.estadisticas)}`);\n}\n\n// **NUEVA L√ìGICA: Agrupar considerando optimizaci√≥n**\nfunction agruparActualizacionesOptimizada() {\n  const actualizacionesInsercion = updates.filter(u => u.values[0][0] !== \"\");\n  const actualizacionesEliminacion = updates.filter(u => u.values[0][0] === \"\");\n  \n  // Si no hay optimizaci√≥n, usar la l√≥gica original\n  if (!optimizacion.optimizacionAplicada) {\n    return agruparModeLegacy(actualizacionesInsercion, actualizacionesEliminacion);\n  }\n  \n  // **MODO OPTIMIZADO**: Agrupar solo las operaciones necesarias\n  console.log(`Modo optimizado activado:\n    - Inserciones necesarias: ${actualizacionesInsercion.length}\n    - Eliminaciones necesarias: ${actualizacionesEliminacion.length}\n    - Operaciones evitadas: ${optimizacion.estadisticas?.operacionesEvitadas || 0}`);\n  \n  const resultados = [];\n  const maxOperaciones = Math.max(actualizacionesInsercion.length, actualizacionesEliminacion.length);\n  \n  for (let i = 0; i < maxOperaciones; i++) {\n    const insercion = i < actualizacionesInsercion.length ? actualizacionesInsercion[i] : null;\n    const eliminacion = i < actualizacionesEliminacion.length ? actualizacionesEliminacion[i] : null;\n    \n    const parActualizaciones = {\n      json: {\n        insercion: insercion ? {\n          address: insercion.address,\n          values: insercion.values,\n          nombreHoja: insercion.nombreHoja || input.nombreHoja\n        } : null,\n        eliminacion: eliminacion ? {\n          address: eliminacion.address,\n          values: eliminacion.values,\n          nombreHoja: eliminacion.nombreHoja || input.nombreHoja\n        } : null,\n        indice: i + 1,\n        informacionCita: input.detalles?.informacionCita,\n        optimizacion: {\n          aplicada: true,\n          tipo: optimizacion.tipoOperacion,\n          estadisticas: optimizacion.estadisticas\n        }\n      }\n    };\n    \n    resultados.push(parActualizaciones);\n  }\n  \n  return resultados;\n}\n\nfunction agruparModeLegacy(actualizacionesInsercion, actualizacionesEliminacion) {\n  console.log('Usando modo legacy - sin optimizaci√≥n');\n  \n  const resultados = [];\n  const maxOperaciones = Math.max(actualizacionesInsercion.length, actualizacionesEliminacion.length);\n  \n  for (let i = 0; i < maxOperaciones; i++) {\n    const insercion = i < actualizacionesInsercion.length ? actualizacionesInsercion[i] : null;\n    const eliminacion = i < actualizacionesEliminacion.length ? actualizacionesEliminacion[i] : null;\n    \n    const parActualizaciones = {\n      json: {\n        insercion: insercion ? {\n          address: insercion.address,\n          values: insercion.values,\n          nombreHoja: insercion.nombreHoja || input.nombreHoja\n        } : null,\n        eliminacion: eliminacion ? {\n          address: eliminacion.address,\n          values: eliminacion.values,\n          nombreHoja: eliminacion.nombreHoja || input.nombreHoja\n        } : null,\n        indice: i + 1,\n        informacionCita: input.detalles?.informacionCita,\n        optimizacion: {\n          aplicada: false,\n          tipo: optimizacion.tipoOperacion || 'legacy',\n          estadisticas: { operacionesEvitadas: 0, eficiencia: '0%' }\n        }\n      }\n    };\n    \n    resultados.push(parActualizaciones);\n  }\n  \n  return resultados;\n}\n\n// Ejecutar agrupaci√≥n\nconst resultados = agruparActualizacionesOptimizada();\n\nconsole.log(`Se crearon ${resultados.length} pares de actualizaciones`);\n\nreturn resultados;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1792,
        4064
      ],
      "id": "4a31da57-97a2-459a-b8e1-2acefee27544",
      "name": "Code Agrupar Franjas2"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        2080,
        4064
      ],
      "id": "89bf399e-2ace-403b-93a5-b86e0fb9ea7f",
      "name": "Loop Over Uno a Uno1"
    },
    {
      "parameters": {
        "jsCode": "// C√≥digo optimizado para \"Code Preparar cada Insercion1\"\nconst input = $input.first().json;\n\n// Constantes para los IDs de SharePoint/OneDrive\nconst siteId = \"gexpresscargo.sharepoint.com,a592f886-4560-4e62-9646-1eee7add7abe,8b514073-41ae-4619-8f76-724bd912bc65\";\nconst driveId = \"b!hviSpWBFYk6WRh7uet16vnNAUYuuQRlGj3ZyS9kSvGVZ4DSg6c5MRqYYm2MdAER8\";\nconst itemId = \"01PPLUUYXY5E2GK3SJ25EZLJPUYJ43H3ME\";\n\n// Verificar que tenemos la estructura esperada\nif (!input || (!input.insercion && !input.eliminacion)) {\n  console.log('Estructura de datos de entrada no v√°lida para las operaciones');\n  return {\n    json: {\n      error: \"FORMATO_INVALIDO\",\n      mensaje: \"La estructura de datos de entrada no es v√°lida para las operaciones combinadas\"\n    }\n  };\n}\n\nconst optimizacion = input.optimizacion || { aplicada: false };\nconst indice = input.indice;\nconst informacionCita = input.informacionCita || {};\n\n// **NUEVA L√ìGICA: Preparar solicitudes considerando optimizaci√≥n**\nfunction prepararSolicitudOptimizada() {\n  const solicitudes = [];\n  \n  // Log de optimizaci√≥n\n  if (optimizacion.aplicada) {\n    console.log(`Preparando solicitud optimizada - Tipo: ${optimizacion.tipo}`);\n    console.log(`Estad√≠sticas de optimizaci√≥n: ${JSON.stringify(optimizacion.estadisticas)}`);\n  } else {\n    console.log('Preparando solicitud en modo legacy');\n  }\n  \n  // Preparar solicitud de inserci√≥n si existe\n  if (input.insercion && input.insercion.address && input.insercion.values) {\n    const requestIdInsercion = `insercion_${input.insercion.address}_${indice}_${Date.now()}`;\n    const nombreHojaInsercion = input.insercion.nombreHoja;\n    \n    if (!nombreHojaInsercion) {\n      console.log('Nombre de hoja faltante para inserci√≥n');\n      return {\n        json: {\n          error: \"HOJA_NO_ESPECIFICADA\",\n          mensaje: \"No se especific√≥ el nombre de la hoja para la inserci√≥n\"\n        }\n      };\n    }\n    \n    solicitudes.push({\n      id: requestIdInsercion,\n      method: \"PATCH\",\n      url: `/sites/${siteId}/drives/${driveId}/items/${itemId}/workbook/worksheets/${encodeURIComponent(nombreHojaInsercion)}/range(address='${input.insercion.address}')`,\n      body: {\n        values: input.insercion.values\n      },\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    });\n    \n    console.log(`Solicitud de inserci√≥n: \"${input.insercion.values[0][0]}\" en celda ${input.insercion.address} de hoja \"${nombreHojaInsercion}\"`);\n  }\n  \n  // Preparar solicitud de eliminaci√≥n si existe\n  if (input.eliminacion && input.eliminacion.address && input.eliminacion.values) {\n    const requestIdEliminacion = `eliminacion_${input.eliminacion.address}_${indice}_${Date.now()}`;\n    const nombreHojaEliminacion = input.eliminacion.nombreHoja;\n    \n    if (!nombreHojaEliminacion) {\n      console.log('Nombre de hoja faltante para eliminaci√≥n');\n      return {\n        json: {\n          error: \"HOJA_NO_ESPECIFICADA\",\n          mensaje: \"No se especific√≥ el nombre de la hoja para la eliminaci√≥n\"\n        }\n      };\n    }\n    \n    solicitudes.push({\n      id: requestIdEliminacion,\n      method: \"PATCH\",\n      url: `/sites/${siteId}/drives/${driveId}/items/${itemId}/workbook/worksheets/${encodeURIComponent(nombreHojaEliminacion)}/range(address='${input.eliminacion.address}')`,\n      body: {\n        values: input.eliminacion.values\n      },\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    });\n    \n    console.log(`Solicitud de eliminaci√≥n: limpiar celda ${input.eliminacion.address} en hoja \"${nombreHojaEliminacion}\"`);\n  }\n  \n  // **VALIDACI√ìN DE OPTIMIZACI√ìN**: Verificar que no estamos procesando franjas innecesarias\n  if (optimizacion.aplicada && optimizacion.tipo === \"mismo_dia_optimizado\") {\n    // En este caso, deber√≠amos tener menos solicitudes que en el modo legacy\n    console.log(`Optimizaci√≥n aplicada: procesando ${solicitudes.length} solicitudes en lugar de las operaciones completas`);\n  }\n  \n  return {\n    requests: solicitudes,\n    _metadata: {\n      indice: indice,\n      optimizacion: optimizacion,\n      operaciones: {\n        insercion: input.insercion ? {\n          celda: input.insercion.address,\n          valor: input.insercion.values[0][0],\n          hoja: input.insercion.nombreHoja\n        } : null,\n        eliminacion: input.eliminacion ? {\n          celda: input.eliminacion.address,\n          valor: \"\",\n          hoja: input.eliminacion.nombreHoja\n        } : null\n      },\n      informacionCita: informacionCita\n    }\n  };\n}\n\n// Verificar si alguna operaci√≥n es realmente necesaria\nif (!input.insercion && !input.eliminacion) {\n  console.log('No hay operaciones que procesar - posible optimizaci√≥n completa');\n  return {\n    json: {\n      requests: [],\n      _metadata: {\n        indice: indice,\n        optimizacion: { ...optimizacion, operacionCompleta: true },\n        mensaje: \"No se requieren operaciones - franjas mantenidas por optimizaci√≥n\"\n      }\n    }\n  };\n}\n\n// Preparar y retornar la solicitud\nconst requestBody = prepararSolicitudOptimizada();\n\nconsole.log(`Solicitud preparada con ${requestBody.requests.length} operaciones`);\n\nreturn {\n  json: requestBody\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2352,
        4160
      ],
      "id": "28e3e27b-6dbd-4579-bf0b-584e2684ae4a",
      "name": "Code Preparar cada Insercion1"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://graph.microsoft.com/v1.0/$batch",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "microsoftOAuth2Api",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        2608,
        4160
      ],
      "id": "d9e63adf-0aa5-4ca9-8240-17e0eac921f0",
      "name": "HTTP Request Actualizar Excel",
      "credentials": {
        "microsoftOAuth2Api": {
          "id": "mh8Z8hxFvd7LDO8D",
          "name": "CuentaMy SharePoint App Desarrollador1 Konfie "
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// C√≥digo actualizado para verificar tanto la inserci√≥n como la eliminaci√≥n\nconst input = $input.first().json;\n\n// Verificar que tenemos la estructura esperada en la respuesta\nif (!input || !input.responses || !Array.isArray(input.responses) || input.responses.length === 0) {\n  console.log('Estructura de datos de respuesta no v√°lida');\n  return {\n    json: {\n      error: \"RESPUESTA_INVALIDA\",\n      mensaje: \"La estructura de datos de la respuesta no es v√°lida\",\n      exito: false\n    }\n  };\n}\n\n// Buscar las respuestas de inserci√≥n y eliminaci√≥n\nconst respuestaInsercion = input.responses.find(r => r.id && r.id.includes('insercion_'));\nconst respuestaEliminacion = input.responses.find(r => r.id && r.id.includes('eliminacion_'));\n\n// Verificar si encontramos ambas respuestas\nif (!respuestaInsercion || !respuestaEliminacion) {\n  console.log('No se encontraron respuestas para inserci√≥n y/o eliminaci√≥n');\n  return {\n    json: {\n      error: \"RESPUESTAS_INCOMPLETAS\",\n      mensaje: \"No se encontraron respuestas para inserci√≥n y/o eliminaci√≥n\",\n      exito: false,\n      respuestasDisponibles: input.responses.map(r => r.id)\n    }\n  };\n}\n\n// Extraer informaci√≥n de las respuestas\nfunction extraerInfoCelda(respuesta) {\n  // Extraer informaci√≥n del ID\n  const idPartes = respuesta.id.split('_');\n  const tipoOperacion = idPartes[0]; // \"insercion\" o \"eliminacion\"\n  const celda = idPartes[1];         // Por ejemplo \"I21\"\n  \n  // Extraer informaci√≥n de direcci√≥n de la respuesta\n  let direccionRespuesta = \"\";\n  let hoja = \"\";\n  \n  if (respuesta.body && respuesta.body.address) {\n    // Formato t√≠pico: 'SEMANA 21'!I21\n    const direccionCompleta = respuesta.body.address;\n    const partesDireccion = direccionCompleta.split('!');\n    \n    if (partesDireccion.length > 1) {\n      // Eliminar comillas simples y extraer el nombre de la hoja\n      hoja = partesDireccion[0].replace(/'/g, '');\n      direccionRespuesta = partesDireccion[1];\n    }\n  }\n  \n  // Obtener el valor de la celda\n  const valor = respuesta.body && respuesta.body.values && \n                respuesta.body.values[0] && respuesta.body.values[0][0] !== undefined ? \n                respuesta.body.values[0][0] : null;\n  \n  // Verificar el c√≥digo de estado HTTP\n  const estadoExitoso = respuesta.status >= 200 && respuesta.status < 300;\n  \n  return {\n    id: respuesta.id,\n    tipoOperacion,\n    celda,\n    direccionRespuesta,\n    hoja,\n    valor,\n    estadoExitoso,\n    statusCode: respuesta.status\n  };\n}\n\n// Procesar ambas respuestas\nconst infoInsercion = extraerInfoCelda(respuestaInsercion);\nconst infoEliminacion = extraerInfoCelda(respuestaEliminacion);\n\n// Determinar √©xito global\nconst exitoGlobal = infoInsercion.estadoExitoso && infoEliminacion.estadoExitoso;\n\n// Crear resultado detallado\nconst resultado = {\n  exito: exitoGlobal,\n  operaciones: {\n    insercion: {\n      exito: infoInsercion.estadoExitoso,\n      celda: infoInsercion.celda,\n      celdaRespuesta: infoInsercion.direccionRespuesta,\n      hoja: infoInsercion.hoja,\n      valor: infoInsercion.valor,\n      statusCode: infoInsercion.statusCode\n    },\n    eliminacion: {\n      exito: infoEliminacion.estadoExitoso,\n      celda: infoEliminacion.celda,\n      celdaRespuesta: infoEliminacion.direccionRespuesta,\n      hoja: infoEliminacion.hoja,\n      valor: infoEliminacion.valor,\n      statusCode: infoEliminacion.statusCode\n    }\n  },\n  mensaje: exitoGlobal ? \n    `Operaciones completadas exitosamente - Inserci√≥n en ${infoInsercion.hoja} y eliminaci√≥n en ${infoEliminacion.hoja}` :\n    `Hubo problemas con una o ambas operaciones`,\n  respuestasOriginales: {\n    insercion: respuestaInsercion,\n    eliminacion: respuestaEliminacion\n  }\n};\n\n// Mantener compatibilidad con el formato antiguo para no romper flujos subsiguientes\nconst resultadoCompatible = {\n  exito: exitoGlobal,\n  celdaOriginal: infoInsercion.tipoOperacion,\n  celdaInsertada: infoInsercion.celda,\n  valorInsertado: infoInsercion.valor,\n  statusCode: infoInsercion.statusCode,\n  requestId: infoInsercion.id,\n  indice: infoInsercion.celda,\n  celdasDiferentes: false, // Ya no es relevante con la nueva estructura\n  falloEstado: !exitoGlobal,\n  respuestaOriginal: respuestaInsercion,\n  // Nuevos campos para la versi√≥n mejorada\n  resultadoDetallado: resultado\n};\n\n// Obtener chat_id si existe\nconst chatId = $('Organiza el Mensaje').first()?.json?.infoMensaje?.chat_id;\n\n// Registrar resultado en consola\nif (exitoGlobal) {\n  console.log(`Operaciones completadas exitosamente:`);\n  console.log(`- Inserci√≥n en hoja ${infoInsercion.hoja}, celda ${infoInsercion.celda}, valor: \"${infoInsercion.valor}\"`);\n  console.log(`- Eliminaci√≥n en hoja ${infoEliminacion.hoja}, celda ${infoEliminacion.celda}`);\n} else {\n  console.log(`Hubo problemas con una o ambas operaciones:`);\n  if (!infoInsercion.estadoExitoso) {\n    console.log(`- Fallo en inserci√≥n: status ${infoInsercion.statusCode}`);\n  }\n  if (!infoEliminacion.estadoExitoso) {\n    console.log(`- Fallo en eliminaci√≥n: status ${infoEliminacion.statusCode}`);\n  }\n}\n\n// Retornar el resultado\nreturn {\n  json: resultadoCompatible,\n  chat_id: chatId\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2832,
        4160
      ],
      "id": "6173b846-fe34-4e58-849d-780f3d2487c9",
      "name": "Code Verificar Inserci√≥n1"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "fb1eda05-eb5e-4683-8556-1cf2b5b8e4d5",
              "leftValue": "={{ $json.exito }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        3072,
        4224
      ],
      "id": "db9afa4b-2f65-4488-bb4f-929cc8dc54bb",
      "name": "If Verificar Inserci√≥n1"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "15a95144-dd82-4ea5-b9ba-9eb924d2ae5c",
              "leftValue": "={{ $json.celdasDiferentes }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        3280,
        4304
      ],
      "id": "5c641d26-3069-4971-95fd-c8eb52cb20fb",
      "name": "If Diferente Caso1"
    },
    {
      "parameters": {
        "jsCode": "// C√≥digo para limpiar una celda donde se insert√≥ incorrectamente un valor\n// Actualizado para manejar la nueva estructura con operaciones de inserci√≥n y eliminaci√≥n\nconst input = $input.first().json;\n\n// Constantes para los IDs de SharePoint/OneDrive\nconst siteId = \"gexpresscargo.sharepoint.com,a592f886-4560-4e62-9646-1eee7add7abe,8b514073-41ae-4619-8f76-724bd912bc65\";\nconst driveId = \"b!hviSpWBFYk6WRh7uet16vnNAUYuuQRlGj3ZyS9kSvGVZ4DSg6c5MRqYYm2MdAER8\";\nconst itemId = \"01PPLUUYXY5E2GK3SJ25EZLJPUYJ43H3ME\";\n\n// Verificar que tenemos la informaci√≥n necesaria\nif (!input || (!input.operaciones && !input.celdaInsertada)) {\n  console.log('Informaci√≥n insuficiente para limpiar la celda incorrecta');\n  return {\n    json: {\n      error: \"INFORMACION_INSUFICIENTE\",\n      mensaje: \"No hay suficiente informaci√≥n para limpiar la celda incorrecta\"\n    }\n  };\n}\n\n// Determinar qu√© celdas necesitan limpieza\nconst celdasALimpiar = [];\n\n// Verificar si estamos usando la nueva estructura con operaciones\nif (input.operaciones) {\n  // Nueva estructura: usar informaci√≥n de las operaciones\n  const { insercion, eliminacion } = input.operaciones;\n  \n  // Si la inserci√≥n fall√≥, agregarla para limpieza\n  if (insercion && !insercion.exito && insercion.celdaRespuesta) {\n    celdasALimpiar.push({\n      celda: insercion.celdaRespuesta,\n      hoja: insercion.hoja || \"\"\n    });\n  }\n  \n  // Si la eliminaci√≥n fall√≥, agregarla para limpieza\n  if (eliminacion && !eliminacion.exito && eliminacion.celdaRespuesta) {\n    celdasALimpiar.push({\n      celda: eliminacion.celdaRespuesta,\n      hoja: eliminacion.hoja || \"\"\n    });\n  }\n} else {\n  // Estructura anterior: solo tenemos informaci√≥n de inserci√≥n\n  // Obtener la celda a limpiar y la informaci√≥n de la hoja\n  const celdaALimpiar = input.celdaInsertada;\n  let hojaExcel = input.nombreHoja || \"\"; // Usar el nombreHoja del input\n  \n  // Intentar extraer el nombre de la hoja de la direcci√≥n en la respuesta si no est√° disponible\n  if ((!hojaExcel || hojaExcel === \"\") && input.respuestaOriginal?.body?.address) {\n    const direccionCompleta = input.respuestaOriginal.body.address;\n    hojaExcel = direccionCompleta.split('!')[0].replace(/'/g, '');\n  }\n  \n  celdasALimpiar.push({\n    celda: celdaALimpiar,\n    hoja: hojaExcel\n  });\n}\n\n// Si no hay celdas para limpiar, devolver error\nif (celdasALimpiar.length === 0) {\n  console.log('No se identificaron celdas para limpiar');\n  return {\n    json: {\n      error: \"NO_HAY_CELDAS\",\n      mensaje: \"No se identificaron celdas que necesiten limpieza\",\n      input: input\n    }\n  };\n}\n\n// Crear solicitudes para limpiar cada celda identificada\nconst solicitudes = celdasALimpiar.map((info, index) => {\n  console.log(`Limpiando celda incorrecta ${info.celda} en hoja ${info.hoja}`);\n  \n  return {\n    id: `Limpiar_${info.celda}_${Date.now()}_${index}`,\n    method: \"PATCH\",\n    url: `/sites/${siteId}/drives/${driveId}/items/${itemId}/workbook/worksheets/${encodeURIComponent(info.hoja)}/range(address='${info.celda}')`,\n    body: {\n      values: [[\"\"]] // Valor vac√≠o para limpiar la celda\n    },\n    headers: {\n      \"Content-Type\": \"application/json\"\n    }\n  };\n});\n\n// Crear la solicitud para limpiar las celdas\nconst requestBody = {\n  requests: solicitudes,\n  _metadata: {\n    accion: \"limpiar\",\n    celdasLimpiadas: celdasALimpiar,\n    datoOriginal: input\n  }\n};\n\n// Retornar el request para limpiar la celda\nreturn {\n  json: requestBody\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3584,
        4128
      ],
      "id": "62656635-9227-4c8a-89b4-f8f90e4f42e3",
      "name": "Code Limpiar Celda Incorrecta1",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://graph.microsoft.com/v1.0/$batch",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "microsoftOAuth2Api",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        3808,
        4128
      ],
      "id": "69f7f883-7492-4cf5-a64b-e5239328c142",
      "name": "HTTP Request Limpiar Celda1",
      "credentials": {
        "microsoftOAuth2Api": {
          "id": "mh8Z8hxFvd7LDO8D",
          "name": "CuentaMy SharePoint App Desarrollador1 Konfie "
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "e570827e-13d0-4d6f-b23e-184ca2d3368c",
              "leftValue": "={{ $json.falloEstado }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        3744,
        4512
      ],
      "id": "59d12087-3bda-4968-a282-010e79e7219f",
      "name": "If fallo Estado1"
    },
    {
      "parameters": {
        "jsCode": "// C√≥digo para reintentar la inserci√≥n en la celda correcta\n// Actualizado para manejar la nueva estructura con operaciones de inserci√≥n y eliminaci√≥n\nconst input = $input.first().json;\n\n// Constantes para los IDs de SharePoint/OneDrive\nconst siteId = \"gexpresscargo.sharepoint.com,a592f886-4560-4e62-9646-1eee7add7abe,8b514073-41ae-4619-8f76-724bd912bc65\";\nconst driveId = \"b!hviSpWBFYk6WRh7uet16vnNAUYuuQRlGj3ZyS9kSvGVZ4DSg6c5MRqYYm2MdAER8\";\nconst itemId = \"01PPLUUYXY5E2GK3SJ25EZLJPUYJ43H3ME\";\n\n// Si el input viene del nodo anterior de limpiar celda, extraer el dato original\nconst datoOriginal = input._metadata?.datoOriginal || input;\n\n// Verificar que tenemos la informaci√≥n necesaria\nif (!datoOriginal) {\n  console.log('Informaci√≥n insuficiente para reintentar la inserci√≥n/eliminaci√≥n');\n  return {\n    json: {\n      error: \"INFORMACION_INSUFICIENTE\",\n      mensaje: \"No hay suficiente informaci√≥n para reintentar las operaciones\"\n    }\n  };\n}\n\n// Operaciones a reintentar\nconst operacionesAReintentar = [];\n\n// Determinar qu√© operaciones necesitan reintento\nif (datoOriginal.operaciones) {\n  // Nueva estructura: evaluar inserci√≥n y eliminaci√≥n\n  const { insercion, eliminacion } = datoOriginal.operaciones;\n  \n  // Verificar si la inserci√≥n necesita reintento\n  if (insercion && !insercion.exito) {\n    operacionesAReintentar.push({\n      tipo: \"insercion\",\n      celda: insercion.celda,\n      valor: insercion.valor,\n      hoja: insercion.hoja || datoOriginal.resultadoDetallado?.operaciones?.insercion?.hoja || \"\"\n    });\n  }\n  \n  // Verificar si la eliminaci√≥n necesita reintento\n  if (eliminacion && !eliminacion.exito) {\n    operacionesAReintentar.push({\n      tipo: \"eliminacion\",\n      celda: eliminacion.celda,\n      valor: \"\", // Para eliminaci√≥n, siempre usamos valor vac√≠o\n      hoja: eliminacion.hoja || datoOriginal.resultadoDetallado?.operaciones?.eliminacion?.hoja || \"\"\n    });\n  }\n} else {\n  // Estructura anterior: solo tenemos informaci√≥n de inserci√≥n\n  // Obtener la celda correcta donde insertar y el valor a insertar\n  const celdaCorrecta = datoOriginal.celdaOriginal;\n  \n  // Intentar obtener el valor correcto a insertar\n  let valorAInsertar;\n  \n  // Primero, verificar si tenemos el valor de la respuesta original\n  if (datoOriginal.valorInsertado !== undefined) {\n    valorAInsertar = datoOriginal.valorInsertado;\n  } \n  // Si no, intentar obtenerlo del body de la respuesta\n  else if (datoOriginal.respuestaOriginal?.body?.values?.[0]?.[0] !== undefined) {\n    valorAInsertar = datoOriginal.respuestaOriginal.body.values[0][0];\n  } \n  // Como √∫ltimo recurso, usar un valor vac√≠o\n  else {\n    valorAInsertar = \"\";\n    console.log('No se pudo determinar el valor a insertar, usando valor vac√≠o');\n  }\n  \n  // Obtener la hoja de Excel - primero del dato original\n  let hojaExcel = datoOriginal.nombreHoja || \"\"; \n  \n  // Si no est√° disponible en el objeto principal, intentar obtenerlo de otros lugares\n  if (!hojaExcel || hojaExcel === \"\") {\n    // Verificar si est√° en el _metadata\n    hojaExcel = input._metadata?.hoja || \"\";\n    \n    // Como √∫ltimo recurso, extraer de la direcci√≥n en la respuesta\n    if ((!hojaExcel || hojaExcel === \"\") && datoOriginal.respuestaOriginal?.body?.address) {\n      const direccionCompleta = datoOriginal.respuestaOriginal.body.address;\n      hojaExcel = direccionCompleta.split('!')[0].replace(/'/g, '');\n    }\n  }\n  \n  operacionesAReintentar.push({\n    tipo: \"insercion\",\n    celda: celdaCorrecta,\n    valor: valorAInsertar,\n    hoja: hojaExcel\n  });\n}\n\n// Si no hay operaciones para reintentar, devolver error\nif (operacionesAReintentar.length === 0) {\n  console.log('No se identificaron operaciones para reintentar');\n  return {\n    json: {\n      error: \"NO_HAY_OPERACIONES\",\n      mensaje: \"No se identificaron operaciones que necesiten reintento\",\n      input: datoOriginal\n    }\n  };\n}\n\n// Crear solicitudes para cada operaci√≥n a reintentar\nconst solicitudes = operacionesAReintentar.map((op, index) => {\n  // Determinar el tipo de valor y formatearlo adecuadamente\n  let valorFormateado;\n  if (typeof op.valor === 'number') {\n    valorFormateado = [[op.valor]]; // Mantener el tipo num√©rico\n  } else {\n    valorFormateado = [[op.valor.toString()]]; // Convertir a string para otros tipos\n  }\n  \n  console.log(`Reintentando ${op.tipo} en celda ${op.celda} de la hoja ${op.hoja} con valor \"${op.valor}\"`);\n  \n  return {\n    id: `Reintento_${op.tipo}_${op.celda}_${Date.now()}_${index}`,\n    method: \"PATCH\",\n    url: `/sites/${siteId}/drives/${driveId}/items/${itemId}/workbook/worksheets/${encodeURIComponent(op.hoja)}/range(address='${op.celda}')`,\n    body: {\n      values: valorFormateado\n    },\n    headers: {\n      \"Content-Type\": \"application/json\"\n    }\n  };\n});\n\n// Crear la solicitud para reintentar las operaciones\nconst requestBody = {\n  requests: solicitudes,\n  _metadata: {\n    accion: \"reintentar\",\n    operaciones: operacionesAReintentar,\n    datoOriginal: datoOriginal,\n    intentos: (datoOriginal._metadata?.intentos || 0) + 1\n  }\n};\n\n// Retornar el request para reintentar las operaciones\nreturn {\n  json: requestBody\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4080,
        4192
      ],
      "id": "1a45be21-8a58-435b-959d-e26475978476",
      "name": "Code Reintentar Inserci√≥n1",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://graph.microsoft.com/v1.0/$batch",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "microsoftOAuth2Api",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        4320,
        4304
      ],
      "id": "51a66a8e-dc72-4052-b040-836c2ba0ea09",
      "name": "HTTP Request Reintentar Inserci√≥n1",
      "credentials": {
        "microsoftOAuth2Api": {
          "id": "mh8Z8hxFvd7LDO8D",
          "name": "CuentaMy SharePoint App Desarrollador1 Konfie "
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// C√≥digo para verificar si la inserci√≥n y eliminaci√≥n fueron exitosas\n// Actualizado para manejar la nueva estructura\nconst input = $input.first().json;\n\n// Verificar que tenemos la estructura esperada en la respuesta\nif (!input || !input.responses || !Array.isArray(input.responses)) {\n  console.log('Estructura de datos de respuesta no v√°lida');\n  return {\n    json: {\n      error: \"RESPUESTA_INVALIDA\",\n      mensaje: \"La estructura de datos de la respuesta no es v√°lida\",\n      exito: false\n    }\n  };\n}\n\n// Si no hay respuestas, devolver error\nif (input.responses.length === 0) {\n  console.log('No se recibieron respuestas del servidor');\n  return {\n    json: {\n      error: \"SIN_RESPUESTAS\",\n      mensaje: \"No se recibieron respuestas del servidor\",\n      exito: false\n    }\n  };\n}\n\n// Analizar las respuestas para determinar a qu√© operaci√≥n corresponde cada una\nconst respuestas = input.responses.map(response => {\n  // Extraer informaci√≥n del ID de la respuesta\n  const idPartes = response.id.split('_');\n  const tipoOperacion = idPartes[0].toLowerCase(); // \"reintento\", \"limpiar\", etc.\n  const tipoEntidad = idPartes[1]?.toLowerCase(); // \"insercion\", \"eliminacion\", etc.\n  const celda = idPartes[2] || \"\"; // La celda como I21, K23, etc.\n  \n  // Extraer informaci√≥n de la direcci√≥n en la respuesta\n  let direccionRespuesta = \"\";\n  let hojaExcel = \"\";\n  \n  if (response.body && response.body.address) {\n    const direccionCompleta = response.body.address;\n    const partesDireccion = direccionCompleta.split('!');\n    \n    if (partesDireccion.length > 1) {\n      // Quitar las comillas simples del nombre de la hoja\n      hojaExcel = partesDireccion[0].replace(/'/g, '');\n      direccionRespuesta = partesDireccion[1];\n    }\n  }\n  \n  // Obtener el valor de la respuesta\n  const valor = response.body?.values?.[0]?.[0];\n  \n  // Verificar si la operaci√≥n fue exitosa (c√≥digo 200-299)\n  const estadoExitoso = response.status >= 200 && response.status < 300;\n  \n  // Verificar si la celda en la respuesta coincide con la esperada\n  const celdaCorrecta = direccionRespuesta === celda;\n  \n  return {\n    id: response.id,\n    tipoOperacion,\n    tipoEntidad,\n    celda,\n    direccionRespuesta,\n    hoja: hojaExcel,\n    valor,\n    estadoExitoso,\n    celdaCorrecta,\n    statusCode: response.status,\n    respuesta: response\n  };\n});\n\n// Separar las respuestas por tipo de operaci√≥n\nconst respuestasInsercion = respuestas.filter(r => \n  r.tipoEntidad === \"insercion\" || \n  (r.tipoOperacion === \"reintento\" && input._metadata?.operaciones?.[0]?.tipo === \"insercion\")\n);\n\nconst respuestasEliminacion = respuestas.filter(r => \n  r.tipoEntidad === \"eliminacion\" || \n  (r.tipoOperacion === \"reintento\" && input._metadata?.operaciones?.[0]?.tipo === \"eliminacion\")\n);\n\n// Determinar √©xito por tipo de operaci√≥n\nconst insercionExitosa = respuestasInsercion.length > 0 && \n                        respuestasInsercion.every(r => r.estadoExitoso && r.celdaCorrecta);\n\nconst eliminacionExitosa = respuestasEliminacion.length > 0 && \n                          respuestasEliminacion.every(r => r.estadoExitoso && r.celdaCorrecta);\n\n// Determinar √©xito global basado en las operaciones presentes\nlet exitoGlobal;\n\nif (respuestasInsercion.length > 0 && respuestasEliminacion.length > 0) {\n  // Si hay ambas operaciones, ambas deben ser exitosas\n  exitoGlobal = insercionExitosa && eliminacionExitosa;\n} else if (respuestasInsercion.length > 0) {\n  // Si solo hay inserci√≥n, solo esa debe ser exitosa\n  exitoGlobal = insercionExitosa;\n} else if (respuestasEliminacion.length > 0) {\n  // Si solo hay eliminaci√≥n, solo esa debe ser exitosa\n  exitoGlobal = eliminacionExitosa;\n} else {\n  // Si no hay operaciones identificables, considerar como no exitoso\n  exitoGlobal = false;\n}\n\n// Obtener la informaci√≥n m√°s relevante para cada tipo de operaci√≥n\nconst infoInsercion = respuestasInsercion.length > 0 ? respuestasInsercion[0] : null;\nconst infoEliminacion = respuestasEliminacion.length > 0 ? respuestasEliminacion[0] : null;\n\n// Crear el resultado detallado\nconst resultadoDetallado = {\n  exito: exitoGlobal,\n  operaciones: {\n    insercion: infoInsercion ? {\n      exito: infoInsercion.estadoExitoso && infoInsercion.celdaCorrecta,\n      celda: infoInsercion.celda,\n      direccionRespuesta: infoInsercion.direccionRespuesta,\n      hoja: infoInsercion.hoja,\n      valor: infoInsercion.valor,\n      statusCode: infoInsercion.statusCode\n    } : null,\n    eliminacion: infoEliminacion ? {\n      exito: infoEliminacion.estadoExitoso && infoEliminacion.celdaCorrecta,\n      celda: infoEliminacion.celda,\n      direccionRespuesta: infoEliminacion.direccionRespuesta,\n      hoja: infoEliminacion.hoja,\n      valor: infoEliminacion.valor,\n      statusCode: infoEliminacion.statusCode\n    } : null\n  },\n  mensaje: exitoGlobal ? \n    \"Todas las operaciones se completaron exitosamente\" : \n    \"Hubo problemas con una o m√°s operaciones\",\n  respuestasCompletas: respuestas\n};\n\n// Crear el resultado compatible con el formato anterior\nconst resultadoCompatible = {\n  exito: exitoGlobal,\n  // Usar la primera respuesta para compatibilidad\n  celdaOriginal: infoInsercion?.celda || infoEliminacion?.celda || \"\",\n  celdaInsertada: infoInsercion?.direccionRespuesta || infoEliminacion?.direccionRespuesta || \"\",\n  valorInsertado: infoInsercion?.valor || infoEliminacion?.valor || \"\",\n  statusCode: infoInsercion?.statusCode || infoEliminacion?.statusCode || 0,\n  requestId: infoInsercion?.id || infoEliminacion?.id || \"\",\n  indice: infoInsercion?.celda || infoEliminacion?.celda || \"\",\n  celdasDiferentes: (infoInsercion && infoInsercion.celda !== infoInsercion.direccionRespuesta) ||\n                   (infoEliminacion && infoEliminacion.celda !== infoEliminacion.direccionRespuesta),\n  falloEstado: !exitoGlobal,\n  // Informaci√≥n adicional para la versi√≥n mejorada\n  resultadoDetallado: resultadoDetallado\n};\n\n// Registrar el resultado en consola\nif (exitoGlobal) {\n  console.log(\"Operaciones completadas exitosamente:\");\n  if (infoInsercion) {\n    console.log(`- Inserci√≥n en hoja ${infoInsercion.hoja}, celda ${infoInsercion.celda}, valor: \"${infoInsercion.valor}\"`);\n  }\n  if (infoEliminacion) {\n    console.log(`- Eliminaci√≥n en hoja ${infoEliminacion.hoja}, celda ${infoEliminacion.celda}`);\n  }\n} else {\n  console.log(\"Problemas detectados en las operaciones:\");\n  if (infoInsercion && (!infoInsercion.estadoExitoso || !infoInsercion.celdaCorrecta)) {\n    console.log(`- Fallo en inserci√≥n: celda=${infoInsercion.celda}, direcci√≥n respuesta=${infoInsercion.direccionRespuesta}, status=${infoInsercion.statusCode}`);\n  }\n  if (infoEliminacion && (!infoEliminacion.estadoExitoso || !infoEliminacion.celdaCorrecta)) {\n    console.log(`- Fallo en eliminaci√≥n: celda=${infoEliminacion.celda}, direcci√≥n respuesta=${infoEliminacion.direccionRespuesta}, status=${infoEliminacion.statusCode}`);\n  }\n}\n\n// Retornar el resultado\nreturn {\n  json: resultadoCompatible\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4544,
        4304
      ],
      "id": "1731bfb3-8885-42eb-859d-414405a749a2",
      "name": "Code Volver a validar Inserci√≥n1",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "f7205e4e-147c-4e77-8fa8-08d082980b48",
              "leftValue": "={{ $json.exito }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        4768,
        4304
      ],
      "id": "52bd4f5e-3c52-4494-9b45-061af007871f",
      "name": "If Verificar Inserci√≥n "
    },
    {
      "parameters": {
        "amount": 3
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        3664,
        4304
      ],
      "id": "1a82e9d0-517b-410f-9134-f864e8e94faf",
      "name": "Wait4",
      "webhookId": "a4bbf2b1-ea0c-4b02-af2c-64b29f2bdb5c"
    },
    {
      "parameters": {
        "amount": 3
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        5072,
        4480
      ],
      "id": "9f23fcee-bdc2-4da3-873c-d52a2f9c85ea",
      "name": "Wait5",
      "webhookId": "9d944db7-9c4f-439e-9990-d9937f2fb18e"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        5504,
        4848
      ],
      "id": "32be7b94-49b1-4dab-91aa-279af7feaacb",
      "name": "OpenAI Chat Model15",
      "credentials": {
        "openAiApi": {
          "id": "AD8kPcNVReuclASd",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "=define",
        "text": "=Eres un asistente de un sistema de agendamiento de citas para la entrega de mercanc√≠a en bodega. Debes notificar al cliente que ha ocurrido un error en el sistema durante el proceso de inserci√≥n de la cita en el sistema de Excel.\n\nGenera un mensaje directo (sin saludos iniciales ni mencionar nombres) que:\n\n1. Comunique claramente que se produjo un error t√©cnico al intentar registrar la cita en el sistema.\n\n2. Indique que es urgente que se comunique con el √°rea de bodega en los pr√≥ximos 5 minutos para que puedan agendar la cita manualmente.\n\n4. Mencione que, de no establecer contacto en ese tiempo, existe el riesgo de perder la franja horaria seleccionada debido a la alta demanda de los muelles.\n\n5. Aclare que esta situaci√≥n es poco com√∫n y se debe a un inconveniente t√©cnico en el sistema de agendamiento.\n\n6. Pida disculpas por los inconvenientes ocasionados y agradezca la comprensi√≥n.\n\nTono: urgente pero profesional, enfatizando la importancia de la acci√≥n inmediata para mantener la franja horaria seleccionada.\n"
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        5584,
        4624
      ],
      "id": "5cec7693-b051-4d67-9bf2-d8ba3b79c9f3",
      "name": "Basic LLM Notificar No Disponibilidad3",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "4bfbecb3-9d4f-4425-aa76-a92abc7708fb",
              "leftValue": "={{ $('Basic LLM Notificar No Disponibilidad3').item.json.text.length }}",
              "rightValue": 70,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        5984,
        4800
      ],
      "id": "5b539820-cf5d-44a2-b389-11a612d37e01",
      "name": "Validaci√≥n de longitud de caracteres10"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d9c2ff70-4fd1-4b93-8571-6d0ac5a0093e",
              "name": "mensaje.ia",
              "value": "={{ $('Basic LLM Notificar No Disponibilidad3').item.json.text }}",
              "type": "string"
            },
            {
              "id": "ac8a03be-0292-4735-9580-39a385945c47",
              "name": "mensaje.longitud",
              "value": "={{ $('Basic LLM Notificar No Disponibilidad3').item.json.text.length }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        6288,
        4832
      ],
      "id": "a7816a05-603b-418b-92c6-6876b6bdd9bb",
      "name": "Organiza variables del mensaje10"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        6464,
        4608
      ],
      "id": "2adcdf10-5cc4-4446-9dad-d94cafe9624b",
      "name": "No Operation, do nothing14"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $('Code Respuesta Faltantes').item.json.text }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        6288,
        4608
      ],
      "id": "a4932d16-b7ec-4a71-a440-0dfdcb2c55b1",
      "name": "HTTP Request Enviar Mensaje por WhatsApp13"
    },
    {
      "parameters": {
        "jsCode": "/*\n===========================================================\n  Nodo Code - VALIDAR INSERCIONES EN EXCEL (n8n)\n  ‚Ä¢ Analiza la salida del ‚ÄúLoop Over Uno a Uno‚Äù.\n  ‚Ä¢ Agrupa los √≠tems por franja (campo `indice` si existe;\n    de lo contrario, cada bloque de 5 √≠tems forma una franja).\n  ‚Ä¢ Verifica que cada inserci√≥n tenga:\n        exito === true\n        statusCode === 200\n        falloEstado === false\n  ‚Ä¢ Devuelve un √∫nico objeto JSON con:\n        ‚Äì Resumen global.\n        ‚Äì Detalle por franja (√©xitos / fallos y celdas con error).\n===========================================================\n*/\n\n// 1) Obtener todos los √≠tems que llegan al nodo\nconst items = $input.all();\n\n// 2) Funci√≥n auxiliar para determinar el identificador de la franja\nfunction obtenerIdFranja(item, idx) {\n  // Si existe 'indice', √∫salo; de lo contrario agrupa cada 5 √≠tems\n  if (item.json && item.json.indice !== undefined && item.json.indice !== null) {\n    return String(item.json.indice).trim();\n  }\n  // +1 para que las franjas queden 1-basadas\n  return String(Math.floor(idx / 5) + 1);\n}\n\n// 3) Agrupar √≠tems por franja\nconst franjas = {};\nitems.forEach((item, idx) => {\n  const idFranja = obtenerIdFranja(item, idx);\n  if (!franjas[idFranja]) {\n    franjas[idFranja] = { id: idFranja, items: [] };\n  }\n  franjas[idFranja].items.push(item.json);\n});\n\n// 4) Analizar cada franja y construir el detalle\nconst detallesPorFranja = Object.values(franjas).map(franja => {\n  const totalOps   = franja.items.length;\n  const exitosas   = franja.items.filter(i =>\n    i.exito === true &&\n    i.statusCode === 200 &&\n    i.falloEstado === false\n  ).length;\n\n  const fallidas   = totalOps - exitosas;\n  const exitoTotal = fallidas === 0;\n\n  // Celdas con error para un diagn√≥stico claro\n  const celdasFallidas = franja.items\n    .filter(i => !(i.exito && i.statusCode === 200 && !i.falloEstado))\n    .map(i => ({\n      celdaOriginal   : i.celdaOriginal,\n      celdaInsertada  : i.celdaInsertada,\n      statusCode      : i.statusCode,\n      falloEstado     : i.falloEstado,\n      celdasDiferentes: i.celdasDiferentes,\n      mensaje         : 'Inserci√≥n fallida'\n    }));\n\n  return {\n    idFranja                : franja.id,\n    exitoFranja             : exitoTotal,\n    operacionesTotales      : totalOps,\n    operacionesExitosas     : exitosas,\n    operacionesFallidas     : fallidas,\n    porcentajeExitosas      : ((exitosas / totalOps) * 100).toFixed(2) + '%',\n    celdasFallidas\n  };\n});\n\n// 5) Resumen global\nconst operacionesTotales   = items.length;\nconst operacionesExitosas  = detallesPorFranja.reduce((sum, f) => sum + f.operacionesExitosas, 0);\nconst operacionesFallidas  = operacionesTotales - operacionesExitosas;\n\nconst franjasTotales   = detallesPorFranja.length;\nconst franjasExitosas  = detallesPorFranja.filter(f => f.exitoFranja).length;\nconst franjasFallidas  = franjasTotales - franjasExitosas;\n\n\nconst resumen = {\n  estadoGeneral              : franjasFallidas === 0 ? '√âXITO_COMPLETO' : '√âXITO_PARCIAL',\n  franjasTotales,\n  franjasExitosas,\n  franjasFallidas,\n  porcentajeFranjasExitosas  : ((franjasExitosas / franjasTotales) * 100).toFixed(2) + '%',\n  operacionesTotales,\n  operacionesExitosas,\n  operacionesFallidas,\n  porcentajeOperacionesExitosas : ((operacionesExitosas / operacionesTotales) * 100).toFixed(2) + '%',\n  detallesPorFranja\n};\n\n// 6) Devolver un √∫nico √≠tem con el resumen\nreturn [\n  {\n    json: resumen\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2464,
        3968
      ],
      "id": "9cd94bc3-fb00-4e7c-80b0-c353f285ca4d",
      "name": "Code Validar inserciones1"
    },
    {
      "parameters": {
        "jsCode": "// 1) Leer chat_id una sola vez\nconst chatId = $node[\"Organiza el Mensaje\"].json.infoMensaje.chat_id;\n\n// 2) Tomamos los datos de informacionCita una sola vez\nconst cita = $input.first().json.informacionCita || {};\nconst historialMensajes = $('Unificaci√≥n y consistencia de datos').first().json.infoMensaje.historialMensajes;\n\n// Funci√≥n para convertir fechas en formato \"06 de mayo de 2025\" a \"YYYY-MM-DD HH:mm:ss\"\nfunction convertirFecha(fechaTexto) {\n  const meses = {\n    enero: '01', febrero: '02', marzo: '03', abril: '04', mayo: '05',\n    junio: '06', julio: '07', agosto: '08', septiembre: '09',\n    octubre: '10', noviembre: '11', diciembre: '12'\n  };\n\n  // Dividir la fecha y mapear el mes\n  const [dia, de, mes, deNuevo, anio] = fechaTexto.split(' ');\n  const mesNumerico = meses[mes.toLowerCase()]; // Convertir el mes a n√∫mero\n  return `${anio}-${mesNumerico}-${dia.padStart(2, '0')} 00:00:00`; // Formato DATETIME\n}\n\n// Convertimos la fecha aqu√≠\nconst fechaCitaConvertida = convertirFecha(cita.fecha);\n\n// 3) Retornamos un solo objeto con todos los datos necesarios\nreturn {\n  json: {\n    chat_id: chatId,\n    proveedor: cita.proveedor,\n    orden_compra: cita.ordenCompra,\n    peso: cita.peso,\n    unidades: cita.unidades,\n    categoria: cita.categoria,\n    muelle: cita.muelle,\n    fecha_cita: fechaCitaConvertida, // Fecha ya convertida\n    hora_inicio: cita.horaInicio,\n    hora_fin: cita.horaFin,\n    chat_historial: historialMensajes,\n    // Incluimos cualquier otro dato que necesites\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2464,
        3824
      ],
      "id": "e24e6338-a55d-468f-9c16-7579c37f0aef",
      "name": "Code Datos Insert Cita1"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "8c501d95-bdf3-4635-a037-224926c2528d",
              "leftValue": "={{ $json.estadoGeneral }}",
              "rightValue": "√âXITO_COMPLETO",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        2800,
        3968
      ],
      "id": "7f075f7a-0688-45ff-aa71-47a241a6510c",
      "name": "If Validar inserciones1"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.1,
      "position": [
        3104,
        3840
      ],
      "id": "2c0d9060-b5d9-4ac1-af01-e58703c33770",
      "name": "Merge4"
    },
    {
      "parameters": {
        "numberInputs": 3
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.1,
      "position": [
        5952,
        4288
      ],
      "id": "406dae42-a794-4f8a-ac06-499255c33d7d",
      "name": "Merge5"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO CitasRecepcion\n(\n    chat_id,\n    nombre,              \n    orden_compra,\n    peso,\n    unidades,\n    horas_entrega,\n    categoria,\n    muelle,\n    fecha_cita,\n    hora_inicio,\n    hora_fin,\n    estado,\n    fecha_creacion,\n    fecha_modificacion,\n    chat_historial,\n    chat_historial_datos\n)\n/* ‚îÄ‚îÄ‚îÄ AQU√ç ‚îÄ‚îÄ‚îÄ */\nOUTPUT INSERTED.id          --  ‚Üê  devolver√° el IDENTITY de la fila reci√©n insertada\nVALUES\n(\n    '{{ $('Code Datos Insert Cita1').item.json.chat_id }}',\n    '{{ $('Code Datos Insert Cita1').item.json.proveedor }}',\n    '{{ $('Code Datos Insert Cita1').item.json.orden_compra }}',\n     {{ $('Code Datos Insert Cita1').item.json.peso }},\n     {{ $('Code Datos Insert Cita1').item.json.unidades }},\n     {{ $json.horas_entrega }},\n    '{{ $('Code Datos Insert Cita1').item.json.categoria }}',\n    '{{ $('Code Datos Insert Cita1').item.json.muelle }}',\n    '{{ $('Code Datos Insert Cita1').item.json.fecha_cita }}',\n    '{{ $('Code Datos Insert Cita1').item.json.hora_inicio }}',\n    '{{ $('Code Datos Insert Cita1').item.json.hora_fin }}',   \n      'PROGRAMADA',                   \n    (SYSDATETIMEOFFSET() AT TIME ZONE 'SA Pacific Standard Time'), \n    NULL,                            \n    '{{ $items(\"Code Datos Insert Cita1\")\n        .map(i => i.json.chat_historial)\n        .join(\"\\n\")\n        .replace(/'/g,\"''\") }}',\n    'SIN DATOS'\n);\n\n"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        5392,
        4048
      ],
      "id": "1de654c6-3b49-48f1-8595-17f3a76c5938",
      "name": "Microsoft SQL Insertar Cita1",
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        6272,
        4384
      ],
      "id": "78e5ca48-2a5e-4ede-9fe4-0bcbe0b21935",
      "name": "OpenAI Chat Model16",
      "credentials": {
        "openAiApi": {
          "id": "AD8kPcNVReuclASd",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "4bfbecb3-9d4f-4425-aa76-a92abc7708fb",
              "leftValue": "={{ $('Basic LLM Notificar Cita Exitosa1').item.json.text.length }}",
              "rightValue": 70,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        6800,
        4352
      ],
      "id": "f69b6403-6626-4d8b-ad30-db5239427b8b",
      "name": "Validaci√≥n de longitud de caracteres11"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d9c2ff70-4fd1-4b93-8571-6d0ac5a0093e",
              "name": "mensaje.ia",
              "value": "={{ $('Basic LLM Notificar Cita Exitosa1').item.json.text }}",
              "type": "string"
            },
            {
              "id": "ac8a03be-0292-4735-9580-39a385945c47",
              "name": "mensaje.longitud",
              "value": "={{ $('Basic LLM Notificar Cita Exitosa1').item.json.text.length }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        7104,
        4464
      ],
      "id": "db91bf40-493c-46f4-b95b-71e536326465",
      "name": "Organiza variables del mensaje11"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        7264,
        4240
      ],
      "id": "14779deb-f81c-4ad0-a8b8-823709d1b88c",
      "name": "No Operation, do nothing15"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $('Code Respuesta Faltantes').item.json.text }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        7088,
        4240
      ],
      "id": "46d25768-1862-4481-8678-141afe424e09",
      "name": "HTTP Request Enviar Mensaje por WhatsApp14"
    },
    {
      "parameters": {
        "promptType": "=define",
        "text": "=# Rol\nEres el asistente virtual de **Konf√≠e Logistics**.  \nTu objetivo es notificar al proveedor que su cita se **reprogram√≥ con √©xito** en el cronograma.\n\n# Datos disponibles  \n- idCita           = {{ $(\"Microsoft SQL Insertar Cita1\").first().json.id }}  \n- fechaCita        = {{ $(\"Code Datos Insert Cita1\").first().json.fecha_cita }}  \n- horaInicio       = {{ $(\"Code Datos Insert Cita1\").first().json.hora_inicio }}  \n- horaFin          = {{ $(\"Code Datos Insert Cita1\").first().json.hora_fin }}  \n- muelle           = {{ $(\"Code Datos Insert Cita1\").first().json.muelle }}  \n- ordenCompra      = {{ $(\"Code Datos Insert Cita1\").first().json.orden_compra }}  \n- categoria        = {{ $(\"Code Datos Insert Cita1\").first().json.categoria }}  \n- pesoKg           = {{ $(\"Code Datos Insert Cita1\").first().json.peso }}  \n- unidades         = {{ $(\"Code Datos Insert Cita1\").first().json.unidades }}\n\n> Ajusta los nombres de nodos/propiedades si tu flujo usa otros.\n\n# Instrucciones de redacci√≥n\n1. Mant√©n un tono profesional, cordial y positivo.  \n2. Empieza con una breve expresi√≥n de entusiasmo por la **reprogramaci√≥n exitosa** (p. ej.: ‚Äú¬°Cita reprogramada con √©xito!‚Äù o ‚Äú¬°Reprogramaci√≥n confirmada!‚Äù).  \n3. Presenta los **nuevos detalles** de la cita en una lista con vi√±etas y emojis adecuados:  \n   ‚Ä¢ üÜî **N√∫mero de cita:** antep√≥n üîñ ‚Üí üîñ {{ $(\"Microsoft SQL Insertar Cita1\").first().json.id }}   \n   ‚Ä¢ üìÖ **Fecha:** {{ $(\"Code Datos Insert Cita1\").first().json.fecha_cita.split(\" \")[0] }}  \n   ‚Ä¢ ‚è∞ **Horario:** {{ $(\"Code Datos Insert Cita1\").first().json.hora_inicio }} ‚Äì {{ $(\"Code Datos Insert Cita1\").first().json.hora_fin }}  \n   ‚Ä¢ üö© **Muelle:** {{ $(\"Code Datos Insert Cita1\").first().json.muelle }}  \n   ‚Ä¢ üè∑Ô∏è **O/C:** {{ $(\"Code Datos Insert Cita1\").first().json.orden_compra }}  \n   ‚Ä¢ üì¶ **Categor√≠a:** {{ $(\"Code Datos Insert Cita1\").first().json.categoria }}  \n   ‚Ä¢ ‚öñÔ∏è **Peso:** {{ $(\"Code Datos Insert Cita1\").first().json.peso }} kg  \n   ‚Ä¢ üì¶ **Unidades:** {{ $(\"Code Datos Insert Cita1\").first().json.unidades }}  \n4. Reitera el n√∫mero de cita con el emoji üîñ y aclara que con ese n√∫mero el proveedor podr√° **volver a modificar o cancelar** la cita si lo necesita.  \n5. Explica claramente la pol√≠tica: ‚ÄúLas modificaciones o cancelaciones deben solicitarse **hasta un d√≠a h√°bil antes** y **antes de las 4:30 p. m.**; despu√©s de ese plazo no podremos realizar cambios.‚Äù  \n6. Cierra agradeciendo su colaboraci√≥n y confirmando que estaremos atentos a su llegada.  \n7. Devuelve **solo** el mensaje final, sin encabezados ni explicaciones adicionales.\n\n# Salida esperada (ejemplo de estilo)\n\n¬°Cita reprogramada con √©xito! üéâ  \nüîñ N√∫mero de cita: 12345  \nüìÖ El 10 de junio de 2025  \n‚è∞ De 14:00 a 16:00  \nüö© Muelle 3  \nüè∑Ô∏è O/C OC-98765  \nüì¶ Categor√≠a Electrodom√©sticos  \n‚öñÔ∏è 500 kg | üì¶ 800 u  \n\nRecuerda tu n√∫mero de cita üîñ 12345 para futuras modificaciones o cancelaci√≥n.  \nPodr√°s gestionarla hasta un d√≠a h√°bil antes y antes de las 4:30 p. m.  \n¬°Muchas gracias por tu confianza y te esperamos!\n"
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        6368,
        4208
      ],
      "id": "06169453-2495-4118-8be8-85491e9fa67d",
      "name": "Basic LLM Notificar Cita Exitosa1",
      "alwaysOutputData": true,
      "executeOnce": true
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "BEGIN TRANSACTION;\n\nDELETE FROM MensajesWhatsApp\nWHERE chat_id = '{{ $('Unificaci√≥n y consistencia de datos').first().json.infoMensaje.chat_id }}'\n   OR (chat_id = 'agenteAI'\n       AND message_id IN (\n           SELECT message_id \n           FROM MensajesWhatsApp\n           WHERE chat_id = '{{ $('Unificaci√≥n y consistencia de datos').first().json.infoMensaje.chat_id }}'\n       )\n   );\n\nDELETE FROM FranjasDisponiblesTemp \nWHERE chat_id = '{{ $('Unificaci√≥n y consistencia de datos').first().json.infoMensaje.chat_id }}';\n\nCOMMIT;\n"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        5392,
        4512
      ],
      "id": "2007bf14-c58d-4b3d-a8c1-845ead4f2d6e",
      "name": "Microsoft SQL Eliminar Mensajes4",
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "/*  ‚¨á‚¨á  PEGAR TODO ESTO EN EL CAMPO ‚ÄúQuery‚Äù DEL NODO SQL  ‚¨á‚¨á  */\n\n/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n   Par√°metro recibido de n8n\n   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n   Asume que en la secci√≥n ‚ÄúQuery Parameters‚Äù del nodo tienes\n   un par√°metro llamado  id   con el valor  {{ $json.id }}\n   (o la propiedad que traiga tu flujo).\n*/\nDECLARE @id           INT = {{ $('Code Validacion de Cita en cronograma para reprogramaci√≥n').first().json.citaAntigua.id }};          -- par√°metro que llega de n8n\nDECLARE @nowBogota    DATETIME;\n\n/* Obtener la fecha/hora actual en zona horaria de Bogot√°           */\n/* (SQL¬†Server 2016+ ‚Äë requiere soporte AT¬†TIME¬†ZONE)                */\nSET @nowBogota =\n    CONVERT(DATETIME, SYSDATETIMEOFFSET() AT TIME ZONE 'SA Pacific Standard Time');\n\n/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  UPDATE  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */\nUPDATE  dbo.CitasRecepcion\nSET     estado            = N'REPROGRAMADA',\n        fecha_modificacion = @nowBogota\nWHERE   id = @id;\n\n/* Devuelve la fila modificada (√∫til para depurar en n8n) */\nSELECT  *\nFROM    dbo.CitasRecepcion\nWHERE   id = @id;\n"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        5008,
        4048
      ],
      "id": "c0de013e-c82f-45c9-9b43-6c79250cd11a",
      "name": "Microsoft SQLUpdate Cita Anterior",
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -3024,
        8432
      ],
      "id": "bac67669-b98e-4d9e-af93-6b8c333043cd",
      "name": "OpenAI Chat Model17",
      "credentials": {
        "openAiApi": {
          "id": "AD8kPcNVReuclASd",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n\"idCita\": \"\",\n\"ordenCompra\": \"\",\n\"camposFaltantes\": []\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.2,
      "position": [
        -2864,
        8432
      ],
      "id": "3ee690b4-62e3-479d-8484-f2ea3c307154",
      "name": "Structured Output Parser5"
    },
    {
      "parameters": {
        "promptType": "=define",
        "text": "=# Extracci√≥n de datos para cancelaci√≥n de citas\n\nAnaliza el historial completo de mensajes y el mensaje actual para extraer los datos necesarios para cancelar una cita existente. **Tu √∫nica responsabilidad es extraer datos, no validarlos ni tomar decisiones.**\n\n## Datos a extraer\n- ID de la cita (por ejemplo, \"Cita 12345\", \"N√∫mero 12345\", etc.)\n- N√∫mero de orden de compra asociado a la cita\n\n## Fuentes de datos a analizar\n- Mensaje actual: {{ $('Unificaci√≥n y consistencia de datos').first().json.infoMensaje.mensajeActual }}\n- Historial de mensajes: {{ $node[\"Unificaci√≥n y consistencia de datos\"].json[\"infoMensaje\"][\"historialMensajes\"] }}\n\n## Instrucciones espec√≠ficas\n1. Buscar PRIMERO el ID de la cita en formato num√©rico en CUALQUIER mensaje previo\n2. Buscar el n√∫mero de orden de compra en CUALQUIER mensaje previo\n3. Considera expresiones como \"cancelar cita\", \"anular cita\", \"no puedo asistir\", etc.\n4. Si no encuentras alguno de los datos requeridos, m√°rcalo como faltante\n\n## Estructura de salida JSON\n{\n  \"idCita\": string,          // ID de la cita\n  \"ordenCompra\": string,     // N√∫mero de orden de compra\n  \"camposFaltantes\": array   // Lista de campos que no pudieron ser extra√≠dos\n}",
        "hasOutputParser": true
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        -2944,
        8224
      ],
      "id": "6701435b-de79-4d87-8e6a-00135b60403d",
      "name": "Basic LLM Extracci√≥n Datos Cancelar Cita"
    },
    {
      "parameters": {
        "jsCode": "// Obtener los datos extra√≠dos\nconst datosExtraidos = $('Basic LLM Extracci√≥n Datos Cancelar Cita').first().json.output;\n\n// Estructura de respuesta\nconst respuesta = {\n  todoCorrecto: false,\n  idCita: datosExtraidos.idCita || \"\",\n  ordenCompra: datosExtraidos.ordenCompra || \"\",\n  camposFaltantes: datosExtraidos.camposFaltantes || [],\n  mensajeSistema: \"\"\n};\n\n// Verificar si hay campos faltantes\nif (respuesta.camposFaltantes && respuesta.camposFaltantes.length > 0) {\n  respuesta.todoCorrecto = false;\n  respuesta.mensajeSistema = generarMensajeCamposFaltantes(respuesta.camposFaltantes);\n} else {\n  respuesta.todoCorrecto = true;\n  respuesta.mensajeSistema = `Entendido. Est√°s solicitando cancelar la cita üîñ ${respuesta.idCita} con orden de compra ${respuesta.ordenCompra}. Verificar√© si es posible realizar la cancelaci√≥n.`;\n}\n\nfunction generarMensajeCamposFaltantes(camposFaltantes) {\n  let mensaje = \"Para poder cancelar tu cita, necesito \";\n  \n  if (camposFaltantes.includes(\"idCita\")) {\n    mensaje += \"el n√∫mero de cita üîñ que aparece en tu confirmaci√≥n, \";\n  }\n  \n  if (camposFaltantes.includes(\"ordenCompra\")) {\n    mensaje += \"el n√∫mero de orden de compra para verificaci√≥n, \";\n  }\n  \n  mensaje = mensaje.slice(0, -2) + \". \";\n  mensaje += \"Por ejemplo: 'Quiero cancelar mi cita 12345 con orden de compra ARGM47896'.\";\n  \n  return mensaje;\n}\n\nreturn respuesta;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2576,
        8224
      ],
      "id": "cc7038c9-fb75-4473-b773-9faa856de5ab",
      "name": "Code Validaci√≥n datos para cancelaci√≥n de citas"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "2b68e9c6-bb33-49e0-b323-c6ed61e3d98e",
              "leftValue": "={{ $json.todoCorrecto }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -2368,
        8224
      ],
      "id": "28b8c2a1-1e49-4cf8-bd30-095401c3197c",
      "name": "If Validar si los datos est√°n completos"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "DECLARE @Id          INT          = {{ $json.idCita }};\nDECLARE @OrdenCompra VARCHAR(50)  = '{{ $json.ordenCompra }}';\n\nIF EXISTS (SELECT 1\n           FROM   CitasRecepcion\n           WHERE  id           = @Id\n             AND  orden_compra = @OrdenCompra\n             AND  estado       = 'PROGRAMADA')\nBEGIN\n    SELECT *\n    FROM   CitasRecepcion\n    WHERE  id           = @Id\n      AND  orden_compra = @OrdenCompra\n      AND  estado       = 'PROGRAMADA';\nEND\nELSE\nBEGIN\n    -- C√≥digo y severidad personalizados\n    THROW 50001, 'La cita no se encuentra en estado PROGRAMADA o los datos no coinciden.', 16;\nEND\n"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        -1936,
        8048
      ],
      "id": "7ad99d29-eaec-4678-8485-6ae9fff0c6d3",
      "name": "Microsoft SQL Obtener Cita para Cancelar",
      "alwaysOutputData": true,
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "4bfbecb3-9d4f-4425-aa76-a92abc7708fb",
              "leftValue": "={{ $('If Validar si los datos est√°n completos').first().json.mensajeSistema.length }}",
              "rightValue": 70,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -1344,
        8928
      ],
      "id": "40cc4115-232e-4acc-b7d9-0e642ddb1fa9",
      "name": "Validaci√≥n de longitud de caracteres12"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d9c2ff70-4fd1-4b93-8571-6d0ac5a0093e",
              "name": "mensaje.ia",
              "value": "={{ $('If Validar si los datos est√°n completos').first().json.mensajeSistema }}",
              "type": "string"
            },
            {
              "id": "ac8a03be-0292-4735-9580-39a385945c47",
              "name": "mensaje.longitud",
              "value": "={{ $('If Validar si los datos est√°n completos').first().json.mensajeSistema.length }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -1040,
        9008
      ],
      "id": "d7e41e6b-e19b-45ac-914d-0cd3de4ff1ab",
      "name": "Organiza variables del mensaje12"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -880,
        8784
      ],
      "id": "58135064-9fc5-43c0-b46e-68d18f26ec5f",
      "name": "No Operation, do nothing16"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $('Code Respuesta Faltantes').item.json.text }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1056,
        8784
      ],
      "id": "1b8055e7-1926-4f93-837d-40530b1b692d",
      "name": "HTTP Request Enviar Mensaje por WhatsApp15"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "1cc112df-9a2d-4ad5-acf5-74b0fbadc479",
              "leftValue": "={{ $json.error === undefined }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -1728,
        8048
      ],
      "id": "1c80de94-d6e9-43a6-9cc7-f4b61750ab9e",
      "name": "If cita para cancelar"
    },
    {
      "parameters": {
        "jsCode": "// Generar respuesta de error para cita no programada\nfor (const item of $input.all()) {\n  item.json = {\n    \"error\": true,\n    \"mensaje\": \"‚ùå **Error de validaci√≥n de datos**\\n\\n\" +\n              \"Los datos ingresados corresponden a una cita que ya fue **cancelada** o **reprogramada**, \" +\n              \"por lo tanto no es posible proceder con la cancelaci√≥n solicitada.\\n\\n\" +\n              \"üìã **Acciones requeridas:**\\n\" +\n              \"‚Ä¢ Verifique que el **n√∫mero de cita** y **orden de compra** sean correctos\\n\" +\n              \"‚Ä¢ Confirme que la cita se encuentre en estado **PROGRAMADA**\\n\" +\n              \"‚Ä¢ Intente nuevamente con los datos correctos\\n\\n\" +\n              \"üîÑ **Por temas de trazabilidad del historial de mensajes, esta conversaci√≥n ser√° eliminada.**\\n\\n\" +\n              \"Por favor inicie un **nuevo chat** y proporcione la informaci√≥n correcta para proceder con la cancelaci√≥n.\",\n    \"codigo_error\": \"CITA_NO_PROGRAMADA\",\n    \"accion_requerida\": \"REINICIAR_CONVERSACION\",\n    \"timestamp\": new Date().toISOString()\n  };\n}\n\nreturn $input.all();"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1440,
        8224
      ],
      "id": "08e22f07-0e0b-4902-b2b9-ef4a25335e07",
      "name": "Code respuesta cita no programada"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "4bfbecb3-9d4f-4425-aa76-a92abc7708fb",
              "leftValue": "={{ $('Code respuesta cita no programada').first().json.mensaje.length }}",
              "rightValue": 70,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -1088,
        8464
      ],
      "id": "420cd4d1-4152-4c5d-a749-bf52c7f81a3d",
      "name": "Validaci√≥n de longitud de caracteres13"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d9c2ff70-4fd1-4b93-8571-6d0ac5a0093e",
              "name": "mensaje.ia",
              "value": "={{ $('Code respuesta cita no programada').first().json.mensaje }}",
              "type": "string"
            },
            {
              "id": "ac8a03be-0292-4735-9580-39a385945c47",
              "name": "mensaje.longitud",
              "value": "={{ $('Code respuesta cita no programada').first().json.mensaje.length }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -800,
        8560
      ],
      "id": "c7a8c6d6-70c8-421e-a904-64ea75791db9",
      "name": "Organiza variables del mensaje13"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -624,
        8320
      ],
      "id": "864d2d44-08a4-46a5-b6b9-4aa5d4f662ea",
      "name": "No Operation, do nothing17"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $('Code Respuesta Faltantes').item.json.text }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -800,
        8320
      ],
      "id": "3ba4c897-0500-4fc1-bbd7-10d194d8b980",
      "name": "HTTP Request Enviar Mensaje por WhatsApp16"
    },
    {
      "parameters": {
        "url": "https://graph.microsoft.com/v1.0/sites/a592f886-4560-4e62-9646-1eee7add7abe/drives/b!hviSpWBFYk6WRh7uet16vnNAUYuuQRlGj3ZyS9kSvGVZ4DSg6c5MRqYYm2MdAER8/items/01PPLUUYXY5E2GK3SJ25EZLJPUYJ43H3ME/content",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "microsoftOAuth2Api",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "file",
              "outputPropertyName": "ExcelMallaRecibido2025"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1296,
        7520
      ],
      "id": "65b0be4c-0ed9-45dc-89ff-5c20d4ac3220",
      "name": "HTTP Request MALLA DE RECIBO 3",
      "credentials": {
        "microsoftOAuth2Api": {
          "id": "mh8Z8hxFvd7LDO8D",
          "name": "CuentaMy SharePoint App Desarrollador1 Konfie "
        }
      }
    },
    {
      "parameters": {
        "operation": "xlsx",
        "binaryPropertyName": "ExcelMallaRecibido2025",
        "options": {
          "sheetName": "={{ $('Unificaci√≥n y consistencia de datos').item.json.hojaSeleccionada }}"
        }
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -1040,
        7408
      ],
      "id": "6a83a4af-3de9-409c-ac23-4d468d767c16",
      "name": "Extract MALLA DE RECIBO 3"
    },
    {
      "parameters": {
        "jsCode": "// Obtener los datos del Excel\nconst excelData = $input.all();\nconst hojaSeleccionada = $('Unificaci√≥n y consistencia de datos').first().json.hojaSeleccionada;\n\n// Obtener hora local en Bogot√°\nconst ahora = new Date(new Date().toLocaleString(\"en-US\", { timeZone: \"America/Bogota\" }));\nconst diaSemanaActual = ahora.getDay(); // 0=domingo, 1=lunes, ..., 5=viernes\nconst horaActual = ahora.getHours();\nconst minutosActual = ahora.getMinutes();\n// Determinar si es despu√©s de las 16:30\nconst pasoLimiteDia = horaActual > 16 || (horaActual === 16 && minutosActual >= 30);\n\n// Definir estructura de la semana y los d√≠as\nconst diasSemana = ['lunes', 'martes', 'mi√©rcoles', 'jueves', 'viernes'];\n\n// Mapeo para saber qu√© d√≠as incluir si hoy es x d√≠a y pas√≥ el l√≠mite\n/**\n * Dado el d√≠a de la semana actual (0=domingo ... 6=s√°bado),\n * devuelve qu√© d√≠as de la semana actual deben incluirse seg√∫n si pas√≥ el l√≠mite.\n */\nfunction diasValidosSemanaActual(diaSemanaActual, pasoLimite) {\n  const mapa = {\n    1: ['martes', 'mi√©rcoles', 'jueves', 'viernes'],   // lunes\n    2: ['mi√©rcoles', 'jueves', 'viernes'],             // martes\n    3: ['jueves', 'viernes'],                          // mi√©rcoles\n    4: ['viernes'],                                     // jueves\n    5: []                                               // viernes (muy tarde para s√°bado)\n  };\n  if (diaSemanaActual < 1 || diaSemanaActual > 5) {\n    return []; // s√°bado o domingo no se agendan en semana actual\n  }\n  if (!pasoLimite) {\n    // a√∫n est√° antes de las 4:30 p.m., se puede incluir el d√≠a siguiente\n    const siguiente = diasSemana[diaSemanaActual];\n    return [siguiente, ...mapa[diaSemanaActual]];\n  }\n  return mapa[diaSemanaActual];\n}\n\n// Objeto para almacenar la malla estructurada\nconst mallaEstructurada = {\n  titulo: \"\",\n  a√±o: \"\",\n  semana: \"\",\n  rangoDias: \"\",\n  franjas: [],\n  dias: {}\n};\n\n// Tabla de meses y d√≠as. Ajusta si necesitas contemplar bisiestos, etc.\nconst meses = {\n  \"enero\": 1,\n  \"febrero\": 2,\n  \"marzo\": 3,\n  \"abril\": 4,\n  \"mayo\": 5,\n  \"junio\": 6,\n  \"julio\": 7,\n  \"agosto\": 8,\n  \"septiembre\": 9,\n  \"octubre\": 10,\n  \"noviembre\": 11,\n  \"diciembre\": 12\n};\n\nconst nombreMes = {\n  1: \"enero\",\n  2: \"febrero\",\n  3: \"marzo\",\n  4: \"abril\",\n  5: \"mayo\",\n  6: \"junio\",\n  7: \"julio\",\n  8: \"agosto\",\n  9: \"septiembre\",\n  10: \"octubre\",\n  11: \"noviembre\",\n  12: \"diciembre\"\n};\n\n/**\n * Funci√≥n para determinar si un a√±o es bisiesto\n * Un a√±o es bisiesto si es divisible por 4, excepto aquellos divisibles por 100 \n * que no son divisibles por 400\n */\nfunction esBisiesto(year) {\n  return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);\n}\n\n/**\n * Funci√≥n para obtener el n√∫mero de d√≠as en un mes, considerando a√±os bisiestos\n */\nfunction getDiasMes(mes, a√±o) {\n  const diasPorMes = {\n    1: 31, // enero\n    2: esBisiesto(a√±o) ? 29 : 28, // febrero - ajustado para a√±o bisiesto\n    3: 31, // marzo\n    4: 30, // abril\n    5: 31, // mayo\n    6: 30, // junio\n    7: 31, // julio\n    8: 31, // agosto\n    9: 30, // septiembre\n    10: 31, // octubre\n    11: 30, // noviembre\n    12: 31  // diciembre\n  };\n  \n  return diasPorMes[mes];\n}\n\n/**\n * Funci√≥n para eliminar acentos y pasar a min√∫sculas (para buscar palabras clave sin importar tildes ni may√∫sculas).\n */\nfunction normalizarTexto(texto) {\n  if (typeof texto !== 'string') return \"\";\n  // Normaliza (NFD) y elimina diacr√≠ticos, luego pasa a min√∫sculas.\n  return texto\n    .normalize(\"NFD\")\n    .replace(/[\\u0300-\\u036f]/g, \"\") // quita acentos\n    .toLowerCase();\n}\n\n/**\n * Dada la informaci√≥n de proveedor, ordenCompra, peso, categor√≠a y unidades,\n * revisa si existe la palabra 'fuera de servicio', 'cancelado' o 'reagendado'\n * en cualquiera de esos campos. De ser as√≠, retorna ese estado especial;\n * de lo contrario, retorna 'ocupado'.\n * \n * Se ignoran may√∫sculas, min√∫sculas y tildes.\n */\nfunction determinarEstadoOcupado(proveedor, ordenCompra, peso, categoria, unidades) {\n  const conjunto = `${proveedor} ${ordenCompra} ${peso} ${categoria} ${unidades}`;\n  const texto = normalizarTexto(conjunto);\n\n  if (texto.includes(\"fuera de servicio\")) {\n    return \"fuera de servicio\";\n  }\n  if (texto.includes(\"cancelado\")) {\n    return \"cancelado\";\n  }\n  if (texto.includes(\"reagendado\")) {\n    return \"reagendado\";\n  }\n  return \"ocupado\";  \n}\n\n// -------------------------------------------------------------\n// 1) PROCESAR DATOS (Cabecera, Horas, Muelles, etc.)\n// -------------------------------------------------------------\nfunction procesarDatos(excelData) {\n  const datos = excelData.map(item => item.json);\n  \n  // A) Cabecera (T√≠tulo, A√±o, Rango)\n  datos.forEach((dato, index) => {\n    // Buscar t√≠tulo\n    if (dato.__EMPTY_2 === \"MALLA DE RECIBO CEDI KONFIE IA\") {\n      mallaEstructurada.titulo = dato.__EMPTY_2;\n      \n      // En la siguiente fila puede estar a√±o, semana, rango\n      if (index + 1 < datos.length) {\n        const datoSiguiente = datos[index + 1];\n        if (datoSiguiente) {\n          // A√±o\n          if (datoSiguiente.__EMPTY_2 && !isNaN(datoSiguiente.__EMPTY_2)) {\n            mallaEstructurada.a√±o = datoSiguiente.__EMPTY_2;\n          }\n          // Semana\n          Object.entries(datoSiguiente).forEach(([k, v]) => {\n            if (typeof v === 'string' && v.includes(\"SEMANA\")) {\n              mallaEstructurada.semana = v;\n            }\n          });\n          // Rango: p.ej. \"LUNES 31 AL VIERNES 4 DE ABRIL\"\n          Object.entries(datoSiguiente).forEach(([k, v]) => {\n            if (typeof v === 'string' && v.includes(\"LUNES\") && v.includes(\"VIERNES\")) {\n              mallaEstructurada.rangoDias = v;\n            }\n          });\n        }\n      }\n    }\n  });\n  \n  // B) Detectar franjas horarias (.__EMPTY = fracci√≥n de d√≠a)\n  const franjasHorarias = [];\n  datos.forEach(dato => {\n    if (\n      dato.__EMPTY !== undefined &&\n      typeof dato.__EMPTY === 'number' &&\n      dato.__EMPTY > 0 &&\n      dato.__EMPTY < 1\n    ) {\n      const totalMin = Math.round(dato.__EMPTY * 24 * 60);\n      const hh = Math.floor(totalMin / 60);\n      const mm = totalMin % 60;\n      \n      let periodo = \"AM\";\n      let hora12 = hh;\n      if (hh >= 12) {\n        periodo = \"PM\";\n        hora12 = (hh === 12 ? 12 : hh - 12);\n      }\n      if (hh === 0) {\n        hora12 = 12;\n      }\n      \n      const horaStr = `${hora12}:${String(mm).padStart(2, '0')} ${periodo}`;\n      franjasHorarias.push({\n        hora: horaStr,\n        indice: datos.indexOf(dato) // fila base\n      });\n    }\n  });\n  franjasHorarias.sort((a, b) => a.indice - b.indice);\n  mallaEstructurada.franjas = franjasHorarias;\n  \n  // C) Detectar muelles (col)\n  const muellesInfo = {};\n  datos.forEach(dato => {\n    Object.entries(dato).forEach(([key, value]) => {\n      if (value === \"MUELLE 01\" || value === \"MUELLE 02\") {\n        const col = parseInt(key.replace(\"__EMPTY_\", \"\"), 10);\n        const muelleKey = (value === \"MUELLE 01\") ? 'muelle1' : 'muelle2';\n        if (!muellesInfo[muelleKey]) {\n          muellesInfo[muelleKey] = [];\n        }\n        muellesInfo[muelleKey].push(col);\n      }\n    });\n  });\n  if (muellesInfo.muelle1) muellesInfo.muelle1.sort((a, b) => a - b);\n  if (muellesInfo.muelle2) muellesInfo.muelle2.sort((a, b) => a - b);\n  \n  // D) Generar los 5 d√≠as (lunes-viernes) con su fecha\n  parsearRangoDias();\n  \n  // E) Extraer Citas\n  extraerCitas(datos, muellesInfo);\n  \n  return mallaEstructurada;\n}\n\n/**\n * Parsea la cadena \"LUNES 31 AL VIERNES 4 DE ABRIL\"\n * (o \"LUNES 31 AL VIERNES 04 DE ABRIL\") y maneja el cruce de mes.\n * Ej.: si dayStart=31 y dayEnd=4, la 1¬™ fecha es 31 de MARZO,\n * luego 1,2,3,4 de ABRIL, en vez de 32,33, etc.\n */\nfunction parsearRangoDias() {\n  const texto = mallaEstructurada.rangoDias;\n  // Regex simple: p.ej. \"31 AL ... 4 DE ABRIL\"\n  // Captura: dayStart, dayEnd, mesFin\n  // Ojo: si dice \"LUNES 31 DE MARZO AL VIERNES 4 DE ABRIL\",\n  // quedar√°: dayStart=31, dayEnd=4, month=ABRIL (al final).\n  const regex = /(\\d+)\\s+AL\\s+\\D+(\\d+)\\s+DE\\s+(\\w+)/i;\n  const match = regex.exec(texto);\n  \n  // Por defecto, creamos 5 d√≠as vac√≠os sin fecha\n  diasSemana.forEach(d => {\n    mallaEstructurada.dias[d] = {\n      muelle1: {},\n      muelle2: {}\n    };\n  });\n  \n  if (!match) {\n    // Sin coincidencia, dejamos los d√≠as sin fecha\n    return;\n  }\n  \n  const dayStart = parseInt(match[1], 10); // 31\n  const dayEnd   = parseInt(match[2], 10); // 4\n  const finalMonthName = match[3].toLowerCase(); // \"abril\"\n  \n  // Convertimos a n√∫mero\n  const finalMonth = meses[finalMonthName] || 3; // fallback marzo\n  const yearNum = parseInt(mallaEstructurada.a√±o, 10) || 2025;\n  \n  // Funci√≥n para obtener la fecha formateada\n  function fechaFormateada(d, m, y) {\n    return `${d} de ${nombreMes[m]} de ${y}`;\n  }\n  \n  // Comprobamos cu√°ntos d√≠as tiene el mes final, considerando bisiestos\n  const diasMesFinal = getDiasMes(finalMonth, yearNum);\n  // y del mes previo\n  const monthPrev = (finalMonth === 1) ? 12 : finalMonth - 1;\n  const yearPrev = (finalMonth === 1) ? yearNum - 1 : yearNum;\n  \n  // Arreglo final con 5 fechas\n  const fechasDias = [];\n  \n  if (dayStart <= dayEnd) {\n    // Caso \"normal\": todo en el mismo mes\n    let d = dayStart;\n    for (let i = 0; i < 5; i++) {\n      fechasDias.push({\n        diaSem: diasSemana[i],\n        diaNum: d,\n        mesNum: finalMonth,\n        yearNum: yearNum\n      });\n      d++;\n      if (d > diasMesFinal) {\n        d = 1;\n        const nextMonth = finalMonth % 12 + 1;\n        const nextYear = (nextMonth === 1) ? yearNum + 1 : yearNum;\n        fechasDias[fechasDias.length - 1].mesNum = nextMonth;\n        fechasDias[fechasDias.length - 1].yearNum = nextYear;\n      }\n    }\n  } else {\n    // Caso \"cruza de mes\": dayStart > dayEnd\n    let d = dayStart;\n    let m = monthPrev;\n    let y = yearPrev;\n    \n    for (let i = 0; i < 5; i++) {\n      fechasDias.push({\n        diaSem: diasSemana[i],\n        diaNum: d,\n        mesNum: m,\n        yearNum: y\n      });\n      d++;\n      if (d > getDiasMes(m, y)) {\n        d = 1;\n        m = m % 12 + 1;\n        if (m === 1) {\n          y++;\n        }\n      }\n    }\n  }\n  \n  // Ahora volcamos esas 5 fechas en la estructura\n  fechasDias.forEach(fd => {\n    const { diaSem, diaNum, mesNum, yearNum } = fd;\n    mallaEstructurada.dias[diaSem] = {\n      fechaDia: fechaFormateada(diaNum, mesNum, yearNum),\n      muelle1: {},\n      muelle2: {}\n    };\n  });\n  \n  // Inicializamos las franjas a 'disponible'\n  if (mallaEstructurada.franjas.length > 0) {\n    diasSemana.forEach(d => {\n      mallaEstructurada.franjas.forEach(f => {\n        mallaEstructurada.dias[d].muelle1[f.hora] = {\n          estado: \"disponible\",\n          proveedor: \"\",\n          ordenCompra: \"\",\n          peso: \"\",\n          categoria: \"\",\n          unidades: \"\"\n        };\n        mallaEstructurada.dias[d].muelle2[f.hora] = {\n          estado: \"disponible\",\n          proveedor: \"\",\n          ordenCompra: \"\",\n          peso: \"\",\n          categoria: \"\",\n          unidades: \"\"\n        };\n      });\n    });\n  }\n}\n\n/**\n * Funci√≥n auxiliar: decide a qu√© d√≠a pertenece una columna,\n * corrigiendo 2 columnas de offset (porque 'Extract from XLSX'\n * deja todo desplazado).\n */\nfunction getDayForColumn(colNumber) {\n  // Ajuste de offset +2\n  const realCol = colNumber + 2;\n\n  // Rangos:\n  //  Lunes:      3..8\n  //  Martes:     9..14\n  //  Mi√©rcoles: 15..20\n  //  Jueves:    21..26\n  //  Viernes:   27..32\n  if (realCol >= 3 && realCol <= 8) {\n    return \"lunes\";\n  }\n  if (realCol >= 9 && realCol <= 14) {\n    return \"martes\";\n  }\n  if (realCol >= 15 && realCol <= 20) {\n    return \"mi√©rcoles\";\n  }\n  if (realCol >= 21 && realCol <= 26) {\n    return \"jueves\";\n  }\n  if (realCol >= 27 && realCol <= 32) {\n    return \"viernes\";\n  }\n  // Si nada coincide, devolvemos null\n  return null;\n}\n\n/**\n * Extraer las citas para cada franja:\n * - Para cada franja, miramos 3 filas:\n *    - Fila base => proveedor\n *    - Fila base+1 => orden\n *    - Fila base+2 => peso, categor√≠a, unidades\n */\nfunction extraerCitas(datos, muellesInfo) {\n  mallaEstructurada.franjas.forEach(franja => {\n    const indiceBase = franja.indice;\n    if (indiceBase < 0 || indiceBase + 2 >= datos.length) {\n      return; // no hay suficientes filas\n    }\n    \n    // Recorremos muelle1, muelle2 y sus columnas\n    const asignarCita = (muelleKey, cols) => {\n      cols.forEach(col => {\n        const provKey = `__EMPTY_${col}`;\n        const filaProv = datos[indiceBase];\n        \n        // Si en esta fila hay un proveedor o alg√∫n texto\n        if (\n          filaProv &&\n          typeof filaProv[provKey] === 'string' &&\n          filaProv[provKey].length > 2\n        ) {\n          // Determinar el d√≠a real\n          const diaOk = getDayForColumn(col);\n          if (!diaOk || !mallaEstructurada.dias[diaOk]) {\n            return; // si no coincide con ninguno, saltamos\n          }\n          \n          // Recuperar valores para proveedor, ordenCompra y dem√°s\n          const filaOrden = datos[indiceBase + 1];\n          const filaDet = datos[indiceBase + 2];\n          \n          const proveedor = filaProv[provKey] || \"\";\n          const ordenCompra = filaOrden && filaOrden[provKey] ? filaOrden[provKey] : \"\";\n          const peso = filaDet && filaDet[provKey] ? filaDet[provKey] : \"\";\n          const cat  = filaDet && filaDet[`__EMPTY_${col + 1}`] ? filaDet[`__EMPTY_${col + 1}`] : \"\";\n          const und  = filaDet && filaDet[`__EMPTY_${col + 2}`] ? filaDet[`__EMPTY_${col + 2}`] : \"\";\n          \n          // Antes pon√≠amos estado=\"ocupado\" directamente\n          // Ahora verificamos si el texto contiene \"reagendado\", \"cancelado\" o \"fuera de servicio\".\n          const nuevoEstado = determinarEstadoOcupado(proveedor, ordenCompra, peso, cat, und);\n          \n          // Asignamos los datos\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].estado = nuevoEstado;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].proveedor = proveedor;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].ordenCompra = ordenCompra;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].peso = peso;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].categoria = cat;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].unidades = und;\n        }\n      });\n    };\n    \n    if (muellesInfo.muelle1) {\n      asignarCita('muelle1', muellesInfo.muelle1);\n    }\n    if (muellesInfo.muelle2) {\n      asignarCita('muelle2', muellesInfo.muelle2);\n    }\n  });\n}\n\n// -------------------------------------------------------------\n// 2) FUNCIONES PARA CONSULTAR LA MALLA\n// -------------------------------------------------------------\nfunction buscarFranjasDisponibles(categoria, duracionHoras) {\n  const muelle = \"muelle1\"; // Ajusta si usas \"categoria -> muelle\" real\n  \n  const franjasDisponibles = [];\n  Object.keys(mallaEstructurada.dias).forEach(dia => {\n    const libres = [];\n    for (let i = 0; i <= mallaEstructurada.franjas.length - duracionHoras; i++) {\n      let disponible = true;\n      for (let h = 0; h < duracionHoras; h++) {\n        const idxF = i + h;\n        const horaAct = mallaEstructurada.franjas[idxF].hora;\n        if (\n          mallaEstructurada.dias[dia][muelle][horaAct].estado !== 'disponible'\n        ) {\n          disponible = false;\n          break;\n        }\n      }\n      if (disponible) {\n        libres.push({\n          horaInicio: mallaEstructurada.franjas[i].hora,\n          duracion: duracionHoras\n        });\n      }\n    }\n    if (libres.length > 0) {\n      franjasDisponibles.push({ dia, franjas: libres });\n    }\n  });\n  return franjasDisponibles;\n}\n\nfunction buscarCitasProveedor(nombreProveedor) {\n  const citas = [];\n  Object.keys(mallaEstructurada.dias).forEach(dia => {\n    const muelle1 = mallaEstructurada.dias[dia].muelle1;\n    const muelle2 = mallaEstructurada.dias[dia].muelle2;\n    mallaEstructurada.franjas.forEach(f => {\n      const hora = f.hora;\n      // muelle1\n      if (normalizarTexto(muelle1[hora].proveedor) === normalizarTexto(nombreProveedor)) {\n        citas.push({\n          dia,\n          hora,\n          muelle: \"Muelle 01\",\n          ordenCompra: muelle1[hora].ordenCompra,\n          peso: muelle1[hora].peso,\n          categoria: muelle1[hora].categoria,\n          unidades: muelle1[hora].unidades,\n          estado: muelle1[hora].estado\n        });\n      }\n      // muelle2\n      if (normalizarTexto(muelle2[hora].proveedor) === normalizarTexto(nombreProveedor)) {\n        citas.push({\n          dia,\n          hora,\n          muelle: \"Muelle 02\",\n          ordenCompra: muelle2[hora].ordenCompra,\n          peso: muelle2[hora].peso,\n          categoria: muelle2[hora].categoria,\n          unidades: muelle2[hora].unidades,\n          estado: muelle2[hora].estado\n        });\n      }\n    });\n  });\n  return citas;\n}\n\nfunction consultarFranjasDisponibles(categoria, duracionHoras) {\n  return buscarFranjasDisponibles(categoria, duracionHoras);\n}\n\nfunction consultarCitasProveedor(nombreProveedor) {\n  return buscarCitasProveedor(nombreProveedor);\n}\n\nfunction obtenerInfoMalla() {\n  return {\n    titulo: mallaEstructurada.titulo,\n    a√±o: mallaEstructurada.a√±o,\n    semana: mallaEstructurada.semana,\n    rangoDias: mallaEstructurada.rangoDias,\n    franjas: mallaEstructurada.franjas.map(f => f.hora)\n  };\n}\n\nfunction estaDisponible(dia, hora, muelle) {\n  const info = mallaEstructurada.dias[dia]?.[muelle]?.[hora];\n  return info ? (info.estado === 'disponible') : false;\n}\n\nfunction obtenerCoordenadasCita(dia, hora, muelle) {\n  // Ajustar con tu mapeo de celdas en Excel\n  return {\n    proveedor: `${dia}_${hora}_${muelle}_proveedor`,\n    ordenCompra: `${dia}_${hora}_${muelle}_ordenCompra`,\n    peso: `${dia}_${hora}_${muelle}_peso`,\n    categoria: `${dia}_${hora}_${muelle}_categoria`,\n    unidades: `${dia}_${hora}_${muelle}_unidades`\n  };\n}\n\n// -------------------------------------------------------------\n// 3) EJECUTAR TODO Y RETORNAR\n// -------------------------------------------------------------\n// Procesar todos los datos\nconst malla = procesarDatos(excelData);\n\n// Aplicar el filtro de d√≠as v√°lidos seg√∫n la hora actual\nconst diasPermitidos = diasValidosSemanaActual(diaSemanaActual, pasoLimiteDia);\nObject.keys(malla.dias).forEach(dia => {\n  if (!diasPermitidos.includes(dia)) {\n    delete malla.dias[dia]; // eliminar d√≠as no v√°lidos\n  }\n});\n\nconst resultado = {\n  datosMalla: malla,\n  funciones: {\n    consultarFranjasDisponibles,\n    consultarCitasProveedor,\n    obtenerInfoMalla,\n    estaDisponible,\n    obtenerCoordenadasCita\n  }\n};\n\nreturn [resultado];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -800,
        7408
      ],
      "id": "ef807af5-0717-45c8-8c1b-7cd1de549da3",
      "name": "Estructuraci√≥n, Datos, Consulta, Citas4"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.1,
      "position": [
        -480,
        7504
      ],
      "id": "8e44aed1-a889-4822-8453-fb2ff30eb5a3",
      "name": "Merge datos Excel4"
    },
    {
      "parameters": {
        "jsCode": "return [{\n  json: {\n    datosMalla: $items(\"Merge datos Excel4\")[0].json.datosMalla,\n    datosMallaProxSemana: $items(\"Merge datos Excel4\")[1].json.datosMallaProxSemana,\n    hojaSeleccionada: $items(\"Merge datos Excel4\")[0].json.datosMalla.semana\n  }\n}];\n\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -240,
        7504
      ],
      "id": "ca40fb44-5215-471c-bd1e-f3a9e6703346",
      "name": "Unificaci√≥n y consistencia de datos5"
    },
    {
      "parameters": {
        "operation": "xlsx",
        "binaryPropertyName": "ExcelMallaRecibido2025",
        "options": {
          "sheetName": "={{    (function() {     const semanaActual = $('Unificaci√≥n y consistencia de datos').item.json.hojaSeleccionada;     const numeroSemana = parseInt(semanaActual.replace(\"SEMANA \", \"\"));     return `SEMANA ${numeroSemana + 1}`;   })() }}"
        }
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -1040,
        7600
      ],
      "id": "f3e54498-d47d-4cb3-9e90-7f944bb5f236",
      "name": "Extract MALLA DE RECIBO Semana Siguiente4",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Si el nodo anterior no devolvi√≥ datos (por error al no existir la hoja), retornamos estructura vac√≠a con mensaje\n// Obtener los datos del Excel\nconst excelData = $input.all();\n\n// Mejora en la detecci√≥n de errores: verificar si hay error expl√≠cito o si los datos no son v√°lidos\nconst hayError = excelData.some(item => item.json && item.json.error);\nconst datosInvalidos = !excelData || excelData.length === 0 || hayError;\n\nif (datosInvalidos) {\n  return [{\n    datosMallaProxSemana: {\n      titulo: \"‚ö†Ô∏è La malla de la pr√≥xima semana no existe en el archivo Excel o a√∫n no ha sido creada.\",\n      a√±o: \"\",\n      semana: \"\",\n      rangoDias: \"\",\n      franjas: [],\n      dias: {\n        lunes: { muelle1: {}, muelle2: {} },\n        martes: { muelle1: {}, muelle2: {} },\n        mi√©rcoles: { muelle1: {}, muelle2: {} },\n        jueves: { muelle1: {}, muelle2: {} },\n        viernes: { muelle1: {}, muelle2: {} }\n      }\n    },\n    funciones: {\n      consultarFranjasDisponibles: \"function not available\",\n      consultarCitasProveedor: \"function not available\",\n      obtenerInfoMalla: \"function not available\",\n      estaDisponible: \"function not available\",\n      obtenerCoordenadasCita: \"function not available\"\n    }\n  }];\n}\n\n// El resto del c√≥digo permanece igual...\nconst hojaSeleccionada = $('Unificaci√≥n y consistencia de datos').first().json.hojaSeleccionada;\n\n// Definir estructura de la semana y los d√≠as\nconst diasSemana = ['lunes', 'martes', 'mi√©rcoles', 'jueves', 'viernes'];\n\n// Objeto para almacenar la malla estructurada\nconst mallaEstructurada = {\n  titulo: \"\",\n  a√±o: \"\",\n  semana: \"\",\n  rangoDias: \"\",\n  franjas: [],\n  dias: {}\n};\n\n// Tabla de meses y d√≠as. Ajusta si necesitas contemplar bisiestos, etc.\nconst meses = {\n  \"enero\": 1,\n  \"febrero\": 2,\n  \"marzo\": 3,\n  \"abril\": 4,\n  \"mayo\": 5,\n  \"junio\": 6,\n  \"julio\": 7,\n  \"agosto\": 8,\n  \"septiembre\": 9,\n  \"octubre\": 10,\n  \"noviembre\": 11,\n  \"diciembre\": 12\n};\n\nconst nombreMes = {\n  1: \"enero\",\n  2: \"febrero\",\n  3: \"marzo\",\n  4: \"abril\",\n  5: \"mayo\",\n  6: \"junio\",\n  7: \"julio\",\n  8: \"agosto\",\n  9: \"septiembre\",\n  10: \"octubre\",\n  11: \"noviembre\",\n  12: \"diciembre\"\n};\n\n/**\n * Funci√≥n para determinar si un a√±o es bisiesto\n * Un a√±o es bisiesto si es divisible por 4, excepto aquellos divisibles por 100 \n * que no son divisibles por 400\n */\nfunction esBisiesto(year) {\n  return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);\n}\n\n/**\n * Funci√≥n para obtener el n√∫mero de d√≠as en un mes, considerando a√±os bisiestos\n */\nfunction getDiasMes(mes, a√±o) {\n  const diasPorMes = {\n    1: 31, // enero\n    2: esBisiesto(a√±o) ? 29 : 28, // febrero - ajustado para a√±o bisiesto\n    3: 31, // marzo\n    4: 30, // abril\n    5: 31, // mayo\n    6: 30, // junio\n    7: 31, // julio\n    8: 31, // agosto\n    9: 30, // septiembre\n    10: 31, // octubre\n    11: 30, // noviembre\n    12: 31  // diciembre\n  };\n  \n  return diasPorMes[mes];\n}\n\n/**\n * Funci√≥n para eliminar acentos y pasar a min√∫sculas (para buscar palabras clave sin importar tildes ni may√∫sculas).\n */\nfunction normalizarTexto(texto) {\n  if (typeof texto !== 'string') return \"\";\n  // Normaliza (NFD) y elimina diacr√≠ticos, luego pasa a min√∫sculas.\n  return texto\n    .normalize(\"NFD\")\n    .replace(/[\\u0300-\\u036f]/g, \"\") // quita acentos\n    .toLowerCase();\n}\n\n/**\n * Dada la informaci√≥n de proveedor, ordenCompra, peso, categor√≠a y unidades,\n * revisa si existe la palabra 'fuera de servicio', 'cancelado' o 'reagendado'\n * en cualquiera de esos campos. De ser as√≠, retorna ese estado especial;\n * de lo contrario, retorna 'ocupado'.\n * \n * Se ignoran may√∫sculas, min√∫sculas y tildes.\n */\nfunction determinarEstadoOcupado(proveedor, ordenCompra, peso, categoria, unidades) {\n  const conjunto = `${proveedor} ${ordenCompra} ${peso} ${categoria} ${unidades}`;\n  const texto = normalizarTexto(conjunto);\n\n  if (texto.includes(\"fuera de servicio\")) {\n    return \"fuera de servicio\";\n  }\n  if (texto.includes(\"cancelado\")) {\n    return \"cancelado\";\n  }\n  if (texto.includes(\"reagendado\")) {\n    return \"reagendado\";\n  }\n  return \"ocupado\";  \n}\n\n// -------------------------------------------------------------\n// 1) PROCESAR DATOS (Cabecera, Horas, Muelles, etc.)\n// -------------------------------------------------------------\nfunction procesarDatos(excelData) {\n  // Verificaci√≥n adicional de datos v√°lidos\n  if (!excelData || !Array.isArray(excelData) || excelData.length === 0) {\n    return {\n      titulo: \"‚ö†Ô∏è La malla de la pr√≥xima semana no existe en el archivo Excel o a√∫n no ha sido creada.\",\n      a√±o: \"\",\n      semana: \"\",\n      rangoDias: \"\",\n      franjas: [],\n      dias: {\n        lunes: { muelle1: {}, muelle2: {} },\n        martes: { muelle1: {}, muelle2: {} },\n        mi√©rcoles: { muelle1: {}, muelle2: {} },\n        jueves: { muelle1: {}, muelle2: {} },\n        viernes: { muelle1: {}, muelle2: {} }\n      }\n    };\n  }\n  \n  // Intentar mapear datos, con manejo de errores para cada item\n  const datos = excelData.map(item => {\n    try {\n      return item.json || {};\n    } catch (e) {\n      return {};\n    }\n  });\n  \n  // A) Cabecera (T√≠tulo, A√±o, Rango)\n  datos.forEach((dato, index) => {\n    // Buscar t√≠tulo\n    if (dato.__EMPTY_2 === \"MALLA DE RECIBO CEDI KONFIE IA\") {\n      mallaEstructurada.titulo = dato.__EMPTY_2;\n      \n      // En la siguiente fila puede estar a√±o, semana, rango\n      if (index + 1 < datos.length) {\n        const datoSiguiente = datos[index + 1];\n        if (datoSiguiente) {\n          // A√±o\n          if (datoSiguiente.__EMPTY_2 && !isNaN(datoSiguiente.__EMPTY_2)) {\n            mallaEstructurada.a√±o = datoSiguiente.__EMPTY_2;\n          }\n          // Semana\n          Object.entries(datoSiguiente).forEach(([k, v]) => {\n            if (typeof v === 'string' && v.includes(\"SEMANA\")) {\n              mallaEstructurada.semana = v;\n            }\n          });\n          // Rango: p.ej. \"LUNES 31 AL VIERNES 4 DE ABRIL\"\n          Object.entries(datoSiguiente).forEach(([k, v]) => {\n            if (typeof v === 'string' && v.includes(\"LUNES\") && v.includes(\"VIERNES\")) {\n              mallaEstructurada.rangoDias = v;\n            }\n          });\n        }\n      }\n    }\n  });\n  \n  // Si despu√©s de procesar no encontramos t√≠tulo, es que no hay malla v√°lida\n  if (!mallaEstructurada.titulo) {\n    mallaEstructurada.titulo = \"‚ö†Ô∏è La malla de la pr√≥xima semana no existe en el archivo Excel o a√∫n no ha sido creada.\";\n    return mallaEstructurada;\n  }\n  \n  // B) Detectar franjas horarias (.__EMPTY = fracci√≥n de d√≠a)\n  const franjasHorarias = [];\n  datos.forEach(dato => {\n    if (\n      dato.__EMPTY !== undefined &&\n      typeof dato.__EMPTY === 'number' &&\n      dato.__EMPTY > 0 &&\n      dato.__EMPTY < 1\n    ) {\n      const totalMin = Math.round(dato.__EMPTY * 24 * 60);\n      const hh = Math.floor(totalMin / 60);\n      const mm = totalMin % 60;\n      \n      let periodo = \"AM\";\n      let hora12 = hh;\n      if (hh >= 12) {\n        periodo = \"PM\";\n        hora12 = (hh === 12 ? 12 : hh - 12);\n      }\n      if (hh === 0) {\n        hora12 = 12;\n      }\n      \n      const horaStr = `${hora12}:${String(mm).padStart(2, '0')} ${periodo}`;\n      franjasHorarias.push({\n        hora: horaStr,\n        indice: datos.indexOf(dato) // fila base\n      });\n    }\n  });\n  franjasHorarias.sort((a, b) => a.indice - b.indice);\n  mallaEstructurada.franjas = franjasHorarias;\n  \n  // C) Detectar muelles (col)\n  const muellesInfo = {};\n  datos.forEach(dato => {\n    Object.entries(dato).forEach(([key, value]) => {\n      if (value === \"MUELLE 01\" || value === \"MUELLE 02\") {\n        const col = parseInt(key.replace(\"__EMPTY_\", \"\"), 10);\n        const muelleKey = (value === \"MUELLE 01\") ? 'muelle1' : 'muelle2';\n        if (!muellesInfo[muelleKey]) {\n          muellesInfo[muelleKey] = [];\n        }\n        muellesInfo[muelleKey].push(col);\n      }\n    });\n  });\n  if (muellesInfo.muelle1) muellesInfo.muelle1.sort((a, b) => a - b);\n  if (muellesInfo.muelle2) muellesInfo.muelle2.sort((a, b) => a - b);\n  \n  // D) Generar los 5 d√≠as (lunes-viernes) con su fecha\n  parsearRangoDias();\n  \n  // E) Extraer Citas\n  extraerCitas(datos, muellesInfo);\n  \n  return mallaEstructurada;\n}\n\n/**\n * Parsea la cadena \"LUNES 31 AL VIERNES 4 DE ABRIL\"\n * (o \"LUNES 31 AL VIERNES 04 DE ABRIL\") y maneja el cruce de mes.\n * Ej.: si dayStart=31 y dayEnd=4, la 1¬™ fecha es 31 de MARZO,\n * luego 1,2,3,4 de ABRIL, en vez de 32,33, etc.\n */\nfunction parsearRangoDias() {\n  const texto = mallaEstructurada.rangoDias;\n  // Regex simple: p.ej. \"31 AL ... 4 DE ABRIL\"\n  // Captura: dayStart, dayEnd, mesFin\n  // Ojo: si dice \"LUNES 31 DE MARZO AL VIERNES 4 DE ABRIL\",\n  // quedar√°: dayStart=31, dayEnd=4, month=ABRIL (al final).\n  const regex = /(\\d+)\\s+AL\\s+\\D+(\\d+)\\s+DE\\s+(\\w+)/i;\n  const match = regex.exec(texto);\n  \n  // Por defecto, creamos 5 d√≠as vac√≠os sin fecha\n  diasSemana.forEach(d => {\n    mallaEstructurada.dias[d] = {\n      muelle1: {},\n      muelle2: {}\n    };\n  });\n  \n  if (!match) {\n    // Sin coincidencia, dejamos los d√≠as sin fecha\n    return;\n  }\n  \n  const dayStart = parseInt(match[1], 10); // 31\n  const dayEnd   = parseInt(match[2], 10); // 4\n  const finalMonthName = match[3].toLowerCase(); // \"abril\"\n  \n  // Convertimos a n√∫mero\n  const finalMonth = meses[finalMonthName] || 3; // fallback marzo\n  const yearNum = parseInt(mallaEstructurada.a√±o, 10) || 2025;\n  \n  // Funci√≥n para obtener la fecha formateada\n  function fechaFormateada(d, m, y) {\n    return `${d} de ${nombreMes[m]} de ${y}`;\n  }\n  \n  // Comprobamos cu√°ntos d√≠as tiene el mes final, considerando bisiestos\n  const diasMesFinal = getDiasMes(finalMonth, yearNum);\n  // y del mes previo\n  const monthPrev = (finalMonth === 1) ? 12 : finalMonth - 1;\n  const yearPrev = (finalMonth === 1) ? yearNum - 1 : yearNum;\n  \n  // Arreglo final con 5 fechas\n  const fechasDias = [];\n  \n  if (dayStart <= dayEnd) {\n    // Caso \"normal\": todo en el mismo mes\n    let d = dayStart;\n    for (let i = 0; i < 5; i++) {\n      fechasDias.push({\n        diaSem: diasSemana[i],\n        diaNum: d,\n        mesNum: finalMonth,\n        yearNum: yearNum\n      });\n      d++;\n      if (d > diasMesFinal) {\n        d = 1;\n        const nextMonth = finalMonth % 12 + 1;\n        const nextYear = (nextMonth === 1) ? yearNum + 1 : yearNum;\n        fechasDias[fechasDias.length - 1].mesNum = nextMonth;\n        fechasDias[fechasDias.length - 1].yearNum = nextYear;\n      }\n    }\n  } else {\n    // Caso \"cruza de mes\": dayStart > dayEnd\n    let d = dayStart;\n    let m = monthPrev;\n    let y = yearPrev;\n    \n    for (let i = 0; i < 5; i++) {\n      fechasDias.push({\n        diaSem: diasSemana[i],\n        diaNum: d,\n        mesNum: m,\n        yearNum: y\n      });\n      d++;\n      if (d > getDiasMes(m, y)) {\n        d = 1;\n        m = m % 12 + 1;\n        if (m === 1) {\n          y++;\n        }\n      }\n    }\n  }\n  \n  // Ahora volcamos esas 5 fechas en la estructura\n  fechasDias.forEach(fd => {\n    const { diaSem, diaNum, mesNum, yearNum } = fd;\n    mallaEstructurada.dias[diaSem] = {\n      fechaDia: fechaFormateada(diaNum, mesNum, yearNum),\n      muelle1: {},\n      muelle2: {}\n    };\n  });\n  \n  // Inicializamos las franjas a 'disponible'\n  if (mallaEstructurada.franjas.length > 0) {\n    diasSemana.forEach(d => {\n      mallaEstructurada.franjas.forEach(f => {\n        mallaEstructurada.dias[d].muelle1[f.hora] = {\n          estado: \"disponible\",\n          proveedor: \"\",\n          ordenCompra: \"\",\n          peso: \"\",\n          categoria: \"\",\n          unidades: \"\"\n        };\n        mallaEstructurada.dias[d].muelle2[f.hora] = {\n          estado: \"disponible\",\n          proveedor: \"\",\n          ordenCompra: \"\",\n          peso: \"\",\n          categoria: \"\",\n          unidades: \"\"\n        };\n      });\n    });\n  }\n}\n\n/**\n * Funci√≥n auxiliar: decide a qu√© d√≠a pertenece una columna,\n * corrigiendo 2 columnas de offset (porque 'Extract from XLSX'\n * deja todo desplazado).\n */\nfunction getDayForColumn(colNumber) {\n  // Ajuste de offset +2\n  const realCol = colNumber + 2;\n\n  // Rangos:\n  //  Lunes:      3..8\n  //  Martes:     9..14\n  //  Mi√©rcoles: 15..20\n  //  Jueves:    21..26\n  //  Viernes:   27..32\n  if (realCol >= 3 && realCol <= 8) {\n    return \"lunes\";\n  }\n  if (realCol >= 9 && realCol <= 14) {\n    return \"martes\";\n  }\n  if (realCol >= 15 && realCol <= 20) {\n    return \"mi√©rcoles\";\n  }\n  if (realCol >= 21 && realCol <= 26) {\n    return \"jueves\";\n  }\n  if (realCol >= 27 && realCol <= 32) {\n    return \"viernes\";\n  }\n  // Si nada coincide, devolvemos null\n  return null;\n}\n\n/**\n * Extraer las citas para cada franja:\n * - Para cada franja, miramos 3 filas:\n *    - Fila base => proveedor\n *    - Fila base+1 => orden\n *    - Fila base+2 => peso, categor√≠a, unidades\n */\nfunction extraerCitas(datos, muellesInfo) {\n  mallaEstructurada.franjas.forEach(franja => {\n    const indiceBase = franja.indice;\n    if (indiceBase < 0 || indiceBase + 2 >= datos.length) {\n      return; // no hay suficientes filas\n    }\n    \n    // Recorremos muelle1, muelle2 y sus columnas\n    const asignarCita = (muelleKey, cols) => {\n      cols.forEach(col => {\n        const provKey = `__EMPTY_${col}`;\n        const filaProv = datos[indiceBase];\n        \n        // Si en esta fila hay un proveedor o alg√∫n texto\n        if (\n          filaProv &&\n          typeof filaProv[provKey] === 'string' &&\n          filaProv[provKey].length > 2\n        ) {\n          // Determinar el d√≠a real\n          const diaOk = getDayForColumn(col);\n          if (!diaOk || !mallaEstructurada.dias[diaOk]) {\n            return; // si no coincide con ninguno, saltamos\n          }\n          \n          // Recuperar valores para proveedor, ordenCompra y dem√°s\n          const filaOrden = datos[indiceBase + 1];\n          const filaDet = datos[indiceBase + 2];\n          \n          const proveedor = filaProv[provKey] || \"\";\n          const ordenCompra = filaOrden && filaOrden[provKey] ? filaOrden[provKey] : \"\";\n          const peso = filaDet && filaDet[provKey] ? filaDet[provKey] : \"\";\n          const cat  = filaDet && filaDet[`__EMPTY_${col + 1}`] ? filaDet[`__EMPTY_${col + 1}`] : \"\";\n          const und  = filaDet && filaDet[`__EMPTY_${col + 2}`] ? filaDet[`__EMPTY_${col + 2}`] : \"\";\n          \n          // Antes pon√≠amos estado=\"ocupado\" directamente\n          // Ahora verificamos si el texto contiene \"reagendado\", \"cancelado\" o \"fuera de servicio\".\n          const nuevoEstado = determinarEstadoOcupado(proveedor, ordenCompra, peso, cat, und);\n          \n          // Asignamos los datos\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].estado = nuevoEstado;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].proveedor = proveedor;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].ordenCompra = ordenCompra;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].peso = peso;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].categoria = cat;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].unidades = und;\n        }\n      });\n    };\n    \n    if (muellesInfo.muelle1) {\n      asignarCita('muelle1', muellesInfo.muelle1);\n    }\n    if (muellesInfo.muelle2) {\n      asignarCita('muelle2', muellesInfo.muelle2);\n    }\n  });\n}\n\n// -------------------------------------------------------------\n// 2) FUNCIONES PARA CONSULTAR LA MALLA\n// -------------------------------------------------------------\nfunction buscarFranjasDisponibles(categoria, duracionHoras) {\n  const muelle = \"muelle1\"; // Ajusta si usas \"categoria -> muelle\" real\n  \n  const franjasDisponibles = [];\n  Object.keys(mallaEstructurada.dias).forEach(dia => {\n    const libres = [];\n    for (let i = 0; i <= mallaEstructurada.franjas.length - duracionHoras; i++) {\n      let disponible = true;\n      for (let h = 0; h < duracionHoras; h++) {\n        const idxF = i + h;\n        const horaAct = mallaEstructurada.franjas[idxF].hora;\n        if (\n          mallaEstructurada.dias[dia][muelle][horaAct].estado !== 'disponible'\n        ) {\n          disponible = false;\n          break;\n        }\n      }\n      if (disponible) {\n        libres.push({\n          horaInicio: mallaEstructurada.franjas[i].hora,\n          duracion: duracionHoras\n        });\n      }\n    }\n    if (libres.length > 0) {\n      franjasDisponibles.push({ dia, franjas: libres });\n    }\n  });\n  return franjasDisponibles;\n}\n\nfunction buscarCitasProveedor(nombreProveedor) {\n  const citas = [];\n  Object.keys(mallaEstructurada.dias).forEach(dia => {\n    const muelle1 = mallaEstructurada.dias[dia].muelle1;\n    const muelle2 = mallaEstructurada.dias[dia].muelle2;\n    mallaEstructurada.franjas.forEach(f => {\n      const hora = f.hora;\n      // muelle1\n      if (normalizarTexto(muelle1[hora].proveedor) === normalizarTexto(nombreProveedor)) {\n        citas.push({\n          dia,\n          hora,\n          muelle: \"Muelle 01\",\n          ordenCompra: muelle1[hora].ordenCompra,\n          peso: muelle1[hora].peso,\n          categoria: muelle1[hora].categoria,\n          unidades: muelle1[hora].unidades,\n          estado: muelle1[hora].estado\n        });\n      }\n      // muelle2\n      if (normalizarTexto(muelle2[hora].proveedor) === normalizarTexto(nombreProveedor)) {\n        citas.push({\n          dia,\n          hora,\n          muelle: \"Muelle 02\",\n          ordenCompra: muelle2[hora].ordenCompra,\n          peso: muelle2[hora].peso,\n          categoria: muelle2[hora].categoria,\n          unidades: muelle2[hora].unidades,\n          estado: muelle2[hora].estado\n        });\n      }\n    });\n  });\n  return citas;\n}\n\nfunction consultarFranjasDisponibles(categoria, duracionHoras) {\n  return buscarFranjasDisponibles(categoria, duracionHoras);\n}\n\nfunction consultarCitasProveedor(nombreProveedor) {\n  return buscarCitasProveedor(nombreProveedor);\n}\n\nfunction obtenerInfoMalla() {\n  return {\n    titulo: mallaEstructurada.titulo,\n    a√±o: mallaEstructurada.a√±o,\n    semana: mallaEstructurada.semana,\n    rangoDias: mallaEstructurada.rangoDias,\n    franjas: mallaEstructurada.franjas.map(f => f.hora)\n  };\n}\n\nfunction estaDisponible(dia, hora, muelle) {\n  const info = mallaEstructurada.dias[dia]?.[muelle]?.[hora];\n  return info ? (info.estado === 'disponible') : false;\n}\n\nfunction obtenerCoordenadasCita(dia, hora, muelle) {\n  // Ajustar con tu mapeo de celdas en Excel\n  return {\n    proveedor: `${dia}_${hora}_${muelle}_proveedor`,\n    ordenCompra: `${dia}_${hora}_${muelle}_ordenCompra`,\n    peso: `${dia}_${hora}_${muelle}_peso`,\n    categoria: `${dia}_${hora}_${muelle}_categoria`,\n    unidades: `${dia}_${hora}_${muelle}_unidades`\n  };\n}\n\n// -------------------------------------------------------------\n// 3) EJECUTAR TODO Y RETORNAR\n// -------------------------------------------------------------\nconst malla = procesarDatos(excelData);\n\nconst resultado = {\n  datosMallaProxSemana: malla,\n  funciones: {\n    consultarFranjasDisponibles,\n    consultarCitasProveedor,\n    obtenerInfoMalla,\n    estaDisponible,\n    obtenerCoordenadasCita\n  }\n};\n\nreturn [resultado];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -800,
        7600
      ],
      "id": "83d79789-b2d3-4617-acae-f1a00cf1e92b",
      "name": "Estructuraci√≥n, Datos, Consulta, Citas Proxima Semana4"
    },
    {
      "parameters": {
        "jsCode": "// Obtener los datos de la cita desde la consulta SQL\nconst citaBD = $('Microsoft SQL Obtener Cita para Cancelar').first().json;\n\n// Obtener los datos de las mallas\nconst datosMalla = $('Unificaci√≥n y consistencia de datos5').first().json;\nconst mallaActual = datosMalla.datosMalla;\nconst mallaProxSemana = datosMalla.datosMallaProxSemana;\n\n// Funci√≥n para normalizar texto (quitar espacios, convertir a min√∫sculas)\nfunction normalizarTexto(texto) {\n  if (!texto) return \"\";\n  return texto.toString().trim().toLowerCase();\n}\n\n// Funci√≥n para buscar cita en una malla espec√≠fica\nfunction buscarCitaEnMalla(malla, citaBuscar) {\n  const diasSemana = ['lunes', 'martes', 'mi√©rcoles', 'jueves', 'viernes'];\n  const muelles = ['muelle1', 'muelle2'];\n  \n  for (const dia of diasSemana) {\n    if (!malla.dias[dia]) continue;\n    \n    for (const muelle of muelles) {\n      if (!malla.dias[dia][muelle]) continue;\n      \n      // Revisar todas las franjas horarias\n      for (const [hora, citaMalla] of Object.entries(malla.dias[dia][muelle])) {\n        // Solo revisar citas ocupadas\n        if (citaMalla.estado !== 'ocupado') continue;\n        \n        // Comparar campos clave\n        const proveedorCoincide = normalizarTexto(citaMalla.proveedor) === normalizarTexto(citaBuscar.nombre);\n        const ordenCoincide = normalizarTexto(citaMalla.ordenCompra) === normalizarTexto(citaBuscar.orden_compra);\n        \n        // Verificar peso (puede ser number o string)\n        let pesoCoincide = false;\n        const pesoBD = parseFloat(citaBuscar.peso) || 0;\n        const pesoMalla = parseFloat(citaMalla.peso) || 0;\n        pesoCoincide = Math.abs(pesoBD - pesoMalla) < 0.01; // tolerancia para decimales\n        \n        // Verificar unidades\n        let unidadesCoincide = false;\n        const unidadesBD = parseFloat(citaBuscar.unidades) || 0;\n        const unidadesMalla = parseFloat(citaMalla.unidades) || 0;\n        unidadesCoincide = Math.abs(unidadesBD - unidadesMalla) < 0.01;\n        \n        // Si coinciden los campos principales, es la misma cita\n        if (proveedorCoincide && ordenCoincide && pesoCoincide && unidadesCoincide) {\n          return {\n            encontrada: true,\n            ubicacion: {\n              malla: malla.semana,\n              dia: dia,\n              hora: hora,\n              muelle: muelle,\n              fechaDia: malla.dias[dia].fechaDia || \"Fecha no disponible\"\n            },\n            detalles: citaMalla\n          };\n        }\n      }\n    }\n  }\n  \n  return { encontrada: false };\n}\n\n// Buscar la cita en ambas mallas\nlet citaEncontrada = null;\nlet ubicacionEncontrada = null;\n\n// Primero buscar en la malla actual\nconst resultadoMallaActual = buscarCitaEnMalla(mallaActual, citaBD);\nif (resultadoMallaActual.encontrada) {\n  citaEncontrada = resultadoMallaActual.detalles;\n  ubicacionEncontrada = resultadoMallaActual.ubicacion;\n}\n\n// Si no se encontr√≥ en la malla actual, buscar en la pr√≥xima semana\nif (!citaEncontrada) {\n  const resultadoMallaProxima = buscarCitaEnMalla(mallaProxSemana, citaBD);\n  if (resultadoMallaProxima.encontrada) {\n    citaEncontrada = resultadoMallaProxima.detalles;\n    ubicacionEncontrada = resultadoMallaProxima.ubicacion;\n  }\n}\n\n// Generar respuesta basada en si se encontr√≥ o no la cita\nif (citaEncontrada) {\n  // Cita encontrada - continuar con el proceso de cancelaci√≥n\n  return [{\n    validacionExitosa: true,\n    citaEncontrada: true,\n    datosValidacion: {\n      citaBD: {\n        id: citaBD.id,\n        nombre: citaBD.nombre,\n        ordenCompra: citaBD.orden_compra,\n        peso: citaBD.peso,\n        unidades: citaBD.unidades,\n        fechaCita: citaBD.fecha_cita,\n        estado: citaBD.estado\n      },\n      citaMalla: citaEncontrada,\n      ubicacion: ubicacionEncontrada\n    },\n    mensaje: `‚úÖ **Validaci√≥n exitosa**\\n\\n` +\n             `Se ha verificado que la cita üîñ **${citaBD.id}** con orden de compra **${citaBD.orden_compra}** ` +\n             `se encuentra correctamente registrada en la malla de la ${ubicacionEncontrada.malla}.\\n\\n` +\n             `üìç **Ubicaci√≥n en malla:**\\n` +\n             `‚Ä¢ **D√≠a:** ${ubicacionEncontrada.dia} (${ubicacionEncontrada.fechaDia})\\n` +\n             `‚Ä¢ **Hora:** ${ubicacionEncontrada.hora}\\n` +\n             `‚Ä¢ **Muelle:** ${ubicacionEncontrada.muelle.replace('muelle', 'Muelle ')}\\n` +\n             `‚Ä¢ **Proveedor:** ${citaEncontrada.proveedor}\\n\\n` +\n             `Procediendo con la cancelaci√≥n de la cita...`\n  }];\n} else {\n  // Cita NO encontrada - generar error\n  return [{\n    validacionExitosa: false,\n    citaEncontrada: false,\n    error: true,\n    datosValidacion: {\n      citaBD: {\n        id: citaBD.id,\n        nombre: citaBD.nombre,\n        ordenCompra: citaBD.orden_compra,\n        peso: citaBD.peso,\n        unidades: citaBD.unidades,\n        fechaCita: citaBD.fecha_cita,\n        estado: citaBD.estado\n      },\n      mallaRevisada: {\n        semanaActual: mallaActual.semana,\n        rangoActual: mallaActual.rangoDias,\n        semanaProxima: mallaProxSemana.semana,\n        rangoProximo: mallaProxSemana.rangoDias\n      }\n    },\n    mensaje: `‚ùå **Error de validaci√≥n de malla**\\n\\n` +\n             `La cita üîñ **${citaBD.id}** con orden de compra **${citaBD.orden_compra}** ` +\n             `se encuentra registrada en la base de datos como **PROGRAMADA**, pero ` +\n             `**NO coincide** con ninguna cita ocupada en la malla de horarios.\\n\\n` +\n             `üìä **Datos de la cita en BD:**\\n` +\n             `‚Ä¢ **Proveedor:** ${citaBD.nombre}\\n` +\n             `‚Ä¢ **Orden de compra:** ${citaBD.orden_compra}\\n` +\n             `‚Ä¢ **Peso:** ${citaBD.peso} kg\\n` +\n             `‚Ä¢ **Unidades:** ${citaBD.unidades}\\n` +\n             `‚Ä¢ **Fecha programada:** ${citaBD.fecha_cita}\\n\\n` +\n             `üîç **Mallas revisadas:**\\n` +\n             `‚Ä¢ ${mallaActual.semana}: ${mallaActual.rangoDias}\\n` +\n             `‚Ä¢ ${mallaProxSemana.semana}: ${mallaProxSemana.rangoDias}\\n\\n` +\n             `‚ö†Ô∏è **Acci√≥n requerida:**\\n` +\n             `Por favor comun√≠quese con el **√°rea de bodega** para verificar qu√© sucedi√≥ con esta cita. ` +\n             `Es posible que haya una inconsistencia entre la base de datos y la malla de horarios.\\n\\n` +\n             `üìû **Contacto:** Extensi√≥n 1234 - Coordinaci√≥n de Bodega\\n\\n` +\n             `üîÑ **Esta conversaci√≥n ser√° eliminada** para mantener la trazabilidad del historial.`,\n    codigoError: \"CITA_NO_ENCONTRADA_EN_MALLA\",\n    accionRequerida: \"CONTACTAR_BODEGA\"\n  }];\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        48,
        7504
      ],
      "id": "1d546d7e-bf52-4764-9d7e-a9a7149a6579",
      "name": "Code validaci√≥n de cita en malla"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "64a1bea0-f03e-4e93-8f05-f2e606167be0",
              "leftValue": "={{ $json.citaEncontrada }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        320,
        7504
      ],
      "id": "5c7ee711-b373-4ae7-91a8-792acfe1f498",
      "name": "If validar cita existe"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "4bfbecb3-9d4f-4425-aa76-a92abc7708fb",
              "leftValue": "={{ $('Code validaci√≥n de cita en malla').first().json.mensaje.length }}",
              "rightValue": 70,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        752,
        7888
      ],
      "id": "39090e0d-db7a-4345-833f-a90c9300d7b8",
      "name": "Validaci√≥n de longitud de caracteres14"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d9c2ff70-4fd1-4b93-8571-6d0ac5a0093e",
              "name": "mensaje.ia",
              "value": "={{ $('Code validaci√≥n de cita en malla').first().json.mensaje }}",
              "type": "string"
            },
            {
              "id": "ac8a03be-0292-4735-9580-39a385945c47",
              "name": "mensaje.longitud",
              "value": "={{ $('Code validaci√≥n de cita en malla').first().json.mensaje.length }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1024,
        7952
      ],
      "id": "333deb04-9e31-4f02-a718-62dc9316ff30",
      "name": "Organiza variables del mensaje14"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        1200,
        7744
      ],
      "id": "84a27e91-fe05-4c50-9825-03428ac3e136",
      "name": "No Operation, do nothing18"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $('Code Respuesta Faltantes').item.json.text }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1024,
        7744
      ],
      "id": "5fb9333e-4f82-493a-8ccb-5286186969e7",
      "name": "HTTP Request Enviar Mensaje por WhatsApp17"
    },
    {
      "parameters": {
        "jsCode": "// C√≥digo adaptado para CANCELACI√ìN de citas\nconst datosValidacion = $('Code validaci√≥n de cita en malla').first().json.datosValidacion;\nconst citaBD = datosValidacion.citaBD;\nconst ubicacionCita = datosValidacion.ubicacion;\nconst datosMalla = $('Unificaci√≥n y consistencia de datos5').first().json.datosMalla;\n\nconsole.log(`Preparando cancelaci√≥n de cita ID ${citaBD.id} ubicada en: ${ubicacionCita.dia} ${ubicacionCita.hora} ${ubicacionCita.muelle}`);\n\n// Funci√≥n para calcular las franjas ocupadas por la cita\nfunction calcularFranjasOcupadas() {\n  const franjas = [];\n  \n  // Encontrar la franja de inicio\n  const franjasOrdenadas = [...datosMalla.franjas].sort((a, b) => {\n    function horaAMinutos(hora) {\n      const match = hora.match(/(\\\\d+):(\\\\d+)\\\\s*([AP]M)/i);\n      if (!match) return 0;\n      \n      let horas = parseInt(match[1], 10);\n      const minutos = parseInt(match[2], 10);\n      const periodo = match[3].toUpperCase();\n      \n      if (periodo === 'PM' && horas !== 12) {\n        horas += 12;\n      } else if (periodo === 'AM' && horas === 12) {\n        horas = 0;\n      }\n      \n      return horas * 60 + minutos;\n    }\n    \n    return horaAMinutos(a.hora) - horaAMinutos(b.hora);\n  });\n  \n  // Encontrar el √≠ndice de la franja actual\n  const indiceInicio = franjasOrdenadas.findIndex(f => \n    f.hora.trim().toLowerCase() === ubicacionCita.hora.trim().toLowerCase()\n  );\n  \n  if (indiceInicio === -1) {\n    console.log(`No se encontr√≥ la franja ${ubicacionCita.hora} en la malla`);\n    return [];\n  }\n  \n  // Determinar cu√°ntas franjas consecutivas est√°n ocupadas por esta cita\n  // Buscar en la malla cu√°ntas franjas consecutivas tienen los mismos datos\n  const muelleKey = ubicacionCita.muelle.toLowerCase().includes(\"1\") ? \"muelle1\" : \"muelle2\";\n  const diaData = datosMalla.dias[ubicacionCita.dia];\n  \n  if (!diaData || !diaData[muelleKey]) {\n    console.log(`No se encontraron datos para ${ubicacionCita.dia} ${muelleKey}`);\n    return [];\n  }\n  \n  // Buscar franjas consecutivas con los mismos datos de la cita\n  for (let i = indiceInicio; i < franjasOrdenadas.length; i++) {\n    const franja = franjasOrdenadas[i];\n    const datosFramja = diaData[muelleKey][franja.hora];\n    \n    // Verificar si esta franja pertenece a la misma cita\n    const mismaCita = datosFramja &&\n      datosFramja.estado === 'ocupado' &&\n      datosFramja.proveedor.trim().toLowerCase() === citaBD.nombre.trim().toLowerCase() &&\n      datosFramja.ordenCompra.trim().toLowerCase() === citaBD.ordenCompra.trim().toLowerCase();\n    \n    if (mismaCita) {\n      const filaBase = calcularFilaExcel(franja.hora, franjasOrdenadas);\n      if (filaBase) {\n        franjas.push({\n          hora: franja.hora,\n          fila: filaBase,\n          datos: {\n            proveedor: \"\",\n            ordenCompra: \"\",\n            peso: \"\",\n            categoria: \"\",\n            unidades: \"\"\n          }\n        });\n      }\n    } else {\n      // Si encontramos una franja que no pertenece a la cita, detenemos la b√∫squeda\n      break;\n    }\n  }\n  \n  console.log(`Se identificaron ${franjas.length} franjas para cancelar`);\n  return franjas;\n}\n\n// Funciones auxiliares (mantener las mismas del nodo original)\nfunction calcularFilaExcel(hora, franjas) {\n  const franjasOrdenadas = [...franjas].sort((a, b) => {\n    function horaAMinutos(hora) {\n      const match = hora.match(/(\\\\d+):(\\\\d+)\\\\s*([AP]M)/i);\n      if (!match) return 0;\n      \n      let horas = parseInt(match[1], 10);\n      const minutos = parseInt(match[2], 10);\n      const periodo = match[3].toUpperCase();\n      \n      if (periodo === 'PM' && horas !== 12) {\n        horas += 12;\n      } else if (periodo === 'AM' && horas === 12) {\n        horas = 0;\n      }\n      \n      return horas * 60 + minutos;\n    }\n    \n    return horaAMinutos(a.hora) - horaAMinutos(b.hora);\n  });\n  \n  const posicion = franjasOrdenadas.findIndex(f => \n    f.hora.trim().toLowerCase() === hora.trim().toLowerCase()\n  );\n  \n  if (posicion === -1) {\n    console.log(`No se encontr√≥ la posici√≥n para la hora ${hora}`);\n    return null;\n  }\n  \n  const FILA_PRIMERA_FRANJA = 12;\n  const INCREMENTO_ESTANDAR = 3;\n  \n  if (posicion === 3) {\n    return 21;\n  } else if (posicion === 4) {\n    return 24;\n  } else if (posicion === 5) {\n    return 27;\n  } else if (posicion < 3) {\n    return FILA_PRIMERA_FRANJA + (posicion * INCREMENTO_ESTANDAR);\n  } else {\n    return 27 + ((posicion - 5) * INCREMENTO_ESTANDAR);\n  }\n}\n\nfunction procesarFranjas(franjas, nombreHoja) {\n  let actualizaciones = [];\n  \n  const diaSemana = ubicacionCita.dia;\n  const muelleKey = ubicacionCita.muelle.toLowerCase().includes(\"1\") ? \"muelle1\" : \"muelle2\";\n  \n  const mapeoColumnas = {\n    'lunes': { 'muelle1': 'C', 'muelle2': 'F' },\n    'martes': { 'muelle1': 'I', 'muelle2': 'L' },\n    'mi√©rcoles': { 'muelle1': 'O', 'muelle2': 'R' },\n    'jueves': { 'muelle1': 'U', 'muelle2': 'X' },\n    'viernes': { 'muelle1': 'AA', 'muelle2': 'AD' }\n  };\n  \n  if (!mapeoColumnas[diaSemana] || !mapeoColumnas[diaSemana][muelleKey]) {\n    console.log(`No hay mapeo para: d√≠a=${diaSemana}, muelle=${muelleKey}`);\n    return [];\n  }\n  \n  const columnaBase = mapeoColumnas[diaSemana][muelleKey];\n  \n  function siguienteColumna(columna) {\n    if (columna.length === 1) {\n      return String.fromCharCode(columna.charCodeAt(0) + 1);\n    } else {\n      const primerChar = columna.charAt(0);\n      const segundoChar = columna.charAt(1);\n      \n      if (segundoChar === 'Z') {\n        return String.fromCharCode(primerChar.charCodeAt(0) + 1) + 'A';\n      } else {\n        return primerChar + String.fromCharCode(segundoChar.charCodeAt(0) + 1);\n      }\n    }\n  }\n  \n  franjas.forEach((franja, index) => {\n    const filaBase = franja.fila;\n    const columnaLineas = siguienteColumna(columnaBase);\n    const columnaUnd = siguienteColumna(columnaLineas);\n    \n    const rangoCeldas = {\n      proveedor: `${columnaBase}${filaBase}`,\n      ordenCompra: `${columnaBase}${filaBase + 1}`,\n      peso: `${columnaBase}${filaBase + 2}`,\n      categoria: `${columnaLineas}${filaBase + 2}`,\n      unidades: `${columnaUnd}${filaBase + 2}`\n    };\n    \n    console.log(`Limpiando franja ${index + 1}: ${franja.hora} - Celdas: ${JSON.stringify(rangoCeldas)}`);\n    \n    // Para cancelaci√≥n, todos los valores son vac√≠os\n    actualizaciones.push(\n      { celda: rangoCeldas.proveedor, valor: \"\", nombreHoja },\n      { celda: rangoCeldas.ordenCompra, valor: \"\", nombreHoja },\n      { celda: rangoCeldas.peso, valor: \"\", nombreHoja },\n      { celda: rangoCeldas.categoria, valor: \"\", nombreHoja },\n      { celda: rangoCeldas.unidades, valor: \"\", nombreHoja }\n    );\n  });\n  \n  return actualizaciones;\n}\n\n// Ejecutar la l√≥gica de cancelaci√≥n\nconst franjasACancelar = calcularFranjasOcupadas();\n\nif (franjasACancelar.length === 0) {\n  return {\n    json: {\n      error: true,\n      mensaje: \"No se pudieron identificar las franjas de la cita para cancelar\",\n      datosValidacion\n    }\n  };\n}\n\n// Usar la semana de la ubicaci√≥n encontrada\nconst nombreHojaActual = ubicacionCita.malla;\n\n// Procesar las franjas para cancelaci√≥n (limpieza)\nconst actualizacionesCancelacion = procesarFranjas(franjasACancelar, nombreHojaActual);\n\n// Preparar el formato para Microsoft Graph\nconst actualizacionesGraph = actualizacionesCancelacion.map(act => ({\n  address: act.celda,\n  values: [[act.valor]], // Valores vac√≠os para cancelaci√≥n\n  nombreHoja: act.nombreHoja\n}));\n\n// Preparar el resultado\nreturn {\n  json: {\n    success: true,\n    accion: \"CANCELACION\",\n    mensaje: `Preparadas ${actualizacionesCancelacion.length} operaciones de limpieza para cancelar la cita ID ${citaBD.id}`,\n    nombreHoja: nombreHojaActual,\n    citaCancelada: {\n      id: citaBD.id,\n      proveedor: citaBD.nombre,\n      ordenCompra: citaBD.ordenCompra,\n      ubicacion: ubicacionCita\n    },\n    graphRequestData: {\n      updates: actualizacionesGraph\n    },\n    detalles: {\n      actualizacionesDetalladas: actualizacionesCancelacion,\n      franjasLimpiadas: franjasACancelar.length,\n      informacionCita: {\n        id: citaBD.id,\n        dia: ubicacionCita.dia,\n        hora: ubicacionCita.hora,\n        muelle: ubicacionCita.muelle,\n        proveedor: citaBD.nombre,\n        ordenCompra: citaBD.ordenCompra\n      }\n    }\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1008,
        6560
      ],
      "id": "525b6fcf-6449-483e-9d3a-b8b1290c43d7",
      "name": "Code (Preparar Cuerpo de Petici√≥n)2"
    },
    {
      "parameters": {
        "jsCode": "// C√≥digo modificado para \"Code Agrupar Franjas3\" - CANCELACI√ìN\n// Ahora devuelve los valores individuales igual que en crear cita\nconst input = $input.first().json;\n\n// Verificar que tenemos la estructura esperada\nif (!input || !input.graphRequestData || !input.graphRequestData.updates) {\n  console.log('Estructura de datos de entrada no v√°lida');\n  return {\n    json: {\n      error: \"FORMATO_INVALIDO\",\n      mensaje: \"La estructura de datos de entrada no es v√°lida\"\n    }\n  };\n}\n\nconst updates = input.graphRequestData.updates;\nconst resultados = [];\n\n// Recorremos cada actualizaci√≥n y creamos un item individual\nupdates.forEach((update, index) => {\n  // Para cancelaci√≥n, el valor siempre es vac√≠o\n  resultados.push({\n    json: {\n      valor: \"\", // Siempre vac√≠o para cancelaci√≥n\n      indice: Math.floor(index / 5) + 1, // Agrupar cada 5 items como una franja\n      nombreHoja: input.nombreHoja,\n      address: update.address,\n      informacionCita: input.detalles?.informacionCita || {},\n      accion: \"CANCELACION\"\n    }\n  });\n});\n\nconsole.log(`Se prepararon ${resultados.length} operaciones de limpieza para cancelaci√≥n`);\nreturn resultados;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        6560
      ],
      "id": "2b18059e-1015-458d-8d59-1c0738538e0a",
      "name": "Code Agrupar Franjas3"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        1504,
        6560
      ],
      "id": "5d7f1af1-2bf7-4777-a50a-9c6d07d91413",
      "name": "Loop Over Uno a Uno2"
    },
    {
      "parameters": {
        "jsCode": "// C√≥digo para preparar cada limpieza (cancelaci√≥n) para Microsoft Graph API\nconst input = $input.first().json;\n\n// Constantes para los IDs de SharePoint/OneDrive\nconst siteId = \"gexpresscargo.sharepoint.com,a592f886-4560-4e62-9646-1eee7add7abe,8b514073-41ae-4619-8f76-724bd912bc65\";\nconst driveId = \"b!hviSpWBFYk6WRh7uet16vnNAUYuuQRlGj3ZyS9kSvGVZ4DSg6c5MRqYYm2MdAER8\";\nconst itemId = \"01PPLUUYXY5E2GK3SJ25EZLJPUYJ43H3ME\";\n\n// Verificar que tenemos la estructura esperada (igual que en crear cita)\nif (!input || input.valor === undefined || !input.address || !input.nombreHoja) {\n  console.log('Estructura de datos de entrada no v√°lida para la cancelaci√≥n');\n  return {\n    json: {\n      error: \"FORMATO_INVALIDO\",\n      mensaje: \"La estructura de datos de entrada no es v√°lida para la cancelaci√≥n\"\n    }\n  };\n}\n\n// Para cancelaci√≥n, siempre usamos valor vac√≠o\nconst valorFormateado = [[\"\"]];\n\n// Generar un ID √∫nico para esta solicitud\nconst requestId = `cancelacion_${input.address}_${input.indice}_${Date.now()}`;\n\n// Crear la estructura de solicitud para Microsoft Graph $batch\nconst requestBody = {\n  requests: [\n    {\n      id: requestId,\n      method: \"PATCH\",\n      url: `/sites/${siteId}/drives/${driveId}/items/${itemId}/workbook/worksheets/${encodeURIComponent(input.nombreHoja)}/range(address='${input.address}')`,\n      body: {\n        values: valorFormateado // Siempre [[\"\"]] para limpiar\n      },\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    }\n  ],\n  _metadata: {\n    celda: input.address,\n    valor: \"\", // Vac√≠o para cancelaci√≥n\n    indice: input.indice,\n    accion: input.accion || \"CANCELACION\",\n    informacionCita: input.informacionCita || {}\n  }\n};\n\nconsole.log(`Preparada solicitud ${requestId} para limpiar celda ${input.address} en la hoja \"${input.nombreHoja}\"`);\n\n// Retornar el objeto request listo para ser enviado a Microsoft Graph $batch\nreturn {\n  json: requestBody\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1760,
        6672
      ],
      "id": "afcaa099-339d-488d-bea5-6eccd2812ed4",
      "name": "Code Preparar cada Insercion2"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://graph.microsoft.com/v1.0/$batch",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "microsoftOAuth2Api",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        2032,
        6672
      ],
      "id": "a3ca3503-77b2-4477-81b6-abcf4e4f22ea",
      "name": "HTTP Request Actualizar Excel2",
      "credentials": {
        "microsoftOAuth2Api": {
          "id": "mh8Z8hxFvd7LDO8D",
          "name": "CuentaMy SharePoint App Desarrollador1 Konfie "
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// C√≥digo para verificar si la limpieza fue exitosa (cancelaci√≥n)\nconst input = $input.first().json;\n\n// Verificar que tenemos la estructura esperada en la respuesta\nif (!input || !input.responses || !Array.isArray(input.responses) || input.responses.length === 0) {\n  console.log('Estructura de datos de respuesta no v√°lida');\n  return {\n    json: {\n      error: \"RESPUESTA_INVALIDA\",\n      mensaje: \"La estructura de datos de la respuesta no es v√°lida\",\n      exito: false\n    }\n  };\n}\n\n// Obtener la primera respuesta\nconst response = input.responses[0];\n\n// Extraer informaci√≥n de la solicitud original del ID\nconst idPartes = response.id.split('_');\nconst tipoOperacion = idPartes[0]; // \"cancelacion\"\nconst celdaOriginal = idPartes[1];\nconst indice = idPartes[2];\n\n// Verificar que la respuesta tiene un cuerpo\nif (!response.body || !response.body.address) {\n  console.log(`Error: La respuesta no contiene informaci√≥n sobre la direcci√≥n de celda`);\n  return {\n    json: {\n      error: \"RESPUESTA_SIN_DIRECCION\",\n      mensaje: \"La respuesta no incluye informaci√≥n sobre la direcci√≥n de celda\",\n      requestId: response.id,\n      status: response.status,\n      celdaOriginal: celdaOriginal,\n      exito: false\n    }\n  };\n}\n\n// Extraer la direcci√≥n de celda de la respuesta\nlet direccionRespuesta = \"\";\nif (response.body && response.body.address) {\n  const partesDireccion = response.body.address.split('!');\n  if (partesDireccion.length > 1) {\n    direccionRespuesta = partesDireccion[1];\n  }\n}\n\n// Obtener el valor de la respuesta (debe ser vac√≠o para cancelaci√≥n)\nconst valorRespuesta = response.body.values && response.body.values[0] && response.body.values[0][0];\n\n// Verificar si la operaci√≥n se realiz√≥ en la celda correcta\nconst celdaCorrecta = direccionRespuesta === celdaOriginal;\n\n// Verificar el c√≥digo de estado HTTP\nconst estadoExitoso = response.status >= 200 && response.status < 300;\n\n// Para cancelaci√≥n, tambi√©n verificamos que el valor sea vac√≠o\nconst valorCorrecto = tipoOperacion === \"cancelacion\" ? valorRespuesta === \"\" : true;\n\n// Crear objeto para almacenar el resultado de la verificaci√≥n\nconst resultado = {\n  exito: celdaCorrecta && estadoExitoso && valorCorrecto,\n  tipoOperacion: tipoOperacion,\n  celdaOriginal: celdaOriginal,\n  celdaInsertada: direccionRespuesta,\n  valorInsertado: valorRespuesta,\n  statusCode: response.status,\n  requestId: response.id,\n  indice: indice,\n  celdasDiferentes: !celdaCorrecta && estadoExitoso,\n  falloEstado: !estadoExitoso,\n  falloValor: !valorCorrecto\n};\n\nconst chatId = $('Organiza el Mensaje').first().json.infoMensaje.chat_id;\n\nif (!resultado.exito) {\n  console.log(`Error en ${tipoOperacion}: celda=${celdaOriginal}, insertada=${direccionRespuesta}, status=${response.status}, valor=\"${valorRespuesta}\"`);\n} else {\n  console.log(`${tipoOperacion} exitosa en celda ${celdaOriginal}`);\n}\n\n// Incluir la respuesta original para tener toda la informaci√≥n\nresultado.respuestaOriginal = response;\n\n// Retornar el resultado de la verificaci√≥n\nreturn {\n  json: resultado,\n  chat_id: chatId\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2240,
        6672
      ],
      "id": "00fcc460-7736-4830-8f18-512832cadf11",
      "name": "Code Verificar Inserci√≥n2"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "fb1eda05-eb5e-4683-8556-1cf2b5b8e4d5",
              "leftValue": "={{ $json.exito }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        2480,
        6720
      ],
      "id": "9af1c134-5c5b-40da-a77c-cb0920457d52",
      "name": "If Verificar Inserci√≥n2"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "15a95144-dd82-4ea5-b9ba-9eb924d2ae5c",
              "leftValue": "={{ $json.celdasDiferentes }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        2704,
        6800
      ],
      "id": "1adc6973-0b52-4a28-9085-c7bba79a4edf",
      "name": "If Diferente Caso2"
    },
    {
      "parameters": {
        "jsCode": "// C√≥digo para limpiar una celda donde se insert√≥ incorrectamente un valor\n// Actualizado para manejar la nueva estructura con operaciones de inserci√≥n y eliminaci√≥n\nconst input = $input.first().json;\n\n// Constantes para los IDs de SharePoint/OneDrive\nconst siteId = \"gexpresscargo.sharepoint.com,a592f886-4560-4e62-9646-1eee7add7abe,8b514073-41ae-4619-8f76-724bd912bc65\";\nconst driveId = \"b!hviSpWBFYk6WRh7uet16vnNAUYuuQRlGj3ZyS9kSvGVZ4DSg6c5MRqYYm2MdAER8\";\nconst itemId = \"01PPLUUYXY5E2GK3SJ25EZLJPUYJ43H3ME\";\n\n// Verificar que tenemos la informaci√≥n necesaria\nif (!input || (!input.operaciones && !input.celdaInsertada)) {\n  console.log('Informaci√≥n insuficiente para limpiar la celda incorrecta');\n  return {\n    json: {\n      error: \"INFORMACION_INSUFICIENTE\",\n      mensaje: \"No hay suficiente informaci√≥n para limpiar la celda incorrecta\"\n    }\n  };\n}\n\n// Determinar qu√© celdas necesitan limpieza\nconst celdasALimpiar = [];\n\n// Verificar si estamos usando la nueva estructura con operaciones\nif (input.operaciones) {\n  // Nueva estructura: usar informaci√≥n de las operaciones\n  const { insercion, eliminacion } = input.operaciones;\n  \n  // Si la inserci√≥n fall√≥, agregarla para limpieza\n  if (insercion && !insercion.exito && insercion.celdaRespuesta) {\n    celdasALimpiar.push({\n      celda: insercion.celdaRespuesta,\n      hoja: insercion.hoja || \"\"\n    });\n  }\n  \n  // Si la eliminaci√≥n fall√≥, agregarla para limpieza\n  if (eliminacion && !eliminacion.exito && eliminacion.celdaRespuesta) {\n    celdasALimpiar.push({\n      celda: eliminacion.celdaRespuesta,\n      hoja: eliminacion.hoja || \"\"\n    });\n  }\n} else {\n  // Estructura anterior: solo tenemos informaci√≥n de inserci√≥n\n  // Obtener la celda a limpiar y la informaci√≥n de la hoja\n  const celdaALimpiar = input.celdaInsertada;\n  let hojaExcel = input.nombreHoja || \"\"; // Usar el nombreHoja del input\n  \n  // Intentar extraer el nombre de la hoja de la direcci√≥n en la respuesta si no est√° disponible\n  if ((!hojaExcel || hojaExcel === \"\") && input.respuestaOriginal?.body?.address) {\n    const direccionCompleta = input.respuestaOriginal.body.address;\n    hojaExcel = direccionCompleta.split('!')[0].replace(/'/g, '');\n  }\n  \n  celdasALimpiar.push({\n    celda: celdaALimpiar,\n    hoja: hojaExcel\n  });\n}\n\n// Si no hay celdas para limpiar, devolver error\nif (celdasALimpiar.length === 0) {\n  console.log('No se identificaron celdas para limpiar');\n  return {\n    json: {\n      error: \"NO_HAY_CELDAS\",\n      mensaje: \"No se identificaron celdas que necesiten limpieza\",\n      input: input\n    }\n  };\n}\n\n// Crear solicitudes para limpiar cada celda identificada\nconst solicitudes = celdasALimpiar.map((info, index) => {\n  console.log(`Limpiando celda incorrecta ${info.celda} en hoja ${info.hoja}`);\n  \n  return {\n    id: `Limpiar_${info.celda}_${Date.now()}_${index}`,\n    method: \"PATCH\",\n    url: `/sites/${siteId}/drives/${driveId}/items/${itemId}/workbook/worksheets/${encodeURIComponent(info.hoja)}/range(address='${info.celda}')`,\n    body: {\n      values: [[\"\"]] // Valor vac√≠o para limpiar la celda\n    },\n    headers: {\n      \"Content-Type\": \"application/json\"\n    }\n  };\n});\n\n// Crear la solicitud para limpiar las celdas\nconst requestBody = {\n  requests: solicitudes,\n  _metadata: {\n    accion: \"limpiar\",\n    celdasLimpiadas: celdasALimpiar,\n    datoOriginal: input\n  }\n};\n\n// Retornar el request para limpiar la celda\nreturn {\n  json: requestBody\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3008,
        6624
      ],
      "id": "bda553d7-0a9b-4af5-bf75-8798ed608196",
      "name": "Code Limpiar Celda Incorrecta2",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://graph.microsoft.com/v1.0/$batch",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "microsoftOAuth2Api",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        3232,
        6624
      ],
      "id": "76c3b2b0-37d2-4d9b-849c-34652ea08f69",
      "name": "HTTP Request Limpiar Celda2",
      "credentials": {
        "microsoftOAuth2Api": {
          "id": "mh8Z8hxFvd7LDO8D",
          "name": "CuentaMy SharePoint App Desarrollador1 Konfie "
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "e570827e-13d0-4d6f-b23e-184ca2d3368c",
              "leftValue": "={{ $json.falloEstado }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        3168,
        7008
      ],
      "id": "dde0efcf-4b1a-4a83-b032-52f6996b2436",
      "name": "If fallo Estado2"
    },
    {
      "parameters": {
        "jsCode": "// C√≥digo para reintentar la inserci√≥n en la celda correcta\n// Actualizado para manejar la nueva estructura con operaciones de inserci√≥n y eliminaci√≥n\nconst input = $input.first().json;\n\n// Constantes para los IDs de SharePoint/OneDrive\nconst siteId = \"gexpresscargo.sharepoint.com,a592f886-4560-4e62-9646-1eee7add7abe,8b514073-41ae-4619-8f76-724bd912bc65\";\nconst driveId = \"b!hviSpWBFYk6WRh7uet16vnNAUYuuQRlGj3ZyS9kSvGVZ4DSg6c5MRqYYm2MdAER8\";\nconst itemId = \"01PPLUUYXY5E2GK3SJ25EZLJPUYJ43H3ME\";\n\n// Si el input viene del nodo anterior de limpiar celda, extraer el dato original\nconst datoOriginal = input._metadata?.datoOriginal || input;\n\n// Verificar que tenemos la informaci√≥n necesaria\nif (!datoOriginal) {\n  console.log('Informaci√≥n insuficiente para reintentar la inserci√≥n/eliminaci√≥n');\n  return {\n    json: {\n      error: \"INFORMACION_INSUFICIENTE\",\n      mensaje: \"No hay suficiente informaci√≥n para reintentar las operaciones\"\n    }\n  };\n}\n\n// Operaciones a reintentar\nconst operacionesAReintentar = [];\n\n// Determinar qu√© operaciones necesitan reintento\nif (datoOriginal.operaciones) {\n  // Nueva estructura: evaluar inserci√≥n y eliminaci√≥n\n  const { insercion, eliminacion } = datoOriginal.operaciones;\n  \n  // Verificar si la inserci√≥n necesita reintento\n  if (insercion && !insercion.exito) {\n    operacionesAReintentar.push({\n      tipo: \"insercion\",\n      celda: insercion.celda,\n      valor: insercion.valor,\n      hoja: insercion.hoja || datoOriginal.resultadoDetallado?.operaciones?.insercion?.hoja || \"\"\n    });\n  }\n  \n  // Verificar si la eliminaci√≥n necesita reintento\n  if (eliminacion && !eliminacion.exito) {\n    operacionesAReintentar.push({\n      tipo: \"eliminacion\",\n      celda: eliminacion.celda,\n      valor: \"\", // Para eliminaci√≥n, siempre usamos valor vac√≠o\n      hoja: eliminacion.hoja || datoOriginal.resultadoDetallado?.operaciones?.eliminacion?.hoja || \"\"\n    });\n  }\n} else {\n  // Estructura anterior: solo tenemos informaci√≥n de inserci√≥n\n  // Obtener la celda correcta donde insertar y el valor a insertar\n  const celdaCorrecta = datoOriginal.celdaOriginal;\n  \n  // Intentar obtener el valor correcto a insertar\n  let valorAInsertar;\n  \n  // Primero, verificar si tenemos el valor de la respuesta original\n  if (datoOriginal.valorInsertado !== undefined) {\n    valorAInsertar = datoOriginal.valorInsertado;\n  } \n  // Si no, intentar obtenerlo del body de la respuesta\n  else if (datoOriginal.respuestaOriginal?.body?.values?.[0]?.[0] !== undefined) {\n    valorAInsertar = datoOriginal.respuestaOriginal.body.values[0][0];\n  } \n  // Como √∫ltimo recurso, usar un valor vac√≠o\n  else {\n    valorAInsertar = \"\";\n    console.log('No se pudo determinar el valor a insertar, usando valor vac√≠o');\n  }\n  \n  // Obtener la hoja de Excel - primero del dato original\n  let hojaExcel = datoOriginal.nombreHoja || \"\"; \n  \n  // Si no est√° disponible en el objeto principal, intentar obtenerlo de otros lugares\n  if (!hojaExcel || hojaExcel === \"\") {\n    // Verificar si est√° en el _metadata\n    hojaExcel = input._metadata?.hoja || \"\";\n    \n    // Como √∫ltimo recurso, extraer de la direcci√≥n en la respuesta\n    if ((!hojaExcel || hojaExcel === \"\") && datoOriginal.respuestaOriginal?.body?.address) {\n      const direccionCompleta = datoOriginal.respuestaOriginal.body.address;\n      hojaExcel = direccionCompleta.split('!')[0].replace(/'/g, '');\n    }\n  }\n  \n  operacionesAReintentar.push({\n    tipo: \"insercion\",\n    celda: celdaCorrecta,\n    valor: valorAInsertar,\n    hoja: hojaExcel\n  });\n}\n\n// Si no hay operaciones para reintentar, devolver error\nif (operacionesAReintentar.length === 0) {\n  console.log('No se identificaron operaciones para reintentar');\n  return {\n    json: {\n      error: \"NO_HAY_OPERACIONES\",\n      mensaje: \"No se identificaron operaciones que necesiten reintento\",\n      input: datoOriginal\n    }\n  };\n}\n\n// Crear solicitudes para cada operaci√≥n a reintentar\nconst solicitudes = operacionesAReintentar.map((op, index) => {\n  // Determinar el tipo de valor y formatearlo adecuadamente\n  let valorFormateado;\n  if (typeof op.valor === 'number') {\n    valorFormateado = [[op.valor]]; // Mantener el tipo num√©rico\n  } else {\n    valorFormateado = [[op.valor.toString()]]; // Convertir a string para otros tipos\n  }\n  \n  console.log(`Reintentando ${op.tipo} en celda ${op.celda} de la hoja ${op.hoja} con valor \"${op.valor}\"`);\n  \n  return {\n    id: `Reintento_${op.tipo}_${op.celda}_${Date.now()}_${index}`,\n    method: \"PATCH\",\n    url: `/sites/${siteId}/drives/${driveId}/items/${itemId}/workbook/worksheets/${encodeURIComponent(op.hoja)}/range(address='${op.celda}')`,\n    body: {\n      values: valorFormateado\n    },\n    headers: {\n      \"Content-Type\": \"application/json\"\n    }\n  };\n});\n\n// Crear la solicitud para reintentar las operaciones\nconst requestBody = {\n  requests: solicitudes,\n  _metadata: {\n    accion: \"reintentar\",\n    operaciones: operacionesAReintentar,\n    datoOriginal: datoOriginal,\n    intentos: (datoOriginal._metadata?.intentos || 0) + 1\n  }\n};\n\n// Retornar el request para reintentar las operaciones\nreturn {\n  json: requestBody\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3504,
        6688
      ],
      "id": "be1c5101-5725-4dc2-8890-a8bd04a56c76",
      "name": "Code Reintentar Inserci√≥n2",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://graph.microsoft.com/v1.0/$batch",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "microsoftOAuth2Api",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        3744,
        6800
      ],
      "id": "343b7ab2-4af4-4d51-94d8-c5f0bd0cecaf",
      "name": "HTTP Request Reintentar Inserci√≥n2",
      "credentials": {
        "microsoftOAuth2Api": {
          "id": "mh8Z8hxFvd7LDO8D",
          "name": "CuentaMy SharePoint App Desarrollador1 Konfie "
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// C√≥digo para verificar si la inserci√≥n y eliminaci√≥n fueron exitosas\n// Actualizado para manejar la nueva estructura\nconst input = $input.first().json;\n\n// Verificar que tenemos la estructura esperada en la respuesta\nif (!input || !input.responses || !Array.isArray(input.responses)) {\n  console.log('Estructura de datos de respuesta no v√°lida');\n  return {\n    json: {\n      error: \"RESPUESTA_INVALIDA\",\n      mensaje: \"La estructura de datos de la respuesta no es v√°lida\",\n      exito: false\n    }\n  };\n}\n\n// Si no hay respuestas, devolver error\nif (input.responses.length === 0) {\n  console.log('No se recibieron respuestas del servidor');\n  return {\n    json: {\n      error: \"SIN_RESPUESTAS\",\n      mensaje: \"No se recibieron respuestas del servidor\",\n      exito: false\n    }\n  };\n}\n\n// Analizar las respuestas para determinar a qu√© operaci√≥n corresponde cada una\nconst respuestas = input.responses.map(response => {\n  // Extraer informaci√≥n del ID de la respuesta\n  const idPartes = response.id.split('_');\n  const tipoOperacion = idPartes[0].toLowerCase(); // \"reintento\", \"limpiar\", etc.\n  const tipoEntidad = idPartes[1]?.toLowerCase(); // \"insercion\", \"eliminacion\", etc.\n  const celda = idPartes[2] || \"\"; // La celda como I21, K23, etc.\n  \n  // Extraer informaci√≥n de la direcci√≥n en la respuesta\n  let direccionRespuesta = \"\";\n  let hojaExcel = \"\";\n  \n  if (response.body && response.body.address) {\n    const direccionCompleta = response.body.address;\n    const partesDireccion = direccionCompleta.split('!');\n    \n    if (partesDireccion.length > 1) {\n      // Quitar las comillas simples del nombre de la hoja\n      hojaExcel = partesDireccion[0].replace(/'/g, '');\n      direccionRespuesta = partesDireccion[1];\n    }\n  }\n  \n  // Obtener el valor de la respuesta\n  const valor = response.body?.values?.[0]?.[0];\n  \n  // Verificar si la operaci√≥n fue exitosa (c√≥digo 200-299)\n  const estadoExitoso = response.status >= 200 && response.status < 300;\n  \n  // Verificar si la celda en la respuesta coincide con la esperada\n  const celdaCorrecta = direccionRespuesta === celda;\n  \n  return {\n    id: response.id,\n    tipoOperacion,\n    tipoEntidad,\n    celda,\n    direccionRespuesta,\n    hoja: hojaExcel,\n    valor,\n    estadoExitoso,\n    celdaCorrecta,\n    statusCode: response.status,\n    respuesta: response\n  };\n});\n\n// Separar las respuestas por tipo de operaci√≥n\nconst respuestasInsercion = respuestas.filter(r => \n  r.tipoEntidad === \"insercion\" || \n  (r.tipoOperacion === \"reintento\" && input._metadata?.operaciones?.[0]?.tipo === \"insercion\")\n);\n\nconst respuestasEliminacion = respuestas.filter(r => \n  r.tipoEntidad === \"eliminacion\" || \n  (r.tipoOperacion === \"reintento\" && input._metadata?.operaciones?.[0]?.tipo === \"eliminacion\")\n);\n\n// Determinar √©xito por tipo de operaci√≥n\nconst insercionExitosa = respuestasInsercion.length > 0 && \n                        respuestasInsercion.every(r => r.estadoExitoso && r.celdaCorrecta);\n\nconst eliminacionExitosa = respuestasEliminacion.length > 0 && \n                          respuestasEliminacion.every(r => r.estadoExitoso && r.celdaCorrecta);\n\n// Determinar √©xito global basado en las operaciones presentes\nlet exitoGlobal;\n\nif (respuestasInsercion.length > 0 && respuestasEliminacion.length > 0) {\n  // Si hay ambas operaciones, ambas deben ser exitosas\n  exitoGlobal = insercionExitosa && eliminacionExitosa;\n} else if (respuestasInsercion.length > 0) {\n  // Si solo hay inserci√≥n, solo esa debe ser exitosa\n  exitoGlobal = insercionExitosa;\n} else if (respuestasEliminacion.length > 0) {\n  // Si solo hay eliminaci√≥n, solo esa debe ser exitosa\n  exitoGlobal = eliminacionExitosa;\n} else {\n  // Si no hay operaciones identificables, considerar como no exitoso\n  exitoGlobal = false;\n}\n\n// Obtener la informaci√≥n m√°s relevante para cada tipo de operaci√≥n\nconst infoInsercion = respuestasInsercion.length > 0 ? respuestasInsercion[0] : null;\nconst infoEliminacion = respuestasEliminacion.length > 0 ? respuestasEliminacion[0] : null;\n\n// Crear el resultado detallado\nconst resultadoDetallado = {\n  exito: exitoGlobal,\n  operaciones: {\n    insercion: infoInsercion ? {\n      exito: infoInsercion.estadoExitoso && infoInsercion.celdaCorrecta,\n      celda: infoInsercion.celda,\n      direccionRespuesta: infoInsercion.direccionRespuesta,\n      hoja: infoInsercion.hoja,\n      valor: infoInsercion.valor,\n      statusCode: infoInsercion.statusCode\n    } : null,\n    eliminacion: infoEliminacion ? {\n      exito: infoEliminacion.estadoExitoso && infoEliminacion.celdaCorrecta,\n      celda: infoEliminacion.celda,\n      direccionRespuesta: infoEliminacion.direccionRespuesta,\n      hoja: infoEliminacion.hoja,\n      valor: infoEliminacion.valor,\n      statusCode: infoEliminacion.statusCode\n    } : null\n  },\n  mensaje: exitoGlobal ? \n    \"Todas las operaciones se completaron exitosamente\" : \n    \"Hubo problemas con una o m√°s operaciones\",\n  respuestasCompletas: respuestas\n};\n\n// Crear el resultado compatible con el formato anterior\nconst resultadoCompatible = {\n  exito: exitoGlobal,\n  // Usar la primera respuesta para compatibilidad\n  celdaOriginal: infoInsercion?.celda || infoEliminacion?.celda || \"\",\n  celdaInsertada: infoInsercion?.direccionRespuesta || infoEliminacion?.direccionRespuesta || \"\",\n  valorInsertado: infoInsercion?.valor || infoEliminacion?.valor || \"\",\n  statusCode: infoInsercion?.statusCode || infoEliminacion?.statusCode || 0,\n  requestId: infoInsercion?.id || infoEliminacion?.id || \"\",\n  indice: infoInsercion?.celda || infoEliminacion?.celda || \"\",\n  celdasDiferentes: (infoInsercion && infoInsercion.celda !== infoInsercion.direccionRespuesta) ||\n                   (infoEliminacion && infoEliminacion.celda !== infoEliminacion.direccionRespuesta),\n  falloEstado: !exitoGlobal,\n  // Informaci√≥n adicional para la versi√≥n mejorada\n  resultadoDetallado: resultadoDetallado\n};\n\n// Registrar el resultado en consola\nif (exitoGlobal) {\n  console.log(\"Operaciones completadas exitosamente:\");\n  if (infoInsercion) {\n    console.log(`- Inserci√≥n en hoja ${infoInsercion.hoja}, celda ${infoInsercion.celda}, valor: \"${infoInsercion.valor}\"`);\n  }\n  if (infoEliminacion) {\n    console.log(`- Eliminaci√≥n en hoja ${infoEliminacion.hoja}, celda ${infoEliminacion.celda}`);\n  }\n} else {\n  console.log(\"Problemas detectados en las operaciones:\");\n  if (infoInsercion && (!infoInsercion.estadoExitoso || !infoInsercion.celdaCorrecta)) {\n    console.log(`- Fallo en inserci√≥n: celda=${infoInsercion.celda}, direcci√≥n respuesta=${infoInsercion.direccionRespuesta}, status=${infoInsercion.statusCode}`);\n  }\n  if (infoEliminacion && (!infoEliminacion.estadoExitoso || !infoEliminacion.celdaCorrecta)) {\n    console.log(`- Fallo en eliminaci√≥n: celda=${infoEliminacion.celda}, direcci√≥n respuesta=${infoEliminacion.direccionRespuesta}, status=${infoEliminacion.statusCode}`);\n  }\n}\n\n// Retornar el resultado\nreturn {\n  json: resultadoCompatible\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3968,
        6800
      ],
      "id": "c7841bf5-d06d-4ccb-9ee8-855b8c93fafa",
      "name": "Code Volver a validar Inserci√≥n2",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "f7205e4e-147c-4e77-8fa8-08d082980b48",
              "leftValue": "={{ $json.exito }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        4192,
        6800
      ],
      "id": "01da706d-2f79-4f41-8ea1-4c7c540c865a",
      "name": "If Verificar Inserci√≥n 1"
    },
    {
      "parameters": {
        "amount": 3
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        3088,
        6800
      ],
      "id": "95ead0fc-5a79-4b44-a362-1f8c480b479f",
      "name": "Wait6",
      "webhookId": "a4bbf2b1-ea0c-4b02-af2c-64b29f2bdb5c"
    },
    {
      "parameters": {
        "amount": 3
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        4480,
        6992
      ],
      "id": "b9a837cf-29d5-488c-9c54-659d58d45ac0",
      "name": "Wait7",
      "webhookId": "9d944db7-9c4f-439e-9990-d9937f2fb18e"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        4928,
        7344
      ],
      "id": "32a5bcf8-d915-457d-b7b6-8296d340518c",
      "name": "OpenAI Chat Model18",
      "credentials": {
        "openAiApi": {
          "id": "AD8kPcNVReuclASd",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "=define",
        "text": "=Eres un asistente de un sistema de agendamiento de citas para la entrega de mercanc√≠a en bodega. Debes notificar al cliente que ha ocurrido un error en el sistema durante el proceso de cancelaci√≥n de la cita en el sistema de Excel.\n\nGenera un mensaje directo (sin saludos iniciales ni mencionar nombres) que:\n\n1. Comunique claramente que se produjo un error t√©cnico al intentar cancelaci√≥n la cita en el sistema.\n\n2. Indique que es urgente que se comunique con el √°rea de bodega en los pr√≥ximos 5 minutos para que puedan cancelar la cita manualmente.\n\n4. Aclare que esta situaci√≥n es poco com√∫n y se debe a un inconveniente t√©cnico en el sistema de agendamiento.\n\n5. Pida disculpas por los inconvenientes ocasionados y agradezca la comprensi√≥n.\n\nTono: urgente pero profesional, enfatizando la importancia de la acci√≥n inmediata para mantener la franja horaria seleccionada.\n"
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        5008,
        7120
      ],
      "id": "c8b3d32d-ae40-44db-babb-8f8707252255",
      "name": "Basic LLM Notificar No Disponibilidad4",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "4bfbecb3-9d4f-4425-aa76-a92abc7708fb",
              "leftValue": "={{ $('Basic LLM Notificar No Disponibilidad4').item.json.text.length }}",
              "rightValue": 70,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        5408,
        7312
      ],
      "id": "fb7443d5-bd29-4bd6-8031-768931f6a35f",
      "name": "Validaci√≥n de longitud de caracteres16"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d9c2ff70-4fd1-4b93-8571-6d0ac5a0093e",
              "name": "mensaje.ia",
              "value": "={{ $('Basic LLM Notificar No Disponibilidad4').item.json.text }}",
              "type": "string"
            },
            {
              "id": "ac8a03be-0292-4735-9580-39a385945c47",
              "name": "mensaje.longitud",
              "value": "={{ $('Basic LLM Notificar No Disponibilidad4').item.json.text.length }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        5712,
        7328
      ],
      "id": "2904aeb7-5633-4c9c-bdbf-038c009a84df",
      "name": "Organiza variables del mensaje15"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        5888,
        7104
      ],
      "id": "f438ee80-a6eb-4500-9168-71929b0d9fe0",
      "name": "No Operation, do nothing20"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $('Code Respuesta Faltantes').item.json.text }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        5712,
        7104
      ],
      "id": "9eab4d91-46c5-464d-8cff-96b1839cd06e",
      "name": "HTTP Request Enviar Mensaje por WhatsApp19"
    },
    {
      "parameters": {
        "jsCode": "/*\n===========================================================\n  Nodo Code - VALIDAR INSERCIONES EN EXCEL (n8n)\n  ‚Ä¢ Analiza la salida del ‚ÄúLoop Over Uno a Uno‚Äù.\n  ‚Ä¢ Agrupa los √≠tems por franja (campo `indice` si existe;\n    de lo contrario, cada bloque de 5 √≠tems forma una franja).\n  ‚Ä¢ Verifica que cada inserci√≥n tenga:\n        exito === true\n        statusCode === 200\n        falloEstado === false\n  ‚Ä¢ Devuelve un √∫nico objeto JSON con:\n        ‚Äì Resumen global.\n        ‚Äì Detalle por franja (√©xitos / fallos y celdas con error).\n===========================================================\n*/\n\n// 1) Obtener todos los √≠tems que llegan al nodo\nconst items = $input.all();\n\n// 2) Funci√≥n auxiliar para determinar el identificador de la franja\nfunction obtenerIdFranja(item, idx) {\n  // Si existe 'indice', √∫salo; de lo contrario agrupa cada 5 √≠tems\n  if (item.json && item.json.indice !== undefined && item.json.indice !== null) {\n    return String(item.json.indice).trim();\n  }\n  // +1 para que las franjas queden 1-basadas\n  return String(Math.floor(idx / 5) + 1);\n}\n\n// 3) Agrupar √≠tems por franja\nconst franjas = {};\nitems.forEach((item, idx) => {\n  const idFranja = obtenerIdFranja(item, idx);\n  if (!franjas[idFranja]) {\n    franjas[idFranja] = { id: idFranja, items: [] };\n  }\n  franjas[idFranja].items.push(item.json);\n});\n\n// 4) Analizar cada franja y construir el detalle\nconst detallesPorFranja = Object.values(franjas).map(franja => {\n  const totalOps   = franja.items.length;\n  const exitosas   = franja.items.filter(i =>\n    i.exito === true &&\n    i.statusCode === 200 &&\n    i.falloEstado === false\n  ).length;\n\n  const fallidas   = totalOps - exitosas;\n  const exitoTotal = fallidas === 0;\n\n  // Celdas con error para un diagn√≥stico claro\n  const celdasFallidas = franja.items\n    .filter(i => !(i.exito && i.statusCode === 200 && !i.falloEstado))\n    .map(i => ({\n      celdaOriginal   : i.celdaOriginal,\n      celdaInsertada  : i.celdaInsertada,\n      statusCode      : i.statusCode,\n      falloEstado     : i.falloEstado,\n      celdasDiferentes: i.celdasDiferentes,\n      mensaje         : 'Inserci√≥n fallida'\n    }));\n\n  return {\n    idFranja                : franja.id,\n    exitoFranja             : exitoTotal,\n    operacionesTotales      : totalOps,\n    operacionesExitosas     : exitosas,\n    operacionesFallidas     : fallidas,\n    porcentajeExitosas      : ((exitosas / totalOps) * 100).toFixed(2) + '%',\n    celdasFallidas\n  };\n});\n\n// 5) Resumen global\nconst operacionesTotales   = items.length;\nconst operacionesExitosas  = detallesPorFranja.reduce((sum, f) => sum + f.operacionesExitosas, 0);\nconst operacionesFallidas  = operacionesTotales - operacionesExitosas;\n\nconst franjasTotales   = detallesPorFranja.length;\nconst franjasExitosas  = detallesPorFranja.filter(f => f.exitoFranja).length;\nconst franjasFallidas  = franjasTotales - franjasExitosas;\n\n\nconst resumen = {\n  estadoGeneral              : franjasFallidas === 0 ? '√âXITO_COMPLETO' : '√âXITO_PARCIAL',\n  franjasTotales,\n  franjasExitosas,\n  franjasFallidas,\n  porcentajeFranjasExitosas  : ((franjasExitosas / franjasTotales) * 100).toFixed(2) + '%',\n  operacionesTotales,\n  operacionesExitosas,\n  operacionesFallidas,\n  porcentajeOperacionesExitosas : ((operacionesExitosas / operacionesTotales) * 100).toFixed(2) + '%',\n  detallesPorFranja\n};\n\n// 6) Devolver un √∫nico √≠tem con el resumen\nreturn [\n  {\n    json: resumen\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1888,
        6464
      ],
      "id": "9089fd79-48fa-4abb-b7b1-674cb9b7c8a8",
      "name": "Code Validar inserciones2"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "8c501d95-bdf3-4635-a037-224926c2528d",
              "leftValue": "={{ $json.estadoGeneral }}",
              "rightValue": "√âXITO_COMPLETO",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        2224,
        6464
      ],
      "id": "a310aed4-c9bd-4424-9961-2a6c3c0dc337",
      "name": "If Validar inserciones2"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.1,
      "position": [
        2528,
        6352
      ],
      "id": "180d7819-ae38-4731-810e-406fb4e1b864",
      "name": "Merge6"
    },
    {
      "parameters": {
        "numberInputs": 3
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.1,
      "position": [
        5360,
        6784
      ],
      "id": "64630b5f-7511-433e-9ada-0be4262a1c2c",
      "name": "Merge7"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        5680,
        6880
      ],
      "id": "7c4be19c-ff88-4bac-a056-f0028450e895",
      "name": "OpenAI Chat Model19",
      "credentials": {
        "openAiApi": {
          "id": "AD8kPcNVReuclASd",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "4bfbecb3-9d4f-4425-aa76-a92abc7708fb",
              "leftValue": "={{ $('Basic LLM Notificar Cancelar Cita').item.json.text.length }}",
              "rightValue": 70,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        6224,
        6848
      ],
      "id": "196af6f0-5422-42f7-bf9d-26dac107a225",
      "name": "Validaci√≥n de longitud de caracteres17"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d9c2ff70-4fd1-4b93-8571-6d0ac5a0093e",
              "name": "mensaje.ia",
              "value": "={{ $('Basic LLM Notificar Cancelar Cita').item.json.text }}",
              "type": "string"
            },
            {
              "id": "ac8a03be-0292-4735-9580-39a385945c47",
              "name": "mensaje.longitud",
              "value": "={{ $('Basic LLM Notificar Cancelar Cita').item.json.text.length }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        6528,
        6960
      ],
      "id": "82d95bed-22b8-4bff-acd2-b4fae96c64ae",
      "name": "Organiza variables del mensaje16"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        6688,
        6752
      ],
      "id": "c4a6f70e-a6a8-46b1-8203-b98e1ad39fe6",
      "name": "No Operation, do nothing21"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $('Code Respuesta Faltantes').item.json.text }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        6512,
        6752
      ],
      "id": "585b42f3-f5b8-42b1-b3cb-ea1dcd2fca80",
      "name": "HTTP Request Enviar Mensaje por WhatsApp20"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "BEGIN TRANSACTION;\n\nDELETE FROM MensajesWhatsApp\nWHERE chat_id = '{{ $('Unificaci√≥n y consistencia de datos').first().json.infoMensaje.chat_id }}'\n   OR (chat_id = 'agenteAI'\n       AND message_id IN (\n           SELECT message_id \n           FROM MensajesWhatsApp\n           WHERE chat_id = '{{ $('Unificaci√≥n y consistencia de datos').first().json.infoMensaje.chat_id }}'\n       )\n   );\n\nDELETE FROM FranjasDisponiblesTemp \nWHERE chat_id = '{{ $('Unificaci√≥n y consistencia de datos').first().json.infoMensaje.chat_id }}';\n\nCOMMIT;\n"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        4800,
        7008
      ],
      "id": "62d1ab0e-df59-4237-b783-ced9776faa84",
      "name": "Microsoft SQL Eliminar Mensajes5",
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "DECLARE @id           INT = {{ $('Code validaci√≥n de cita en malla').first().json.datosValidacion.citaBD.id }};\nDECLARE @nowBogota    DATETIME;\n\n/* Obtener fecha/hora actual en Bogot√° */\nSET @nowBogota = CONVERT(DATETIME, SYSDATETIMEOFFSET() AT TIME ZONE 'SA Pacific Standard Time');\n\n/* UPDATE para CANCELACI√ìN */\nUPDATE dbo.CitasRecepcion\nSET estado = N'CANCELADA',\n    fecha_modificacion = @nowBogota\nWHERE id = @id;\n\n/* Devolver la fila modificada */\nSELECT *\nFROM dbo.CitasRecepcion\nWHERE id = @id;"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        4432,
        6544
      ],
      "id": "0d9b69c9-9bc0-4dfa-98f3-0da14398192c",
      "name": "Microsoft SQLUpdate Cita Anterior1",
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// C√≥digo para preparar datos de CANCELACI√ìN\nconst datosValidacion = $('Code validaci√≥n de cita en malla').first().json.datosValidacion;\nconst citaBD = datosValidacion.citaBD;\nconst chatId = $('Organiza el Mensaje').first().json.infoMensaje.chat_id;\nconst historialMensajes = $('Unificaci√≥n y consistencia de datos').first().json.infoMensaje.historialMensajes;\n\nconsole.log(`Preparando datos para cancelaci√≥n de cita ID ${citaBD.id}`);\n\nconst datosCancelacion = {\n  // Datos identificadores\n  id: citaBD.id,\n  chat_id: chatId,\n  \n  // Datos de la cita cancelada\n  proveedor: citaBD.nombre,\n  orden_compra: citaBD.ordenCompra,\n  peso: citaBD.peso,\n  unidades: citaBD.unidades,\n  fecha_cita_original: citaBD.fechaCita,\n  \n  // Estado y auditor√≠a\n  estado_anterior: \"PROGRAMADA\",\n  estado_nuevo: \"CANCELADA\",\n  chat_historial: historialMensajes,\n  fecha_cancelacion: new Date().toISOString(),\n  \n  // Informaci√≥n adicional\n  ubicacion_malla: datosValidacion.ubicacion,\n  accion: \"CANCELACION\",\n  motivo: \"cancelacion_por_proveedor\"\n};\n\nconsole.log(`Cancelaci√≥n preparada: ${datosCancelacion.proveedor} - O/C: ${datosCancelacion.orden_compra}`);\n\nreturn {\n  json: datosCancelacion\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1888,
        6320
      ],
      "id": "c7448259-73e2-40f7-8a49-09a8ccc8a2eb",
      "name": "Code Datos Cancelar Cita"
    },
    {
      "parameters": {
        "promptType": "=define",
        "text": "=# Rol\nEres el asistente virtual de **Konf√≠e Logistics**.  \nTu objetivo es notificar al proveedor que su cita se **cancel√≥ exitosamente**.\n\n# Datos disponibles  \n- idCita           = {{ $('Code validaci√≥n de cita en malla').first().json.datosValidacion.citaBD.id }}  \n- ordenCompra      = {{ $('Code validaci√≥n de cita en malla').first().json.datosValidacion.citaBD.ordenCompra }}\n- proveedor        = {{ $('Code validaci√≥n de cita en malla').first().json.datosValidacion.citaBD.nombre }}\n- peso             = {{ $('Code validaci√≥n de cita en malla').first().json.datosValidacion.citaBD.peso }}\n- unidades         = {{ $('Code validaci√≥n de cita en malla').first().json.datosValidacion.citaBD.unidades }}\n- fechaCita        = {{ $('Code validaci√≥n de cita en malla').first().json.datosValidacion.citaBD.fechaCita }}\n- ubicacionMalla   = {{ $('Code validaci√≥n de cita en malla').first().json.datosValidacion.ubicacion }}\n\n# Instrucciones de redacci√≥n\n1. Mant√©n un tono profesional, comprensivo y servicial.  \n2. Empieza confirmando la cancelaci√≥n exitosa (ej: \"‚úÖ Cancelaci√≥n confirmada\" o \"üö´ Cita cancelada exitosamente\").  \n3. Muestra los **detalles de la cita cancelada** con emojis:  \n   ‚Ä¢ üîñ **Cita cancelada:** {{ $('Code validaci√≥n de cita en malla').first().json.datosValidacion.citaBD.id }}\n   ‚Ä¢ üë§ **Proveedor:** {{ $('Code validaci√≥n de cita en malla').first().json.datosValidacion.citaBD.nombre }}\n   ‚Ä¢ üè∑Ô∏è **O/C:** {{ $('Code validaci√≥n de cita en malla').first().json.datosValidacion.citaBD.ordenCompra }}\n   ‚Ä¢ üìÖ **Fecha programada:** {{ $('Code validaci√≥n de cita en malla').first().json.datosValidacion.citaBD.fechaCita }}\n   ‚Ä¢ ‚öñÔ∏è **Peso:** {{ $('Code validaci√≥n de cita en malla').first().json.datosValidacion.citaBD.peso }} kg\n   ‚Ä¢ üì¶ **Unidades:** {{ $('Code validaci√≥n de cita en malla').first().json.datosValidacion.citaBD.unidades }}\n4. Informa que si necesita **agendar una nueva cita**, puede iniciar una nueva conversaci√≥n.\n5. Agradece por haber notificado la cancelaci√≥n con anticipaci√≥n.\n6. Devuelve **solo** el mensaje final, sin encabezados.\n\n# Salida esperada (ejemplo de estilo)\n\nüö´ **Cita cancelada exitosamente**\n\nLos siguientes datos han sido cancelados en nuestro sistema:\n- üîñ **Cita:** 12345  \n- üë§ **Proveedor:** SPB COLOMBIA S.A.S  \n- üè∑Ô∏è **O/C:** ARGM47896  \n- üìÖ **Fecha:** 10 de junio de 2025  \n- ‚öñÔ∏è **Peso:** 300 kg | üì¶ **Unidades:** 600  \n\nSi necesitas agendar una nueva cita, puedes iniciar una nueva conversaci√≥n en cualquier momento.\n\n¬°Gracias por notificar la cancelaci√≥n con anticipaci√≥n! üôè"
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        5792,
        6704
      ],
      "id": "b739d92a-bd13-4435-93b4-8e281dabc7e0",
      "name": "Basic LLM Notificar Cancelar Cita",
      "alwaysOutputData": true,
      "executeOnce": true
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -1456,
        10352
      ],
      "id": "1a381459-6a1a-4e29-8bfc-5a62cb1a7470",
      "name": "OpenAI Chat Model5",
      "credentials": {
        "openAiApi": {
          "id": "AD8kPcNVReuclASd",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "b2110549-dd58-46b3-9707-dbbe0a5004f2",
              "leftValue": "={{ $('Estructuraci√≥n, de datos').item.json.mensajeParaEnviar.length }}",
              "rightValue": 70,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -640,
        10144
      ],
      "id": "4e2fb6e3-b1fe-4b7a-856e-20273f3bab1e",
      "name": "Validaci√≥n de longitud de caracteres15"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -96,
        10000
      ],
      "id": "c76e1d5e-74be-4771-be74-ec639e8a6a64",
      "name": "No Operation, do nothing19"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $('Estructuraci√≥n, de datos').item.json.mensajeParaEnviar }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -288,
        10000
      ],
      "id": "504cc79e-5cbf-4d99-aca5-9e5efb84ddaf",
      "name": "HTTP Request Enviar Mensaje por WhatsApp18"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d9c2ff70-4fd1-4b93-8571-6d0ac5a0093e",
              "name": "mensaje.ia",
              "value": "={{ $('Estructuraci√≥n, de datos').item.json.mensajeParaEnviar }}",
              "type": "string"
            },
            {
              "id": "ac8a03be-0292-4735-9580-39a385945c47",
              "name": "mensaje.longitud",
              "value": "={{ $('Estructuraci√≥n, de datos').item.json.mensajeParaEnviar.length }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        4160,
        10128
      ],
      "id": "873c2e0b-d8fe-4d4d-8533-d757a1c93868",
      "name": "Organiza variables del mensaje17"
    },
    {
      "parameters": {
        "promptType": "=define",
        "text": "=# ASISTENTE DE INFORMACI√ìN GENERAL - KONFIE IA LOGISTICS\n\nEres un asistente especializado en proporcionar informaci√≥n general sobre Konfie IA Logistics, una empresa pionera en log√≠stica inteligente en Colombia.\n\n## CONTEXTO IMPORTANTE DEL CHAT\n**PROP√ìSITO ESPEC√çFICO:** Este chat de WhatsApp est√° dise√±ado EXCLUSIVAMENTE para que los proveedores de Konfie IA Logistics puedan gestionar citas de entrega de mercanc√≠a en la bodega de la empresa. No est√° autorizado ni programado para otras gestiones comerciales, ventas, contrataciones o servicios generales.\n\n**AUDIENCIA:** Proveedores que necesitan agendar, consultar, modificar o cancelar citas de descargue de mercanc√≠a.\n\n## INFORMACI√ìN DE LA EMPRESA\n\n### Acerca de Konfie IA Logistics\n**Misi√≥n:** Redefinir los l√≠mites de lo posible en log√≠stica a trav√©s de la transparencia y la innovaci√≥n.\n**Visi√≥n:** Transformar la log√≠stica en una experiencia sin precedentes.\n**Especialidad:** Log√≠stica inteligente con tecnolog√≠a de inteligencia artificial y sistemas GPS de √∫ltima generaci√≥n.\n\n### Servicios Principales\n1. **Transporte Impo y Expo**\n   - Operaciones de transporte de carga contenerizada desde y hacia los puertos\n   - Servicios FTL (Full Truck Load), LTL (Less Than Truck Load), ITR\n\n2. **Carga Masiva Nacional**\n   - Transporte masivo nacional\n   - Servicios urbanos y nacionales\n   - Multientregas con rutas l√≥gicas\n   - Diferentes tipos de veh√≠culos\n\n3. **Distribuci√≥n Multientrega**\n   - Transporte a m√∫ltiples destinos\n   - Seguimiento en tiempo real\n   - Informaci√≥n detallada de cada entrega por separado\n\n4. **Almacenamiento**\n   - Administraci√≥n, control y seguridad de mercanc√≠a\n   - Gesti√≥n integral de inventarios\n\n5. **√öltima Milla**\n   - Distribuci√≥n a cliente final\n   - Desde centros de distribuci√≥n o almacenamiento\n   - Cualquier tipo de veh√≠culo requerido\n   - Servicio de urgencias\n\n6. **ITR (Inland Terminal Rail)**\n   - Operaci√≥n de patios en puertos\n   - Cargue y descargue de veh√≠culos\n   - Consolidaci√≥n de mercanc√≠as\n\n7. **Flotas Dedicadas**\n   - Ajuste a especificaciones t√©cnicas espec√≠ficas\n   - Flotas personalizadas seg√∫n tipo de veh√≠culo requerido\n\n### Tecnolog√≠a e Innovaci√≥n\n- **Inteligencia Artificial:** Optimizaci√≥n de rutas y procesos\n- **Sistemas GPS:** Tecnolog√≠a de √∫ltima generaci√≥n para seguimiento\n- **Seguimiento en tiempo real:** Informaci√≥n oportuna y veraz\n- **Sostenibilidad:** Pr√°cticas responsables con el medio ambiente\n\n### Cobertura\n- **Pa√≠s principal:** Colombia\n- **Alcance:** Env√≠os en toda Colombia\n- **Experiencia:** A√±os de trayectoria en el mercado log√≠stico\n\n### Sitio Web\n- **URL:** https://www.konfie.com/es_CO\n- **Redes sociales:** Facebook - Konfie IA Logistics\n\n## INSTRUCCIONES PARA RESPONDER\n\n1. **SIEMPRE mencionar el prop√≥sito del chat:** En cada respuesta, recuerda al usuario que este chat est√° destinado exclusivamente para gesti√≥n de citas de entrega de mercanc√≠a en la bodega\n2. **Respuestas claras y concisas:** Proporciona informaci√≥n directa y √∫til sobre la empresa\n3. **Tono profesional y amigable:** Mant√©n un tono cordial pero profesional\n4. **Informaci√≥n espec√≠fica:** Cuando sea posible, proporciona detalles espec√≠ficos sobre servicios de la empresa\n5. **Redirecci√≥n apropiada:** Siempre orienta hacia el prop√≥sito principal del chat (gesti√≥n de citas)\n6. **Respuestas completas:** Aseg√∫rate de abordar la consulta pero contextualizar el prop√≥sito del chat\n\n## TIPOS DE PREGUNTAS QUE PUEDES RESPONDER\n- Informaci√≥n sobre servicios y capacidades de Konfie IA Logistics\n- Ubicaci√≥n y cobertura geogr√°fica de la empresa\n- Tecnolog√≠a y diferenciadores de la empresa\n- Proceso general de trabajo de la empresa\n- Informaci√≥n corporativa de Konfie IA Logistics\n- Preguntas sobre sostenibilidad y responsabilidad ambiental de la empresa\n\n**IMPORTANTE:** Independientemente del tipo de pregunta, SIEMPRE debes contextualizar que este chat es para gesti√≥n de citas de entrega de mercanc√≠a.\n\n## MANEJO DE CONSULTAS NO RELACIONADAS CON LA EMPRESA\n\n### Si la pregunta NO tiene relaci√≥n con Konfie IA Logistics:\n**Ejemplo de respuesta:**\n\"Hola, espero que est√©s bien. Este chat pertenece a **Konfie IA Logistics**, una empresa especializada en log√≠stica inteligente que ofrece servicios como transporte de carga, distribuci√≥n, almacenamiento y √∫ltima milla en Colombia. \n\nEspec√≠ficamente, este chat est√° dise√±ado para que nuestros **proveedores puedan gestionar citas de entrega de mercanc√≠a en nuestra bodega** (agendar, consultar, modificar o cancelar citas de descargue).\n\nSi necesitas m√°s informaci√≥n sobre nuestra empresa, puedes visitar: https://www.konfie.com/es_CO\n\n¬øEn qu√© puedo ayudarte con la gesti√≥n de tu cita de entrega?\"\n\n### Si la pregunta S√ç est√° relacionada con Konfie pero NO con citas de entrega:\n**Ejemplo de respuesta:**\n\"Te comparto la informaci√≥n sobre [responder la pregunta espec√≠fica sobre la empresa]. \n\nEs importante mencionar que este chat est√° espec√≠ficamente dise√±ado para que nuestros **proveedores gestionen citas de entrega de mercanc√≠a en nuestra bodega**. Para consultas comerciales, contrataciones o otros servicios, te recomiendo contactar directamente a trav√©s de nuestro sitio web: https://www.konfie.com/es_CO\n\n¬øNecesitas ayuda con alguna gesti√≥n de cita de entrega de mercanc√≠a?\"\n\n## LIMITACIONES\n- **NO proporciones informaci√≥n de precios espec√≠ficos** (solicita que contacten directamente)\n- **NO hagas promesas sobre tiempos de entrega espec√≠ficos** sin conocer detalles\n- **NO proporciones informaci√≥n de contacto espec√≠fica** que no tengas confirmada\n- **NO gestiones consultas comerciales, ventas o contrataciones** (este chat es solo para citas de entrega)\n- **SIEMPRE contextualiza** que este chat es para gesti√≥n de citas de entrega de mercanc√≠a en la bodega\n\n---\n\n## DATOS DEL MENSAJE ACTUAL\n**Pregunta del usuario:**\n```\n{{ $json.infoMensaje.mensajeActual }}\n```\n\n**Historial de conversaci√≥n:**\n```\n{{ $json.infoMensaje.historialMensajes }}\n```\n\n**Fecha:** {{ $json.infoMensaje.fechaMensajeActual }}\n**Hora:** {{ $json.infoMensaje.horaMensajeActual }}\n\n---\n\n### INSTRUCCIONES FINALES\n1. Analiza la pregunta del usuario en el contexto del historial\n2. **SIEMPRE menciona** que este chat est√° dise√±ado para gesti√≥n de citas de entrega de mercanc√≠a por parte de proveedores\n3. Proporciona informaci√≥n √∫til y completa sobre Konfie IA Logistics cuando sea relevante\n4. Si la pregunta no est√° relacionada con la empresa, explica qu√© es Konfie IA Logistics y redirige al prop√≥sito del chat\n5. Si la pregunta est√° relacionada con la empresa pero no con citas de entrega, proporciona la informaci√≥n pero contextualiza el prop√≥sito espec√≠fico del chat\n6. Mant√©n un tono profesional pero cercano\n7. Si necesitan informaci√≥n muy espec√≠fica (precios, cotizaciones, servicios comerciales), inv√≠talos a contactar directamente a trav√©s del sitio web\n8. **SIEMPRE finaliza** preguntando si necesitan ayuda con gesti√≥n de citas de entrega\n\n**FORMATO DE RESPUESTA:**\n- Responde la consulta de manera √∫til\n- Contextualiza el prop√≥sito espec√≠fico del chat (gesti√≥n de citas de entrega de mercanc√≠a)\n- Proporciona el sitio web si es necesario: https://www.konfie.com/es_CO\n- Pregunta si necesitan ayuda con citas de entrega\n\n**EJEMPLOS DE CIERRE:**\n- \"¬øNecesitas ayuda con alguna gesti√≥n de cita de entrega de mercanc√≠a?\"\n- \"¬øEn qu√© puedo ayudarte con la gesti√≥n de tu cita de entrega?\"\n- \"¬øRequieres agendar, consultar o modificar alguna cita de entrega en nuestra bodega?\""
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        -1376,
        10144
      ],
      "id": "f41f1c02-73b2-404c-9d42-571fa6703234",
      "name": "Basic LLM CONVERSACI√ìN GENERAL"
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\nconst output = [];\n\nfor (const item of items) {\n  try {\n    // Para PREGUNTA_GENERAL, el LLM devuelve texto plano, no JSON\n    let respuestaTexto = item.json.text ? item.json.text.trim() : \"\";\n    \n    // Verificar que hay contenido\n    if (!respuestaTexto) {\n      throw new Error(\"Respuesta vac√≠a del modelo LLM\");\n    }\n    \n    // Estructurar la salida para PREGUNTA_GENERAL\n    output.push({\n      json: {\n        mensajeParaEnviar: respuestaTexto,\n        tipo: \"informacion_general\",\n        accion: \"respuesta_informativa\", \n        origen: \"intencionPreguntaGeneral\"\n      }\n    });\n    \n  } catch (error) {\n    output.push({\n      json: {\n        error: true,\n        mensaje: \"Error al interpretar la respuesta del modelo LLM\",\n        detalle: error.message,\n        contenidoOriginal: item.json.text || \"No hay contenido\",\n        tipo: \"error\",\n        accion: \"error_procesamiento\",\n        origen: \"intencionPreguntaGeneral\"\n      }\n    });\n  }\n}\n\nreturn output;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -976,
        10144
      ],
      "id": "69612fdd-fe58-4444-a99e-9b612abe8056",
      "name": "Estructuraci√≥n, de datos"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "b2110549-dd58-46b3-9707-dbbe0a5004f2",
              "leftValue": "={{ $('Estructuraci√≥n, de datos1').item.json.message.length }}",
              "rightValue": 70,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -624,
        11184
      ],
      "id": "36883086-c49e-4624-bb2f-5c150487c3cd",
      "name": "Validaci√≥n de longitud de caracteres18"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -80,
        11040
      ],
      "id": "017bcbe8-7eda-4746-beaf-9fa3209012eb",
      "name": "No Operation, do nothing22"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $('Estructuraci√≥n, de datos1').item.json.mensajeParaEnviar }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -256,
        11040
      ],
      "id": "d378c726-6b29-46b0-acd3-bb3ee45f3776",
      "name": "HTTP Request Enviar Mensaje por WhatsApp21"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d9c2ff70-4fd1-4b93-8571-6d0ac5a0093e",
              "name": "mensaje.ia",
              "value": "={{ $('Estructuraci√≥n, de datos1').item.json.message }}",
              "type": "string"
            },
            {
              "id": "ac8a03be-0292-4735-9580-39a385945c47",
              "name": "mensaje.longitud",
              "value": "={{ $('Estructuraci√≥n, de datos1').item.json.message.length }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        4192,
        11168
      ],
      "id": "45525aef-f482-45f3-8341-fe4c2437fe84",
      "name": "Organiza variables del mensaje18"
    },
    {
      "parameters": {
        "jsCode": "return [\n  {\n    json: {\n      message: `‚úÖ **ELIMINACI√ìN DE CONVERSACI√ìN EXITOSA**\n\nLa eliminaci√≥n de mensajes en la base de datos se ha completado correctamente.\n\nüîÑ **Puedes empezar una nueva conversaci√≥n**\nAhora puedes iniciar una conversaci√≥n completamente limpia con el asistente.\n\nüìÖ **Tus citas est√°n seguras**\nSi ten√≠as citas programadas, no te preocupes - las citas NO se han eliminado. Solo se elimin√≥ el historial de conversaci√≥n para hacer limpieza del sistema.\n\nüí¨ **Conversaci√≥n limpia lista**\nPuedes comenzar de nuevo y tener una experiencia fresca con el asistente. Todos tus datos importantes permanecen intactos.\n\n¬°Escribe tu mensaje para empezar una nueva conversaci√≥n!`,\n      success: true,\n      timestamp: new Date().toISOString()\n    }\n  }\n];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1376,
        10880
      ],
      "id": "845ca6f1-e1f4-420d-8b65-7577507afa83",
      "name": "Estructuraci√≥n, de datos1"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Borrar el mensaje por ID recibido desde el flujo de n8n\nDELETE FROM MensajesWhatsApp\nWHERE id = {{ $('Unificaci√≥n y consistencia de datos').first().json.infoMensaje.chat_id }};\nDBCC CHECKIDENT ('MensajesWhatsApp', RESEED, 0);\n\n-- Borrar franja disponible por ID recibido desde el flujo de n8n\nDELETE FROM FranjasDisponiblesTemp\nWHERE id = {{ $('Unificaci√≥n y consistencia de datos').first().json.infoMensaje.chat_id }};\nDBCC CHECKIDENT ('FranjasDisponiblesTemp', RESEED, 0);"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        -2336,
        11312
      ],
      "id": "d23ddc56-0fda-42df-92f5-948091ef97b5",
      "name": "Microsoft SQL Eliminaci√≥n Mensajes",
      "alwaysOutputData": true,
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      },
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "b2110549-dd58-46b3-9707-dbbe0a5004f2",
              "leftValue": "={{ $('Estructuraci√≥n, de datos2').item.json.message.length }}",
              "rightValue": 70,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -448,
        12048
      ],
      "id": "a80cba0c-8fcd-425c-b69c-3d7b49635d96",
      "name": "Validaci√≥n de longitud de caracteres19"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        112,
        11904
      ],
      "id": "bf450313-fce8-4fb8-b332-8ba350ddb149",
      "name": "No Operation, do nothing23"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $('Estructuraci√≥n, de datos2').item.json.mensajeParaEnviar }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -80,
        11904
      ],
      "id": "341f3163-fd7d-4977-ab15-17a66a05ba9b",
      "name": "HTTP Request Enviar Mensaje por WhatsApp22"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d9c2ff70-4fd1-4b93-8571-6d0ac5a0093e",
              "name": "mensaje.ia",
              "value": "={{ $('Estructuraci√≥n, de datos2').item.json.message }}",
              "type": "string"
            },
            {
              "id": "ac8a03be-0292-4735-9580-39a385945c47",
              "name": "mensaje.longitud",
              "value": "={{ $('Estructuraci√≥n, de datos2').item.json.message.length }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        4368,
        12032
      ],
      "id": "09b9d43f-6b64-4478-a000-9ec44ab825db",
      "name": "Organiza variables del mensaje19"
    },
    {
      "parameters": {
        "jsCode": "return [\n  {\n    json: {\n      message: `‚ùå **ERROR EN ELIMINACI√ìN DE CONVERSACI√ìN**\n\nLamentamos informarte que ha ocurrido un error durante la eliminaci√≥n autom√°tica de la conversaci√≥n en nuestro sistema.\n\nüîß **Acci√≥n requerida**\nPor favor, comun√≠cate directamente con el **√°rea de Bodega de Konf√≠e** para que validen manualmente qu√© sucedi√≥ con la eliminaci√≥n de datos en el sistema.\n\nüìû **Contacto necesario**\nEl equipo de Bodega deber√° revisar y procesar manualmente la eliminaci√≥n de tu conversaci√≥n para garantizar que se complete correctamente.\n\n‚ö†Ô∏è **Situaci√≥n excepcional**\nTe pedimos disculpas por este inconveniente. Este tipo de errores son muy poco frecuentes en nuestro sistema, pero requieren atenci√≥n manual para resolverse adecuadamente.\n\nüôè **Disculpas por las molestias**\nSentimos mucho las molestias causadas por esta situaci√≥n t√©cnica. El equipo de Bodega te ayudar√° a resolver esto lo antes posible.\n\nPor favor contacta a Bodega de Konf√≠e para continuar con el proceso.`,\n      success: false,\n      error: true,\n      timestamp: new Date().toISOString(),\n      action_required: \"contact_bodega\"\n    }\n  }\n];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1200,
        11744
      ],
      "id": "459261e9-31d1-49ad-9ae4-c0804ebc5f7a",
      "name": "Estructuraci√≥n, de datos2"
    }
  ],
  "pinData": {},
  "connections": {
    "Mensaje Entrada": {
      "main": [
        [
          {
            "node": "Parametrizaci√≥n",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parametrizaci√≥n": {
      "main": [
        [
          {
            "node": "Guarda el mensaje en SQL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Guarda el mensaje en SQL": {
      "main": [
        [
          {
            "node": "Recupera todos los mensajes",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Recupera todos los mensajes": {
      "main": [
        [
          {
            "node": "Count y Tiempo √öltimo Mensaje",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge de Datos",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Count y Tiempo √öltimo Mensaje": {
      "main": [
        [
          {
            "node": "If (Salida 0 - No hacer nada)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If (Salida 0 - No hacer nada)": {
      "main": [
        [
          {
            "node": "No Operation, do nothing",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "If (Salida 1 - Esperar)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If (Salida 1 - Esperar)": {
      "main": [
        [
          {
            "node": "Espera X segundos",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "If (Salida 2 - Seguir)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Espera X segundos": {
      "main": [
        [
          {
            "node": "Recupera todos los mensajes",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If (Salida 2 - Seguir)": {
      "main": [
        [
          {
            "node": "Merge de Datos",
            "type": "main",
            "index": 1
          }
        ],
        [
          {
            "node": "No Operation, do nothing1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organizaci√≥n y estructuracion de mensajes": {
      "main": [
        [
          {
            "node": "Organiza el Mensaje",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza el Mensaje": {
      "main": [
        [
          {
            "node": "Merge de Datos para session ID",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Recuperar historial Citas": {
      "main": [
        [
          {
            "node": "Remueve registros de citas duplicados",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge de Datos": {
      "main": [
        [
          {
            "node": "Organizaci√≥n y estructuracion de mensajes",
            "type": "main",
            "index": 0
          },
          {
            "node": "Recuperar historial Citas",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Remueve registros de citas duplicados": {
      "main": [
        [
          {
            "node": "Organizaci√≥n y estructuracion historial citas",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organizaci√≥n y estructuracion historial citas": {
      "main": [
        [
          {
            "node": "Organiza el historial de citas",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza el historial de citas": {
      "main": [
        [
          {
            "node": "Merge de Datos para session ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge de Datos para session ID": {
      "main": [
        [
          {
            "node": "Unificaci√≥n y consistencia de datos",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Unificaci√≥n y consistencia de datos": {
      "main": [
        [
          {
            "node": "Basic LLM CLASIFICADOR",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request MALLA DE RECIBO 2025": {
      "main": [
        [
          {
            "node": "Extract MALLA DE RECIBO 2025",
            "type": "main",
            "index": 0
          },
          {
            "node": "Extract MALLA DE RECIBO Semana Siguiente",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract MALLA DE RECIBO 2025": {
      "main": [
        [
          {
            "node": "Estructuraci√≥n, Datos, Consulta, Citas",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Malla Fija": {
      "main": [
        [
          {
            "node": "Extract Datos Proveedor",
            "type": "main",
            "index": 0
          },
          {
            "node": "Extract from Categorias",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Datos Proveedor": {
      "main": [
        [
          {
            "node": "Estructuraci√≥n, Consulta, Datos Proveedor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Estructuraci√≥n, Datos, Consulta, Citas": {
      "main": [
        [
          {
            "node": "Merge datos Excel",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Estructuraci√≥n, Consulta, Datos Proveedor": {
      "main": [
        [
          {
            "node": "Merge datos Excel",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "Merge datos Excel": {
      "main": [
        [
          {
            "node": "Unificaci√≥n y consistencia de datos1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from Categorias": {
      "main": [
        [
          {
            "node": "Estructuraci√≥n, Consulta, Datos Categorias",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Estructuraci√≥n, Consulta, Datos Categorias": {
      "main": [
        [
          {
            "node": "Merge datos Excel",
            "type": "main",
            "index": 3
          }
        ]
      ]
    },
    "Unificaci√≥n y consistencia de datos1": {
      "main": [
        [
          {
            "node": "Basic LLM Chain RECOLECCI√ìN1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM CLASIFICADOR",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM CLASIFICADOR": {
      "main": [
        [
          {
            "node": "Almacenar la intenci√≥n detectada",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model2": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM CONVERSACI√ìN (SALUDO)",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Switch basado en intenci√≥n": {
      "main": [
        [
          {
            "node": "Basic LLM CONVERSACI√ìN (SALUDO)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "HTTP Request MALLA DE RECIBO 2025",
            "type": "main",
            "index": 0
          },
          {
            "node": "HTTP Request Malla Fija",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Microsoft SQL Obtener Alternativas",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Basic LLM Extracci√≥n y Validacion de Datos Editar Cita",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Basic LLM Extracci√≥n Datos Cancelar Cita",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "HTTP Request Malla Fija1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Basic LLM CONVERSACI√ìN GENERAL",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Microsoft SQL Eliminaci√≥n Mensajes",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Almacenar la intenci√≥n detectada": {
      "main": [
        [
          {
            "node": "Switch basado en intenci√≥n",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model3": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Chain RECOLECCI√ìN",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Chain RECOLECCI√ìN": {
      "main": [
        [
          {
            "node": "Code (Formatear JSON RECOLECCI√ìN)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code (Formatear JSON RECOLECCI√ìN)": {
      "main": [
        [
          {
            "node": "IF Datos Completos",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Datos Completos": {
      "main": [
        [
          {
            "node": "Basic LLM Chain EXTRACCI√ìN_DATOS_CITA",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Code Respuesta Faltantes",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Respuesta Faltantes": {
      "main": [
        [
          {
            "node": "Setear estado conversacional",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Setear estado conversacional": {
      "main": [
        [
          {
            "node": "Validaci√≥n de longitud de caracteres",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validaci√≥n de longitud de caracteres": {
      "main": [
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Organiza variables del mensaje",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza variables del mensaje": {
      "main": [
        [
          {
            "node": "Basic LLM Separaci√≥n de Mensaje",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser": {
      "ai_outputParser": [
        [
          {
            "node": "Basic LLM Separaci√≥n de Mensaje",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model4": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Separaci√≥n de Mensaje",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp": {
      "main": [
        [
          {
            "node": "No Operation, do nothing2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Separaci√≥n de Mensaje": {
      "main": [
        [
          {
            "node": "Split Out Separa el Mensaje",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Out Separa el Mensaje": {
      "main": [
        [
          {
            "node": "Loop Over Items Recorre las Partes",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Items Recorre las Partes": {
      "main": [
        [
          {
            "node": "Merge2",
            "type": "main",
            "index": 1
          },
          {
            "node": "Merge3",
            "type": "main",
            "index": 1
          }
        ],
        [
          {
            "node": "Recuento de Caracteres",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Recuento de Caracteres": {
      "main": [
        [
          {
            "node": "Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch": {
      "main": [
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp1": {
      "main": [
        [
          {
            "node": "Microsoft SQL1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp2": {
      "main": [
        [
          {
            "node": "Microsoft SQL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp3": {
      "main": [
        [
          {
            "node": "Microsoft SQL2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Microsoft SQL": {
      "main": [
        [
          {
            "node": "Wait",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Microsoft SQL1": {
      "main": [
        [
          {
            "node": "Wait",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Microsoft SQL2": {
      "main": [
        [
          {
            "node": "Wait",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait": {
      "main": [
        [
          {
            "node": "Loop Over Items Recorre las Partes",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract MALLA DE RECIBO Semana Siguiente": {
      "main": [
        [
          {
            "node": "Estructuraci√≥n, Datos, Consulta, Citas Proxima Semana",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Estructuraci√≥n, Datos, Consulta, Citas Proxima Semana": {
      "main": [
        [
          {
            "node": "Merge datos Excel",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "OpenAI Chat Model6": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM CONSULTAR MALLA",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Malla Fija1": {
      "main": [
        [
          {
            "node": "Extract from Categorias1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from Categorias1": {
      "main": [
        [
          {
            "node": "Estructuraci√≥n, Consulta, Datos Categorias1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Estructuraci√≥n, Consulta, Datos Categorias1": {
      "main": [
        [
          {
            "node": "Basic LLM CONSULTAR MALLA",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM CONSULTAR MALLA": {
      "main": [
        [
          {
            "node": "Consistencia de datos, intenci√≥n consultar malla",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Consistencia de datos, intenci√≥n consultar malla": {
      "main": [
        [
          {
            "node": "Validaci√≥n de longitud de caracteres1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp4": {
      "main": [
        [
          {
            "node": "No Operation, do nothing3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validaci√≥n de longitud de caracteres1": {
      "main": [
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp4",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Organiza variables del mensaje1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza variables del mensaje1": {
      "main": [
        [
          {
            "node": "Basic LLM Separaci√≥n de Mensaje",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM CONVERSACI√ìN (SALUDO)": {
      "main": [
        [
          {
            "node": "Estructuraci√≥n, Consulta, Datos Categorias2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validaci√≥n de longitud de caracteres2": {
      "main": [
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp5",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Organiza variables del mensaje2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp5": {
      "main": [
        [
          {
            "node": "No Operation, do nothing4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Estructuraci√≥n, Consulta, Datos Categorias2": {
      "main": [
        [
          {
            "node": "Validaci√≥n de longitud de caracteres2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza variables del mensaje2": {
      "main": [
        [
          {
            "node": "Basic LLM Separaci√≥n de Mensaje",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model7": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Chain MOSTRAR_FRANJAS",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model8": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Chain EXTRACCI√ìN_DATOS_CITA",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Chain EXTRACCI√ìN_DATOS_CITA": {
      "main": [
        [
          {
            "node": "Microsoft SQL Guardar EXTRACCI√ìN_DATOS_CITA",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser1": {
      "ai_outputParser": [
        [
          {
            "node": "Basic LLM Chain EXTRACCI√ìN_DATOS_CITA",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Chain MOSTRAR_FRANJAS": {
      "main": [
        [
          {
            "node": "Code estandarizar respuestas MOSTRAR_FRANJAS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Microsoft SQL Guardar EXTRACCI√ìN_DATOS_CITA": {
      "main": [
        [
          {
            "node": "Code MOSTRAR_FRANJAS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code estandarizar respuestas MOSTRAR_FRANJAS": {
      "main": [
        [
          {
            "node": "Microsoft SQL Guardar MOSTRAR_FRANJAS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code MOSTRAR_FRANJAS": {
      "main": [
        [
          {
            "node": "Basic LLM Chain MOSTRAR_FRANJAS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code RECOLECCI√ìN": {
      "main": [
        [
          {
            "node": "Basic LLM Chain RECOLECCI√ìN",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validaci√≥n de longitud de caracteres3": {
      "main": [
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp6",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Organiza variables del mensaje3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp6": {
      "main": [
        [
          {
            "node": "No Operation, do nothing5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Microsoft SQL Guardar MOSTRAR_FRANJAS": {
      "main": [
        [
          {
            "node": "Validaci√≥n de longitud de caracteres3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza variables del mensaje3": {
      "main": [
        [
          {
            "node": "Basic LLM Separaci√≥n de Mensaje",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Microsoft SQL Obtener Alternativas": {
      "main": [
        [
          {
            "node": "Code Verificar Tiempo Transcurrido",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Verificar Tiempo Transcurrido": {
      "main": [
        [
          {
            "node": "If Verificar Expiraci√≥n",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model9": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Notificar No Disponibilidad",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "If Verificar Expiraci√≥n": {
      "main": [
        [
          {
            "node": "Basic LLM Notificar No Disponibilidad",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "HTTP Request MALLA DE RECIBO ",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request MALLA DE RECIBO ": {
      "main": [
        [
          {
            "node": "Extract MALLA DE RECIBO ",
            "type": "main",
            "index": 0
          },
          {
            "node": "Extract MALLA DE RECIBO Semana Siguiente1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract MALLA DE RECIBO ": {
      "main": [
        [
          {
            "node": "Estructuraci√≥n, Datos, Consulta, Citas1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Estructuraci√≥n, Datos, Consulta, Citas1": {
      "main": [
        [
          {
            "node": "Merge datos Excel1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge datos Excel1": {
      "main": [
        [
          {
            "node": "Unificaci√≥n y consistencia de datos2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract MALLA DE RECIBO Semana Siguiente1": {
      "main": [
        [
          {
            "node": "Estructuraci√≥n, Datos, Consulta, Citas Proxima Semana1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Estructuraci√≥n, Datos, Consulta, Citas Proxima Semana1": {
      "main": [
        [
          {
            "node": "Merge datos Excel1",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Unificaci√≥n y consistencia de datos2": {
      "main": [
        [
          {
            "node": "Basic LLM Validar selecci√≥n alternativa",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code VALIDACI√ìN DE CITA EN CRONOGRAMA": {
      "main": [
        [
          {
            "node": "If CREACION DE CITA EN CRONOGRAMA",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If CREACION DE CITA EN CRONOGRAMA": {
      "main": [
        [
          {
            "node": "Code (Preparar Cuerpo de Petici√≥n)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Basic LLM Notificar No Disponibilidad1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model10": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Notificar No Disponibilidad1",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Validaci√≥n de longitud de caracteres4": {
      "main": [
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp7",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Organiza variables del mensaje4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp7": {
      "main": [
        [
          {
            "node": "No Operation, do nothing6",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Notificar No Disponibilidad": {
      "main": [
        [
          {
            "node": "Validaci√≥n de longitud de caracteres4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza variables del mensaje4": {
      "main": [
        [
          {
            "node": "Basic LLM Separaci√≥n de Mensaje",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validaci√≥n de longitud de caracteres5": {
      "main": [
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp8",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Organiza variables del mensaje5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp8": {
      "main": [
        [
          {
            "node": "No Operation, do nothing7",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Notificar No Disponibilidad1": {
      "main": [
        [
          {
            "node": "Validaci√≥n de longitud de caracteres5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza variables del mensaje5": {
      "main": [
        [
          {
            "node": "Basic LLM Separaci√≥n de Mensaje",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model11": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Validar selecci√≥n alternativa",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Validar selecci√≥n alternativa": {
      "main": [
        [
          {
            "node": "Code VALIDACI√ìN DE CITA EN CRONOGRAMA",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser2": {
      "ai_outputParser": [
        [
          {
            "node": "Basic LLM Validar selecci√≥n alternativa",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Code (Preparar Cuerpo de Petici√≥n)": {
      "main": [
        [
          {
            "node": "Code Agrupar Franjas",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Agrupar Franjas": {
      "main": [
        [
          {
            "node": "Loop Over Uno a Uno",
            "type": "main",
            "index": 0
          },
          {
            "node": "Code Datos Insert Cita",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Uno a Uno": {
      "main": [
        [
          {
            "node": "Code Validar inserciones",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Code Preparar cada Insercion",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Preparar cada Insercion": {
      "main": [
        [
          {
            "node": "HTTP Request Actualizar Excel1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Actualizar Excel1": {
      "main": [
        [
          {
            "node": "Code Verificar Inserci√≥n",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Verificar Inserci√≥n": {
      "main": [
        [
          {
            "node": "If Verificar Inserci√≥n",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Verificar Inserci√≥n": {
      "main": [
        [
          {
            "node": "Wait2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "If Diferente Caso",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Diferente Caso": {
      "main": [
        [
          {
            "node": "Code Limpiar Celda Incorrecta",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "If fallo Estado",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Limpiar Celda Incorrecta": {
      "main": [
        [
          {
            "node": "HTTP Request Limpiar Celda",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If fallo Estado": {
      "main": [
        [
          {
            "node": "Code Reintentar Inserci√≥n",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "HTTP Request Limpiar Celda": {
      "main": [
        [
          {
            "node": "Code Reintentar Inserci√≥n",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Reintentar Inserci√≥n": {
      "main": [
        [
          {
            "node": "HTTP Request Reintentar Inserci√≥n",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Reintentar Inserci√≥n": {
      "main": [
        [
          {
            "node": "Code Volver a validar Inserci√≥n",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Volver a validar Inserci√≥n": {
      "main": [
        [
          {
            "node": "If Verificar Inserci√≥n 2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait2": {
      "main": [
        [
          {
            "node": "Loop Over Uno a Uno",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Verificar Inserci√≥n 2": {
      "main": [
        [
          {
            "node": "Wait3",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Wait3": {
      "main": [
        [
          {
            "node": "Loop Over Uno a Uno",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model12": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Notificar No Disponibilidad2",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Validaci√≥n de longitud de caracteres6": {
      "main": [
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp9",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Organiza variables del mensaje6",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp9": {
      "main": [
        [
          {
            "node": "No Operation, do nothing8",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Notificar No Disponibilidad2": {
      "main": [
        [
          {
            "node": "Validaci√≥n de longitud de caracteres6",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza variables del mensaje6": {
      "main": [
        [
          {
            "node": "Basic LLM Separaci√≥n de Mensaje",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Chain RECOLECCI√ìN1",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Chain RECOLECCI√ìN1": {
      "main": [
        [
          {
            "node": "Code RECOLECCI√ìN",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser3": {
      "ai_outputParser": [
        [
          {
            "node": "Basic LLM Chain RECOLECCI√ìN1",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Code Datos Insert Cita": {
      "main": [
        [
          {
            "node": "Microsoft SQL Franjas Temporales",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Validar inserciones": {
      "main": [
        [
          {
            "node": "If Validar inserciones",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Microsoft SQL Franjas Temporales": {
      "main": [
        [
          {
            "node": "Code Estructuraci√≥n de franjas temporales",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Validar inserciones": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ],
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Merge2",
            "type": "main",
            "index": 0
          },
          {
            "node": "Microsoft SQL Insertar Cita",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Estructuraci√≥n de franjas temporales": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge1": {
      "main": [
        [
          {
            "node": "Microsoft SQL Eliminar Mensajes2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Microsoft SQL Insertar Cita": {
      "main": [
        [
          {
            "node": "Basic LLM Notificar Cita Exitosa",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model13": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Notificar Cita Exitosa",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Validaci√≥n de longitud de caracteres7": {
      "main": [
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp10",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Organiza variables del mensaje7",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp10": {
      "main": [
        [
          {
            "node": "No Operation, do nothing9",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Notificar Cita Exitosa": {
      "main": [
        [
          {
            "node": "Validaci√≥n de longitud de caracteres7",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Microsoft SQL Eliminar Mensajes": {
      "main": [
        [
          {
            "node": "No Operation, do nothing10",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza variables del mensaje7": {
      "main": [
        [
          {
            "node": "Basic LLM Separaci√≥n de Mensaje",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Microsoft SQL Eliminar Mensajes2": {
      "main": [
        [
          {
            "node": "Basic LLM Notificar No Disponibilidad2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model14": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Extracci√≥n y Validacion de Datos Editar Cita",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser4": {
      "ai_outputParser": [
        [
          {
            "node": "Basic LLM Extracci√≥n y Validacion de Datos Editar Cita",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Extracci√≥n y Validacion de Datos Editar Cita": {
      "main": [
        [
          {
            "node": "Code Validaci√≥n de datos para reprogramaci√≥n de citas",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Validar si la operaci√≥n es posible (todoCorrecto)": {
      "main": [
        [
          {
            "node": "Microsoft SQL Obtener Cita",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "If Verificar si se intenta modificar datos no permitidos",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Verificar si se intenta modificar datos no permitidos": {
      "main": [
        [
          {
            "node": "Validaci√≥n de longitud de caracteres8",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "If Verificar si es un rechazo por motivos temporales",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Verificar si es un rechazo por motivos temporales": {
      "main": [
        [
          {
            "node": "Validaci√≥n de longitud de caracteres8",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "If Verificar si faltan datos",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Verificar si faltan datos": {
      "main": [
        [
          {
            "node": "Validaci√≥n de longitud de caracteres8",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Code Mensaje Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validaci√≥n de longitud de caracteres8": {
      "main": [
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp11",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Organiza variables del mensaje8",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp11": {
      "main": [
        [
          {
            "node": "No Operation, do nothing11",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Mensaje Error": {
      "main": [
        [
          {
            "node": "Validaci√≥n de longitud de caracteres8",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza variables del mensaje8": {
      "main": [
        [
          {
            "node": "Basic LLM Separaci√≥n de Mensaje",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Microsoft SQL Obtener Cita": {
      "main": [
        [
          {
            "node": "If existe cita",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If existe cita": {
      "main": [
        [
          {
            "node": "HTTP Request MALLA DE RECIBO 2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Code Mensaje Error1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Mensaje Error1": {
      "main": [
        [
          {
            "node": "Validaci√≥n de longitud de caracteres8",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge2": {
      "main": [
        [
          {
            "node": "Recupera todos los mensajes1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code integracion de mensajes": {
      "main": [
        [
          {
            "node": "Microsoft SQL Actualiza la Cita",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Recupera todos los mensajes1": {
      "main": [
        [
          {
            "node": "Code integracion de mensajes",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Microsoft SQL Actualiza la Cita": {
      "main": [
        [
          {
            "node": "Microsoft SQL Eliminar Mensajes",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Validaci√≥n de datos para reprogramaci√≥n de citas": {
      "main": [
        [
          {
            "node": "If Validar si la operaci√≥n es posible (todoCorrecto)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge3": {
      "main": [
        [
          {
            "node": "Microsoft SQL Eliminar Mensajes3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Microsoft SQL Eliminar Mensajes3": {
      "main": [
        [
          {
            "node": "No Operation, do nothing12",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request MALLA DE RECIBO 2": {
      "main": [
        [
          {
            "node": "Extract MALLA DE RECIBO 2",
            "type": "main",
            "index": 0
          },
          {
            "node": "Extract MALLA DE RECIBO Semana Siguiente3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract MALLA DE RECIBO 2": {
      "main": [
        [
          {
            "node": "Estructuraci√≥n, Datos, Consulta, Citas3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Estructuraci√≥n, Datos, Consulta, Citas3": {
      "main": [
        [
          {
            "node": "Merge datos Excel3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge datos Excel3": {
      "main": [
        [
          {
            "node": "Unificaci√≥n y consistencia de datos4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract MALLA DE RECIBO Semana Siguiente3": {
      "main": [
        [
          {
            "node": "Estructuraci√≥n, Datos, Consulta, Citas Proxima Semana3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Estructuraci√≥n, Datos, Consulta, Citas Proxima Semana3": {
      "main": [
        [
          {
            "node": "Merge datos Excel3",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Unificaci√≥n y consistencia de datos4": {
      "main": [
        [
          {
            "node": "Code Validacion de Cita en cronograma para reprogramaci√≥n",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Validacion de Cita en cronograma para reprogramaci√≥n": {
      "main": [
        [
          {
            "node": "If validacion de reprogramacion",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If validacion de reprogramacion": {
      "main": [
        [
          {
            "node": "Code (Preparar Cuerpo de Petici√≥n)1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Validaci√≥n de longitud de caracteres9",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validaci√≥n de longitud de caracteres9": {
      "main": [
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp12",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Organiza variables del mensaje9",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp12": {
      "main": [
        [
          {
            "node": "No Operation, do nothing13",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza variables del mensaje9": {
      "main": [
        [
          {
            "node": "Basic LLM Separaci√≥n de Mensaje",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code (Preparar Cuerpo de Petici√≥n)1": {
      "main": [
        [
          {
            "node": "Code Agrupar Franjas2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Agrupar Franjas2": {
      "main": [
        [
          {
            "node": "Loop Over Uno a Uno1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Code Datos Insert Cita1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Uno a Uno1": {
      "main": [
        [
          {
            "node": "Code Validar inserciones1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Code Preparar cada Insercion1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Preparar cada Insercion1": {
      "main": [
        [
          {
            "node": "HTTP Request Actualizar Excel",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Actualizar Excel": {
      "main": [
        [
          {
            "node": "Code Verificar Inserci√≥n1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Verificar Inserci√≥n1": {
      "main": [
        [
          {
            "node": "If Verificar Inserci√≥n1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Verificar Inserci√≥n1": {
      "main": [
        [
          {
            "node": "Wait4",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "If Diferente Caso1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Diferente Caso1": {
      "main": [
        [
          {
            "node": "Code Limpiar Celda Incorrecta1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "If fallo Estado1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Limpiar Celda Incorrecta1": {
      "main": [
        [
          {
            "node": "HTTP Request Limpiar Celda1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Limpiar Celda1": {
      "main": [
        [
          {
            "node": "Code Reintentar Inserci√≥n1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If fallo Estado1": {
      "main": [
        [
          {
            "node": "Code Reintentar Inserci√≥n1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Merge5",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "Code Reintentar Inserci√≥n1": {
      "main": [
        [
          {
            "node": "HTTP Request Reintentar Inserci√≥n1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Reintentar Inserci√≥n1": {
      "main": [
        [
          {
            "node": "Code Volver a validar Inserci√≥n1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Volver a validar Inserci√≥n1": {
      "main": [
        [
          {
            "node": "If Verificar Inserci√≥n ",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Verificar Inserci√≥n ": {
      "main": [
        [
          {
            "node": "Wait5",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Merge5",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Wait4": {
      "main": [
        [
          {
            "node": "Loop Over Uno a Uno1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait5": {
      "main": [
        [
          {
            "node": "Loop Over Uno a Uno1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model15": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Notificar No Disponibilidad3",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Notificar No Disponibilidad3": {
      "main": [
        [
          {
            "node": "Validaci√≥n de longitud de caracteres10",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validaci√≥n de longitud de caracteres10": {
      "main": [
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp13",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Organiza variables del mensaje10",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp13": {
      "main": [
        [
          {
            "node": "No Operation, do nothing14",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Validar inserciones1": {
      "main": [
        [
          {
            "node": "If Validar inserciones1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Datos Insert Cita1": {
      "main": [
        [
          {
            "node": "Merge4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Validar inserciones1": {
      "main": [
        [
          {
            "node": "Merge4",
            "type": "main",
            "index": 1
          }
        ],
        [
          {
            "node": "Merge5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge4": {
      "main": [
        [
          {
            "node": "Microsoft SQLUpdate Cita Anterior",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge5": {
      "main": [
        [
          {
            "node": "Microsoft SQL Eliminar Mensajes4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Microsoft SQL Insertar Cita1": {
      "main": [
        [
          {
            "node": "Basic LLM Notificar Cita Exitosa1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model16": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Notificar Cita Exitosa1",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Validaci√≥n de longitud de caracteres11": {
      "main": [
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp14",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Organiza variables del mensaje11",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp14": {
      "main": [
        [
          {
            "node": "No Operation, do nothing15",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Notificar Cita Exitosa1": {
      "main": [
        [
          {
            "node": "Validaci√≥n de longitud de caracteres11",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Microsoft SQL Eliminar Mensajes4": {
      "main": [
        [
          {
            "node": "Basic LLM Notificar No Disponibilidad3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Microsoft SQLUpdate Cita Anterior": {
      "main": [
        [
          {
            "node": "Microsoft SQL Insertar Cita1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza variables del mensaje11": {
      "main": [
        [
          {
            "node": "Basic LLM Separaci√≥n de Mensaje",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza variables del mensaje10": {
      "main": [
        [
          {
            "node": "Basic LLM Separaci√≥n de Mensaje",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model17": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Extracci√≥n Datos Cancelar Cita",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser5": {
      "ai_outputParser": [
        [
          {
            "node": "Basic LLM Extracci√≥n Datos Cancelar Cita",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Extracci√≥n Datos Cancelar Cita": {
      "main": [
        [
          {
            "node": "Code Validaci√≥n datos para cancelaci√≥n de citas",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Validaci√≥n datos para cancelaci√≥n de citas": {
      "main": [
        [
          {
            "node": "If Validar si los datos est√°n completos",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Validar si los datos est√°n completos": {
      "main": [
        [
          {
            "node": "Microsoft SQL Obtener Cita para Cancelar",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Validaci√≥n de longitud de caracteres12",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validaci√≥n de longitud de caracteres12": {
      "main": [
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp15",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Organiza variables del mensaje12",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp15": {
      "main": [
        [
          {
            "node": "No Operation, do nothing16",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza variables del mensaje12": {
      "main": [
        [
          {
            "node": "Basic LLM Separaci√≥n de Mensaje",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Microsoft SQL Obtener Cita para Cancelar": {
      "main": [
        [
          {
            "node": "If cita para cancelar",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If cita para cancelar": {
      "main": [
        [
          {
            "node": "HTTP Request MALLA DE RECIBO 3",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Code respuesta cita no programada",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validaci√≥n de longitud de caracteres13": {
      "main": [
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp16",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Organiza variables del mensaje13",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp16": {
      "main": [
        [
          {
            "node": "No Operation, do nothing17",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code respuesta cita no programada": {
      "main": [
        [
          {
            "node": "Validaci√≥n de longitud de caracteres13",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza variables del mensaje13": {
      "main": [
        [
          {
            "node": "Basic LLM Separaci√≥n de Mensaje",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request MALLA DE RECIBO 3": {
      "main": [
        [
          {
            "node": "Extract MALLA DE RECIBO 3",
            "type": "main",
            "index": 0
          },
          {
            "node": "Extract MALLA DE RECIBO Semana Siguiente4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract MALLA DE RECIBO 3": {
      "main": [
        [
          {
            "node": "Estructuraci√≥n, Datos, Consulta, Citas4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Estructuraci√≥n, Datos, Consulta, Citas4": {
      "main": [
        [
          {
            "node": "Merge datos Excel4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge datos Excel4": {
      "main": [
        [
          {
            "node": "Unificaci√≥n y consistencia de datos5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract MALLA DE RECIBO Semana Siguiente4": {
      "main": [
        [
          {
            "node": "Estructuraci√≥n, Datos, Consulta, Citas Proxima Semana4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Estructuraci√≥n, Datos, Consulta, Citas Proxima Semana4": {
      "main": [
        [
          {
            "node": "Merge datos Excel4",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Unificaci√≥n y consistencia de datos5": {
      "main": [
        [
          {
            "node": "Code validaci√≥n de cita en malla",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code validaci√≥n de cita en malla": {
      "main": [
        [
          {
            "node": "If validar cita existe",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validaci√≥n de longitud de caracteres14": {
      "main": [
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp17",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Organiza variables del mensaje14",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp17": {
      "main": [
        [
          {
            "node": "No Operation, do nothing18",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If validar cita existe": {
      "main": [
        [
          {
            "node": "Code (Preparar Cuerpo de Petici√≥n)2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Validaci√≥n de longitud de caracteres14",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza variables del mensaje14": {
      "main": [
        [
          {
            "node": "Basic LLM Separaci√≥n de Mensaje",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code (Preparar Cuerpo de Petici√≥n)2": {
      "main": [
        [
          {
            "node": "Code Agrupar Franjas3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Agrupar Franjas3": {
      "main": [
        [
          {
            "node": "Loop Over Uno a Uno2",
            "type": "main",
            "index": 0
          },
          {
            "node": "Code Datos Cancelar Cita",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Uno a Uno2": {
      "main": [
        [
          {
            "node": "Code Validar inserciones2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Code Preparar cada Insercion2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Preparar cada Insercion2": {
      "main": [
        [
          {
            "node": "HTTP Request Actualizar Excel2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Actualizar Excel2": {
      "main": [
        [
          {
            "node": "Code Verificar Inserci√≥n2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Verificar Inserci√≥n2": {
      "main": [
        [
          {
            "node": "If Verificar Inserci√≥n2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Verificar Inserci√≥n2": {
      "main": [
        [
          {
            "node": "Wait6",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "If Diferente Caso2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Diferente Caso2": {
      "main": [
        [
          {
            "node": "Code Limpiar Celda Incorrecta2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "If fallo Estado2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Limpiar Celda Incorrecta2": {
      "main": [
        [
          {
            "node": "HTTP Request Limpiar Celda2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Limpiar Celda2": {
      "main": [
        [
          {
            "node": "Code Reintentar Inserci√≥n2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If fallo Estado2": {
      "main": [
        [
          {
            "node": "Code Reintentar Inserci√≥n2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Merge7",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "Code Reintentar Inserci√≥n2": {
      "main": [
        [
          {
            "node": "HTTP Request Reintentar Inserci√≥n2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Reintentar Inserci√≥n2": {
      "main": [
        [
          {
            "node": "Code Volver a validar Inserci√≥n2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Volver a validar Inserci√≥n2": {
      "main": [
        [
          {
            "node": "If Verificar Inserci√≥n 1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Verificar Inserci√≥n 1": {
      "main": [
        [
          {
            "node": "Wait7",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Merge7",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Wait6": {
      "main": [
        [
          {
            "node": "Loop Over Uno a Uno2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait7": {
      "main": [
        [
          {
            "node": "Loop Over Uno a Uno2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model18": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Notificar No Disponibilidad4",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Notificar No Disponibilidad4": {
      "main": [
        [
          {
            "node": "Validaci√≥n de longitud de caracteres16",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validaci√≥n de longitud de caracteres16": {
      "main": [
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp19",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Organiza variables del mensaje15",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp19": {
      "main": [
        [
          {
            "node": "No Operation, do nothing20",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Validar inserciones2": {
      "main": [
        [
          {
            "node": "If Validar inserciones2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Validar inserciones2": {
      "main": [
        [
          {
            "node": "Merge6",
            "type": "main",
            "index": 1
          }
        ],
        [
          {
            "node": "Merge7",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge6": {
      "main": [
        [
          {
            "node": "Microsoft SQLUpdate Cita Anterior1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge7": {
      "main": [
        [
          {
            "node": "Microsoft SQL Eliminar Mensajes5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model19": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Notificar Cancelar Cita",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Validaci√≥n de longitud de caracteres17": {
      "main": [
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp20",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Organiza variables del mensaje16",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp20": {
      "main": [
        [
          {
            "node": "No Operation, do nothing21",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Microsoft SQL Eliminar Mensajes5": {
      "main": [
        [
          {
            "node": "Basic LLM Notificar No Disponibilidad4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Microsoft SQLUpdate Cita Anterior1": {
      "main": [
        [
          {
            "node": "Basic LLM Notificar Cancelar Cita",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Datos Cancelar Cita": {
      "main": [
        [
          {
            "node": "Merge6",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Notificar Cancelar Cita": {
      "main": [
        [
          {
            "node": "Validaci√≥n de longitud de caracteres17",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza variables del mensaje15": {
      "main": [
        [
          {
            "node": "Basic LLM Separaci√≥n de Mensaje",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza variables del mensaje16": {
      "main": [
        [
          {
            "node": "Basic LLM Separaci√≥n de Mensaje",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model5": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM CONVERSACI√ìN GENERAL",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Validaci√≥n de longitud de caracteres15": {
      "main": [
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp18",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Organiza variables del mensaje17",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp18": {
      "main": [
        [
          {
            "node": "No Operation, do nothing19",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM CONVERSACI√ìN GENERAL": {
      "main": [
        [
          {
            "node": "Estructuraci√≥n, de datos",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Estructuraci√≥n, de datos": {
      "main": [
        [
          {
            "node": "Validaci√≥n de longitud de caracteres15",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza variables del mensaje17": {
      "main": [
        [
          {
            "node": "Basic LLM Separaci√≥n de Mensaje",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validaci√≥n de longitud de caracteres18": {
      "main": [
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp21",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Organiza variables del mensaje18",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp21": {
      "main": [
        [
          {
            "node": "No Operation, do nothing22",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Estructuraci√≥n, de datos1": {
      "main": [
        [
          {
            "node": "Validaci√≥n de longitud de caracteres18",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Microsoft SQL Eliminaci√≥n Mensajes": {
      "main": [
        [
          {
            "node": "Estructuraci√≥n, de datos1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Estructuraci√≥n, de datos2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza variables del mensaje18": {
      "main": [
        [
          {
            "node": "Basic LLM Separaci√≥n de Mensaje",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validaci√≥n de longitud de caracteres19": {
      "main": [
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp22",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Organiza variables del mensaje19",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp22": {
      "main": [
        [
          {
            "node": "No Operation, do nothing23",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Estructuraci√≥n, de datos2": {
      "main": [
        [
          {
            "node": "Validaci√≥n de longitud de caracteres19",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza variables del mensaje19": {
      "main": [
        [
          {
            "node": "Basic LLM Separaci√≥n de Mensaje",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "93adf8af-0486-4d56-89fe-3007fe34c350",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "1eb0088037a07ba7867394f235324ea67bbb89bb030f5b44da808ec979ca0c6d"
  },
  "id": "wwZsz0zm6wDkZCx0",
  "tags": []
}