{
  "name": "My workflow",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "b53e7f9a-75f6-4090-a956-97c8fa707895",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -50224,
        -7408
      ],
      "id": "eccb9b65-a419-4ff1-96ae-75fc95b693f3",
      "name": "Mensaje Entrada",
      "webhookId": "b53e7f9a-75f6-4090-a956-97c8fa707895"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "42be7c60-3517-4559-9891-c6e774f76888",
              "name": "message.id",
              "value": "={{ $json.body.data.key.id }}",
              "type": "string"
            },
            {
              "id": "4379efd4-3f5c-418c-8126-c3ce1e18b7a3",
              "name": "message.contenido",
              "value": "={{ $json.body.data.message.conversation }}",
              "type": "string"
            },
            {
              "id": "08d830cc-5846-41e2-b2f5-d2e6dbbb37e2",
              "name": "message.date",
              "value": "={{ new Date(Date.now() - 5*60*60*1000).toISOString() }}",
              "type": "string"
            },
            {
              "id": "51f87c32-fe22-430b-9a43-04f45e9cc969",
              "name": "message.chat.id",
              "value": "={{ $json.body.data.key.remoteJid }}",
              "type": "string"
            },
            {
              "id": "18719256-6e5b-4a97-91c3-9a4e9c440997",
              "name": "message.chat.instance",
              "value": "={{ $json.body.instance }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -50016,
        -7408
      ],
      "id": "04c84296-6052-4104-92bc-16ec1e056a7b",
      "name": "Parametrización"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO MensajesWhatsApp (message_id, contenido, fecha, chat_id, instance)\nVALUES ('{{ $json.message.id }}',\n        '{{ $json.message.contenido }}',\n        FORMAT(CONVERT(datetime, '{{ $json.message.date }}', 127), 'yyyy-MM-dd HH:mm:ss'),\n        '{{ $json[\"message\"][\"chat\"][\"id\"] }}',\n        '{{ $json[\"message\"][\"chat\"][\"instance\"] }}');\n"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        -49808,
        -7408
      ],
      "id": "df197253-ed37-485d-8ab1-41fe3d6c7ba2",
      "name": "Guarda el mensaje en SQL",
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT * FROM MensajesWhatsApp\nWHERE chat_id = '{{ $('Parametrización').item.json.message.chat.id }}'\n   OR (chat_id = 'agenteAI' AND message_id IN (\n       SELECT message_id \n       FROM MensajesWhatsApp \n       WHERE chat_id = '{{ $('Parametrización').item.json.message.chat.id }}'\n   ))\nORDER BY fecha ASC;\n"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        -49568,
        -7408
      ],
      "id": "3ae0a10b-7cd0-4991-b4bb-ad3b28e3dfbb",
      "name": "Recupera todos los mensajes",
      "alwaysOutputData": true,
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Obtener los mensajes del input\nconst mensajes = $input.all();\n\n// Asegurar que haya mensajes antes de continuar\nif (mensajes.length === 0) {\n  return [{ mensajeCount: 0, tiempoUltimoMensaje: null }];\n}\n\n// Obtener la fecha del último mensaje\nconst fechaMensajeStr = mensajes[mensajes.length - 1].json.fecha; // Asegúrate de que 'fecha' es el nombre correcto\nconst fechaMensajeDate = new Date(fechaMensajeStr); // Convertir a Date\n\n// Obtener la fecha y hora actual\nconst fechaActual = new Date();\n\n// Calcular la diferencia en segundos\nconst diferenciaSegundos = Math.floor((fechaActual.getTime() - fechaMensajeDate.getTime()) / 1000);\n\n// Retornar datos para el nodo Switch\nreturn [{\n  mensajeCount: mensajes.length,\n  tiempoUltimoMensaje: diferenciaSegundos\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -49376,
        -7024
      ],
      "id": "478b48eb-f66e-4b1e-b920-9993699b74e3",
      "name": "Count y Tiempo Último Mensaje"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "81c77bfb-8151-4c31-9380-784ae2c20f02",
              "leftValue": "={{ $json.mensajeCount }}",
              "rightValue": 1,
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            },
            {
              "id": "e049aa85-8cb2-483a-814e-0b17613927a5",
              "leftValue": "={{ $json.tiempoUltimoMensaje }}",
              "rightValue": 5,
              "operator": {
                "type": "number",
                "operation": "lte"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -49152,
        -7200
      ],
      "id": "c1be7f14-0991-4e55-a79b-411bb486dd26",
      "name": "If (Salida 0 - No hacer nada)"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "e327003b-210e-4d36-a17d-6550957ca66c",
              "leftValue": "={{ $json.tiempoUltimoMensaje }}",
              "rightValue": 5,
              "operator": {
                "type": "number",
                "operation": "gte"
              }
            },
            {
              "id": "de6f6e64-1e10-434c-8bc5-303d98bdb3ac",
              "leftValue": "={{ $json.tiempoUltimoMensaje }}",
              "rightValue": 15,
              "operator": {
                "type": "number",
                "operation": "lte"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -48928,
        -7088
      ],
      "id": "dfec5ede-330f-4499-9482-95d9f1a79c35",
      "name": "If (Salida 1 - Esperar)"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "143c51ad-50d4-44ee-a050-61e4ffcf2eb3",
              "leftValue": "={{ $json.tiempoUltimoMensaje }}",
              "rightValue": 15,
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -48736,
        -6912
      ],
      "id": "6c28077a-320a-4d6c-85b4-0cb42eb92fa2",
      "name": "If (Salida 2 - Seguir)"
    },
    {
      "parameters": {
        "amount": "={{$json[\"tiempoUltimoMensaje\"]}}"
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        -48064,
        -6848
      ],
      "id": "29fcaf1d-865b-44c6-ab75-a21584658d79",
      "name": "Espera X segundos",
      "webhookId": "9c8f7481-324f-499e-9136-938ad85f693c"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -48928,
        -7280
      ],
      "id": "8bd94520-cbcb-427b-8dc6-2062005c8b55",
      "name": "No Operation, do nothing"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -48496,
        -6848
      ],
      "id": "a9c9277f-1c4e-491e-81eb-c3517183ea7e",
      "name": "No Operation, do nothing1"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "8086b05f-a632-494c-a9c3-d1b74bc1a244",
              "name": "infoMensaje.chat_id",
              "value": "={{ $('Merge de Datos').first().json.chat_id }}",
              "type": "string"
            },
            {
              "id": "5d101db7-b90d-4464-8da5-68b82779fc85",
              "name": "infoMensaje.historialMensajes",
              "value": "={{ $json.historialMensajes }}",
              "type": "string"
            },
            {
              "id": "5c95d18f-1470-4096-83a5-f0a55234d1e5",
              "name": "infoMensaje.count",
              "value": "={{ $('If (Salida 2 - Seguir)').first().json.mensajeCount }}",
              "type": "string"
            },
            {
              "id": "0c776e32-ba1b-41b2-86f4-33f19d7c06dc",
              "name": "infoMensaje.tiempoUltimoMensaje",
              "value": "={{ $('If (Salida 2 - Seguir)').first().json.tiempoUltimoMensaje }}",
              "type": "string"
            },
            {
              "id": "d86a9164-3da9-4e08-872b-c05816a4ef92",
              "name": "infoMensaje.mensajeActual",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.message.conversation }}",
              "type": "string"
            },
            {
              "id": "530fe022-b6aa-4e79-adbb-c4f32edd8ccb",
              "name": "infoMensaje.fechaMensajeActual",
              "value": "={{ $('Parametrización').first().json.message.date.split('T')[0] }}",
              "type": "string"
            },
            {
              "id": "c51a7336-1fd0-40aa-a1b6-7afab57af93c",
              "name": "infoMensaje.horaMensajeActual",
              "value": "={{ \n  new Date($('Parametrización').first().json.message.date)\n    .toLocaleTimeString(\"es-CO\", { \n      hour: '2-digit', \n      minute: '2-digit', \n      hour12: true,\n      timeZone: 'UTC' \n    }) \n}}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -47808,
        -7040
      ],
      "id": "8c86a4d8-d696-4898-bf29-fbdb09022cc2",
      "name": "Organiza el Mensaje"
    },
    {
      "parameters": {
        "jsCode": "// Obtener todos los datos de entrada\nconst datosEntrada = $input.all();\n\n// Filtrar solo los objetos que contienen un mensaje, descartando estadísticas\nconst mensajes = datosEntrada.filter(item => item.json.message_id);\n\n// Función para convertir la fecha a formato Colombia (UTC-5) en formato de 12 horas\nfunction convertirHoraColombia(fechaUTC) {\n    if (!fechaUTC) return \"[Hora no encontrada]\";\n    let fecha = new Date(fechaUTC);\n    fecha.setHours(fecha.getHours()); // Convertir a UTC-5\n    return fecha.toLocaleTimeString('es-CO', { hour: '2-digit', minute: '2-digit', hour12: true });\n}\n\n// Función para dar formato de fecha en español sin hora\nfunction formatearFecha(fechaUTC) {\n    if (!fechaUTC) return \"[Fecha no encontrada]\";\n    let fecha = new Date(fechaUTC);\n    return fecha.toLocaleDateString('es-CO', { year: 'numeric', month: 'long', day: 'numeric' });\n}\n\n// Estructurar los mensajes en un formato claro para el agente IA\nconst mensajesEstructurados = mensajes.map((mensaje, index) => {\n    let fecha = mensaje.json.fecha ? formatearFecha(mensaje.json.fecha) : \"[Fecha no encontrada]\";\n    let hora = mensaje.json.fecha ? convertirHoraColombia(mensaje.json.fecha) : \"[Hora no encontrada]\";\n    let contenido = mensaje.json.contenido || \"[Sin contenido]\";\n    \n    // Determinar si el mensaje es del usuario o del agente IA\n    let remitente = mensaje.json.chat_id === 'agenteAI' ? 'El Agente ChatBot IA dice:' : 'El usuario dice:';\n    \n    return `Mensaje ${index + 1} enviado el ${fecha} a las ${hora}.\\n${remitente} \"${contenido}\".`;\n});\n\n// Unir todos los mensajes en un solo texto estructurado\nconst historialMensajes = mensajesEstructurados.join('\\n\\n');\n\n// Retornar los datos estructurados\nreturn [{ historialMensajes }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -48064,
        -7040
      ],
      "id": "c824dd3e-d816-423a-8b4e-4cbdc050a8a6",
      "name": "Organización y estructuracion de mensajes"
    },
    {
      "parameters": {
        "content": "# 📩 Agrupa todos los mensajes del usuario\n\n## 🔹 Este flujo se encarga de recibir y almacenar los mensajes enviados por el usuario, recuperar el historial completo de la conversación, estructurar la información de manera clara y organizada, y enviarla al siguiente proceso para su interpretación y respuesta.\n",
        "height": 1000,
        "width": 3480,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -50304,
        -7600
      ],
      "typeVersion": 1,
      "id": "4c7e608a-30af-40a9-aef3-0da24ae7cb52",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT DISTINCT * FROM CitasRecepcion\nWHERE chat_id = '{{ $json.chat_id }}'\nAND (estado = 'PROGRAMADA' OR estado = 'REPROGRAMADA')\nORDER BY fecha_creacion ASC;"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        -48208,
        -7392
      ],
      "id": "33ae6717-4c91-4394-b006-038242b7ae33",
      "name": "Recuperar historial Citas",
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        -48496,
        -7392
      ],
      "id": "39a5d870-3cd3-4859-bc10-a6261230dbbb",
      "name": "Merge de Datos"
    },
    {
      "parameters": {
        "jsCode": "// Obtener todos los elementos del historial de citas\nconst historialCitas = $input.all();\n\n// Verificar si hay datos\nif (!historialCitas || historialCitas.length === 0) {\n  return [{ historialCitasFormateado: \"No hay historial de citas disponible\" }];\n}\n\n// Función para obtener valor seguro\nfunction getValorSeguro(objeto, propiedad) {\n  try {\n    // Intenta acceder directamente\n    if (objeto && objeto[propiedad] !== undefined && objeto[propiedad] !== null) {\n      return objeto[propiedad];\n    }\n    \n    // Intenta acceder a través de json\n    if (objeto && objeto.json && objeto.json[propiedad] !== undefined && objeto.json[propiedad] !== null) {\n      return objeto.json[propiedad];\n    }\n    \n    return 'N/A';\n  } catch (error) {\n    return 'N/A';\n  }\n}\n\n// Función para formatear fecha\nfunction formatearFecha(fechaStr) {\n  if (!fechaStr || fechaStr === 'N/A') return 'N/A';\n  \n  try {\n    const fecha = new Date(fechaStr);\n    return fecha.toLocaleDateString('es-CO', { year: 'numeric', month: 'long', day: 'numeric' });\n  } catch (error) {\n    return fechaStr;\n  }\n}\n\n// Estructurar las citas en un formato claro\nconst citasEstructuradas = historialCitas.map((cita, index) => {\n  // Obtener valores de forma segura\n  const id = getValorSeguro(cita, 'id');\n  const chatId = getValorSeguro(cita, 'chat_id');\n  const nombre = getValorSeguro(cita, 'nombre');\n  const ordenCompra = getValorSeguro(cita, 'orden_compra');\n  const peso = getValorSeguro(cita, 'peso');\n  const unidades = getValorSeguro(cita, 'unidades');\n  const fechaCita = formatearFecha(getValorSeguro(cita, 'fecha_cita'));\n  const estado = getValorSeguro(cita, 'estado');\n  const fechaCreacion = formatearFecha(getValorSeguro(cita, 'fecha_creacion'));\n  const chatHistorial = getValorSeguro(cita, 'chat_historial');\n  \n  // Crear texto estructurado para esta cita\n  let citaTexto = `CITA #${index + 1}\\n`;\n  citaTexto += `ID: ${id}\\n`;\n  citaTexto += `Chat ID: ${chatId}\\n`;\n  citaTexto += `Nombre: ${nombre}\\n`;\n  citaTexto += `Orden de compra: ${ordenCompra}\\n`;\n  citaTexto += `Peso: ${peso}\\n`;\n  citaTexto += `Unidades: ${unidades}\\n`;\n  citaTexto += `Fecha de cita: ${fechaCita}\\n`;\n  citaTexto += `Estado: ${estado}\\n`;\n  citaTexto += `Fecha de creación: ${fechaCreacion}\\n`;\n  \n  // Agregar historial de chat si existe\n  if (chatHistorial && chatHistorial !== 'N/A') {\n    citaTexto += `Chat: ${chatHistorial}\\n`;\n  }\n  \n  return citaTexto;\n});\n\n// Unir todas las citas en un solo texto estructurado\nconst historialCitasFormateado = citasEstructuradas.join('\\n\\n');\n\n// Retornar un objeto simple con el texto formateado\nreturn [{ historialCitasFormateado }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -47776,
        -7392
      ],
      "id": "b072aef7-d038-4d9a-816f-ba8f30b30805",
      "name": "Organización y estructuracion historial citas"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.removeDuplicates",
      "typeVersion": 2,
      "position": [
        -47984,
        -7392
      ],
      "id": "a7778dac-ede4-4c17-a96e-ad48f4ae5583",
      "name": "Remueve registros de citas duplicados"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "51f49645-ea1d-4717-8195-837dbb674f73",
              "name": "infoMensajecita.chat_id",
              "value": "={{ $('Remueve registros de citas duplicados').first().json.chat_id }}",
              "type": "string"
            },
            {
              "id": "ae0619ec-87bc-47d7-9b8a-d7b629bbea4a",
              "name": "infoMensajecita.historialCitas",
              "value": "={{ $json.historialCitasFormateado }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -47552,
        -7392
      ],
      "id": "1d0a36f0-da0c-4e5c-8f6e-516f553fb884",
      "name": "Organiza el historial de citas"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        -47248,
        -7168
      ],
      "id": "2bf340da-cbe1-4ebd-8857-9cb58b60eb60",
      "name": "Merge de Datos para session ID"
    },
    {
      "parameters": {
        "jsCode": "const output = {};\n\n// Variables auxiliares para garantizar la estructura fija\noutput.infoMensajecita = { chat_id: \"\", historialCitas: \"\" };\noutput.infoMensaje = { \n    chat_id: \"\", \n    historialMensajes: \"\", \n    count: \"0\", \n    tiempoUltimoMensaje: \"0\", \n    mensajeActual: \"\", \n    fechaMensajeActual: \"\", \n    horaMensajeActual: \"\" \n};\n\n// Recorremos los items de entrada y asignamos los datos si existen\nfor (const item of $input.all()) {\n    if (item.json.infoMensajecita) {\n        output.infoMensajecita = item.json.infoMensajecita;\n    }\n    if (item.json.infoMensaje) {\n        output.infoMensaje = item.json.infoMensaje;\n    }\n}\n\n// Generar Session ID basado en los datos disponibles\noutput.sessionId = output.infoMensajecita.chat_id || output.infoMensaje.chat_id || null;\n\n// Calcular la semana actual\nconst fechaActual = new Date();\nconst inicioAno = new Date(fechaActual.getFullYear(), 0, 1);\nconst diff = fechaActual - inicioAno;\nconst diasDesdeInicio = Math.floor(diff / (1000 * 60 * 60 * 24));\nconst numeroSemana = Math.ceil((diasDesdeInicio + inicioAno.getDay()) / 7);\noutput.hojaSeleccionada = `SEMANA ${numeroSemana}`;\n\n// Devolver un solo objeto con todos los datos unificados\nreturn [{ json: output }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -47008,
        -7168
      ],
      "id": "eba8fd75-b303-4355-bc95-1aae92904c0c",
      "name": "Unificación y consistencia de datos"
    },
    {
      "parameters": {
        "url": "https://graph.microsoft.com/v1.0/sites/a592f886-4560-4e62-9646-1eee7add7abe/drives/b!hviSpWBFYk6WRh7uet16vnNAUYuuQRlGj3ZyS9kSvGVZ4DSg6c5MRqYYm2MdAER8/items/01PPLUUYXY5E2GK3SJ25EZLJPUYJ43H3ME/content",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "microsoftOAuth2Api",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "file",
              "outputPropertyName": "ExcelMallaRecibido2025"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -39872,
        -10592
      ],
      "id": "6e10a347-938c-423c-b887-abe18cbb1add",
      "name": "HTTP Request MALLA DE RECIBO 2025",
      "credentials": {
        "microsoftOAuth2Api": {
          "id": "mh8Z8hxFvd7LDO8D",
          "name": "CuentaMy SharePoint App Desarrollador1 Konfie "
        }
      }
    },
    {
      "parameters": {
        "operation": "xlsx",
        "binaryPropertyName": "ExcelMallaRecibido2025",
        "options": {
          "sheetName": "={{ $('Unificación y consistencia de datos').item.json.hojaSeleccionada }}"
        }
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -39616,
        -10704
      ],
      "id": "3ed45af2-d54e-4579-b493-a134438a1ff4",
      "name": "Extract MALLA DE RECIBO 2025"
    },
    {
      "parameters": {
        "url": "https://graph.microsoft.com/v1.0/drives/b!hviSpWBFYk6WRh7uet16vnNAUYuuQRlGj3ZyS9kSvGVZ4DSg6c5MRqYYm2MdAER8/items/01PPLUUYTWY3753ZJ6ERAZ6LQBYUR2JOTY/content",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "microsoftOAuth2Api",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "file",
              "outputPropertyName": "MallaFija"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -39872,
        -10208
      ],
      "id": "7e5ce412-0de1-460b-8ca1-fa966ed056f5",
      "name": "HTTP Request Malla Fija",
      "credentials": {
        "microsoftOAuth2Api": {
          "id": "mh8Z8hxFvd7LDO8D",
          "name": "CuentaMy SharePoint App Desarrollador1 Konfie "
        }
      }
    },
    {
      "parameters": {
        "operation": "xlsx",
        "binaryPropertyName": "MallaFija",
        "options": {
          "sheetName": "DatosProveedor"
        }
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -39616,
        -10352
      ],
      "id": "ec633572-97ab-4cd9-ae98-c181a6607695",
      "name": "Extract Datos Proveedor"
    },
    {
      "parameters": {
        "jsCode": "// Obtener los datos del Excel\nconst excelData = $input.all();\nconst hojaSeleccionada = $('Unificación y consistencia de datos').first().json.hojaSeleccionada;\n\n// Obtener hora local en Bogotá\nconst ahora = new Date(new Date().toLocaleString(\"en-US\", { timeZone: \"America/Bogota\" }));\nconst diaSemanaActual = ahora.getDay(); // 0=domingo, 1=lunes, ..., 5=viernes\nconst horaActual = ahora.getHours();\nconst minutosActual = ahora.getMinutes();\n// Determinar si es después de las 16:30\nconst pasoLimiteDia = horaActual > 16 || (horaActual === 16 && minutosActual >= 30);\n\n// Definir estructura de la semana y los días\nconst diasSemana = ['lunes', 'martes', 'miércoles', 'jueves', 'viernes'];\n\n// Mapeo para saber qué días incluir si hoy es x día y pasó el límite\n/**\n * Dado el día de la semana actual (0=domingo ... 6=sábado),\n * devuelve qué días de la semana actual deben incluirse según si pasó el límite.\n */\nfunction diasValidosSemanaActual(diaSemanaActual, pasoLimite) {\n  const mapa = {\n    1: ['martes', 'miércoles', 'jueves', 'viernes'],   // lunes\n    2: ['miércoles', 'jueves', 'viernes'],             // martes\n    3: ['jueves', 'viernes'],                          // miércoles\n    4: ['viernes'],                                     // jueves\n    5: []                                               // viernes (muy tarde para sábado)\n  };\n  if (diaSemanaActual < 1 || diaSemanaActual > 5) {\n    return []; // sábado o domingo no se agendan en semana actual\n  }\n  if (!pasoLimite) {\n    // aún está antes de las 4:30 p.m., se puede incluir el día siguiente\n    const siguiente = diasSemana[diaSemanaActual];\n    return [siguiente, ...mapa[diaSemanaActual]];\n  }\n  return mapa[diaSemanaActual];\n}\n\n// Objeto para almacenar la malla estructurada\nconst mallaEstructurada = {\n  titulo: \"\",\n  año: \"\",\n  semana: \"\",\n  rangoDias: \"\",\n  franjas: [],\n  dias: {}\n};\n\n// Tabla de meses y días. Ajusta si necesitas contemplar bisiestos, etc.\nconst meses = {\n  \"enero\": 1,\n  \"febrero\": 2,\n  \"marzo\": 3,\n  \"abril\": 4,\n  \"mayo\": 5,\n  \"junio\": 6,\n  \"julio\": 7,\n  \"agosto\": 8,\n  \"septiembre\": 9,\n  \"octubre\": 10,\n  \"noviembre\": 11,\n  \"diciembre\": 12\n};\n\nconst nombreMes = {\n  1: \"enero\",\n  2: \"febrero\",\n  3: \"marzo\",\n  4: \"abril\",\n  5: \"mayo\",\n  6: \"junio\",\n  7: \"julio\",\n  8: \"agosto\",\n  9: \"septiembre\",\n  10: \"octubre\",\n  11: \"noviembre\",\n  12: \"diciembre\"\n};\n\n/**\n * Función para determinar si un año es bisiesto\n * Un año es bisiesto si es divisible por 4, excepto aquellos divisibles por 100 \n * que no son divisibles por 400\n */\nfunction esBisiesto(year) {\n  return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);\n}\n\n/**\n * Función para obtener el número de días en un mes, considerando años bisiestos\n */\nfunction getDiasMes(mes, año) {\n  const diasPorMes = {\n    1: 31, // enero\n    2: esBisiesto(año) ? 29 : 28, // febrero - ajustado para año bisiesto\n    3: 31, // marzo\n    4: 30, // abril\n    5: 31, // mayo\n    6: 30, // junio\n    7: 31, // julio\n    8: 31, // agosto\n    9: 30, // septiembre\n    10: 31, // octubre\n    11: 30, // noviembre\n    12: 31  // diciembre\n  };\n  \n  return diasPorMes[mes];\n}\n\n/**\n * Función para eliminar acentos y pasar a minúsculas (para buscar palabras clave sin importar tildes ni mayúsculas).\n */\nfunction normalizarTexto(texto) {\n  if (typeof texto !== 'string') return \"\";\n  // Normaliza (NFD) y elimina diacríticos, luego pasa a minúsculas.\n  return texto\n    .normalize(\"NFD\")\n    .replace(/[\\u0300-\\u036f]/g, \"\") // quita acentos\n    .toLowerCase();\n}\n\n/**\n * Dada la información de proveedor, ordenCompra, peso, categoría y unidades,\n * revisa si existe la palabra 'fuera de servicio', 'cancelado' o 'reagendado'\n * en cualquiera de esos campos. De ser así, retorna ese estado especial;\n * de lo contrario, retorna 'ocupado'.\n * \n * Se ignoran mayúsculas, minúsculas y tildes.\n */\nfunction determinarEstadoOcupado(proveedor, ordenCompra, peso, categoria, unidades) {\n  const conjunto = `${proveedor} ${ordenCompra} ${peso} ${categoria} ${unidades}`;\n  const texto = normalizarTexto(conjunto);\n\n  if (texto.includes(\"fuera de servicio\")) {\n    return \"fuera de servicio\";\n  }\n  if (texto.includes(\"cancelado\")) {\n    return \"cancelado\";\n  }\n  if (texto.includes(\"reagendado\")) {\n    return \"reagendado\";\n  }\n  return \"ocupado\";  \n}\n\n// -------------------------------------------------------------\n// 1) PROCESAR DATOS (Cabecera, Horas, Muelles, etc.)\n// -------------------------------------------------------------\nfunction procesarDatos(excelData) {\n  const datos = excelData.map(item => item.json);\n  \n  // A) Cabecera (Título, Año, Rango)\n  datos.forEach((dato, index) => {\n    // Buscar título\n    if (dato.__EMPTY_2 === \"MALLA DE RECIBO CEDI KONFIE IA\") {\n      mallaEstructurada.titulo = dato.__EMPTY_2;\n      \n      // En la siguiente fila puede estar año, semana, rango\n      if (index + 1 < datos.length) {\n        const datoSiguiente = datos[index + 1];\n        if (datoSiguiente) {\n          // Año\n          if (datoSiguiente.__EMPTY_2 && !isNaN(datoSiguiente.__EMPTY_2)) {\n            mallaEstructurada.año = datoSiguiente.__EMPTY_2;\n          }\n          // Semana\n          Object.entries(datoSiguiente).forEach(([k, v]) => {\n            if (typeof v === 'string' && v.includes(\"SEMANA\")) {\n              mallaEstructurada.semana = v;\n            }\n          });\n          // Rango: p.ej. \"LUNES 31 AL VIERNES 4 DE ABRIL\"\n          Object.entries(datoSiguiente).forEach(([k, v]) => {\n            if (typeof v === 'string' && v.includes(\"LUNES\") && v.includes(\"VIERNES\")) {\n              mallaEstructurada.rangoDias = v;\n            }\n          });\n        }\n      }\n    }\n  });\n  \n  // B) Detectar franjas horarias (.__EMPTY = fracción de día)\n  const franjasHorarias = [];\n  datos.forEach(dato => {\n    if (\n      dato.__EMPTY !== undefined &&\n      typeof dato.__EMPTY === 'number' &&\n      dato.__EMPTY > 0 &&\n      dato.__EMPTY < 1\n    ) {\n      const totalMin = Math.round(dato.__EMPTY * 24 * 60);\n      const hh = Math.floor(totalMin / 60);\n      const mm = totalMin % 60;\n      \n      let periodo = \"AM\";\n      let hora12 = hh;\n      if (hh >= 12) {\n        periodo = \"PM\";\n        hora12 = (hh === 12 ? 12 : hh - 12);\n      }\n      if (hh === 0) {\n        hora12 = 12;\n      }\n      \n      const horaStr = `${hora12}:${String(mm).padStart(2, '0')} ${periodo}`;\n      franjasHorarias.push({\n        hora: horaStr,\n        indice: datos.indexOf(dato) // fila base\n      });\n    }\n  });\n  franjasHorarias.sort((a, b) => a.indice - b.indice);\n  mallaEstructurada.franjas = franjasHorarias;\n  \n  // C) Detectar muelles (col)\n  const muellesInfo = {};\n  datos.forEach(dato => {\n    Object.entries(dato).forEach(([key, value]) => {\n      if (value === \"MUELLE 01\" || value === \"MUELLE 02\") {\n        const col = parseInt(key.replace(\"__EMPTY_\", \"\"), 10);\n        const muelleKey = (value === \"MUELLE 01\") ? 'muelle1' : 'muelle2';\n        if (!muellesInfo[muelleKey]) {\n          muellesInfo[muelleKey] = [];\n        }\n        muellesInfo[muelleKey].push(col);\n      }\n    });\n  });\n  if (muellesInfo.muelle1) muellesInfo.muelle1.sort((a, b) => a - b);\n  if (muellesInfo.muelle2) muellesInfo.muelle2.sort((a, b) => a - b);\n  \n  // D) Generar los 5 días (lunes-viernes) con su fecha\n  parsearRangoDias();\n  \n  // E) Extraer Citas\n  extraerCitas(datos, muellesInfo);\n  \n  return mallaEstructurada;\n}\n\n/**\n * Parsea la cadena \"LUNES 31 AL VIERNES 4 DE ABRIL\"\n * (o \"LUNES 31 AL VIERNES 04 DE ABRIL\") y maneja el cruce de mes.\n * Ej.: si dayStart=31 y dayEnd=4, la 1ª fecha es 31 de MARZO,\n * luego 1,2,3,4 de ABRIL, en vez de 32,33, etc.\n */\nfunction parsearRangoDias() {\n  const texto = mallaEstructurada.rangoDias;\n  // Regex simple: p.ej. \"31 AL ... 4 DE ABRIL\"\n  // Captura: dayStart, dayEnd, mesFin\n  // Ojo: si dice \"LUNES 31 DE MARZO AL VIERNES 4 DE ABRIL\",\n  // quedará: dayStart=31, dayEnd=4, month=ABRIL (al final).\n  const regex = /(\\d+)\\s+AL\\s+\\D+(\\d+)\\s+DE\\s+(\\w+)/i;\n  const match = regex.exec(texto);\n  \n  // Por defecto, creamos 5 días vacíos sin fecha\n  diasSemana.forEach(d => {\n    mallaEstructurada.dias[d] = {\n      muelle1: {},\n      muelle2: {}\n    };\n  });\n  \n  if (!match) {\n    // Sin coincidencia, dejamos los días sin fecha\n    return;\n  }\n  \n  const dayStart = parseInt(match[1], 10); // 31\n  const dayEnd   = parseInt(match[2], 10); // 4\n  const finalMonthName = match[3].toLowerCase(); // \"abril\"\n  \n  // Convertimos a número\n  const finalMonth = meses[finalMonthName] || 3; // fallback marzo\n  const yearNum = parseInt(mallaEstructurada.año, 10) || 2025;\n  \n  // Función para obtener la fecha formateada\n  function fechaFormateada(d, m, y) {\n    return `${d} de ${nombreMes[m]} de ${y}`;\n  }\n  \n  // Comprobamos cuántos días tiene el mes final, considerando bisiestos\n  const diasMesFinal = getDiasMes(finalMonth, yearNum);\n  // y del mes previo\n  const monthPrev = (finalMonth === 1) ? 12 : finalMonth - 1;\n  const yearPrev = (finalMonth === 1) ? yearNum - 1 : yearNum;\n  \n  // Arreglo final con 5 fechas\n  const fechasDias = [];\n  \n  if (dayStart <= dayEnd) {\n    // Caso \"normal\": todo en el mismo mes\n    let d = dayStart;\n    for (let i = 0; i < 5; i++) {\n      fechasDias.push({\n        diaSem: diasSemana[i],\n        diaNum: d,\n        mesNum: finalMonth,\n        yearNum: yearNum\n      });\n      d++;\n      if (d > diasMesFinal) {\n        d = 1;\n        const nextMonth = finalMonth % 12 + 1;\n        const nextYear = (nextMonth === 1) ? yearNum + 1 : yearNum;\n        fechasDias[fechasDias.length - 1].mesNum = nextMonth;\n        fechasDias[fechasDias.length - 1].yearNum = nextYear;\n      }\n    }\n  } else {\n    // Caso \"cruza de mes\": dayStart > dayEnd\n    let d = dayStart;\n    let m = monthPrev;\n    let y = yearPrev;\n    \n    for (let i = 0; i < 5; i++) {\n      fechasDias.push({\n        diaSem: diasSemana[i],\n        diaNum: d,\n        mesNum: m,\n        yearNum: y\n      });\n      d++;\n      if (d > getDiasMes(m, y)) {\n        d = 1;\n        m = m % 12 + 1;\n        if (m === 1) {\n          y++;\n        }\n      }\n    }\n  }\n  \n  // Ahora volcamos esas 5 fechas en la estructura\n  fechasDias.forEach(fd => {\n    const { diaSem, diaNum, mesNum, yearNum } = fd;\n    mallaEstructurada.dias[diaSem] = {\n      fechaDia: fechaFormateada(diaNum, mesNum, yearNum),\n      muelle1: {},\n      muelle2: {}\n    };\n  });\n  \n  // Inicializamos las franjas a 'disponible'\n  if (mallaEstructurada.franjas.length > 0) {\n    diasSemana.forEach(d => {\n      mallaEstructurada.franjas.forEach(f => {\n        mallaEstructurada.dias[d].muelle1[f.hora] = {\n          estado: \"disponible\",\n          proveedor: \"\",\n          ordenCompra: \"\",\n          peso: \"\",\n          categoria: \"\",\n          unidades: \"\"\n        };\n        mallaEstructurada.dias[d].muelle2[f.hora] = {\n          estado: \"disponible\",\n          proveedor: \"\",\n          ordenCompra: \"\",\n          peso: \"\",\n          categoria: \"\",\n          unidades: \"\"\n        };\n      });\n    });\n  }\n}\n\n/**\n * Función auxiliar: decide a qué día pertenece una columna,\n * corrigiendo 2 columnas de offset (porque 'Extract from XLSX'\n * deja todo desplazado).\n */\nfunction getDayForColumn(colNumber) {\n  // Ajuste de offset +2\n  const realCol = colNumber + 2;\n\n  // Rangos:\n  //  Lunes:      3..8\n  //  Martes:     9..14\n  //  Miércoles: 15..20\n  //  Jueves:    21..26\n  //  Viernes:   27..32\n  if (realCol >= 3 && realCol <= 8) {\n    return \"lunes\";\n  }\n  if (realCol >= 9 && realCol <= 14) {\n    return \"martes\";\n  }\n  if (realCol >= 15 && realCol <= 20) {\n    return \"miércoles\";\n  }\n  if (realCol >= 21 && realCol <= 26) {\n    return \"jueves\";\n  }\n  if (realCol >= 27 && realCol <= 32) {\n    return \"viernes\";\n  }\n  // Si nada coincide, devolvemos null\n  return null;\n}\n\n/**\n * Extraer las citas para cada franja:\n * - Para cada franja, miramos 3 filas:\n *    - Fila base => proveedor\n *    - Fila base+1 => orden\n *    - Fila base+2 => peso, categoría, unidades\n */\nfunction extraerCitas(datos, muellesInfo) {\n  mallaEstructurada.franjas.forEach(franja => {\n    const indiceBase = franja.indice;\n    if (indiceBase < 0 || indiceBase + 2 >= datos.length) {\n      return; // no hay suficientes filas\n    }\n    \n    // Recorremos muelle1, muelle2 y sus columnas\n    const asignarCita = (muelleKey, cols) => {\n      cols.forEach(col => {\n        const provKey = `__EMPTY_${col}`;\n        const filaProv = datos[indiceBase];\n        \n        // Si en esta fila hay un proveedor o algún texto\n        if (\n          filaProv &&\n          typeof filaProv[provKey] === 'string' &&\n          filaProv[provKey].length > 2\n        ) {\n          // Determinar el día real\n          const diaOk = getDayForColumn(col);\n          if (!diaOk || !mallaEstructurada.dias[diaOk]) {\n            return; // si no coincide con ninguno, saltamos\n          }\n          \n          // Recuperar valores para proveedor, ordenCompra y demás\n          const filaOrden = datos[indiceBase + 1];\n          const filaDet = datos[indiceBase + 2];\n          \n          const proveedor = filaProv[provKey] || \"\";\n          const ordenCompra = filaOrden && filaOrden[provKey] ? filaOrden[provKey] : \"\";\n          const peso = filaDet && filaDet[provKey] ? filaDet[provKey] : \"\";\n          const cat  = filaDet && filaDet[`__EMPTY_${col + 1}`] ? filaDet[`__EMPTY_${col + 1}`] : \"\";\n          const und  = filaDet && filaDet[`__EMPTY_${col + 2}`] ? filaDet[`__EMPTY_${col + 2}`] : \"\";\n          \n          // Antes poníamos estado=\"ocupado\" directamente\n          // Ahora verificamos si el texto contiene \"reagendado\", \"cancelado\" o \"fuera de servicio\".\n          const nuevoEstado = determinarEstadoOcupado(proveedor, ordenCompra, peso, cat, und);\n          \n          // Asignamos los datos\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].estado = nuevoEstado;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].proveedor = proveedor;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].ordenCompra = ordenCompra;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].peso = peso;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].categoria = cat;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].unidades = und;\n        }\n      });\n    };\n    \n    if (muellesInfo.muelle1) {\n      asignarCita('muelle1', muellesInfo.muelle1);\n    }\n    if (muellesInfo.muelle2) {\n      asignarCita('muelle2', muellesInfo.muelle2);\n    }\n  });\n}\n\n// -------------------------------------------------------------\n// 2) FUNCIONES PARA CONSULTAR LA MALLA\n// -------------------------------------------------------------\nfunction buscarFranjasDisponibles(categoria, duracionHoras) {\n  const muelle = \"muelle1\"; // Ajusta si usas \"categoria -> muelle\" real\n  \n  const franjasDisponibles = [];\n  Object.keys(mallaEstructurada.dias).forEach(dia => {\n    const libres = [];\n    for (let i = 0; i <= mallaEstructurada.franjas.length - duracionHoras; i++) {\n      let disponible = true;\n      for (let h = 0; h < duracionHoras; h++) {\n        const idxF = i + h;\n        const horaAct = mallaEstructurada.franjas[idxF].hora;\n        if (\n          mallaEstructurada.dias[dia][muelle][horaAct].estado !== 'disponible'\n        ) {\n          disponible = false;\n          break;\n        }\n      }\n      if (disponible) {\n        libres.push({\n          horaInicio: mallaEstructurada.franjas[i].hora,\n          duracion: duracionHoras\n        });\n      }\n    }\n    if (libres.length > 0) {\n      franjasDisponibles.push({ dia, franjas: libres });\n    }\n  });\n  return franjasDisponibles;\n}\n\nfunction buscarCitasProveedor(nombreProveedor) {\n  const citas = [];\n  Object.keys(mallaEstructurada.dias).forEach(dia => {\n    const muelle1 = mallaEstructurada.dias[dia].muelle1;\n    const muelle2 = mallaEstructurada.dias[dia].muelle2;\n    mallaEstructurada.franjas.forEach(f => {\n      const hora = f.hora;\n      // muelle1\n      if (normalizarTexto(muelle1[hora].proveedor) === normalizarTexto(nombreProveedor)) {\n        citas.push({\n          dia,\n          hora,\n          muelle: \"Muelle 01\",\n          ordenCompra: muelle1[hora].ordenCompra,\n          peso: muelle1[hora].peso,\n          categoria: muelle1[hora].categoria,\n          unidades: muelle1[hora].unidades,\n          estado: muelle1[hora].estado\n        });\n      }\n      // muelle2\n      if (normalizarTexto(muelle2[hora].proveedor) === normalizarTexto(nombreProveedor)) {\n        citas.push({\n          dia,\n          hora,\n          muelle: \"Muelle 02\",\n          ordenCompra: muelle2[hora].ordenCompra,\n          peso: muelle2[hora].peso,\n          categoria: muelle2[hora].categoria,\n          unidades: muelle2[hora].unidades,\n          estado: muelle2[hora].estado\n        });\n      }\n    });\n  });\n  return citas;\n}\n\nfunction consultarFranjasDisponibles(categoria, duracionHoras) {\n  return buscarFranjasDisponibles(categoria, duracionHoras);\n}\n\nfunction consultarCitasProveedor(nombreProveedor) {\n  return buscarCitasProveedor(nombreProveedor);\n}\n\nfunction obtenerInfoMalla() {\n  return {\n    titulo: mallaEstructurada.titulo,\n    año: mallaEstructurada.año,\n    semana: mallaEstructurada.semana,\n    rangoDias: mallaEstructurada.rangoDias,\n    franjas: mallaEstructurada.franjas.map(f => f.hora)\n  };\n}\n\nfunction estaDisponible(dia, hora, muelle) {\n  const info = mallaEstructurada.dias[dia]?.[muelle]?.[hora];\n  return info ? (info.estado === 'disponible') : false;\n}\n\nfunction obtenerCoordenadasCita(dia, hora, muelle) {\n  // Ajustar con tu mapeo de celdas en Excel\n  return {\n    proveedor: `${dia}_${hora}_${muelle}_proveedor`,\n    ordenCompra: `${dia}_${hora}_${muelle}_ordenCompra`,\n    peso: `${dia}_${hora}_${muelle}_peso`,\n    categoria: `${dia}_${hora}_${muelle}_categoria`,\n    unidades: `${dia}_${hora}_${muelle}_unidades`\n  };\n}\n\n// -------------------------------------------------------------\n// 3) EJECUTAR TODO Y RETORNAR\n// -------------------------------------------------------------\n// Procesar todos los datos\nconst malla = procesarDatos(excelData);\n\n// Aplicar el filtro de días válidos según la hora actual\nconst diasPermitidos = diasValidosSemanaActual(diaSemanaActual, pasoLimiteDia);\nObject.keys(malla.dias).forEach(dia => {\n  if (!diasPermitidos.includes(dia)) {\n    delete malla.dias[dia]; // eliminar días no válidos\n  }\n});\n\nconst resultado = {\n  datosMalla: malla,\n  funciones: {\n    consultarFranjasDisponibles,\n    consultarCitasProveedor,\n    obtenerInfoMalla,\n    estaDisponible,\n    obtenerCoordenadasCita\n  }\n};\n\nreturn [resultado];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -39376,
        -10704
      ],
      "id": "20ac6505-61fe-45ce-ae2b-ef1d38b29ad7",
      "name": "Estructuración, Datos, Consulta, Citas"
    },
    {
      "parameters": {
        "jsCode": "// Obtener todos los items de la entrada\nconst items = $input.all();\nconst datosProveedores = [];\n\n// Recorrer cada ítem de la entrada\nfor (const item of items) {\n  // Ahora sabemos exactamente cómo se llaman los campos en el JSON original\n  const originalData = item.json;\n  \n  // Crear objeto con los campos normalizados\n  const nuevoObjeto = {\n    // Los campos principales que siempre deben estar presentes\n    proveedor: originalData.PROVEEDOR || \"\",\n    rotacion: originalData.ROTACION || \"\",\n    unidadesPorHora: originalData[\"UNIDADES X HORA\"] || 0,\n    \n    // Los campos que tienen espacios al final en los nombres\n    // Nota: \"Tipo de Proveedor \" tiene un espacio al final\n    tipoProveedor: originalData[\"Tipo de Proveedor \"] || \"\",\n    \n    // \"Dia \" también tiene un espacio al final\n    dia: originalData[\"Dia \"] || \"\",\n    \n    // Este campo tiene un espacio en medio y otro al final\n    numeroDia: originalData[\"Dia _1\"] || 0,\n    \n    // Este campo no tiene espacios extras\n    hora: originalData.Hora || 0,\n    \n    // Campos adicionales que podrían ser útiles\n    cantidadSedes: originalData[\"Cantidad de Sedes\"] || 0\n  };\n  \n  // Añadir el nuevo objeto al array de resultados\n  datosProveedores.push(nuevoObjeto);\n}\n\n// Retornar un único objeto que contiene el array de datos de proveedores\n// dentro de un parámetro global llamado \"datosproveedor\"\nreturn [\n  {\n    json: {\n      datosproveedor: datosProveedores\n    }\n  }\n];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -39376,
        -10352
      ],
      "id": "137c6286-934e-4ba8-874c-4e2ecf89fda0",
      "name": "Estructuración, Consulta, Datos Proveedor"
    },
    {
      "parameters": {
        "numberInputs": 4
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.1,
      "position": [
        -39056,
        -10432
      ],
      "id": "24da198c-583d-4f42-802f-8a652db0de34",
      "name": "Merge datos Excel"
    },
    {
      "parameters": {
        "operation": "xlsx",
        "binaryPropertyName": "MallaFija",
        "options": {
          "sheetName": "Categorias"
        }
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -39616,
        -10128
      ],
      "id": "cf787be1-506a-4abf-bfeb-170d09d34ed8",
      "name": "Extract from Categorias"
    },
    {
      "parameters": {
        "jsCode": "// Obtener todos los items de la entrada\nconst items = $input.all();\nconst categorias = [];\n\n// Mapa para verificar categorías duplicadas\nconst categoriasMap = new Map();\n\n// Recorrer cada ítem de la entrada de categorías\nfor (const item of items) {\n  // Obtener los datos originales\n  const originalData = item.json;\n  \n  // Extraer categoría y muelle\n  const categoria = originalData.CATEGORIA || \"\";\n  const muelle = originalData.MUELLE || \"\";\n  \n  // Solo procesar si tanto la categoría como el muelle tienen valor\n  if (categoria && muelle) {\n    // Verificar si esta categoría ya existe en nuestro mapa\n    if (categoriasMap.has(categoria)) {\n      console.log(`Advertencia: La categoría \"${categoria}\" está duplicada. Se ignorará la segunda aparición.`);\n      continue; // Saltar este elemento\n    }\n    \n    // Agregar al mapa para control de duplicados\n    categoriasMap.set(categoria, muelle);\n    \n    // Agregar el objeto al array de categorías\n    categorias.push({\n      \"CATEGORIA\": categoria,\n      \"MUELLE\": muelle\n    });\n  } else {\n    console.log(`Advertencia: Elemento ignorado por falta de categoría o muelle: ${JSON.stringify(originalData)}`);\n  }\n}\n\n// Retornar un único objeto que contiene el array de categorías\n// dentro de un parámetro global llamado \"datoscategorias\"\nreturn [\n  {\n    json: {\n      datoscategorias: categorias\n    }\n  }\n];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -39376,
        -10128
      ],
      "id": "1ba24a8c-7155-4294-a85d-9e0af363f3c6",
      "name": "Estructuración, Consulta, Datos Categorias"
    },
    {
      "parameters": {
        "jsCode": "return [{\n  json: {\n    datosMalla: $items(\"Merge datos Excel\")[0].json.datosMalla,\n    datosMallaProxSemana: $items(\"Merge datos Excel\")[1].json.datosMallaProxSemana,\n    datosproveedor: $items(\"Merge datos Excel\")[2].json.datosproveedor,\n    datoscategorias: $items(\"Merge datos Excel\")[3].json.datoscategorias,\n    hojaSeleccionada: $items(\"Merge datos Excel\")[0].json.datosMalla.semana\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -38800,
        -10400
      ],
      "id": "e0a3d3a8-3fa0-4025-9417-b30011712302",
      "name": "Unificación y consistencia de datos1"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -46752,
        -6992
      ],
      "id": "29b1f18b-a49d-4ad1-aac7-6aac2bee7350",
      "name": "OpenAI Chat Model1",
      "credentials": {
        "openAiApi": {
          "id": "AD8kPcNVReuclASd",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "=define",
        "text": "=# SISTEMA\nEres un asistente especializado en logística y gestión de citas en bodega. Tu tarea es clasificar la intención principal del mensaje recibido por un proveedor que se comunica por WhatsApp, con base en el mensaje actual y el historial completo.\nEste modelo no valida datos, solo detecta la intención principal del mensaje, considerando el contexto previo.\n\n## REGLA DE PRIORIDAD MÁXIMA\n**SI EL MENSAJE CONTIENE LA PALABRA EXACTA \"ELIMINAR_MENSAJES\" EN MAYÚSCULAS, LA INTENCIÓN ES SIEMPRE \"ELIMINAR_MENSAJES\", SIN IMPORTAR CUALQUIER OTRO CONTENIDO.**\n\n## POSIBLES INTENCIONES (en orden de prioridad)\n1.  **ELIMINAR_MENSAJES** → Cuando el mensaje contiene exactamente la palabra \"ELIMINAR_MENSAJES\" en mayúsculas.\n2.  **RESPUESTA_FUERA_CONTEXTO** → Cuando el mensaje es completamente irrelevante al contexto de logística/citas (ej: \"quiero que seas mi esposa\", \"cuéntame un chiste\", \"¿cómo está el clima?\", conversaciones personales, temas románticos, etc.).\n3.  **SALUDO** → Cuando el proveedor dice \"Hola\", \"Buenos días\", etc. sin contexto adicional.\n4.  **CREAR_CITA** → Cuando desea agendar una cita de entrega o está proporcionando datos para una nueva cita, **incluso si cambia de opinión sobre los datos varias veces.**\n5.  **EDITAR_CITA** → Cuando quiere modificar una cita que **ya tiene programada y menciona su ID de cita**.\n6.  **CANCELAR_CITA** → Cuando quiere anular una cita **agendada y menciona su ID de cita**.\n7.  **CONSULTAR_MALLA** → Cuando pregunta por disponibilidad de horarios o franjas.\n8.  **PREGUNTA_GENERAL** → Cuando hace una pregunta relacionada con el negocio pero no sobre citas específicas.\n9.  **CONFIRMACION_CITA** → Cuando selecciona una franja horaria específica de opciones previamente ofrecidas.\n\n## DATOS DE ENTRADA\n**Mensaje actual del proveedor:**\n```\n{{ $json.infoMensaje.mensajeActual }}\n```\n\n**Historial completo de conversación:**\n```\n{{ $json.infoMensaje.historialMensajes }}\n```\n\n**Historial de citas del proveedor (si aplica):**\n```\n{{ $json.infoMensajecita.historialCitas }}\n\n## INSTRUCCIONES DE CLASIFICACIÓN\n\n### PASO 1: VERIFICACIÓN DE ELIMINAR_MENSAJES\nBusca PRIMERO si el mensaje actual contiene exactamente \"ELIMINAR_MENSAJES\" en mayúsculas.\n- Si la encuentra → INTENCIÓN: ELIMINAR_MENSAJES (termina aquí)\n- Si no la encuentra → continúa con el PASO 2\n\n### PASO 2: VERIFICACIÓN DE CONTEXTO EMPRESARIAL\nAntes de clasificar, verifica si el mensaje está relacionado con:\n- Logística, entregas, citas, horarios, proveedores\n- Consultas sobre disponibilidad, fechas, productos\n- Confirmaciones, cancelaciones, modificaciones de citas\n- Preguntas sobre el servicio de bodega\n\n**Si el mensaje NO está relacionado con estos temas empresariales:**\n- Ejemplos: \"quiero que seas mi esposa\", \"cuéntame un chiste\", \"¿te gusta la música?\", \"hablemos de deportes\", \"eres bonita\", conversaciones románticas o personales\n- → INTENCIÓN: RESPUESTA_FUERA_CONTEXTO (termina aquí)\n\n### PASO 3: ANÁLISIS CONTEXTUAL INTELIGENTE\n1. Lee TODO el historial de conversación para establecer el contexto.\n2. **Diferencia clave:** ¿El usuario ha mencionado un ID de cita existente (ej: \"cita 12345\")?\n   - **Si SÍ ha mencionado un ID:** El contexto es `EDITAR_CITA` o `CANCELAR_CITA`.\n   - **Si NO ha mencionado un ID:** El contexto es `CREAR_CITA`, incluso si cambia de opinión sobre la fecha/hora.\n\n### CRITERIOS ESPECÍFICOS POR INTENCIÓN\n\n<!-- CAMBIO CLAVE: Se redefine CREAR_CITA para ser más tolerante a los cambios de opinión. -->\n**CREAR_CITA:**\n- Expresa deseo de agendar una cita nueva (sin mencionar ID de cita existente).\n- Proporciona datos iniciales (nombre, categoría, peso).\n- **Cambia de opinión sobre la fecha, hora o cualquier otro dato durante el proceso de creación.** Mientras no se haya confirmado una cita y generado un ID, sigue siendo parte del flujo de CREACIÓN.\n- Completa información faltante para una nueva cita.\n\n**EDITAR_CITA:**\n- **REQUISITO INDISPENSABLE: El usuario debe mencionar un ID de cita existente.**\n- Proveedor solicita reprogramar/modificar una cita ya confirmada.\n- Proporciona nuevos datos (fecha/hora) para una cita existente identificada por su ID.\n- Responde a solicitudes del sistema para la reprogramación de una cita específica.\n\n**CONFIRMACION_CITA:**\n- SOLO cuando el sistema presentó una lista numerada de horarios o una única opción para confirmar.\n- El mensaje del proveedor es una elección clara de esas opciones (ej: \"la 2\", \"confirmo\", \"sí, esa está bien\").\n- **NO es una confirmación si el usuario propone una fecha/hora completamente nueva.**\n\n**CANCELAR_CITA:**\n- **REQUISITO INDISPENSABLE: El usuario debe mencionar un ID de cita existente.**\n- Solicita explícitamente cancelar/anular una cita.\n- Menciona que no podrá asistir a una cita programada, haciendo referencia a ella.\n\n**CONSULTAR_MALLA:**\n- Pregunta por disponibilidad sin datos específicos.\n- Solicita ver horarios disponibles.\n\n**RESPUESTA_FUERA_CONTEXTO:**\n- Mensajes románticos o personales (\"quiero que seas mi esposa\", \"eres hermosa\")\n- Solicitudes de entretenimiento (\"cuéntame un chiste\", \"canta una canción\")\n- Temas completamente ajenos al negocio (deportes, política, clima personal)\n- Conversaciones filosóficas o existenciales\n- Cualquier mensaje que no tenga relación con logística, citas o el servicio de bodega\n\n**PREGUNTA_GENERAL:**\n- Preguntas sobre ubicación, teléfono, otros procesos relacionados con el negocio.\n- Cualquier tema relacionado con el servicio pero no sobre citas específicas.\n\n**SALUDO:**\n- Saludos sin contexto adicional.\n- Primera interacción sin más información.\n\n## REGLAS IMPORTANTES\n1. La palabra \"ELIMINAR_MENSAJES\" tiene prioridad absoluta.\n2. **RESPUESTA_FUERA_CONTEXTO tiene segunda prioridad** - siempre clasifica así los mensajes no relacionados con el negocio.\n3. Si el mensaje es ambiguo, usa SIEMPRE el contexto del historial para determinar si ya se está trabajando sobre una cita con ID (EDITAR) o si es una nueva (CREAR).\n4. **Un cambio de fecha/hora sin mencionar un ID de cita es parte de `CREAR_CITA`.**\n5. Una vez establecido un contexto (ej. reprogramar la cita 12345), mantén ese contexto hasta cambio explícito de tema.\n6. Solo clasifica, no valides ni interpretes emociones.\n\n## FORMATO DE RESPUESTA\nEscribe ÚNICAMENTE la intención detectada en este formato:\nINTENCION: [NOMBRE_INTENCION]\n\n### EJEMPLOS\n\n**Ejemplo 1 - ELIMINAR_MENSAJES**\nMensaje: \"Hola, necesito ELIMINAR_MENSAJES por favor\"\nRespuesta: INTENCION: ELIMINAR_MENSAJES\n\n**Ejemplo 2 - RESPUESTA_FUERA_CONTEXTO**\nMensaje: \"Quiero que seas mi esposa\"\nRespuesta: INTENCION: RESPUESTA_FUERA_CONTEXTO\n\n**Ejemplo 3 - RESPUESTA_FUERA_CONTEXTO**\nMensaje: \"Cuéntame un chiste\"\nRespuesta: INTENCION: RESPUESTA_FUERA_CONTEXTO\n\n**Ejemplo 4 - EDITAR_CITA (Correcto)**\nHistorial: Usuario dijo \"quiero reprogramar mi cita 12345\"\nMensaje actual: \"Mi orden es ABC123\"\nRespuesta: INTENCION: EDITAR_CITA\n\n<!-- CAMBIO CLAVE: Se ajusta el ejemplo para reflejar la nueva lógica. -->\n**Ejemplo 3 - CREAR_CITA (con cambio de opinión)**\nHistorial: Bot ofrece alternativas para el 17 de julio.\nMensaje actual: \"No mejor quiero la cita para el 18 de julio\"\nAnálisis: No hay ID de cita. El usuario sigue definiendo los datos para una NUEVA cita.\nRespuesta: INTENCION: CREAR_CITA\n\n**Ejemplo 4 - CONFIRMACION_CITA**\nHistorial: Sistema ofreció \"1) 9:00 AM, 2) 10:00 AM, 3) 11:00 AM\"\nMensaje actual: \"La 2\"\nRespuesta: INTENCION: CONFIRMACION_CITA\n\n**Ejemplo 5 - SALUDO**\nMensaje: \"Buenos días\"\nRespuesta: INTENCION: SALUDO\n\n## RECORDATORIO FINAL\n1. Busca PRIMERO \"ELIMINAR_MENSAJES\" en mayúsculas.\n2. Luego verifica si es RESPUESTA_FUERA_CONTEXTO (no relacionado con el negocio).\n3. Si está relacionado con el negocio, analiza el contexto completo. **La presencia de un ID de cita es el factor decisivo entre CREAR y EDITAR/CANCELAR.**\n4. Clasifica según el flujo en curso, permitiendo cambios de opinión dentro del flujo de `CREAR_CITA`.\n5. Responde SOLO con el formato indicado."
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        -46656,
        -7200
      ],
      "id": "15589f8a-edbd-4429-8762-67813e977074",
      "name": "Basic LLM CLASIFICADOR"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.intencionDetectada }}",
                    "rightValue": "SALUDO",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "9dcab097-7554-4462-a979-fdf8536d0486"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "SALUDO"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "e006f52b-8954-4501-a9bb-a1afd0d9ded9",
                    "leftValue": "={{ $json.intencionDetectada }}",
                    "rightValue": "CREAR_CITA",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "CREAR_CITA"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "2d70e739-97ca-4370-90d6-a54d59aa360e",
                    "leftValue": "={{ $json.intencionDetectada }}",
                    "rightValue": "CONFIRMACION_CITA",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "CONFIRMACION_CITA"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "73fa4c42-bcd5-4680-87bd-b90baa1c4fce",
                    "leftValue": "={{ $json.intencionDetectada }}",
                    "rightValue": "EDITAR_CITA",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "EDITAR_CITA"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "029fb8dc-7e9f-4dfa-bec0-a933c7d06c53",
                    "leftValue": "={{ $json.intencionDetectada }}",
                    "rightValue": "CANCELAR_CITA",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "CANCELAR_CITA"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "e38bba1f-bf89-4389-b6dc-b8093dc344e1",
                    "leftValue": "={{ $json.intencionDetectada }}",
                    "rightValue": "CONSULTAR_MALLA",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "CONSULTAR_MALLA"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "e6ea3bd9-d425-42e2-8f6b-69342b093cff",
                    "leftValue": "={{ $json.intencionDetectada }}",
                    "rightValue": "PREGUNTA_GENERAL",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "PREGUNTA_GENERAL"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "63eae036-bb70-4b9a-a67a-7fe6e2886456",
                    "leftValue": "={{ $json.intencionDetectada }}",
                    "rightValue": "ELIMINAR_MENSAJES",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "ELIMINAR_MENSAJES"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
                    "leftValue": "={{ $json.intencionDetectada }}",
                    "rightValue": "RESPUESTA_FUERA_CONTEXTO",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "RESPUESTA_FUERA_CONTEXTO"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -46048,
        -7312
      ],
      "id": "fa070e52-8008-400c-8063-07a17b8eac63",
      "name": "Switch basado en intención"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -39888,
        -11440
      ],
      "id": "546c4f77-f548-4356-a212-3cb7556581e2",
      "name": "OpenAI Chat Model2",
      "credentials": {
        "openAiApi": {
          "id": "AD8kPcNVReuclASd",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "return [{\n  json: {\n    intencionDetectada: $json.text ? $json.text.replace(\"INTENCION: \", \"\").trim() : \"\"\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -46272,
        -7200
      ],
      "id": "9e26c319-6f8c-4e37-bbc6-9dd8cdfaa2df",
      "name": "Almacenar la intención detectada"
    },
    {
      "parameters": {
        "promptType": "=define",
        "text": "=### SISTEMA\n\nEres un asistente especializado en logística de bodegas, encargado de atender proveedores que escriben por WhatsApp para gestionar sus citas de descarga de mercancía.\n\nTrabajas para **Konfíe IA Logistics**, y tu función es actuar como un **coordinador de citas automatizado** en la bodega, ofreciendo un servicio amable, eficiente y profesional.\n\nTu tarea es responder cuando el proveedor inicia la conversación con un saludo (como \"Hola\", \"Buenos días\", etc.).\n\n---\n\n🕐 Usa la hora del mensaje actual ({{ $('Unificación y consistencia de datos').item.json.infoMensaje.horaMensajeActual }}) para elegir el saludo correcto:\n- Entre 06:00 y 11:59 → \"Buenos días\"\n- Entre 12:00 y 17:59 → \"Buenas tardes\"\n- Entre 18:00 y 05:59 → \"Buenas noches\"\n\n---\n\nTu mensaje debe:\n\n- Saludar cordialmente según la hora.\n- Presentarte como el **asistente virtual de Konfíe IA Logistics**.\n- Explicar que puedes ayudar a:\n  - Agendar una nueva cita para descarga.\n  - Consultar disponibilidad de franjas.\n  - Editar una cita ya programada.\n  - Cancelar una entrega programada.\n- Mostrarte disponible y servicial.\n- No solicitar datos todavía.\n- Si el proveedor tiene **citas activas en su historial**, puedes mencionarlo suavemente:  \n  > “Veo que ya tienes citas agendadas. Si deseas hacer algún ajuste o consultar algo, estoy para ayudarte.”\n- Si el mensaje o el historial **sugiere** que el proveedor quiere saber disponibilidad, puedes decir algo como:  \n  > “Si quieres revisar disponibilidad, puedes contarme el día y la categoría del producto, y con gusto te ayudaré.”  \n  (No lo pidas directamente, solo sugiérelo amablemente.)\n\n---\n\n### 🧾 MENSAJE ACTUAL DEL PROVEEDOR:\n{{ $('Unificación y consistencia de datos').first().json.infoMensaje.mensajeActual }}\n\n---\n\n### 🗂️ HISTORIAL DE MENSAJES:\n{{ $node[\"Unificación y consistencia de datos\"].json[\"infoMensaje\"][\"historialMensajes\"] }}\n\n---\n\n### 📆 HISTORIAL DE CITAS DEL PROVEEDOR:\n{{ $node[\"Unificación y consistencia de datos\"].json[\"infoMensajecita\"][\"historialCitas\"] }}\n\n---\n\n### 🧠 FORMATO DE RESPUESTA (JSON válido):\n```json\n{\n  \"mensajeSistema\": \"Texto cordial, humano y claro presentando al sistema, explicando qué puede hacer por el proveedor, y dejando la conversación abierta para que continúe.\"\n}\n"
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        -39808,
        -11648
      ],
      "id": "84bda8e2-8c2c-4ddc-b586-ab3adbce478a",
      "name": "Basic LLM CONVERSACIÓN (SALUDO)"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -38000,
        -10224
      ],
      "id": "6d099741-5329-4e2b-b412-37e366166e9c",
      "name": "OpenAI Chat Model3",
      "credentials": {
        "openAiApi": {
          "id": "AD8kPcNVReuclASd",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "=define",
        "text": "=# Prompt para el Asistente de Logística de Bodegas\n\n## SISTEMA\nEres un asistente experto en logística de bodegas, especializado en comunicar información sobre citas de descarga de mercancía. Tu función ahora es:\n\n1. **Interpretar los resultados de la validación** que ya fue realizada por el nodo de código JavaScript.\n2. **Generar mensajes humanos, claros y amables** para comunicarse con los proveedores.\n3. **NO repetir el procesamiento de validación** ya que esto se hizo en el nodo de código anterior.\n4. **Mantener el formato de salida JSON** requerido por el sistema.\n\n## DETECCIÓN DE DATOS CONTRADICTORIOS\nSi detectas múltiples fechas/horas diferentes en el historial que contradicen el mensaje actual:\n- Identifica inconsistencias en los datos proporcionados\n- Prioriza SIEMPRE la información más reciente del usuario  \n- Si hay confusión excesiva (3+ cambios de fecha), marca como \"datos_contradictorios\"\n\n---\n### 📊 RESULTADOS DE LA VALIDACIÓN:\n```json\n{{ JSON.stringify($node[\"Code RECOLECCIÓN\"].json, null, 2) }}\n```\n\n### 📋 CATEGORÍAS DISPONIBLES (USAR SOLO ESTAS):\n```json\n{{ $items(\"Estructuración, Consulta, Datos Categorias\")[0].json.datoscategorias.map(cat => cat.CATEGORIA) }}\n```\n\n### 🧾 MENSAJE ACTUAL DEL PROVEEDOR:\n{{ $('Unificación y consistencia de datos').first().json.infoMensaje.mensajeActual }}\n\n### 🕓 FECHA Y HORA ACTUAL (BOGOTÁ, COLOMBIA):\n{{ new Date().toLocaleString(\"es-CO\", { timeZone: \"America/Bogota\", hour12: true }) }}\n\n### 📝 INSTRUCCIONES PARA GENERAR RESPUESTAS:\n\n**REGLA CRÍTICA PARA NOMBRES DE PROVEEDORES:**\n- Al mencionar el nombre del proveedor en el mensajeSistema, NUNCA agregues puntos, comas o signos de puntuación adicionales al final del nombre\n- El nombre del proveedor debe aparecer exactamente como está en la base de datos, sin modificaciones de puntuación\n- Ejemplo correcto: \"SPB COLOMBIA S.A.S\" (sin punto adicional)\n- Ejemplo incorrecto: \"SPB COLOMBIA S.A.S.\" (con punto adicional)\n\n#### 1. SI TODO ESTÁ CORRECTO (`todoCorrecto: true`):\n- Genera un mensaje confirmando que la cita ha sido registrada exitosamente.\n- Incluye todos los detalles identificados: proveedor completo, fecha, hora, categoría, peso, unidades, número de orden.\n- Usa un tono profesional y amable, agradeciendo por la información completa.\n- Ejemplo: \"He registrado tu cita para SPB COLOMBIA S.A.S el día 14 de abril a las 10:00 AM, categoría ARENAS, 300 kilos, 900 unidades con número de orden ARGM47896. Tu cita ha sido registrada con éxito.\"\n- IMPORTANTE: NO solicites confirmaciones innecesarias cuando todos los datos estén correctos.\n\n#### 2. SI HAY DATOS PREVIAMENTE CONFIRMADOS (`datosPreviamenteConfirmados: true`):\n- Genera un mensaje final confirmando que la cita ha sido registrada con éxito.\n- Incluye todos los detalles ya confirmados: proveedor, fecha, hora, etc.\n- Usa un tono de cierre, agradeciendo por la confirmación.\n- Ejemplo: \"¡Perfecto! He confirmado tu cita para SPB COLOMBIA S.A.S el día 14 de abril a las 10:00 AM. Tu cita ha sido registrada con éxito.\"\n\n#### 3. SI HAY PROVEEDORES SIMILARES QUE REQUIEREN CONFIRMACIÓN:\n- Cuando `proveedoresSimilares` no esté vacío, genera un mensaje pidiendo confirmación específica del proveedor.\n- Lista las opciones de proveedores de forma clara y ordenada.\n- Incluye los demás datos ya confirmados (fecha, hora, categoría, etc.).\n- Ejemplo: \"He identificado varios proveedores que coinciden con tu solicitud. Por favor, confirma cuál deseas usar:\\n- SPB COLOMBIA S.A.S\\n- SOPORTE PRODUCTIVO S.A.S.\\nLos demás datos de tu cita (14 de abril a las 10:00 AM, categoría ARENAS, 300 kilos, 900 unidades) ya están registrados.\"\n\n#### 4. SI HAY CATEGORÍAS SIMILARES QUE REQUIEREN CONFIRMACIÓN:\n- Cuando `categoriasSimilares` no esté vacío, genera un mensaje pidiendo confirmación específica de la categoría.\n- Lista las opciones de categorías de forma clara y ordenada.\n- Incluye los demás datos ya confirmados (proveedor, fecha, hora, etc.).\n\n#### 5. SI FALTAN CAMPOS OBLIGATORIOS:\n- Cuando `camposFaltantes` no esté vacío, genera un mensaje solicitando específicamente los campos faltantes.\n- **USA EL FORMATO AMIGABLE Y ESTRUCTURADO** con lista para cada campo faltante.\n- **IMPORTANTE: SIEMPRE usa las categorías del nodo de datos, NUNCA uses ejemplos hardcodeados**.\n- Proporciona ejemplos claros para cada campo.\n- Template de respuesta:\n```\nGracias por tu solicitud. Para poder agendar tu cita de entrega, necesito que me proporciones la siguiente información:\n[SI FALTA PROVEEDOR] • El nombre del proveedor (proporcionar el nombre lo más completo posible)\n[SI FALTA CATEGORÍA] • La categoría del material (los cuales pueden ser: {{ $items(\"Estructuración, Consulta, Datos Categorias\")[0].json.datoscategorias.map(cat => cat.CATEGORIA).map(cat => cat.toUpperCase()).join(', ') }})\n[SI FALTA FECHA] • La fecha de entrega (ejemplo: 25 de junio)\n[SI FALTA HORA] • La hora de entrega (ejemplo: 9:00 AM)\n[SI FALTA PESO] • El peso de la mercancía (ejemplo: 300 kilos)\n[SI FALTA UNIDADES] • La cantidad de unidades a descargar (ejemplo: 600 unidades)\n[SI FALTA ORDEN] • El número de orden de compra (ejemplo: ARGM47896)\n\nPor favor, proporciona estos datos para completar tu solicitud.\n```\n\n#### 6. NUEVAS VERIFICACIONES DE FECHA Y HORA:\n- Si `fechaValida` es `false` o `horaValida` es `false`, debes comunicar al usuario el problema específico.\n- Utiliza el mensaje que viene en `mensajeValidacionTemporal` para explicar el motivo del rechazo.\n- Solicita al usuario que proporcione una fecha u hora válida según corresponda.\n\n#### 7. SI LA FECHA SOLICITADA ES PARA UN DÍA NO HÁBIL:\n- Si `diaHabil` es `false`, debes informar al usuario que solo se pueden agendar citas en días hábiles (lunes a viernes).\n- Sugiere al usuario que elija una fecha en día hábil cercano.\n\n#### 8. SI EL NODO DE VALIDACIÓN DETECTÓ UNA FECHA \"MAÑANA\" PERO LA INTERPRETÓ INCORRECTAMENTE:\n- Si el mensaje actual contiene la palabra \"mañana\" pero la fecha validada no corresponde al día siguiente, debes corregirlo.\n- Verifica que, si el usuario dice \"mañana\", la fecha debe ser el día siguiente al actual.\n\n### ⚠️ REGLAS CRÍTICAS SOBRE CATEGORÍAS:\n\n1. **NUNCA uses categorías de ejemplo o hardcodeadas**. SIEMPRE obtén las categorías del nodo: {{ $items(\"Estructuración, Consulta, Datos Categorias\")[0].json.datoscategorias.map(cat => cat.CATEGORIA) }}\n\n2. **Para mostrar categorías en negrilla sin asteriscos visibles**, usa uno de estos formatos:\n   - En texto plano: simplemente lista las categorías en MAYÚSCULAS separadas por comas\n   - Con viñetas: usa el símbolo • antes de cada elemento\n\n3. **Elimina TODOS los ejemplos de categorías hardcodeadas** del prompt. Solo usa las categorías dinámicas.\n\n### ⚠️ OTRAS REGLAS IMPORTANTES:\n\n1. **NUNCA pidas confirmación cuando el nodo de código ya determinó que todo está correcto** (`todoCorrecto: true`).\n\n2. **NUNCA pidas confirmación para datos que ya fueron correctamente identificados**.\n\n3. **Usa un lenguaje humano, amable y natural**, evitando tecnicismos.\n\n4. **No repitas datos innecesariamente** ni hagas preguntas redundantes.\n\n5. **No permitas citas para el mismo día con menos de 2 horas de anticipación**.\n\n6. **Rechaza explícitamente las citas para días no hábiles** (fines de semana).\n\n7. **SIEMPRE obtén las categorías disponibles del nodo correspondiente**.\n\n### 📋 EJEMPLOS DE RESPUESTAS (IMPORTANTE: NO uses las categorías de estos ejemplos):\n\n#### EJEMPLO 1 - TODO CORRECTO:\n```json\n{\n  \"todoCorrecto\": true,\n  \"datosPreviamenteConfirmados\": false,\n  \"camposFaltantes\": [],\n  \"proveedoresSimilares\": [],\n  \"categoriasSimilares\": [],\n  \"fechaSolicitada\": \"14 de abril de 2025\",\n  \"horaSolicitada\": \"10:00 AM\",\n  \"mensajeSistema\": \"He registrado tu cita para [PROVEEDOR] el día [FECHA] a las [HORA], categoría [CATEGORÍA REAL DEL NODO], con un peso de [PESO] kilos y [UNIDADES] unidades. Tu número de orden de compra [ORDEN] ha sido registrado. Tu cita ha sido confirmada exitosamente.\",\n  \"mensajeEstado\": \"datos_completos\",\n  \"motivoRechazo\": \"\"\n}\n```\n\n#### EJEMPLO 2 - FALTA INFORMACIÓN COMPLETA:\n```json\n{\n  \"todoCorrecto\": false,\n  \"datosPreviamenteConfirmados\": false,\n  \"camposFaltantes\": [\"proveedor\", \"categoría\", \"fecha\", \"hora\", \"peso\", \"unidades\", \"orden de compra\"],\n  \"proveedoresSimilares\": [],\n  \"categoriasSimilares\": [],\n  \"fechaSolicitada\": \"\",\n  \"horaSolicitada\": \"\",\n  \"mensajeSistema\": \"Gracias por tu solicitud. Para poder agendar tu cita de entrega, necesito que me proporciones la siguiente información:\\n• El nombre del proveedor (proporcionar el nombre lo más completo posible)\\n• La categoría del material (los cuales pueden ser: [USAR CATEGORÍAS REALES DEL NODO])\\n• La fecha y hora de entrega (ejemplo: 25 de junio a las 9:00 AM)\\n• El peso de la mercancía (ejemplo: 300 kilos)\\n• La cantidad de unidades a descargar (ejemplo: 600 unidades)\\n• El número de orden de compra (ejemplo: ARGM47896)\\n\\nPor favor, proporciona estos datos para completar tu solicitud.\",\n  \"mensajeEstado\": \"datos_incompletos\",\n  \"motivoRechazo\": \"\"\n}\n```\n\n#### EJEMPLO 3 - DATOS CONTRADICTORIOS:\n```json\n{\n  \"todoCorrecto\": false,\n  \"datosPreviamenteConfirmados\": false,\n  \"camposFaltantes\": [],\n  \"proveedoresSimilares\": [],\n  \"categoriasSimilares\": [],\n  \"fechaSolicitada\": \"\",\n  \"horaSolicitada\": \"\",\n  \"mensajeSistema\": \"He detectado múltiples cambios en las fechas solicitadas. Para evitar confusiones, por favor proporciona todos los datos completos en un solo mensaje.\",\n  \"mensajeEstado\": \"datos_contradictorios\",\n  \"motivoRechazo\": \"Usuario ha proporcionado fechas contradictorias múltiples veces\"\n}\n```\n\n### 📤 FORMATO DE TU RESPUESTA:\nIMPORTANTE: Debes responder EXCLUSIVAMENTE en formato JSON con la siguiente estructura:\n\n```json\n{\n  \"todoCorrecto\": true | false,\n  \"datosPreviamenteConfirmados\": true | false,\n  \"camposFaltantes\": [\"campo1\", \"campo2\", ...],\n  \"proveedoresSimilares\": [\"Proveedor 1\", \"Proveedor 2\", ...],\n  \"categoriasSimilares\": [\"Categoría 1\", \"Categoría 2\", ...],\n  \"fechaSolicitada\": \"Fecha exacta que el proveedor solicitó\",\n  \"horaSolicitada\": \"Hora exacta que el proveedor solicitó\",\n  \"mensajeSistema\": \"Texto humano, amable y claro para el proveedor\",\n  \"mensajeEstado\": \"datos_completos\" | \"datos_incompletos\" | \"datos_contradictorios\",\n  \"motivoRechazo\": \"Descripción del motivo si aplica\"\n}\n```\n\nLa respuesta NO debe incluir explicaciones, razonamientos o texto adicional fuera del objeto JSON."
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        -37920,
        -10432
      ],
      "id": "ac77081b-2b49-469c-8c9e-2e8d73297db9",
      "name": "Basic LLM Chain RECOLECCIÓN"
    },
    {
      "parameters": {
        "jsCode": "const rawText = $json.text;\n\n// Eliminar bloques ```json y otros caracteres extra si existen\nconst clean = rawText\n  .replace(/```json/g, '')\n  .replace(/```/g, '')\n  .trim();\n\nlet parsed;\ntry {\n  parsed = JSON.parse(clean);\n} catch (e) {\n  parsed = {\n    todoCorrecto: false,\n    camposFaltantes: [\"error_json\"],\n    mensajeSistema: \"Hubo un error al interpretar los datos del modelo IA.\"\n  };\n}\n\n// Detectar retractaciones y forzar reset\nif (parsed.mensajeEstado === \"datos_contradictorios\") {\n  return [{ \n    json: { \n      forzarReset: true, \n      mensaje: \"🔄 **Múltiples cambios detectados**\\n\\nPara evitar errores, proporciona todos los datos en un solo mensaje completo.\" \n    } \n  }];\n}\n\nreturn [{ json: parsed }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -37568,
        -10432
      ],
      "id": "a9329265-d2f6-40e5-b86b-ca6a6292f2e4",
      "name": "Code (Formatear JSON RECOLECCIÓN)"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "9fb4ec76-c88a-4b6e-ac86-10bd802e5e8a",
              "leftValue": "={{ $json.todoCorrecto }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -37344,
        -10432
      ],
      "id": "03655416-a23d-4950-aeb9-f6c635f2437a",
      "name": "IF Datos Completos"
    },
    {
      "parameters": {
        "jsCode": "return [{\n  json: {\n    text: $json.mensajeSistema\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -36976,
        -10160
      ],
      "id": "51591a19-17c5-4f78-ae1a-708dd3fb5dc6",
      "name": "Code Respuesta Faltantes"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "07f5d304-964c-4736-94aa-a05d439dcf6e",
              "name": "estadoConversacion",
              "value": "RECOLECCIÓN",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -36704,
        -10160
      ],
      "id": "9ab004ad-844c-4fb6-9c0f-03e103e087f8",
      "name": "Setear estado conversacional"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "4bfbecb3-9d4f-4425-aa76-a92abc7708fb",
              "leftValue": "={{ $('Code Respuesta Faltantes').item.json.text.length }}",
              "rightValue": 70,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -34704,
        -10160
      ],
      "id": "58d5580d-2ff0-47c4-b6f5-fb1beeb27bf7",
      "name": "Validación de longitud de caracteres"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d9c2ff70-4fd1-4b93-8571-6d0ac5a0093e",
              "name": "mensaje.ia",
              "value": "={{ $('Code Respuesta Faltantes').item.json.text }}",
              "type": "string"
            },
            {
              "id": "ac8a03be-0292-4735-9580-39a385945c47",
              "name": "mensaje.longitud",
              "value": "={{ $('Code Respuesta Faltantes').item.json.text.length }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -34400,
        -10160
      ],
      "id": "68e4e00c-ccba-4859-8e01-ee243ad9e5f7",
      "name": "Organiza variables del mensaje"
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n  \"partes\": [\n    \"Primera parte del mensaje\",\n    \"Segunda parte del mensaje (si aplica)\",\n    \"Tercera parte del mensaje (si aplica)\",\n    \"Cuarta parte del mensaje (si aplica)\",\n    \"Quinta parte del mensaje (si aplica)\"\n  ]\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.2,
      "position": [
        -13536,
        -2992
      ],
      "id": "b7383bd8-23d0-4e83-86c4-b6d31b80cd7b",
      "name": "Structured Output Parser"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -13744,
        -2992
      ],
      "id": "52db62d7-07a0-408e-befa-fd2efa31074d",
      "name": "OpenAI Chat Model4",
      "credentials": {
        "openAiApi": {
          "id": "AD8kPcNVReuclASd",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -34224,
        -10368
      ],
      "id": "aa95e860-a27d-4c74-9fd4-8bc1eefac9b9",
      "name": "No Operation, do nothing2"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $('Code Respuesta Faltantes').item.json.text }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -34400,
        -10368
      ],
      "id": "2242e521-d6e9-4676-a380-3d4a174ba1e1",
      "name": "HTTP Request Enviar Mensaje por WhatsApp"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.mensaje.ia }}",
        "hasOutputParser": true,
        "messages": {
          "messageValues": [
            {
              "message": "=Divide inteligentemente mensajes largos para WhatsApp preservando coherencia y legibilidad.\n\nANÁLISIS PREVIO:\n1. Identifica el tipo de contenido: confirmación de cita, cancelación, información, etc.\n2. Detecta estructura: párrafos naturales, listas, citas del cliente, respuestas del sistema\n3. Respeta SIEMPRE los saltos de línea existentes (\\\\n)\n\nREGLAS ESTRICTAS:\n\n📏 LÍMITES:\n- Si ≤1500 caracteres → NO dividir, devuelve el texto completo\n- Cada parte: 800-1500 caracteres (preferir ~1200)\n- Máximo 5 partes\n\n✂️ DÓNDE CORTAR (orden de prioridad):\n1. Entre bloques temáticos diferentes (ej: solicitud del cliente / respuesta del sistema)\n2. Después de párrafos completos (busca \\\\n\\\\n o doble salto)\n3. Después de puntos finales de oraciones\n4. PROHIBIDO cortar: en medio de oraciones, datos importantes, citas\n\n🔗 MANTENER SIEMPRE JUNTOS:\n- Solicitud completa del cliente con TODOS sus datos\n- Confirmación del sistema con detalles del muelle y horario\n- Advertencias o recordatorios importantes completos\n- Datos relacionados: fecha+hora+lugar+cantidades\n\n📝 FORMATO:\n- Preserva emojis, negritas (**), saltos de línea\n- NO agregues texto extra como \"Parte 1:\" o números\n- Si una idea continúa, termina con \"...\"\n- Si es continuación, empieza naturalmente\n\nEJEMPLO REAL DE BUENA DIVISIÓN:\n\nInput: \"Hola, deseo agendar una cita de entrega para el jueves 19, el nombre del proveedor es spb, categoría arenas, con un peso de 300 kilos, a las 6 de la mañana, 600 unidades, el número de orden de compra es ARGM47896\\\\n\\\\n¡Genial! Viendo el cronograma me registra que sí hay espacio para agendar esta cita, sería para el 19 de junio de 2025, desde las 06:00 AM hasta las 08:00 AM, ya que por la cantidad de unidades y peso en promedio va a tardar 2 horas el descargue en el MUELLE 1. El sistema pide una confirmación de tu parte para que la cita se genere en el cronograma, por favor responde confirmando la cita y recuerda que el sistema nos da 5 minutos para confirmar la cita o de lo contrario no se puede garantizar el cupo solicitado en el cronograma.\"\n\nOutput correcto:\n{\n  \"partes\": [\n    \"Hola, deseo agendar una cita de entrega para el jueves 19, el nombre del proveedor es spb, categoría arenas, con un peso de 300 kilos, a las 6 de la mañana, 600 unidades, el número de orden de compra es ARGM47896\\\\n\\\\n¡Genial! Viendo el cronograma me registra que sí hay espacio para agendar esta cita, sería para el 19 de junio de 2025, desde las 06:00 AM hasta las 08:00 AM, ya que por la cantidad de unidades y peso en promedio va a tardar 2 horas el descargue en el MUELLE 1.\",\n    \"El sistema pide una confirmación de tu parte para que la cita se genere en el cronograma, por favor responde confirmando la cita y recuerda que el sistema nos da 5 minutos para confirmar la cita o de lo contrario no se puede garantizar el cupo solicitado en el cronograma.\"\n  ]\n}\n\nRESPONDE SOLO EL JSON, sin explicaciones:\n{\n  \"partes\": [\"texto de cada parte\"]\n}\n\nTexto a dividir:\n{{ $json.mensaje.ia }}"
            }
          ]
        }
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.5,
      "position": [
        -13680,
        -3200
      ],
      "id": "f12b4812-f517-4f40-b057-59f932e9ef7d",
      "name": "Basic LLM Separación de Mensaje"
    },
    {
      "parameters": {
        "fieldToSplitOut": "output.partes",
        "options": {}
      },
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [
        -13216,
        -3200
      ],
      "id": "9b225b9b-c4fd-4f91-973f-4a49dd142264",
      "name": "Split Out Separa el Mensaje"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        -12880,
        -3200
      ],
      "id": "743ce007-8120-45c3-b608-56daa4f76d4e",
      "name": "Loop Over Items Recorre las Partes"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "7e24e44a-14df-4559-b8f0-5a714b4e28ee",
              "name": "Mensaje",
              "value": "={{ $json['output.partes'] }}",
              "type": "string"
            },
            {
              "id": "9a3b644f-ccc6-4f2a-ac00-909990c06524",
              "name": "longitud",
              "value": "={{ $json['output.partes'].length }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -12096,
        -2848
      ],
      "id": "240ba42b-6c41-4a78-a496-4fa740742157",
      "name": "Recuento de Caracteres"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.longitud }}",
                    "rightValue": 121,
                    "operator": {
                      "type": "number",
                      "operation": "lt"
                    },
                    "id": "b5afcf0e-93bb-4d29-9b45-faa775511ba5"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Corto"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "ddc297e5-bff7-4b9d-812d-9131fc251995",
                    "leftValue": "={{ $json.longitud }}",
                    "rightValue": 181,
                    "operator": {
                      "type": "number",
                      "operation": "lt"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Medio"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "35e399f9-47fb-4402-8e74-17602592c599",
                    "leftValue": "={{ $json.longitud }}",
                    "rightValue": 182,
                    "operator": {
                      "type": "number",
                      "operation": "gte"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Largo"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -11888,
        -2848
      ],
      "id": "7b899923-9500-4d5b-8b46-a0732d5b98d1",
      "name": "Switch"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $json.Mensaje }}"
            },
            {
              "name": "delay",
              "value": "={{3000}}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -11584,
        -3104
      ],
      "id": "c3f7b9e9-be78-4677-af96-83dd69693df4",
      "name": "HTTP Request Enviar Mensaje por WhatsApp1"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $json.Mensaje }}"
            },
            {
              "name": "delay",
              "value": "={{ 4000 }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -11584,
        -2880
      ],
      "id": "00b377e1-85ce-4f29-babc-1ba35543d2c0",
      "name": "HTTP Request Enviar Mensaje por WhatsApp2"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $json.Mensaje }}"
            },
            {
              "name": "delay",
              "value": "={{ 6000 }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -11584,
        -2688
      ],
      "id": "3d4ce2cd-2d2e-4957-a535-38b6502dca1a",
      "name": "HTTP Request Enviar Mensaje por WhatsApp3"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=INSERT INTO MensajesWhatsApp (message_id, contenido, fecha, chat_id, instance)\nVALUES (\n  '{{ $('Parametrización').first().json.message.id }}',\n  '{{ $json.message.conversation.replace(/'/g, \"''\") }}',\n  FORMAT(SWITCHOFFSET(GETDATE(), '-05:00'), 'yyyy-MM-dd HH:mm:ss'),\n  'agenteAI',\n  '{{ $('Parametrización').first().json.message.chat.instance }}'\n);"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        -11280,
        -2880
      ],
      "id": "1a3aa386-a7a7-4bbb-bec4-aadc95ff6156",
      "name": "Microsoft SQL",
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=INSERT INTO MensajesWhatsApp (message_id, contenido, fecha, chat_id, instance)\nVALUES (\n  '{{ $('Parametrización').first().json.message.id }}',\n  '{{ $json.message.conversation.replace(/'/g, \"''\") }}',\n  FORMAT(SWITCHOFFSET(GETDATE(), '-05:00'), 'yyyy-MM-dd HH:mm:ss'),\n  'agenteAI',\n  '{{ $('Parametrización').first().json.message.chat.instance }}'\n);"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        -11280,
        -3104
      ],
      "id": "e31ad858-f06b-4fc9-918d-3dd888d369a7",
      "name": "Microsoft SQL1",
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=INSERT INTO MensajesWhatsApp (message_id, contenido, fecha, chat_id, instance)\nVALUES (\n  '{{ $('Parametrización').first().json.message.id }}',\n  '{{ $json.message.conversation.replace(/'/g, \"''\") }}',\n  FORMAT(SWITCHOFFSET(GETDATE(), '-05:00'), 'yyyy-MM-dd HH:mm:ss'),\n  'agenteAI',\n  '{{ $('Parametrización').first().json.message.chat.instance }}'\n);"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        -11280,
        -2688
      ],
      "id": "e52543ad-7cb5-4c30-bd8a-8ae3207a240b",
      "name": "Microsoft SQL2",
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "amount": 0
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        -10960,
        -2640
      ],
      "id": "51cf16d5-a4e7-45ca-8f0c-d4f15d1111fb",
      "name": "Wait",
      "webhookId": "2d0cc5ee-b809-403d-8de5-06a71a8a40e9"
    },
    {
      "parameters": {
        "operation": "xlsx",
        "binaryPropertyName": "ExcelMallaRecibido2025",
        "options": {
          "sheetName": "={{    (function() {     const semanaActual = $('Unificación y consistencia de datos').item.json.hojaSeleccionada;     const numeroSemana = parseInt(semanaActual.replace(\"SEMANA \", \"\"));     return `SEMANA ${numeroSemana + 1}`;   })() }}"
        }
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -39616,
        -10512
      ],
      "id": "5051533b-1d16-4810-a84d-02c3707cfa8c",
      "name": "Extract MALLA DE RECIBO Semana Siguiente",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Si el nodo anterior no devolvió datos (por error al no existir la hoja), retornamos estructura vacía con mensaje\n// Obtener los datos del Excel\nconst excelData = $input.all();\n\n// Mejora en la detección de errores: verificar si hay error explícito o si los datos no son válidos\nconst hayError = excelData.some(item => item.json && item.json.error);\nconst datosInvalidos = !excelData || excelData.length === 0 || hayError;\n\nif (datosInvalidos) {\n  return [{\n    datosMallaProxSemana: {\n      titulo: \"⚠️ La malla de la próxima semana no existe en el archivo Excel o aún no ha sido creada.\",\n      año: \"\",\n      semana: \"\",\n      rangoDias: \"\",\n      franjas: [],\n      dias: {\n        lunes: { muelle1: {}, muelle2: {} },\n        martes: { muelle1: {}, muelle2: {} },\n        miércoles: { muelle1: {}, muelle2: {} },\n        jueves: { muelle1: {}, muelle2: {} },\n        viernes: { muelle1: {}, muelle2: {} }\n      }\n    },\n    funciones: {\n      consultarFranjasDisponibles: \"function not available\",\n      consultarCitasProveedor: \"function not available\",\n      obtenerInfoMalla: \"function not available\",\n      estaDisponible: \"function not available\",\n      obtenerCoordenadasCita: \"function not available\"\n    }\n  }];\n}\n\n// El resto del código permanece igual...\nconst hojaSeleccionada = $('Unificación y consistencia de datos').first().json.hojaSeleccionada;\n\n// Definir estructura de la semana y los días\nconst diasSemana = ['lunes', 'martes', 'miércoles', 'jueves', 'viernes'];\n\n// Objeto para almacenar la malla estructurada\nconst mallaEstructurada = {\n  titulo: \"\",\n  año: \"\",\n  semana: \"\",\n  rangoDias: \"\",\n  franjas: [],\n  dias: {}\n};\n\n// Tabla de meses y días. Ajusta si necesitas contemplar bisiestos, etc.\nconst meses = {\n  \"enero\": 1,\n  \"febrero\": 2,\n  \"marzo\": 3,\n  \"abril\": 4,\n  \"mayo\": 5,\n  \"junio\": 6,\n  \"julio\": 7,\n  \"agosto\": 8,\n  \"septiembre\": 9,\n  \"octubre\": 10,\n  \"noviembre\": 11,\n  \"diciembre\": 12\n};\n\nconst nombreMes = {\n  1: \"enero\",\n  2: \"febrero\",\n  3: \"marzo\",\n  4: \"abril\",\n  5: \"mayo\",\n  6: \"junio\",\n  7: \"julio\",\n  8: \"agosto\",\n  9: \"septiembre\",\n  10: \"octubre\",\n  11: \"noviembre\",\n  12: \"diciembre\"\n};\n\n/**\n * Función para determinar si un año es bisiesto\n * Un año es bisiesto si es divisible por 4, excepto aquellos divisibles por 100 \n * que no son divisibles por 400\n */\nfunction esBisiesto(year) {\n  return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);\n}\n\n/**\n * Función para obtener el número de días en un mes, considerando años bisiestos\n */\nfunction getDiasMes(mes, año) {\n  const diasPorMes = {\n    1: 31, // enero\n    2: esBisiesto(año) ? 29 : 28, // febrero - ajustado para año bisiesto\n    3: 31, // marzo\n    4: 30, // abril\n    5: 31, // mayo\n    6: 30, // junio\n    7: 31, // julio\n    8: 31, // agosto\n    9: 30, // septiembre\n    10: 31, // octubre\n    11: 30, // noviembre\n    12: 31  // diciembre\n  };\n  \n  return diasPorMes[mes];\n}\n\n/**\n * Función para eliminar acentos y pasar a minúsculas (para buscar palabras clave sin importar tildes ni mayúsculas).\n */\nfunction normalizarTexto(texto) {\n  if (typeof texto !== 'string') return \"\";\n  // Normaliza (NFD) y elimina diacríticos, luego pasa a minúsculas.\n  return texto\n    .normalize(\"NFD\")\n    .replace(/[\\u0300-\\u036f]/g, \"\") // quita acentos\n    .toLowerCase();\n}\n\n/**\n * Dada la información de proveedor, ordenCompra, peso, categoría y unidades,\n * revisa si existe la palabra 'fuera de servicio', 'cancelado' o 'reagendado'\n * en cualquiera de esos campos. De ser así, retorna ese estado especial;\n * de lo contrario, retorna 'ocupado'.\n * \n * Se ignoran mayúsculas, minúsculas y tildes.\n */\nfunction determinarEstadoOcupado(proveedor, ordenCompra, peso, categoria, unidades) {\n  const conjunto = `${proveedor} ${ordenCompra} ${peso} ${categoria} ${unidades}`;\n  const texto = normalizarTexto(conjunto);\n\n  if (texto.includes(\"fuera de servicio\")) {\n    return \"fuera de servicio\";\n  }\n  if (texto.includes(\"cancelado\")) {\n    return \"cancelado\";\n  }\n  if (texto.includes(\"reagendado\")) {\n    return \"reagendado\";\n  }\n  return \"ocupado\";  \n}\n\n// -------------------------------------------------------------\n// 1) PROCESAR DATOS (Cabecera, Horas, Muelles, etc.)\n// -------------------------------------------------------------\nfunction procesarDatos(excelData) {\n  // Verificación adicional de datos válidos\n  if (!excelData || !Array.isArray(excelData) || excelData.length === 0) {\n    return {\n      titulo: \"⚠️ La malla de la próxima semana no existe en el archivo Excel o aún no ha sido creada.\",\n      año: \"\",\n      semana: \"\",\n      rangoDias: \"\",\n      franjas: [],\n      dias: {\n        lunes: { muelle1: {}, muelle2: {} },\n        martes: { muelle1: {}, muelle2: {} },\n        miércoles: { muelle1: {}, muelle2: {} },\n        jueves: { muelle1: {}, muelle2: {} },\n        viernes: { muelle1: {}, muelle2: {} }\n      }\n    };\n  }\n  \n  // Intentar mapear datos, con manejo de errores para cada item\n  const datos = excelData.map(item => {\n    try {\n      return item.json || {};\n    } catch (e) {\n      return {};\n    }\n  });\n  \n  // A) Cabecera (Título, Año, Rango)\n  datos.forEach((dato, index) => {\n    // Buscar título\n    if (dato.__EMPTY_2 === \"MALLA DE RECIBO CEDI KONFIE IA\") {\n      mallaEstructurada.titulo = dato.__EMPTY_2;\n      \n      // En la siguiente fila puede estar año, semana, rango\n      if (index + 1 < datos.length) {\n        const datoSiguiente = datos[index + 1];\n        if (datoSiguiente) {\n          // Año\n          if (datoSiguiente.__EMPTY_2 && !isNaN(datoSiguiente.__EMPTY_2)) {\n            mallaEstructurada.año = datoSiguiente.__EMPTY_2;\n          }\n          // Semana\n          Object.entries(datoSiguiente).forEach(([k, v]) => {\n            if (typeof v === 'string' && v.includes(\"SEMANA\")) {\n              mallaEstructurada.semana = v;\n            }\n          });\n          // Rango: p.ej. \"LUNES 31 AL VIERNES 4 DE ABRIL\"\n          Object.entries(datoSiguiente).forEach(([k, v]) => {\n            if (typeof v === 'string' && v.includes(\"LUNES\") && v.includes(\"VIERNES\")) {\n              mallaEstructurada.rangoDias = v;\n            }\n          });\n        }\n      }\n    }\n  });\n  \n  // Si después de procesar no encontramos título, es que no hay malla válida\n  if (!mallaEstructurada.titulo) {\n    mallaEstructurada.titulo = \"⚠️ La malla de la próxima semana no existe en el archivo Excel o aún no ha sido creada.\";\n    return mallaEstructurada;\n  }\n  \n  // B) Detectar franjas horarias (.__EMPTY = fracción de día)\n  const franjasHorarias = [];\n  datos.forEach(dato => {\n    if (\n      dato.__EMPTY !== undefined &&\n      typeof dato.__EMPTY === 'number' &&\n      dato.__EMPTY > 0 &&\n      dato.__EMPTY < 1\n    ) {\n      const totalMin = Math.round(dato.__EMPTY * 24 * 60);\n      const hh = Math.floor(totalMin / 60);\n      const mm = totalMin % 60;\n      \n      let periodo = \"AM\";\n      let hora12 = hh;\n      if (hh >= 12) {\n        periodo = \"PM\";\n        hora12 = (hh === 12 ? 12 : hh - 12);\n      }\n      if (hh === 0) {\n        hora12 = 12;\n      }\n      \n      const horaStr = `${hora12}:${String(mm).padStart(2, '0')} ${periodo}`;\n      franjasHorarias.push({\n        hora: horaStr,\n        indice: datos.indexOf(dato) // fila base\n      });\n    }\n  });\n  franjasHorarias.sort((a, b) => a.indice - b.indice);\n  mallaEstructurada.franjas = franjasHorarias;\n  \n  // C) Detectar muelles (col)\n  const muellesInfo = {};\n  datos.forEach(dato => {\n    Object.entries(dato).forEach(([key, value]) => {\n      if (value === \"MUELLE 01\" || value === \"MUELLE 02\") {\n        const col = parseInt(key.replace(\"__EMPTY_\", \"\"), 10);\n        const muelleKey = (value === \"MUELLE 01\") ? 'muelle1' : 'muelle2';\n        if (!muellesInfo[muelleKey]) {\n          muellesInfo[muelleKey] = [];\n        }\n        muellesInfo[muelleKey].push(col);\n      }\n    });\n  });\n  if (muellesInfo.muelle1) muellesInfo.muelle1.sort((a, b) => a - b);\n  if (muellesInfo.muelle2) muellesInfo.muelle2.sort((a, b) => a - b);\n  \n  // D) Generar los 5 días (lunes-viernes) con su fecha\n  parsearRangoDias();\n  \n  // E) Extraer Citas\n  extraerCitas(datos, muellesInfo);\n  \n  return mallaEstructurada;\n}\n\n/**\n * Parsea la cadena \"LUNES 31 AL VIERNES 4 DE ABRIL\"\n * (o \"LUNES 31 AL VIERNES 04 DE ABRIL\") y maneja el cruce de mes.\n * Ej.: si dayStart=31 y dayEnd=4, la 1ª fecha es 31 de MARZO,\n * luego 1,2,3,4 de ABRIL, en vez de 32,33, etc.\n */\nfunction parsearRangoDias() {\n  const texto = mallaEstructurada.rangoDias;\n  // Regex simple: p.ej. \"31 AL ... 4 DE ABRIL\"\n  // Captura: dayStart, dayEnd, mesFin\n  // Ojo: si dice \"LUNES 31 DE MARZO AL VIERNES 4 DE ABRIL\",\n  // quedará: dayStart=31, dayEnd=4, month=ABRIL (al final).\n  const regex = /(\\d+)\\s+AL\\s+\\D+(\\d+)\\s+DE\\s+(\\w+)/i;\n  const match = regex.exec(texto);\n  \n  // Por defecto, creamos 5 días vacíos sin fecha\n  diasSemana.forEach(d => {\n    mallaEstructurada.dias[d] = {\n      muelle1: {},\n      muelle2: {}\n    };\n  });\n  \n  if (!match) {\n    // Sin coincidencia, dejamos los días sin fecha\n    return;\n  }\n  \n  const dayStart = parseInt(match[1], 10); // 31\n  const dayEnd   = parseInt(match[2], 10); // 4\n  const finalMonthName = match[3].toLowerCase(); // \"abril\"\n  \n  // Convertimos a número\n  const finalMonth = meses[finalMonthName] || 3; // fallback marzo\n  const yearNum = parseInt(mallaEstructurada.año, 10) || 2025;\n  \n  // Función para obtener la fecha formateada\n  function fechaFormateada(d, m, y) {\n    return `${d} de ${nombreMes[m]} de ${y}`;\n  }\n  \n  // Comprobamos cuántos días tiene el mes final, considerando bisiestos\n  const diasMesFinal = getDiasMes(finalMonth, yearNum);\n  // y del mes previo\n  const monthPrev = (finalMonth === 1) ? 12 : finalMonth - 1;\n  const yearPrev = (finalMonth === 1) ? yearNum - 1 : yearNum;\n  \n  // Arreglo final con 5 fechas\n  const fechasDias = [];\n  \n  if (dayStart <= dayEnd) {\n    // Caso \"normal\": todo en el mismo mes\n    let d = dayStart;\n    for (let i = 0; i < 5; i++) {\n      fechasDias.push({\n        diaSem: diasSemana[i],\n        diaNum: d,\n        mesNum: finalMonth,\n        yearNum: yearNum\n      });\n      d++;\n      if (d > diasMesFinal) {\n        d = 1;\n        const nextMonth = finalMonth % 12 + 1;\n        const nextYear = (nextMonth === 1) ? yearNum + 1 : yearNum;\n        fechasDias[fechasDias.length - 1].mesNum = nextMonth;\n        fechasDias[fechasDias.length - 1].yearNum = nextYear;\n      }\n    }\n  } else {\n    // Caso \"cruza de mes\": dayStart > dayEnd\n    let d = dayStart;\n    let m = monthPrev;\n    let y = yearPrev;\n    \n    for (let i = 0; i < 5; i++) {\n      fechasDias.push({\n        diaSem: diasSemana[i],\n        diaNum: d,\n        mesNum: m,\n        yearNum: y\n      });\n      d++;\n      if (d > getDiasMes(m, y)) {\n        d = 1;\n        m = m % 12 + 1;\n        if (m === 1) {\n          y++;\n        }\n      }\n    }\n  }\n  \n  // Ahora volcamos esas 5 fechas en la estructura\n  fechasDias.forEach(fd => {\n    const { diaSem, diaNum, mesNum, yearNum } = fd;\n    mallaEstructurada.dias[diaSem] = {\n      fechaDia: fechaFormateada(diaNum, mesNum, yearNum),\n      muelle1: {},\n      muelle2: {}\n    };\n  });\n  \n  // Inicializamos las franjas a 'disponible'\n  if (mallaEstructurada.franjas.length > 0) {\n    diasSemana.forEach(d => {\n      mallaEstructurada.franjas.forEach(f => {\n        mallaEstructurada.dias[d].muelle1[f.hora] = {\n          estado: \"disponible\",\n          proveedor: \"\",\n          ordenCompra: \"\",\n          peso: \"\",\n          categoria: \"\",\n          unidades: \"\"\n        };\n        mallaEstructurada.dias[d].muelle2[f.hora] = {\n          estado: \"disponible\",\n          proveedor: \"\",\n          ordenCompra: \"\",\n          peso: \"\",\n          categoria: \"\",\n          unidades: \"\"\n        };\n      });\n    });\n  }\n}\n\n/**\n * Función auxiliar: decide a qué día pertenece una columna,\n * corrigiendo 2 columnas de offset (porque 'Extract from XLSX'\n * deja todo desplazado).\n */\nfunction getDayForColumn(colNumber) {\n  // Ajuste de offset +2\n  const realCol = colNumber + 2;\n\n  // Rangos:\n  //  Lunes:      3..8\n  //  Martes:     9..14\n  //  Miércoles: 15..20\n  //  Jueves:    21..26\n  //  Viernes:   27..32\n  if (realCol >= 3 && realCol <= 8) {\n    return \"lunes\";\n  }\n  if (realCol >= 9 && realCol <= 14) {\n    return \"martes\";\n  }\n  if (realCol >= 15 && realCol <= 20) {\n    return \"miércoles\";\n  }\n  if (realCol >= 21 && realCol <= 26) {\n    return \"jueves\";\n  }\n  if (realCol >= 27 && realCol <= 32) {\n    return \"viernes\";\n  }\n  // Si nada coincide, devolvemos null\n  return null;\n}\n\n/**\n * Extraer las citas para cada franja:\n * - Para cada franja, miramos 3 filas:\n *    - Fila base => proveedor\n *    - Fila base+1 => orden\n *    - Fila base+2 => peso, categoría, unidades\n */\nfunction extraerCitas(datos, muellesInfo) {\n  mallaEstructurada.franjas.forEach(franja => {\n    const indiceBase = franja.indice;\n    if (indiceBase < 0 || indiceBase + 2 >= datos.length) {\n      return; // no hay suficientes filas\n    }\n    \n    // Recorremos muelle1, muelle2 y sus columnas\n    const asignarCita = (muelleKey, cols) => {\n      cols.forEach(col => {\n        const provKey = `__EMPTY_${col}`;\n        const filaProv = datos[indiceBase];\n        \n        // Si en esta fila hay un proveedor o algún texto\n        if (\n          filaProv &&\n          typeof filaProv[provKey] === 'string' &&\n          filaProv[provKey].length > 2\n        ) {\n          // Determinar el día real\n          const diaOk = getDayForColumn(col);\n          if (!diaOk || !mallaEstructurada.dias[diaOk]) {\n            return; // si no coincide con ninguno, saltamos\n          }\n          \n          // Recuperar valores para proveedor, ordenCompra y demás\n          const filaOrden = datos[indiceBase + 1];\n          const filaDet = datos[indiceBase + 2];\n          \n          const proveedor = filaProv[provKey] || \"\";\n          const ordenCompra = filaOrden && filaOrden[provKey] ? filaOrden[provKey] : \"\";\n          const peso = filaDet && filaDet[provKey] ? filaDet[provKey] : \"\";\n          const cat  = filaDet && filaDet[`__EMPTY_${col + 1}`] ? filaDet[`__EMPTY_${col + 1}`] : \"\";\n          const und  = filaDet && filaDet[`__EMPTY_${col + 2}`] ? filaDet[`__EMPTY_${col + 2}`] : \"\";\n          \n          // Antes poníamos estado=\"ocupado\" directamente\n          // Ahora verificamos si el texto contiene \"reagendado\", \"cancelado\" o \"fuera de servicio\".\n          const nuevoEstado = determinarEstadoOcupado(proveedor, ordenCompra, peso, cat, und);\n          \n          // Asignamos los datos\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].estado = nuevoEstado;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].proveedor = proveedor;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].ordenCompra = ordenCompra;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].peso = peso;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].categoria = cat;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].unidades = und;\n        }\n      });\n    };\n    \n    if (muellesInfo.muelle1) {\n      asignarCita('muelle1', muellesInfo.muelle1);\n    }\n    if (muellesInfo.muelle2) {\n      asignarCita('muelle2', muellesInfo.muelle2);\n    }\n  });\n}\n\n// -------------------------------------------------------------\n// 2) FUNCIONES PARA CONSULTAR LA MALLA\n// -------------------------------------------------------------\nfunction buscarFranjasDisponibles(categoria, duracionHoras) {\n  const muelle = \"muelle1\"; // Ajusta si usas \"categoria -> muelle\" real\n  \n  const franjasDisponibles = [];\n  Object.keys(mallaEstructurada.dias).forEach(dia => {\n    const libres = [];\n    for (let i = 0; i <= mallaEstructurada.franjas.length - duracionHoras; i++) {\n      let disponible = true;\n      for (let h = 0; h < duracionHoras; h++) {\n        const idxF = i + h;\n        const horaAct = mallaEstructurada.franjas[idxF].hora;\n        if (\n          mallaEstructurada.dias[dia][muelle][horaAct].estado !== 'disponible'\n        ) {\n          disponible = false;\n          break;\n        }\n      }\n      if (disponible) {\n        libres.push({\n          horaInicio: mallaEstructurada.franjas[i].hora,\n          duracion: duracionHoras\n        });\n      }\n    }\n    if (libres.length > 0) {\n      franjasDisponibles.push({ dia, franjas: libres });\n    }\n  });\n  return franjasDisponibles;\n}\n\nfunction buscarCitasProveedor(nombreProveedor) {\n  const citas = [];\n  Object.keys(mallaEstructurada.dias).forEach(dia => {\n    const muelle1 = mallaEstructurada.dias[dia].muelle1;\n    const muelle2 = mallaEstructurada.dias[dia].muelle2;\n    mallaEstructurada.franjas.forEach(f => {\n      const hora = f.hora;\n      // muelle1\n      if (normalizarTexto(muelle1[hora].proveedor) === normalizarTexto(nombreProveedor)) {\n        citas.push({\n          dia,\n          hora,\n          muelle: \"Muelle 01\",\n          ordenCompra: muelle1[hora].ordenCompra,\n          peso: muelle1[hora].peso,\n          categoria: muelle1[hora].categoria,\n          unidades: muelle1[hora].unidades,\n          estado: muelle1[hora].estado\n        });\n      }\n      // muelle2\n      if (normalizarTexto(muelle2[hora].proveedor) === normalizarTexto(nombreProveedor)) {\n        citas.push({\n          dia,\n          hora,\n          muelle: \"Muelle 02\",\n          ordenCompra: muelle2[hora].ordenCompra,\n          peso: muelle2[hora].peso,\n          categoria: muelle2[hora].categoria,\n          unidades: muelle2[hora].unidades,\n          estado: muelle2[hora].estado\n        });\n      }\n    });\n  });\n  return citas;\n}\n\nfunction consultarFranjasDisponibles(categoria, duracionHoras) {\n  return buscarFranjasDisponibles(categoria, duracionHoras);\n}\n\nfunction consultarCitasProveedor(nombreProveedor) {\n  return buscarCitasProveedor(nombreProveedor);\n}\n\nfunction obtenerInfoMalla() {\n  return {\n    titulo: mallaEstructurada.titulo,\n    año: mallaEstructurada.año,\n    semana: mallaEstructurada.semana,\n    rangoDias: mallaEstructurada.rangoDias,\n    franjas: mallaEstructurada.franjas.map(f => f.hora)\n  };\n}\n\nfunction estaDisponible(dia, hora, muelle) {\n  const info = mallaEstructurada.dias[dia]?.[muelle]?.[hora];\n  return info ? (info.estado === 'disponible') : false;\n}\n\nfunction obtenerCoordenadasCita(dia, hora, muelle) {\n  // Ajustar con tu mapeo de celdas en Excel\n  return {\n    proveedor: `${dia}_${hora}_${muelle}_proveedor`,\n    ordenCompra: `${dia}_${hora}_${muelle}_ordenCompra`,\n    peso: `${dia}_${hora}_${muelle}_peso`,\n    categoria: `${dia}_${hora}_${muelle}_categoria`,\n    unidades: `${dia}_${hora}_${muelle}_unidades`\n  };\n}\n\n// -------------------------------------------------------------\n// 3) EJECUTAR TODO Y RETORNAR\n// -------------------------------------------------------------\nconst malla = procesarDatos(excelData);\n\nconst resultado = {\n  datosMallaProxSemana: malla,\n  funciones: {\n    consultarFranjasDisponibles,\n    consultarCitasProveedor,\n    obtenerInfoMalla,\n    estaDisponible,\n    obtenerCoordenadasCita\n  }\n};\n\nreturn [resultado];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -39376,
        -10512
      ],
      "id": "571adb86-788b-445b-895c-70273dc8da9e",
      "name": "Estructuración, Datos, Consulta, Citas Proxima Semana"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -37360,
        -2128
      ],
      "id": "c6de5282-a6a6-45aa-93a4-6b2bb45171af",
      "name": "OpenAI Chat Model6",
      "credentials": {
        "openAiApi": {
          "id": "AD8kPcNVReuclASd",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "=define",
        "text": "=### SISTEMA\nEres un asistente experto en logística de bodegas. Tu tarea es **responder cuando un proveedor consulta la disponibilidad de citas para entregar mercancía**, a través de WhatsApp. Debes ser sensible al **día y hora** en que se recibe la consulta para dar información precisa sobre la disponibilidad general.\n\nDebes revisar cuidadosamente:\n- El mensaje actual del proveedor.\n- El historial de mensajes recientes.\n- El historial de citas del proveedor (si lo hay).\n- **IMPORTANTE: El día y la hora actual de la consulta.**\n\nY con base en eso, generar una respuesta que sea:\n- **Amable, empática, clara y conversacional.**\n- **Breve pero informativa**, explicando correctamente la disponibilidad general **según el momento de la consulta**.\n- Que explique que para ofrecer opciones reales y exactas se requiere **información clave**.\n- Que **invite de forma cordial** a compartir los datos necesarios para avanzar.\n- Que **aclare al proveedor que si desea agendar la cita**, esos datos son obligatorios.\n\n**NUEVO: Considera el día y la hora actual para determinar la disponibilidad general:**\n- **Entradas Requeridas (provistas por el sistema externo):**\n    - Hoy es `{{ new Date().toLocaleDateString(\"es-CO\", { timeZone: \"America/Bogota\", weekday: \"long\" }) }}`: Día de la semana actual (Lunes, Martes, Miércoles, Jueves, Viernes, Sábado, Domingo).\n    -La hora actual es `{{ new Date().toLocaleTimeString(\"es-CO\", { timeZone: \"America/Bogota\", hour: \"numeric\", minute: \"2-digit\", hour12: true }) }}`: Hora actual en formato HHMM (ej. 0900 para 9:00 AM, 1630 para 4:30 PM).\n- **Reglas de Disponibilidad General:**\n    - **Regla 1:** Si es **Lunes, Martes, Miércoles** O (es **Jueves** Y la hora es **antes de 1630**): Hay disponibilidad general para la semana **actual y la próxima**.\n    - **Regla 2:** Si (es **Jueves** Y la hora es **1630 o posterior**) O es **Viernes**: La disponibilidad general es solo para la **próxima semana**.\n    - **Regla 3:** Si es **Sábado o Domingo**: La disponibilidad general es solo para la **próxima semana**.\n\n---\n### MENSAJE ACTUAL DEL PROVEEDOR:\n{{ $node[\"Unificación y consistencia de datos\"].json[\"infoMensaje\"][\"mensajeActual\"] }}\n---\n### HISTORIAL DE MENSAJES:\n{{ $node[\"Unificación y consistencia de datos\"].json[\"infoMensaje\"][\"historialMensajes\"] }}\n---\n### 📆 HISTORIAL DE CITAS DEL PROVEEDOR:\n{{ $node[\"Unificación y consistencia de datos\"].json[\"infoMensajecita\"][\"historialCitas\"] }}\n---\n### CATEGORÍAS:\n```json\n{{ JSON.stringify($json.datoscategorias, null, 2) }}\n```\n\n## 🎯 OBJETIVO\nGenera una respuesta siguiendo estos pasos:\n\n### Saluda amablemente y explica la disponibilidad general APLICANDO LAS REGLAS de día/hora:\n\n- **Si aplica la Regla 1** (Lunes-Miércoles, Jueves < 16:30): Usa una frase como:\n  > ¡Hola! Gracias por escribirnos 😊. Te confirmo que tenemos disponibilidad general para agendar entregas tanto en la semana actual como en la próxima. Para poder mostrarte los horarios específicos y ayudarte a programar tu cita, necesito que me confirmes algunos datos clave.\n\n- **Si aplica la Regla 2** (Jueves >= 16:30, Viernes): Usa una frase adaptada al día.\n  - Si es Jueves tarde:\n    > ¡Hola! Gracias por escribirnos 😊. Te comento que, por la hora, la disponibilidad de citas ya es para la próxima semana. Para poder mostrarte los horarios específicos y ayudarte a programar tu cita, necesito que me confirmes algunos datos clave.\n  - Si es Viernes:\n    > ¡Hola! Gracias por escribirnos 😊. Te comento que, al ser hoy viernes, la disponibilidad de citas ya es para la próxima semana. Para poder mostrarte los horarios específicos y ayudarte a programar tu cita, necesito que me confirmes algunos datos clave.\n\n- **Si aplica la Regla 3** (Sábado, Domingo): Usa una frase como:\n  > ¡Hola! Gracias por escribirnos 😊. Ya que nos contactas en fin de semana, la disponibilidad de citas es a partir de la próxima semana. Para poder mostrarte los horarios específicos y ayudarte a programar tu cita, necesito que me confirmes algunos datos clave.\n\n### Después de la frase de disponibilidad, muestra en forma de mini lista amigable estructurada los datos requeridos para agendar:\n\n> 📝 Por favor indícame la siguiente información:\n> • Nombre del proveedor (En lo posible nombre completo y legible)\n> • Fecha deseada para la entrega (ej. 16 de abril)\n> • Hora de entrega (ej. 9:00 AM, 10:00 AM)\n> • Categoría del producto (puedes elegir entre las siguientes disponibles: {{ $json.datoscategorias.map(cat => cat.CATEGORIA).join(', ') }})\n> • Peso estimado en kilos\n> • Número de unidades (en número entero)\n> • Número de orden de compra\n\n### Cierra el mensaje con una frase amable que motive a continuar:\n\n> Con esta información, el sistema podrá mostrarte las franjas disponibles y ayudarte a agendar tu cita rápidamente. Estoy aquí para ayudarte en todo el proceso. 💪\n---\n### 📌 RESPUESTA FORMATO JSON\n```json\n{\n  \"mensajeSistema\": \"¡Hola! Gracias por escribirnos 😊. Actualmente tenemos disponibilidad para agendar entregas durante esta semana y la próxima. Para poder mostrarte horarios específicos, necesito que me confirmes algunos datos:\n\n📝 Por favor indícame la siguiente información:\n• Nombre del proveedor (En lo posible nombre completo y legible)\n• Fecha deseada para la entrega (ej. 16 de abril)\n• Hora de entrega (ej. 9:00 AM, 10:00 AM)\n• Categoría del producto (puedes elegir entre las siguientes disponibles: {{ $json.datoscategorias.map(cat => cat.CATEGORIA).join(', ') }})\n• Peso estimado en kilos\n• Número de unidades (en número entero)\n• Número de orden de compra\n\nCon esta información, el sistema podrá mostrarte las franjas disponibles y ayudarte a agendar tu cita rápidamente. Estoy aquí para ayudarte en todo el proceso. 💪\"\n}\n```"
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        -37280,
        -2320
      ],
      "id": "07c0850d-884b-492b-a5b1-8e1c0d09fbde",
      "name": "Basic LLM CONSULTAR MALLA"
    },
    {
      "parameters": {
        "url": "https://graph.microsoft.com/v1.0/drives/b!hviSpWBFYk6WRh7uet16vnNAUYuuQRlGj3ZyS9kSvGVZ4DSg6c5MRqYYm2MdAER8/items/01PPLUUYTWY3753ZJ6ERAZ6LQBYUR2JOTY/content",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "microsoftOAuth2Api",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "file",
              "outputPropertyName": "MallaFija"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -41424,
        -2320
      ],
      "id": "d3b7fa32-19b3-426c-9134-329554b62376",
      "name": "HTTP Request Malla Fija1",
      "credentials": {
        "microsoftOAuth2Api": {
          "id": "mh8Z8hxFvd7LDO8D",
          "name": "CuentaMy SharePoint App Desarrollador1 Konfie "
        }
      }
    },
    {
      "parameters": {
        "operation": "xlsx",
        "binaryPropertyName": "MallaFija",
        "options": {
          "sheetName": "Categorias"
        }
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -37840,
        -2320
      ],
      "id": "0284d8f2-a1c1-407b-92a5-1f2344267793",
      "name": "Extract from Categorias1"
    },
    {
      "parameters": {
        "jsCode": "// Obtener todos los items de la entrada\nconst items = $input.all();\nconst categorias = [];\n\n// Mapa para verificar categorías duplicadas\nconst categoriasMap = new Map();\n\n// Recorrer cada ítem de la entrada de categorías\nfor (const item of items) {\n  // Obtener los datos originales\n  const originalData = item.json;\n  \n  // Extraer categoría y muelle\n  const categoria = originalData.CATEGORIA || \"\";\n  const muelle = originalData.MUELLE || \"\";\n  \n  // Solo procesar si tanto la categoría como el muelle tienen valor\n  if (categoria && muelle) {\n    // Verificar si esta categoría ya existe en nuestro mapa\n    if (categoriasMap.has(categoria)) {\n      console.log(`Advertencia: La categoría \"${categoria}\" está duplicada. Se ignorará la segunda aparición.`);\n      continue; // Saltar este elemento\n    }\n    \n    // Agregar al mapa para control de duplicados\n    categoriasMap.set(categoria, muelle);\n    \n    // Agregar el objeto al array de categorías\n    categorias.push({\n      \"CATEGORIA\": categoria,\n      \"MUELLE\": muelle\n    });\n  } else {\n    console.log(`Advertencia: Elemento ignorado por falta de categoría o muelle: ${JSON.stringify(originalData)}`);\n  }\n}\n\n// Retornar un único objeto que contiene el array de categorías\n// dentro de un parámetro global llamado \"datoscategorias\"\nreturn [\n  {\n    json: {\n      datoscategorias: categorias\n    }\n  }\n];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -37600,
        -2320
      ],
      "id": "73414e81-9506-4766-8090-7b265c8d71c3",
      "name": "Estructuración, Consulta, Datos Categorias1"
    },
    {
      "parameters": {
        "jsCode": "// Obtener la respuesta generada por el LLM\nconst entrada = $input.item.json;\n\ntry {\n  // Extraer el bloque de texto generado\n  const texto = entrada.text;\n\n  // Buscar el contenido entre los delimitadores de bloque ```json\n  const match = texto.match(/```json\\s*([\\s\\S]*?)\\s*```/);\n\n  if (match && match[1]) {\n    const jsonParsed = JSON.parse(match[1]);\n\n    return [\n      {\n        json: {\n          mensaje: jsonParsed.mensajeSistema || \"No se pudo obtener el mensaje.\"\n        }\n      }\n    ];\n  } else {\n    throw new Error(\"No se encontró contenido JSON en el texto.\");\n  }\n} catch (error) {\n  return [\n    {\n      json: {\n        mensaje: \"Ocurrió un error al procesar la respuesta del asistente: \" + error.message\n      }\n    }\n  ];\n}\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -36864,
        -2320
      ],
      "id": "66dcc4c9-4199-45fb-aaa2-1b491c27ecb9",
      "name": "Consistencia de datos, intención consultar malla"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "b2110549-dd58-46b3-9707-dbbe0a5004f2",
              "leftValue": "={{ $('Consistencia de datos, intención consultar malla').item.json.mensaje.length }}",
              "rightValue": 70,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -36640,
        -2320
      ],
      "id": "f37a0728-f3dc-409c-a5ea-da9211fa26c6",
      "name": "Validación de longitud de caracteres1"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -36096,
        -2400
      ],
      "id": "e351e5de-4e14-4070-9f29-8ac95983d8b6",
      "name": "No Operation, do nothing3"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $('Consistencia de datos, intención consultar malla').item.json.mensaje }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -36288,
        -2400
      ],
      "id": "724b5cd1-aaea-4238-ac2b-92fd83e77c82",
      "name": "HTTP Request Enviar Mensaje por WhatsApp4"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d9c2ff70-4fd1-4b93-8571-6d0ac5a0093e",
              "name": "mensaje.ia",
              "value": "={{ $('Consistencia de datos, intención consultar malla').item.json.mensaje }}",
              "type": "string"
            },
            {
              "id": "ac8a03be-0292-4735-9580-39a385945c47",
              "name": "mensaje.longitud",
              "value": "={{ $('Consistencia de datos, intención consultar malla').item.json.mensaje.length }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -36288,
        -2208
      ],
      "id": "94ddd372-bae8-40c9-8c7c-81c17cc2f8ed",
      "name": "Organiza variables del mensaje1"
    },
    {
      "parameters": {
        "jsCode": "// Estructura el mensaje generado por el modelo LLM (SALUDO)\n// Este nodo espera que el campo `text` contenga un JSON válido con una clave `mensajeSistema`,\n// incluso si viene envuelto entre comillas invertidas y etiquetas de bloque tipo ```json ... ```\n\nconst items = $input.all();\nconst output = [];\n\nfor (const item of items) {\n  try {\n    let raw = item.json.text.trim();\n\n    // Elimina etiquetas de bloque Markdown ```json y ```\n    raw = raw.replace(/```json\\s*|```/g, '');\n\n    // Intenta parsear el contenido limpio como JSON\n    const respuesta = JSON.parse(raw);\n\n    output.push({\n      json: {\n        mensajeParaEnviar: respuesta.mensajeSistema || \"¡Hola! Soy tu asistente para gestión de citas en la bodega. ¿En qué puedo ayudarte?\",\n        tipo: \"saludo\",\n        accion: \"conversacion\",\n        origen: \"intencionSaludo\"\n      }\n    });\n\n  } catch (error) {\n    output.push({\n      json: {\n        error: true,\n        mensaje: \"Error al interpretar la respuesta del modelo LLM\",\n        detalle: error.message,\n        contenidoOriginal: item.json.text\n      }\n    });\n  }\n}\n\nreturn output;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -39408,
        -11648
      ],
      "id": "0ce0ad9c-cfd8-4c65-bbc7-af8c9bee9a1c",
      "name": "Estructuración, Consulta, Datos Categorias2"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "b2110549-dd58-46b3-9707-dbbe0a5004f2",
              "leftValue": "={{ $('Estructuración, Consulta, Datos Categorias2').item.json.mensajeParaEnviar.length }}",
              "rightValue": 70,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -39072,
        -11648
      ],
      "id": "3b2c0cbc-3690-49e0-b2ba-8f7a01007c49",
      "name": "Validación de longitud de caracteres2"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -38528,
        -11792
      ],
      "id": "5eda3851-ffa2-4999-a338-af9c651e67d6",
      "name": "No Operation, do nothing4"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $('Estructuración, Consulta, Datos Categorias2').item.json.mensajeParaEnviar }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -38704,
        -11792
      ],
      "id": "293edd39-2f95-4e3e-8223-8acc61f6e7fe",
      "name": "HTTP Request Enviar Mensaje por WhatsApp5"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d9c2ff70-4fd1-4b93-8571-6d0ac5a0093e",
              "name": "mensaje.ia",
              "value": "={{ $('Estructuración, Consulta, Datos Categorias2').item.json.mensajeParaEnviar }}",
              "type": "string"
            },
            {
              "id": "ac8a03be-0292-4735-9580-39a385945c47",
              "name": "mensaje.longitud",
              "value": "={{ $('Estructuración, Consulta, Datos Categorias2').item.json.mensajeParaEnviar.length }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -34256,
        -11664
      ],
      "id": "faadd877-d51d-4166-ab17-9a5bcfb9159b",
      "name": "Organiza variables del mensaje2"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -35888,
        -10592
      ],
      "id": "3052300d-585a-4b63-ab6c-1268a13e54fd",
      "name": "OpenAI Chat Model7",
      "credentials": {
        "openAiApi": {
          "id": "AD8kPcNVReuclASd",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "=define",
        "text": "=# SISTEMA\n\nEres un asistente experto en logística de bodegas, especializado en verificar disponibilidad de franjas horarias para citas de descarga de mercancía. Tu función es:\n\n1. **Utilizar los datos estructurados** proporcionados por el nodo anterior.\n2. **Validar y corregir posibles inconsistencias** en los datos recibidos.\n3. **Analizar la información del proveedor y sus características** (rotación, unidades por hora, etc.).\n4. **Verificar las franjas disponibles** y alternativas presentadas.\n5. **Generar un mensaje claro, amable y conversacional** informando el resultado de la verificación.\n6. **Presentar la respuesta en una estructura JSON específica** que será procesada por el siguiente nodo.\n\n---\n\n## 📌 DATOS DE ENTRADA (YA PROCESADOS):\n\n```json\n{{JSON.stringify($node[\"Code MOSTRAR_FRANJAS\"].json.output, null, 2)}}\n```\n\n## 🕓 FECHA Y HORA ACTUAL (BOGOTÁ, COLOMBIA):\n\n```\n{{new Date().toLocaleString(\"es-CO\", { timeZone: \"America/Bogota\", hour12: true })}}\n```\n\n## CANTIDAD DE FRAJAS DE LA MALLA DE LA SEMANA ACTUAL:\n\n```\n{{ $('Unificación y consistencia de datos1').item.json.datosMalla.franjas.length }}\n```\n\n## CANTIDAD DE FRAJAS DE LA MALLA DE LA PROXIMA SEMANA:\n\n```\n{{ $('Unificación y consistencia de datos1').item.json.datosMallaProxSemana.franjas.length }}\n```\n\n---\n\n## 🧮 VALIDACIÓN Y CORRECCIÓN DE DATOS DE ENTRADA:\n\n**Validaciones Generales:**\n\n- **Validar disponibilidadConfirmada:** Debe ser un booleano (true/false). Si es nulo o no está definido, asume false.\n- **Validar fecha:** Debe tener formato \"DD de mes de YYYY\". Si hay un formato diferente, mantenlo tal cual, pero asegúrate de generar un mensaje coherente.\n- **Validar horas:** Deben tener formato \"H:MM AM/PM\". Si hay formatos diferentes o inconsistentes entre horaInicio y horaFin, mantenlos tal cual pero genera un mensaje coherente.\n- **Validar duracionHoras:** Debe ser un número entero positivo. Si es decimal, redondea hacia arriba. Si falta, calcula aproximadamente basándote en horaInicio y horaFin.\n- **Validar muelle:** Debe ser \"MUELLE X\" donde X es un número. Si tiene otro formato, mantenlo tal cual.\n- **Validar alternativasDisponibles:** Debe ser un array. Si es nulo, conviértelo en array vacío [].\n- **Validar restriccionHoraSuperada:** Debe ser un booleano. Si es nulo, asume false.\n\nSi detectas errores graves en los datos de entrada (datos completamente faltantes o corruptos), genera un mensaje informando del problema y solicitando intentar nuevamente.\n\nSi se incluyen datos del proveedor, utilízalos para personalizar el mensaje mencionando el nombre del proveedor y sus características relevantes.\n\n---\n\n## 🗣️ REGLAS PARA LA REDACCIÓN DEL MENSAJE:\n\n**IMPORTANTE:** Siempre comunica claramente que la cita NO está confirmada aún, sino que hay disponibilidad para agendarla pero requiere confirmación del usuario para que se genere oficialmente en el cronograma.\n\n### Para citas disponibles (disponibilidadConfirmada = true):\n\n- Usa expresiones como \"¡Genial!\", \"¡Buenas noticias!\" para iniciar el mensaje\n- Clarifica que \"hay espacio para agendar esta cita\" (NO que \"la cita está programada\")\n- Menciona la fecha, hora inicio, hora fin y muelle de manera clara\n- Si tienes datos sobre la duración \"cantidad\" en horas, menciona que es el tiempo asignado para el descargue de la mercancía\n- Especifica que \"el sistema pide una confirmación de tu parte para que la cita se genere en el cronograma\"\n- Solicita explícitamente \"por favor responde confirmando la cita\"\n- Recuerda el límite de 5 minutos para confirmar, explicando que \"de lo contrario no se puede garantizar el cupo solicitado en el cronograma\"\n\n### Para citas con restricción de hora (restriccionHoraSuperada = true):\n\n- Explica amablemente la restricción (no agendar para el día siguiente después de 4:30 PM)\n- Presenta todas las alternativas organizadas por día\n- **MODIFICADO:** Muestra cada alternativa en una línea separada, con emojis numéricos (1️⃣, 2️⃣, 3️⃣, etc.) para cada opción\n- Especifica horas y muelle para cada alternativa\n- Agrega un salto de línea doble después de listar todas las alternativas\n- Precede la solicitud de confirmación con el emoji ✏️\n- Aclara que se necesita confirmación para apartar el espacio en el cronograma\n- Recuerda el límite de 5 minutos para confirmar\n\n### Para citas con restricción de hora (restriccionHoraSuperada = true):\n\n- Explica amablemente la restricción (no agendar para el día siguiente después de 4:30 PM)\n- Presenta todas las alternativas organizadas por día\n- **MODIFICADO:** Muestra cada alternativa en una línea separada, con emojis numéricos (1️⃣, 2️⃣, 3️⃣, etc.) para cada opción\n- Especifica horas y muelle para cada alternativa\n- Agrega un salto de línea doble después de listar todas las alternativas\n- Precede la solicitud de confirmación con el emoji ✏️\n- Aclara que se necesita confirmación para apartar el espacio en el cronograma\n- Recuerda el límite de 5 minutos para confirmar\n\n### Para citas no disponibles (disponibilidadConfirmada = false, restriccionHoraSuperada = false):\n\n**ANTES de procesar alternativas, verifica descarga sobredimensionada:**\n- Utilizando la FECHA Y HORA ACTUAL y la fecha de la cita solicitada, determina si la cita es para la semana en curso o la próxima\n- Compara el valor de `duracionHoras` con la cantidad de franjas correspondiente (semana actual o próxima)\n- Si `duracionHoras` es MAYOR que la cantidad de franjas diarias permitidas, aplica el mensaje de \"descarga sobredimensionada\" (ver abajo) y NO muestres alternativas\n- Si NO excede la capacidad, procede normalmente con las alternativas\n\n**Para descarga sobredimensionada:**\n- Informa que la franja solicitada no está disponible\n- Explica: **\"ya que la cantidad de mercancía que se intenta descargar excede un día entero de descargue\"**\n- **NO ofrezcas alternativas**\n- Recomienda contactar directamente con el área de logística\n- `disponibilidadConfirmada = false` y `alternativasDisponibles = []`\n\n**Para proceso normal (cuando NO excede capacidad):**\n- Lamenta que la franja solicitada no esté disponible\n- Presenta las alternativas después de un salto de línea doble\n- **MODIFICADO:** Muestra cada alternativa en una línea separada, con emojis numéricos (1️⃣, 2️⃣, 3️⃣, etc.) para cada opción\n- **MODIFICADO:** El formato exacto para cada alternativa debe ser: \"[emoji numérico] [fecha], de [horaInicio] a [horaFin] en el [muelle]\"\n- Agrega un salto de línea doble después de listar todas las alternativas\n- Precede la solicitud de confirmación con el emoji ✏️\n- Aclara que se necesita confirmación para apartar el espacio en el cronograma\n- Recuerda el límite de 5 minutos para confirmar\n\n### Para citas con \"descarga sobredimensionada\" (cuando duracionHoras excede la capacidad diaria):\n\n**SOLO aplica este caso cuando:**\n- `disponibilidadConfirmada = false`\n- `restriccionHoraSuperada = false` \n- `duracionHoras` > cantidad de franjas diarias permitidas\n\n**Mensaje específico:**\n- Informa que la franja solicitada no está disponible\n- Explica la razón específica: **\"ya que la cantidad de mercancía que se intenta descargar excede un día entero de descargue\"**\n- **NO ofrezcas alternativas**, ya que el problema es el volumen de la carga, no el horario\n- Recomienda contactar directamente con el área de logística para explorar otras opciones, como dividir la entrega\n- En este caso, `disponibilidadConfirmada` debe ser false y `alternativasDisponibles` debe ser un array vacío []\n\n**Ejemplo de mensaje:** \n> \"Lamentablemente, la franja solicitada para el [fecha], de [horaInicio] a [horaFin] en el [muelle] no está disponible, ya que la cantidad de mercancía que se intenta descargar excede un día entero de descargue. Te recomiendo contactar directamente con el área de logística para explorar otras opciones.\"\n\n### Para citas sin alternativas disponibles:\n\n- Si no hay alternativas, informa claramente la situación\n- Recomienda contactar directamente con el área de logística\n- Sugiere intentar en otro momento\n- Puedes apoyarte en tu respuesta a partir de la respuesta de la recolección de datos \"{{ $('Code RECOLECCIÓN').item.json.mensajeSistema }}\"\n\n### Personalización del mensaje:\n\n- Si tienes datos del proveedor, menciona su nombre\n- Si tienes información sobre las unidades a entregar, inclúyela para explicar el tiempo asignado\n- Si conoces la categoría del producto, utilízala para contextualizar\n\n### Tono y estilo:\n\n- Usa un tono conversacional, humano y cercano\n- Incluye frases como \"viendo el cronograma me registra que...\", \"por la cantidad de unidades y peso en promedio va a tardar...\"\n- Evita frases formales o rígidas como \"Se ha encontrado una franja disponible\"\n- Estructura el mensaje para que fluya naturalmente como una conversación\n\n### MODIFICADO - EJEMPLO DE FORMATO PARA ALTERNATIVAS (cuando disponibilidadConfirmada = false):\n\n\"Lamentablemente, la franja solicitada para el 06 de mayo de 2025, de 08:00 AM a 10:00 AM en el MUELLE 1 no está disponible. Sin embargo, tengo algunas alternativas para ti:\n\n1️⃣ 06 de mayo de 2025, de 6:00 AM a 8:00 AM en el MUELLE 1\n2️⃣ 06 de mayo de 2025, de 10:00 AM a 12:00 PM en el MUELLE 1\n3️⃣ 06 de mayo de 2025, de 11:00 AM a 1:00 PM en el MUELLE 1\n4️⃣ 06 de mayo de 2025, de 12:00 PM a 2:00 PM en el MUELLE 1\n\n✏️ Necesito tu confirmación para apartar el espacio en el cronograma, y recuerda que el sistema nos da 5 minutos para confirmar la cita o de lo contrario no se puede garantizar el cupo solicitado.\"\n\n---\n\n## 🧾 ESTRUCTURA DE SALIDA REQUERIDA\n\nDebes devolver una estructura JSON con exactamente estos campos:\n\n```json\n{\n  \"disponibilidadConfirmada\": boolean,\n  \"fecha\": string,\n  \"horaInicio\": string,\n  \"horaFin\": string,\n  \"muelle\": string,\n  \"duracionHoras\": number,\n  \"restriccionHoraSuperada\": boolean,\n  \"alternativasDisponibles\": array,\n  \"mensajeSistema\": string\n}\n```\n\n---\n\n## ✅ VALIDACIONES FINALES ANTES DE ENVIAR LA RESPUESTA:\n\n- Verifica que todos los campos obligatorios estén presentes en tu respuesta.\n- Asegúrate de que los tipos de datos sean correctos (boolean para booleanos, string para texto, number para números, array para arreglos).\n- Comprueba que la estructura JSON sea válida y esté correctamente formateada.\n- Verifica que el campo `mensajeSistema` sea coherente con los demás campos (ej: si disponibilidadConfirmada=true, el mensaje debe indicar que hay espacio disponible pero requiere confirmación, NO que la cita ya está programada).\n- Asegúrate de que `alternativasDisponibles` sea un array, incluso si está vacío.\n- **MODIFICADO:** Verifica que cuando existen alternativas, cada una aparezca en su propia línea con el emoji numérico correspondiente.\n- **MODIFICADO:** Verifica que la solicitud de confirmación aparezca después de un salto de línea doble y precedida por el emoji ✏️.\n- Si utilizas caracteres especiales o saltos de línea en `mensajeSistema`, verifica que estén correctamente escapados en el JSON.\n- Revisa que el mensaje comunique claramente que la cita NO está confirmada aún.\n\n---\n\n## IMPORTANTE:\n\n- **NO uses bloques de código markdown** como ```json.\n- **NO agregues ningún texto** antes ni después.\n- **SOLO responde con un objeto JSON plano.**\n- El contenido debe empezar directamente con `{` y terminar con `}`.\n- El JSON debe cumplir con el siguiente formato y campos obligatorios:\n\n```json\n{\n  \"disponibilidadConfirmada\": boolean,\n  \"fecha\": string,\n  \"horaInicio\": string,\n  \"horaFin\": string,\n  \"muelle\": string,\n  \"duracionHoras\": number,\n  \"restriccionHoraSuperada\": boolean,\n  \"alternativasDisponibles\": array,\n  \"mensajeSistema\": string\n}\n```\n\n---\n\n## EJEMPLO DE MENSAJE IDEAL PARA DISPONIBILIDAD CONFIRMADA:\n\n\"¡Genial! Viendo el cronograma me registra que sí hay espacio para agendar esta cita, sería para el 15 de abril de 2025, desde las 9:00 AM hasta las 12:00 PM ya que por la cantidad de unidades y peso en promedio va a tardar 3 horas el descargue en el MUELLE 1. El sistema pide una confirmación de tu parte para que la cita se genere en el cronograma, por favor responde confirmando la cita y recuerda que el sistema nos da 5 minutos para confirmar la cita o de lo contrario no se puede garantizar el cupo solicitado en el cronograma.\""
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        -35808,
        -10784
      ],
      "id": "089acdad-a124-4e42-b727-1d8289639071",
      "name": "Basic LLM Chain MOSTRAR_FRANJAS"
    },
    {
      "parameters": {
        "promptType": "=define",
        "text": "=### SISTEMA\nEres un asistente especializado en extraer datos de citas de entrega de mercancía a partir del historial de conversaciones entre un proveedor y un sistema de agendamiento. Tu función es:\n1. **Analizar el historial completo de mensajes** entre el proveedor y el sistema.\n2. **Identificar y extraer los datos finales validados** para la cita de entrega.\n3. **Estructurar estos datos** en un formato JSON claro y consistente para su procesamiento posterior.\n---\n### 🗂️ HISTORIAL DE MENSAJES:\n{{ $node[\"Unificación y consistencia de datos\"].json[\"infoMensaje\"][\"historialMensajes\"] }}\n\n### 📩 MENSAJE DE CONFIRMACIÓN DEL SISTEMA:\n{{ $json.mensajeSistema }}\n\n### 🕓 FECHA Y HORA ACTUAL (BOGOTÁ, COLOMBIA):\n{{ new Date().toLocaleString(\"es-CO\", { timeZone: \"America/Bogota\", hour12: true }) }}\n---\n### ✅ DATOS A EXTRAER:\n\n**REGLA CRÍTICA PARA NOMBRES DE PROVEEDORES:**\n- Al mencionar el nombre del proveedor en el mensajeSistema, NUNCA agregues puntos, comas o signos de puntuación adicionales al final del nombre\n- El nombre del proveedor debe aparecer exactamente como está en la base de datos, sin modificaciones de puntuación\n- Ejemplo correcto: \"SPB COLOMBIA S.A.S\" (sin punto adicional)\n- Ejemplo incorrecto: \"SPB COLOMBIA S.A.S.\" (con punto adicional)\n\n- **Nombre del proveedor**: El nombre validado y confirmado (debe ser el nombre exacto que aparece en los registros).\n- **Fecha de la cita**: La fecha validada para la entrega (en formato \"DD de [mes] de YYYY\").\n- **Hora de la cita**: La hora validada para la entrega (en formato estándar, ej. \"10:00 AM\").\n- **Categoría del producto**: La categoría validada y confirmada.\n- **Peso estimado**: El peso en kilos.\n- **Número de unidades**: La cantidad de unidades a entregar.\n- **Número de orden de compra**: El número de referencia para la orden.\n\n### 🔍 JERARQUÍA DE FUENTES DE DATOS:\n1. **PRIORIDAD ALTA**: Usa siempre el mensaje de confirmación del sistema (mensajeSistema) como fuente principal, ya que contiene los datos completamente validados, normalizados y oficiales.\n2. **PRIORIDAD MEDIA**: Si algún dato específico no está en el mensaje de confirmación del sistema, búscalo en los últimos mensajes del historial de conversación.\n3. **PRIORIDAD BAJA**: Solo como último recurso, usa los datos iniciales proporcionados por el usuario.\n\n### 🔄 ALGORITMO DE EXTRACCIÓN:\n1. **Primero, analiza el mensaje de confirmación del sistema** (mensajeSistema) ya que contiene los datos más precisos y validados.\n2. **Extrae de allí todos los datos disponibles**, prestando especial atención a:\n   - El nombre completo y oficial del proveedor (no abreviaturas)\n   - La categoría normalizada del producto\n   - Datos numéricos validados como peso y unidades\n3. **Solo si algún dato no está disponible en el mensaje de confirmación**, revisa el historial completo de mensajes para encontrarlo.\n4. **Estructura todos los datos obtenidos** en el formato JSON requerido.\n\n### 📌 RESPUESTA (EN FORMATO JSON VÁLIDO):\n```json\n{\n  \"proveedor\": \"Nombre exacto del proveedor validado\",\n  \"fecha\": \"DD de [mes] de YYYY\",\n  \"hora\": \"HH:MM AM/PM\",\n  \"categoria\": \"Categoría validada\",\n  \"peso\": 000,\n  \"unidades\": 000,\n  \"ordenCompra\": \"Código de la orden de compra\"\n}\n```\n\n**REGLAS IMPORTANTES**:\n1. **SIEMPRE prioriza los datos del mensaje de confirmación del sistema** sobre los datos proporcionados inicialmente por el usuario.\n2. **Para el nombre del proveedor y la categoría**, usa SIEMPRE la versión completa y normalizada que aparece en el mensaje de confirmación del sistema, ya que este contiene los nombres oficiales como están registrados en la base de datos.\n3. **Convierte todas las expresiones temporales** a fechas específicas (ej. \"mañana\" → \"15 de abril de 2025\").\n4. **Convierte valores numéricos** (peso, unidades) a formato numérico sin unidades (ej. \"300 kilos\" → 300).\n5. **Estandariza el formato de hora** (ej. \"10 de la mañana\" → \"10:00 AM\").\n\n**EJEMPLO DE EXTRACCIÓN CORRECTO**:\n**Mensaje del usuario**:\n```\n\"Hola, deseo agendar una cita de entrega para mañana, el nombre del proveedor es spb, categoría arenas, con un peso de 300 kilos, a las 9 de la mañana, 900 unidades, el número de orden de compra es ARGM47896.\"\n```\n\n**Mensaje de confirmación del sistema**:\n```\n\"He registrado tu cita para SPB COLOMBIA S.A.S el día 14 de abril a las 09:00 AM, categoría ARENAS, con un peso de 300 kilos y 900 unidades. Tu número de orden de compra ARGM47896 ha sido registrado. Tu cita ha sido confirmada exitosamente.\"\n```\n\n**Respuesta esperada**:\n```json\n{\n  \"proveedor\": \"SPB COLOMBIA S.A.S\",\n  \"fecha\": \"14 de abril de 2025\",\n  \"hora\": \"09:00 AM\",\n  \"categoria\": \"ARENAS\",\n  \"peso\": 300,\n  \"unidades\": 900,\n  \"ordenCompra\": \"ARGM47896\"\n}\n```\n\nIMPORTANTE: Tu tarea es SOLO extraer y estructurar los datos validados. No agregues explicaciones fuera del JSON requerido. Estos datos serán utilizados por otro nodo para verificar disponibilidad en las mallas de recibo.",
        "hasOutputParser": true
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        -36928,
        -10784
      ],
      "id": "44c5af11-25e9-4246-ae45-768a028e1805",
      "name": "Basic LLM Chain EXTRACCIÓN_DATOS_CITA"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4o-mini"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -36944,
        -10592
      ],
      "id": "c42c15f8-3a61-4a08-b528-81026684b4d7",
      "name": "OpenAI Chat Model8",
      "credentials": {
        "openAiApi": {
          "id": "AD8kPcNVReuclASd",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n  \"proveedor\": \"string\",\n  \"fecha\": \"string\",\n  \"hora\": \"string\",\n  \"categoria\": \"string\",\n  \"peso\": 0,\n  \"unidades\": 0,\n  \"ordenCompra\": \"string\"\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.2,
      "position": [
        -36720,
        -10528
      ],
      "id": "fb9db4a8-4a0c-472e-8199-d11a47cc77f2",
      "name": "Structured Output Parser1"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=INSERT INTO MensajesWhatsApp (message_id, contenido, fecha, chat_id, instance)\nVALUES (\n  '{{ $('Parametrización').first().json.message.id }}',\n  '{{ JSON.stringify($node[\"Basic LLM Chain EXTRACCIÓN_DATOS_CITA\"].json.output, null, 2).replace(/'/g, \"''\") }}',\n  FORMAT(SWITCHOFFSET(GETDATE(), '-05:00'), 'yyyy-MM-dd HH:mm:ss'),\n  'agenteAI',\n  '{{ $('Parametrización').first().json.message.chat.instance }}'\n); "
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        -36448,
        -10784
      ],
      "id": "09e8dc98-3d27-43e3-9ca9-95399e068960",
      "name": "Microsoft SQL Guardar EXTRACCIÓN_DATOS_CITA",
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Extraer directamente el texto JSON desde el nodo LLM\nlet textoPlano = $node[\"Basic LLM Chain MOSTRAR_FRANJAS\"].json.text;\n\nlet llmResponse;\ntry {\n  llmResponse = JSON.parse(textoPlano.trim());\n} catch (error) {\n  throw new Error(\"❌ No se pudo parsear el JSON generado por el modelo. Revisa el formato.\\nTexto recibido:\\n\" + textoPlano);\n}\n\n// Convertir formato de fecha a ISO (YYYY-MM-DD)\nlet fechaFormateada = llmResponse.fecha;\nif (fechaFormateada && fechaFormateada.includes(\"de\")) {\n  const meses = {\n    \"enero\": \"01\", \"febrero\": \"02\", \"marzo\": \"03\", \"abril\": \"04\",\n    \"mayo\": \"05\", \"junio\": \"06\", \"julio\": \"07\", \"agosto\": \"08\",\n    \"septiembre\": \"09\", \"octubre\": \"10\", \"noviembre\": \"11\", \"diciembre\": \"12\"\n  };\n\n  const partes = fechaFormateada.split(\" de \");\n  if (partes.length === 3) {\n    const dia = partes[0].padStart(2, \"0\");\n    const mes = meses[partes[1].toLowerCase()];\n    const año = partes[2];\n    fechaFormateada = `${año}-${mes}-${dia}`;\n  }\n}\n\n// Preparar objeto estandarizado\nlet standardResponse = {\n  disponibilidadConfirmada: llmResponse.disponibilidadConfirmada,\n  fecha: llmResponse.fecha,\n  fechaFormateada: fechaFormateada,\n  horaInicio: llmResponse.horaInicio,\n  horaFin: llmResponse.horaFin,\n  muelle: llmResponse.muelle,\n  duracionHoras: llmResponse.duracionHoras,\n  alternativasDisponibles: Array.isArray(llmResponse.alternativasDisponibles) \n    ? llmResponse.alternativasDisponibles \n    : [],\n  mensajeSistema: llmResponse.mensajeSistema,\n  datosCita: {\n    proveedor: $node[\"Basic LLM Chain EXTRACCIÓN_DATOS_CITA\"].json.output.proveedor,\n    categoria: $node[\"Basic LLM Chain EXTRACCIÓN_DATOS_CITA\"].json.output.categoria,\n    peso: $node[\"Basic LLM Chain EXTRACCIÓN_DATOS_CITA\"].json.output.peso,\n    unidades: $node[\"Basic LLM Chain EXTRACCIÓN_DATOS_CITA\"].json.output.unidades,\n    ordenCompra: $node[\"Basic LLM Chain EXTRACCIÓN_DATOS_CITA\"].json.output.ordenCompra\n  },\n  timestamp: new Date().toISOString()\n};\n\n// Normalizar hora (por si empieza con cero innecesario)\nstandardResponse.horaInicio = standardResponse.horaInicio.replace(/^0(\\d:00 [AP]M)$/, \"$1\");\n\nreturn { standardResponse };"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -35360,
        -10784
      ],
      "id": "2295ea09-4041-4a4f-b380-a8d7d46e700d",
      "name": "Code estandarizar respuestas MOSTRAR_FRANJAS"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO FranjasDisponiblesTemp \n(chat_id, franjas_json, timestamp_enviado, datos_cita_json, fecha_cita, hora_inicio, hora_fin) \nVALUES \n(\n    '{{$node[\"Organiza el Mensaje\"].json[\"infoMensaje\"][\"chat_id\"]}}', \n    '{{JSON.stringify($node[\"Code estandarizar respuestas MOSTRAR_FRANJAS\"].json.standardResponse).replace(/'/g, \"''\")}}', \n    GETDATE(), \n    '{{JSON.stringify($node[\"Code estandarizar respuestas MOSTRAR_FRANJAS\"].json.standardResponse.datosCita)}}', \n    CONVERT(DATETIME, '{{$node[\"Code estandarizar respuestas MOSTRAR_FRANJAS\"].json.standardResponse.fechaFormateada}}'), \n    FORMAT(CAST('{{$node[\"Code estandarizar respuestas MOSTRAR_FRANJAS\"].json.standardResponse.horaInicio}}' AS DATETIME), 'HH:mm'), \n    FORMAT(CAST('{{$node[\"Code estandarizar respuestas MOSTRAR_FRANJAS\"].json.standardResponse.horaFin}}' AS DATETIME), 'HH:mm')\n);"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        -35088,
        -10784
      ],
      "id": "ab1eab65-615b-4476-9b55-6ff9235c09d4",
      "name": "Microsoft SQL Guardar MOSTRAR_FRANJAS",
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Código para verificar disponibilidad de franjas horarias en n8n\n// — versión corregida 2025-06-17 — Busca por fecha exacta en fechaDia\n\n// Función ejecutada por el nodo Code\nfunction procesarVerificacionFranjas(items, runIndex) {\n  try {\n    // 0. Entradas provenientes de los nodos anteriores\n    const datosCita            = $node[\"Basic LLM Chain EXTRACCIÓN_DATOS_CITA\"].json.output;     // datos de la cita\n    const datosMalla           = $node[\"Unificación y consistencia de datos1\"].json.datosMalla;   // malla semana actual\n    const datosMallaProxSemana = $node[\"Unificación y consistencia de datos1\"].json.datosMallaProxSemana;\n    const datoscategorias      = $node[\"Unificación y consistencia de datos1\"].json.datoscategorias;\n    const datosproveedor       = $node[\"Unificación y consistencia de datos1\"].json.datosproveedor;\n\n    // 1. Agrupamos todo en un solo objeto\n    const datosEntrada = {\n      datosCita,\n      datosMalla,\n      datosMallaProxSemana,\n      datoscategorias,\n      datosproveedor\n    };\n\n    // 2. Ejecutamos la verificación\n    const resultado = verificarDisponibilidadFranjas(datosEntrada);\n\n    // 3. Devolvemos la salida en el formato que n8n espera\n    return [{ json: resultado }];\n  } catch (error) {\n    console.error(\"Error en procesamiento principal:\", error);\n    return [{ json: { error: error.message || \"Error en el procesamiento\" } }];\n  }\n}\n\n/* ════════════════════════════════════════════════════════════════════════\n *  FUNCIÓN PRINCIPAL DE VERIFICACIÓN\n * ════════════════════════════════════════════════════════════════════════ */\nfunction verificarDisponibilidadFranjas(datosEntrada) {\n  try {\n    /* ─────────────────────────── 1. DATOS BÁSICOS ─────────────────────────── */\n    const {\n      datosCita,\n      datosMalla:        mallaActual,\n      datosMallaProxSemana: mallaProxima,\n      datoscategorias:   categorias,\n      datosproveedor:    proveedores\n    } = datosEntrada;\n\n    const fechaHoraActual = new Date();\n\n    const proveedor       = datosCita.proveedor   || \"\";\n    const fechaSolicitada = datosCita.fecha       || \"\";\n    const horaSolicitada  = datosCita.hora        || \"\";\n    const categoria       = datosCita.categoria   || \"\";\n    const unidades        = Number.parseInt(String(datosCita.unidades || \"0\"), 10);\n\n    /* Validaciones mínimas */\n    if (!proveedor)       return { error: \"Proveedor no especificado\" };\n    if (!fechaSolicitada) return { error: \"Fecha no especificada\" };\n    if (!horaSolicitada)  return { error: \"Hora no especificada\" };\n    if (!categoria)       return { error: \"Categoría no especificada\" };\n    if (Number.isNaN(unidades) || unidades <= 0) return { error: \"Cantidad de unidades inválida\" };\n\n    /* ────────────────────────── 2. PROVEEDOR ─────────────────────────────── */\n    const datosProveedor = buscarProveedor(proveedores, proveedor);\n    if (!datosProveedor) {\n      return { error: `No se encontró el proveedor \"${proveedor}\" en la base de datos` };\n    }\n\n    const unidadesPorHora = datosProveedor.unidadesPorHora;\n    if (!unidadesPorHora || unidadesPorHora <= 0) {\n      return { error: `El proveedor \"${proveedor}\" no tiene definidas unidades por hora válidas` };\n    }\n\n    /* ────────────────────────── 3. CÁLCULOS BÁSICOS ───────────────────────── */\n    const horasNecesarias = Math.ceil(unidades / unidadesPorHora);\n    const restriccionHoraSuperada = verificarRestriccionHoraCitaManana(fechaHoraActual, fechaSolicitada);\n\n    /* ────────────────────────── 4. HORA NORMALIZADA ──────────────────────── */\n    const horaNormalizada = horaSolicitada.trim();\n\n    /* ────────────────────────── 5. MUELLE POR CATEGORÍA ──────────────────── */\n    const muelleAsignado = determinarMuellePorCategoria(categorias, categoria);\n    if (!muelleAsignado) {\n      return { error: `No se encontró un muelle asignado para la categoría \"${categoria}\"` };\n    }\n\n    /* ────────────────────────── 6. DISPONIBILIDAD / ALTERNATIVAS ─────────── */\n    let resultado;\n\n    if (restriccionHoraSuperada) {\n      // Caso: contactaron después de las 4:30 p.m. y la cita es para mañana\n      const alternativas = buscarAlternativasDesdeDosDiasDespues(\n        fechaHoraActual,\n        mallaActual,\n        mallaProxima,\n        muelleAsignado,\n        horasNecesarias\n      );\n\n      resultado = {\n        disponibilidadConfirmada: false,\n        fecha:           fechaSolicitada,\n        horaInicio:      horaNormalizada,\n        horaFin:         calcularHoraFin(horaNormalizada, horasNecesarias),\n        muelle:          muelleAsignado,\n        duracionHoras:   horasNecesarias,\n        restriccionHoraSuperada: true,\n        alternativasDisponibles: alternativas.slice(0, 10)\n      };\n    } else {\n      const disponible = verificarDisponibilidadHoraSolicitada(\n        fechaSolicitada,\n        horaNormalizada,\n        muelleAsignado,\n        horasNecesarias,\n        mallaActual,\n        mallaProxima\n      );\n\n      if (disponible) {\n        resultado = {\n          disponibilidadConfirmada: true,\n          fecha:           fechaSolicitada,\n          horaInicio:      horaNormalizada,\n          horaFin:         calcularHoraFin(horaNormalizada, horasNecesarias),\n          muelle:          muelleAsignado,\n          duracionHoras:   horasNecesarias,\n          restriccionHoraSuperada: false,\n          alternativasDisponibles: []\n        };\n      } else {\n        const alternativasMismoDia = buscarAlternativasMismoDia(\n          fechaSolicitada,\n          muelleAsignado,\n          horasNecesarias,\n          mallaActual,\n          mallaProxima\n        );\n\n        const todasAlternativas = alternativasMismoDia.length > 0\n          ? alternativasMismoDia\n          : buscarAlternativasDiasPeriores(\n              fechaSolicitada,\n              muelleAsignado,\n              horasNecesarias,\n              mallaActual,\n              mallaProxima\n            );\n\n        resultado = {\n          disponibilidadConfirmada: false,\n          fecha:           fechaSolicitada,\n          horaInicio:      horaNormalizada,\n          horaFin:         calcularHoraFin(horaNormalizada, horasNecesarias),\n          muelle:          muelleAsignado,\n          duracionHoras:   horasNecesarias,\n          restriccionHoraSuperada: false,\n          alternativasDisponibles: todasAlternativas\n        };\n      }\n    }\n\n    /* ────────────────────────── 7. DATOS PROVEEDOR ───────────────────────── */\n    resultado.datosProveedorEncontrado = {\n      nombre:           datosProveedor.proveedor,\n      unidadesPorHora:  datosProveedor.unidadesPorHora,\n      rotacion:         datosProveedor.rotacion,\n      tipoProveedor:    datosProveedor.tipoProveedor\n    };\n\n    return { output: resultado };\n  } catch (error) {\n    console.error(\"Error en verificación de disponibilidad:\", error);\n    return { error: `Error en la verificación: ${error.message}` };\n  }\n}\n\n/* ════════════════════════════════════════════════════════════════════════\n *  FUNCIONES DE APOYO\n * ════════════════════════════════════════════════════════════════════════ */\n\n// (1) Búsqueda de proveedor\nfunction buscarProveedor(listaProveedores, nombreProveedor) {\n  if (!Array.isArray(listaProveedores) || listaProveedores.length === 0) return null;\n  if (!nombreProveedor) return null;\n\n  const nombreLower = nombreProveedor.toLowerCase();\n  const exacta  = listaProveedores.find(p => (p.proveedor || \"\").toLowerCase() === nombreLower);\n  if (exacta) return exacta;\n\n  return listaProveedores.find(p => (p.proveedor || \"\").toLowerCase().includes(nombreLower));\n}\n\n// (2) Normalizador de hora para comparaciones\nfunction limpiarHora(h) {\n  return h ? h.trim().replace(/^0+/, \"\").toUpperCase() : \"\";\n}\n\n// (3) Determinar muelle por categoría\nfunction determinarMuellePorCategoria(categorias, categoriaProducto) {\n  if (!Array.isArray(categorias) || categorias.length === 0) return null;\n  const catLower = categoriaProducto.toLowerCase();\n\n  const exacta = categorias.find(c => (c.CATEGORIA || \"\").toLowerCase() === catLower);\n  if (exacta) return exacta.MUELLE;\n\n  const parcial = categorias.find(c => (c.CATEGORIA || \"\").toLowerCase().includes(catLower));\n  return parcial ? parcial.MUELLE : null;\n}\n\n// (4) Calcular hora de fin\nfunction calcularHoraFin(horaInicio, horasNecesarias) {\n  if (!horaInicio) return \"\";\n  const [horaTxt, meridiano] = horaInicio.trim().split(\" \");\n  let hora = parseInt(horaTxt, 10);\n  if (meridiano === \"PM\" && hora < 12) hora += 12;\n  if (meridiano === \"AM\" && hora === 12) hora = 0;\n  hora += horasNecesarias;\n  let nuevoMeridiano = \"AM\";\n  if (hora >= 12) {\n    nuevoMeridiano = \"PM\";\n    if (hora > 12) hora -= 12;\n  }\n  if (hora === 0) { hora = 12; nuevoMeridiano = \"AM\"; }\n  return `${hora}:00 ${nuevoMeridiano}`;\n}\n\n// (5) Restricción 4:30 p.m. → cita mañana (CORREGIDO - ZONA HORARIA)\nfunction verificarRestriccionHoraCitaManana(fechaHoraActual, fechaSolicitada) {\n  // 1. Obtener la fecha y hora actual en la zona horaria de Bogotá.\n  //    Esto es CRUCIAL para que la comparación de las 4:30 PM funcione correctamente\n  //    independientemente de la zona horaria del servidor.\n  const ahoraEnBogota = new Date(new Date().toLocaleString(\"en-US\", { timeZone: \"America/Bogota\" }));\n\n  // 2. Verificar si la hora actual en Bogotá es después de las 4:30 PM.\n  const horaBogota = ahoraEnBogota.getHours();\n  const minutosBogota = ahoraEnBogota.getMinutes();\n  const esDespuesDe430PM = horaBogota > 16 || (horaBogota === 16 && minutosBogota >= 30);\n\n  // 3. Parsear la fecha que el usuario solicitó.\n  const fechaSolicitadaObj = parsearFechaEspanol(fechaSolicitada);\n  if (!fechaSolicitadaObj || isNaN(fechaSolicitadaObj.getTime())) {\n    console.error(\"Fecha solicitada inválida:\", fechaSolicitada);\n    return false;\n  }\n\n  // 4. Calcular la fecha de \"mañana\" basándose en la fecha actual de Bogotá.\n  const fechaManana = new Date(ahoraEnBogota);\n  fechaManana.setDate(fechaManana.getDate() + 1);\n  \n  // 5. Comparar si la fecha solicitada es efectivamente \"mañana\".\n  //    Se compara año, mes y día para evitar problemas con horas.\n  const esMañana = fechaSolicitadaObj.getFullYear() === fechaManana.getFullYear() &&\n                   fechaSolicitadaObj.getMonth() === fechaManana.getMonth() &&\n                   fechaSolicitadaObj.getDate() === fechaManana.getDate();\n\n  // 6. La restricción se aplica solo si AMBAS condiciones son verdaderas.\n  return esMañana && esDespuesDe430PM;\n}\n\n\n// (6) Parsear fecha \"30 de abril de 2025\"\nfunction parsearFechaEspanol(fechaTexto) {\n  const [dia, , mesTxt, , anio] = fechaTexto.split(\" \");\n  return new Date(Number(anio), obtenerNumeroMes(mesTxt), Number(dia));\n}\n\n// (7) Obtener número de mes\nfunction obtenerNumeroMes(nombreMes) {\n  const meses = [\"enero\",\"febrero\",\"marzo\",\"abril\",\"mayo\",\"junio\",\"julio\",\"agosto\",\"septiembre\",\"octubre\",\"noviembre\",\"diciembre\"];\n  return meses.indexOf(nombreMes.toLowerCase());\n}\n\n// (8) NUEVA FUNCIÓN: Buscar día por fecha exacta en todas las mallas\nfunction buscarDiaPorFechaExacta(fechaSolicitada, mallaActual, mallaProxima) {\n  const mallas = [\n    { malla: mallaActual, nombre: \"actual\" },\n    { malla: mallaProxima, nombre: \"proxima\" }\n  ];\n\n  for (const { malla, nombre } of mallas) {\n    if (!malla || !malla.dias) continue;\n\n    // Recorrer todos los días de la malla\n    for (const [nombreDia, datosDia] of Object.entries(malla.dias)) {\n      if (datosDia && datosDia.fechaDia === fechaSolicitada) {\n        console.log(`Fecha ${fechaSolicitada} encontrada en malla ${nombre}, día: ${nombreDia}`);\n        return {\n          malla: malla,\n          nombreDia: nombreDia,\n          datosDia: datosDia,\n          mallaUsada: nombre\n        };\n      }\n    }\n  }\n\n  console.log(`Fecha ${fechaSolicitada} NO encontrada en ninguna malla`);\n  return null;\n}\n\n// (9) Verificar disponibilidad de la hora solicitada (NUEVA LÓGICA)\nfunction verificarDisponibilidadHoraSolicitada(\n  fechaSolicitada,\n  horaSolicitada,\n  muelle,\n  horasNecesarias,\n  mallaActual,\n  mallaProxima\n) {\n  try {\n    console.log(`Verificando disponibilidad para fecha: ${fechaSolicitada}, hora: ${horaSolicitada}, muelle: ${muelle}`);\n\n    /* ── Buscar el día por fecha exacta ── */\n    const resultadoBusqueda = buscarDiaPorFechaExacta(fechaSolicitada, mallaActual, mallaProxima);\n    \n    if (!resultadoBusqueda) {\n      console.log(`No se encontró la fecha ${fechaSolicitada} en ninguna malla`);\n      return false;\n    }\n\n    const { malla, nombreDia, datosDia } = resultadoBusqueda;\n\n    /* ── Verificar muelle ── */\n    const nombreMuelle = muelle.toLowerCase().replace(/\\s+/g, \"\"); // \"MUELLE 1\" → \"muelle1\"\n    if (!datosDia[nombreMuelle]) {\n      console.log(`No se encontró el muelle ${nombreMuelle} para el día ${nombreDia}`);\n      console.log(`Muelles disponibles:`, Object.keys(datosDia).filter(k => k !== 'fechaDia'));\n      return false;\n    }\n\n    /* ── Verificar franjas ── */\n    if (!malla.franjas || !Array.isArray(malla.franjas) || malla.franjas.length === 0) {\n      console.log(\"No hay franjas definidas en la malla\");\n      return false;\n    }\n\n    const franjas = malla.franjas.map(f => f.hora);\n    const indiceInicio = franjas.findIndex(h => limpiarHora(h) === limpiarHora(horaSolicitada));\n    \n    if (indiceInicio === -1) {\n      console.log(`No se encontró la hora ${horaSolicitada} en las franjas disponibles`);\n      console.log(`Franjas disponibles:`, franjas);\n      return false;\n    }\n    \n    if (indiceInicio + horasNecesarias > franjas.length) {\n      console.log(`No hay suficientes franjas consecutivas disponibles (necesita ${horasNecesarias})`);\n      return false;\n    }\n\n    /* ── Verificar disponibilidad de todas las franjas necesarias ── */\n    for (let i = 0; i < horasNecesarias; i++) {\n      const horaFranja = franjas[indiceInicio + i];\n      const franja = datosDia[nombreMuelle][horaFranja];\n      \n      if (!franja) {\n        console.log(`No se encontró la franja ${horaFranja} en ${nombreMuelle}`);\n        return false;\n      }\n      \n      const estadoFranja = (franja.estado || \"\").toLowerCase().trim();\n      console.log(`Franja ${horaFranja}: estado = \"${estadoFranja}\"`);\n      \n      if (estadoFranja !== \"disponible\") {\n        console.log(`La franja ${horaFranja} no está disponible. Estado: ${franja.estado}`);\n        return false;\n      }\n    }\n    \n    console.log(`Todas las franjas están disponibles para ${fechaSolicitada} ${horaSolicitada}`);\n    return true;\n  } catch (error) {\n    console.error(`Error verificando disponibilidad: ${error.message}`);\n    return false;\n  }\n}\n\n// (10) Formatear fecha en formato español\nfunction formatearFechaEspanol(fecha) {\n  if (!fecha || !(fecha instanceof Date)) {\n    return \"\";\n  }\n  \n  const dia = fecha.getDate();\n  const meses = [\n    \"enero\", \"febrero\", \"marzo\", \"abril\", \"mayo\", \"junio\",\n    \"julio\", \"agosto\", \"septiembre\", \"octubre\", \"noviembre\", \"diciembre\"\n  ];\n  const mes = meses[fecha.getMonth()];\n  const anio = fecha.getFullYear();\n  \n  return `${dia} de ${mes} de ${anio}`;\n}\n\n/* ───────────────────────────────────────────────────────────────────────── */\n/* FUNCIONES PARA BUSCAR ALTERNATIVAS                                        */\n/* ───────────────────────────────────────────────────────────────────────── */\n\n// Buscar alternativas desde dos días después\nfunction buscarAlternativasDesdeDosDiasDespues(\n  fechaActual,\n  mallaActual,\n  mallaProxima,\n  muelle,\n  horasNecesarias\n) {\n  try {\n    const fechaDosDiasDespues = new Date(fechaActual);\n    fechaDosDiasDespues.setDate(fechaDosDiasDespues.getDate() + 2);\n    \n    // Ajustar si cae en fin de semana\n    if (fechaDosDiasDespues.getDay() === 0) { // Domingo\n      fechaDosDiasDespues.setDate(fechaDosDiasDespues.getDate() + 1);\n    } else if (fechaDosDiasDespues.getDay() === 6) { // Sábado\n      fechaDosDiasDespues.setDate(fechaDosDiasDespues.getDate() + 2);\n    }\n    \n    const fechaDosDiasDespuesStr = formatearFechaEspanol(fechaDosDiasDespues);\n    const alternativas = buscarAlternativasParaDiaConFechaExacta(\n      fechaDosDiasDespuesStr,\n      muelle,\n      horasNecesarias,\n      mallaActual,\n      mallaProxima\n    );\n    \n    // Solo devolver máximo 10 alternativas de ese día\n    return alternativas.slice(0, 10);\n  } catch (error) {\n    console.error(`Error buscando alternativas: ${error.message}`);\n    return [];\n  }\n}\n\n// Buscar alternativas para un día específico usando fecha exacta\nfunction buscarAlternativasParaDiaConFechaExacta(\n  fechaTexto,\n  muelle,\n  horasNecesarias,\n  mallaActual,\n  mallaProxima\n) {\n  try {\n    const alternativas = [];\n    \n    const resultadoBusqueda = buscarDiaPorFechaExacta(fechaTexto, mallaActual, mallaProxima);\n    if (!resultadoBusqueda) {\n      return alternativas;\n    }\n\n    const { malla, datosDia } = resultadoBusqueda;\n    const nombreMuelle = muelle.toLowerCase().replace(/\\s+/g, \"\");\n    \n    if (!datosDia[nombreMuelle]) {\n      return alternativas;\n    }\n    \n    if (!malla.franjas || !Array.isArray(malla.franjas) || malla.franjas.length === 0) {\n      return alternativas;\n    }\n    \n    const franjasHorario = malla.franjas.map(f => f.hora);\n    \n    // Verificar cada posible hora de inicio\n    for (let i = 0; i <= franjasHorario.length - horasNecesarias; i++) {\n      const horaInicio = franjasHorario[i];\n      let todasDisponibles = true;\n      \n      // Verificar disponibilidad de todas las franjas consecutivas\n      for (let j = 0; j < horasNecesarias; j++) {\n        const horaActual = franjasHorario[i + j];\n        const franja = datosDia[nombreMuelle][horaActual];\n        \n        if (!franja || (franja.estado || \"\").toLowerCase().trim() !== \"disponible\") {\n          todasDisponibles = false;\n          break;\n        }\n      }\n      \n      // Si todas las franjas están disponibles, agregar como alternativa\n      if (todasDisponibles) {\n        const horaFin = calcularHoraFin(horaInicio, horasNecesarias);\n        alternativas.push({\n          fecha: fechaTexto,\n          horaInicio: horaInicio,\n          horaFin: horaFin,\n          muelle: muelle\n        });\n      }\n    }\n    \n    return alternativas;\n  } catch (error) {\n    console.error(`Error buscando alternativas para día: ${error.message}`);\n    return [];\n  }\n}\n\n// Buscar alternativas en el mismo día\nfunction buscarAlternativasMismoDia(\n  fechaSolicitada,\n  muelle,\n  horasNecesarias,\n  mallaActual,\n  mallaProxima\n) {\n  const alternativas = buscarAlternativasParaDiaConFechaExacta(\n    fechaSolicitada,\n    muelle,\n    horasNecesarias,\n    mallaActual,\n    mallaProxima\n  );\n  \n  // Limitar a máximo 8 alternativas del mismo día\n  return alternativas.slice(0, 8);\n}\n\n// Buscar alternativas en días posteriores\nfunction buscarAlternativasDiasPeriores(\n  fechaSolicitada,\n  muelle,\n  horasNecesarias,\n  mallaActual,\n  mallaProxima\n) {\n  try {\n    const fechaSolicitadaObj = parsearFechaEspanol(fechaSolicitada);\n    const fechaSiguiente = new Date(fechaSolicitadaObj);\n    fechaSiguiente.setDate(fechaSiguiente.getDate() + 1);\n    \n    // Solo buscar en el día siguiente\n    const fechaSiguienteStr = formatearFechaEspanol(fechaSiguiente);\n    const alternativasDiaSiguiente = buscarAlternativasParaDiaConFechaExacta(\n      fechaSiguienteStr,\n      muelle,\n      horasNecesarias,\n      mallaActual,\n      mallaProxima\n    );\n    \n    // Limitar a máximo 8 alternativas del día siguiente\n    return alternativasDiaSiguiente.slice(0, 8);\n  } catch (error) {\n    console.error(`Error buscando alternativas posteriores: ${error.message}`);\n    return [];\n  }\n}\n\n// Aseguramos que n8n ejecute la función principal\nreturn procesarVerificacionFranjas(items, 0);"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -36128,
        -10784
      ],
      "id": "d982cecf-d5cc-4490-9089-efdca04f6adb",
      "name": "Code MOSTRAR_FRANJAS"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Sistema de Validación de Datos para Citas de Logística\n * VERSIÓN 5.3 — 2025-04-25\n * - Aplana proveedores y categorías que vienen dentro de \"datosproveedor\" /\n *   \"datoscategorias\"\n * - Mantiene la lógica de coincidencias para abreviaturas (\"spb\") y variantes\n *   sing/plural (\"arena\"→\"ARENAS\")\n * - Incluye guard-rails para evitar undefined\n */\n\n/*────────────────────── UTILIDAD GENÉRICA ──────────────────────*/\nfunction getNodeItems(nodeName) {\n  try {\n    return $items(nodeName).map(i => i.json) || [];\n  } catch (e) {          // ← con (e) o (error)\n    return [];\n  }\n}\n\n/*────────────────────── CARGA Y APLANADO ───────────────────────*/\nfunction procesarValidacionCita() {\n  try {   \n// 🔄 Carga cruda\nlet proveedoresRaw  = getNodeItems(\"Estructuración, Consulta, Datos Proveedor\");\nlet categoriasRaw   = getNodeItems(\"Estructuración, Consulta, Datos Categorias\");\n\n// 🔄 Aplanar proveedores\nlet datosproveedor = [];\nfor (const itm of proveedoresRaw) {\n  if (Array.isArray(itm.datosproveedor))  datosproveedor.push(...itm.datosproveedor);\n  else if (itm.proveedor)                 datosproveedor.push(itm);\n}\n\n// 🔄 Aplanar categorías\nlet datoscategorias = [];\nfor (const itm of categoriasRaw) {\n  if (Array.isArray(itm.datoscategorias)) datoscategorias.push(...itm.datoscategorias);\n  else if (itm.CATEGORIA)                 datoscategorias.push(itm);\n}\n\n// Fallbacks (por compatibilidad con Merge datos Excel)\nif (!datosproveedor.length  && $node[\"Merge datos Excel\"]?.json?.datosproveedor)\n  datosproveedor  = $node[\"Merge datos Excel\"].json.datosproveedor;\nif (!datoscategorias.length && $node[\"Merge datos Excel\"]?.json?.datoscategorias)\n  datoscategorias = $node[\"Merge datos Excel\"].json.datoscategorias;\n\n/*──────────────────── DATOS DEL LLM Y CONTEXTO ─────────────────*/\nconst datosLLM          = $node[\"Basic LLM Chain RECOLECCIÓN1\"].json.output;\nconst mensajeActual     = $('Unificación y consistencia de datos').first().json.infoMensaje.mensajeActual;\nconst historialMensajes = $node[\"Unificación y consistencia de datos\"].json.infoMensaje.historialMensajes;\nconst mallaProximaSemana= $('Estructuración, Datos, Consulta, Citas Proxima Semana').first().json;\nconst mallaProximaNoExiste = verificarMallaProximaNoExiste(mallaProximaSemana);\nconst fechaActualObj    = new Date();\n    \n    // Inicializar el objeto de respuesta\n    const resultado = {\n      todoCorrecto: false,\n      datosPreviamenteConfirmados: false,\n      camposFaltantes: [],\n      proveedoresSimilares: [],\n      categoriasSimilares: [],\n      fechaSolicitada: \"\",\n      horaSolicitada: \"\",\n      proveedorIdentificado: \"\",\n      categoriaIdentificada: \"\",\n      pesoIdentificado: 0,\n      unidadesIdentificadas: 0,\n      ordenCompraIdentificada: \"\",\n      mensajeSistema: \"\",\n      mensajesCamposFaltantes: {},\n      mallaProximaDisponible: !mallaProximaNoExiste,\n      fechaValida: true,\n      horaValida: true,\n      diaHabil: true,\n      mensajeValidacionTemporal: \"\"\n    };\n\n    // Si la malla próxima no existe, agregar un mensaje informativo\n    if (mallaProximaNoExiste) {\n      resultado.mensajeSistema = \"Te informo que la malla de la próxima semana aún no ha sido creada o no está disponible. Solo puedo mostrarte disponibilidad para la semana actual.\";\n    }\n\n    // 1. VERIFICAR SI ES UNA CONFIRMACIÓN DIRECTA DE TODOS LOS DATOS\n    const confirmacionPrevia = verificarConfirmacionPrevia(historialMensajes, mensajeActual);\n    if (confirmacionPrevia.confirmado) {\n      resultado.datosPreviamenteConfirmados = true;\n      resultado.todoCorrecto = true;\n      resultado.proveedorIdentificado = confirmacionPrevia.proveedor;\n      resultado.fechaSolicitada = confirmacionPrevia.fecha;\n      resultado.horaSolicitada = confirmacionPrevia.hora;\n      resultado.categoriaIdentificada = confirmacionPrevia.categoria;\n      resultado.pesoIdentificado = confirmacionPrevia.peso;\n      resultado.unidadesIdentificadas = confirmacionPrevia.unidades;\n      resultado.ordenCompraIdentificada = confirmacionPrevia.ordenCompra;\n      \n      // Validar que la fecha y hora confirmadas no estén en el pasado\n      const validacionTemporal = validarFechaHora(resultado.fechaSolicitada, resultado.horaSolicitada, fechaActualObj);\n      resultado.fechaValida = validacionTemporal.fechaValida;\n      resultado.horaValida = validacionTemporal.horaValida;\n      resultado.diaHabil = validacionTemporal.diaHabil;\n      resultado.mensajeValidacionTemporal = validacionTemporal.mensaje;\n      \n      // Si hay problemas con la fecha/hora, la cita no está correcta\n      if (!validacionTemporal.fechaValida || !validacionTemporal.horaValida || !validacionTemporal.diaHabil) {\n        resultado.todoCorrecto = false;\n      }\n      \n      return resultado;\n    }\n\n    // 2. USAR DIRECTAMENTE LOS DATOS DEL LLM\n    // No intentar extraer datos del mensaje - confiar en lo que extrajo el LLM\n    resultado.fechaSolicitada = datosLLM.fecha || \"\";\n    resultado.horaSolicitada = datosLLM.hora || \"\";\n    resultado.pesoIdentificado = parseInt(datosLLM.peso) || 0;\n    resultado.unidadesIdentificadas = parseInt(datosLLM.unidades) || 0;\n    resultado.ordenCompraIdentificada = datosLLM.ordenCompra || \"\";\n\n    // 3. VALIDACIÓN DEL PROVEEDOR\n    if (datosLLM.proveedor) {\n      const resultadoProveedor = validarProveedor(datosLLM.proveedor, datosproveedor);\n      \n      if (resultadoProveedor.coincidenciaExacta) {\n        resultado.proveedorIdentificado = resultadoProveedor.nombreCompleto;\n      } else if (resultadoProveedor.coincidenciaParcialClara) {\n        resultado.proveedorIdentificado = resultadoProveedor.nombreCompleto;\n      } else if (resultadoProveedor.coincidenciasParciales && resultadoProveedor.coincidenciasParciales.length > 0) {\n        resultado.proveedoresSimilares = resultadoProveedor.coincidenciasParciales;\n      } else {\n        resultado.camposFaltantes.push(\"proveedor\");\n        resultado.mensajesCamposFaltantes[\"proveedor\"] = \"Por favor proporciona el nombre del proveedor ya que es necesario para buscarlo en nuestra base de datos y que el sistema pueda asociar la cita a ese nombre, trata de proporcionar el nombre lo más completo posible.\";\n      }\n    } else {\n      resultado.camposFaltantes.push(\"proveedor\");\n      resultado.mensajesCamposFaltantes[\"proveedor\"] = \"Por favor proporciona el nombre del proveedor ya que es necesario para buscarlo en nuestra base de datos y que el sistema pueda asociar la cita a ese nombre, trata de proporcionar el nombre lo más completo posible.\";\n    }\n\n    // 4. VALIDACIÓN DE LA CATEGORÍA\n    if (datosLLM.categoria) {\n      const resultadoCategoria = validarCategoria(datosLLM.categoria, datoscategorias);\n      if (resultadoCategoria.coincidenciaExacta) {\n        resultado.categoriaIdentificada = resultadoCategoria.nombreCompleto;\n      } else if (resultadoCategoria.coincidenciaSimilar) {\n        // Si es \"arena\" para \"ARENAS\", por ejemplo\n        resultado.categoriaIdentificada = resultadoCategoria.nombreCompleto;\n      } else if (resultadoCategoria.categoriasSimilares && resultadoCategoria.categoriasSimilares.length > 0) {\n        resultado.categoriasSimilares = resultadoCategoria.categoriasSimilares;\n      } else {\n        resultado.camposFaltantes.push(\"categoría\");\n        \n        // Preparar la lista de categorías disponibles para el mensaje\n        let categoriasDisponibles = datoscategorias.map(cat => cat.CATEGORIA).join(\", \");\n        if (categoriasDisponibles.length > 100) {\n          // Si hay muchas categorías, mostrar solo las primeras\n          const primerasCategorias = datoscategorias.slice(0, 5).map(cat => cat.CATEGORIA);\n          categoriasDisponibles = primerasCategorias.join(\", \") + \", entre otras...\";\n        }\n        \n        resultado.mensajesCamposFaltantes[\"categoría\"] = `Por favor indica la categoría del material. Las categorías disponibles incluyen: ${categoriasDisponibles}`;\n      }\n    } else {\n      resultado.camposFaltantes.push(\"categoría\");\n      \n      // Preparar la lista de categorías disponibles para el mensaje\n      let categoriasDisponibles = datoscategorias.map(cat => cat.CATEGORIA).join(\", \");\n      if (categoriasDisponibles.length > 100) {\n        // Si hay muchas categorías, mostrar solo las primeras\n        const primerasCategorias = datoscategorias.slice(0, 5).map(cat => cat.CATEGORIA);\n        categoriasDisponibles = primerasCategorias.join(\", \") + \", entre otras...\";\n      }\n      \n      resultado.mensajesCamposFaltantes[\"categoría\"] = `Por favor indica la categoría del material. Las categorías disponibles incluyen: ${categoriasDisponibles}`;\n    }\n\n    // 5. VERIFICACIÓN DE CAMPOS OBLIGATORIOS FALTANTES\n    if (!resultado.fechaSolicitada) {\n      resultado.camposFaltantes.push(\"fecha\");\n      resultado.mensajesCamposFaltantes[\"fecha\"] = \"Por favor es necesaria la fecha de entrega para que el sistema pueda revisar el cronograma y entregarte información precisa.\";\n    }\n    \n    if (!resultado.horaSolicitada) {\n      resultado.camposFaltantes.push(\"hora\");\n      resultado.mensajesCamposFaltantes[\"hora\"] = \"Por favor indica la hora preferida para la cita, es necesaria para verificar la disponibilidad en nuestro cronograma.\";\n    }\n    \n    if (!resultado.pesoIdentificado) {\n      resultado.camposFaltantes.push(\"peso\");\n      resultado.mensajesCamposFaltantes[\"peso\"] = \"Te falta el dato del peso de la mercancía. Por favor proporcionar este dato ojalá en kilos, es necesario para que el sistema calcule la duración del descargue de la mercancía.\";\n    }\n    \n    if (!resultado.unidadesIdentificadas) {\n      resultado.camposFaltantes.push(\"unidades\");\n      resultado.mensajesCamposFaltantes[\"unidades\"] = \"Te faltó el dato de la cantidad de unidades a descargar. Este dato es importante para que el sistema pueda calcular el tiempo que se necesita para el descargue.\";\n    }\n    \n    if (!resultado.ordenCompraIdentificada) {\n      resultado.camposFaltantes.push(\"orden de compra\");\n      resultado.mensajesCamposFaltantes[\"orden de compra\"] = \"Falta el número de la orden de compra. Por favor proporcionar este dato ya que es necesario para que la cita en el cronograma quede relacionada a esta orden de compra por temas de trazabilidad en la operación.\";\n    }\n\n    // 6. VALIDACIÓN: Verificar que la fecha y hora sean válidas\n    if (resultado.fechaSolicitada && resultado.horaSolicitada) {\n      const validacionTemporal = validarFechaHora(resultado.fechaSolicitada, resultado.horaSolicitada, fechaActualObj);\n      resultado.fechaValida = validacionTemporal.fechaValida;\n      resultado.horaValida = validacionTemporal.horaValida;\n      resultado.diaHabil = validacionTemporal.diaHabil;\n      resultado.mensajeValidacionTemporal = validacionTemporal.mensaje;\n      \n      // Si la fecha u hora no son válidas, añadir a campos faltantes\n      if (!validacionTemporal.fechaValida) {\n        if (!resultado.camposFaltantes.includes(\"fecha\")) {\n          resultado.camposFaltantes.push(\"fecha\");\n        }\n        resultado.mensajesCamposFaltantes[\"fecha\"] = validacionTemporal.mensaje;\n      }\n      \n      if (!validacionTemporal.horaValida) {\n        if (!resultado.camposFaltantes.includes(\"hora\")) {\n          resultado.camposFaltantes.push(\"hora\");\n        }\n        resultado.mensajesCamposFaltantes[\"hora\"] = validacionTemporal.mensaje;\n      }\n      \n      if (!validacionTemporal.diaHabil) {\n        if (!resultado.camposFaltantes.includes(\"fecha\")) {\n          resultado.camposFaltantes.push(\"fecha\");\n        }\n        resultado.mensajesCamposFaltantes[\"fecha\"] = validacionTemporal.mensaje;\n      }\n    }\n\n    // 7. DETERMINAR ESTADO FINAL\n    if (\n      resultado.camposFaltantes.length === 0 && \n      resultado.proveedoresSimilares.length === 0 && \n      resultado.categoriasSimilares.length === 0 &&\n      resultado.proveedorIdentificado && \n      resultado.categoriaIdentificada &&\n      resultado.fechaValida &&\n      resultado.horaValida &&\n      resultado.diaHabil\n    ) {\n      resultado.todoCorrecto = true;\n    }\n\n    return resultado;\n  } catch (e) {\n    console.error(\"Error en procesamiento de cita:\", e);\n    return {\n      error: e.message,\n      todoCorrecto: false,\n      mensajeSistema: \"Ocurrió un error durante el procesamiento de tu solicitud. Por favor, intenta nuevamente.\"\n    };\n  }\n}\n\n/**\n * Valida que la fecha y hora solicitadas sean válidas\n * (no en el pasado, día hábil, etc.)\n */\nfunction validarFechaHora(fechaStr, horaStr, fechaActualObj) {\n  const resultado = {\n    fechaValida: true,\n    horaValida: true,\n    diaHabil: true,\n    mensaje: \"\"\n  };\n  \n  try {\n    // Crear el objeto fecha a partir del string de fecha\n    let fechaSolicitadaObj = parsearFechaEspanol(fechaStr);\n    console.log(\"Fecha solicitada parseada:\", fechaSolicitadaObj);\n    \n    // Verificar si es un día hábil (L-V)\n    const diaSemana = fechaSolicitadaObj.getDay();\n    if (diaSemana === 0 || diaSemana === 6) { // 0 = domingo, 6 = sábado\n      resultado.diaHabil = false;\n      resultado.mensaje = \"La fecha solicitada cae en fin de semana. Por favor elige un día hábil (lunes a viernes).\";\n      return resultado;\n    }\n    \n    // Verificar si la fecha es hoy\n    const esHoy = esMismaFecha(fechaSolicitadaObj, fechaActualObj);\n    console.log(\"¿Es hoy?\", esHoy);\n    \n    // Si es hoy, verificar que la hora sea futura y con al menos 2 horas de anticipación\n    if (esHoy) {\n      // Convertir la hora solicitada a un objeto Date\n      const horaSolicitadaObj = parsearHora(horaStr, fechaSolicitadaObj);\n      console.log(\"Hora solicitada parseada:\", horaSolicitadaObj);\n      \n      // Verificar que sea futura\n      if (horaSolicitadaObj < fechaActualObj) {\n        resultado.horaValida = false;\n        resultado.mensaje = \"La hora solicitada ya pasó. Por favor elige una hora futura.\";\n        return resultado;\n      }\n      \n      // Verificar que haya al menos 2 horas de anticipación\n      const diferenciaMilis = horaSolicitadaObj - fechaActualObj;\n      const diferenciaHoras = diferenciaMilis / (1000 * 60 * 60);\n      console.log(\"Diferencia en horas:\", diferenciaHoras);\n      \n      if (diferenciaHoras < 2) {\n        resultado.horaValida = false;\n        resultado.mensaje = \"Necesitamos al menos 2 horas de anticipación para programar una cita. Por favor elige una hora posterior o una fecha futura.\";\n        return resultado;\n      }\n    }\n    \n    // Verificar que la fecha no sea pasada\n    if (fechaSolicitadaObj < fechaActualObj && !esHoy) {\n      resultado.fechaValida = false;\n      resultado.mensaje = \"La fecha solicitada ya pasó. Por favor elige una fecha futura.\";\n      return resultado;\n    }\n    \n    // NO HAY RESTRICCIÓN DE HORARIO DE OPERACIÓN\n    \n    return resultado;\n  } catch (e) {\n    console.error(\"Error en validación de fecha/hora:\", e);\n    resultado.fechaValida = false;\n    resultado.mensaje = \"Error al validar la fecha y hora. Por favor verifica el formato.\";\n    return resultado;\n  }\n}\n\n/**\n * Parsea una fecha en español a un objeto Date\n */\nfunction parsearFechaEspanol(fechaStr) {\n  try {\n    // Normalizar la fecha (quitar \"de\", etc.)\n    const fechaNormalizada = fechaStr.toLowerCase()\n      .replace(/\\s+de\\s+/g, \" \")\n      .replace(/\\s+del\\s+/g, \" \");\n    \n    // Mapeo de meses en español a números\n    const meses = {\n      \"enero\": 0, \"febrero\": 1, \"marzo\": 2, \"abril\": 3, \"mayo\": 4, \"junio\": 5,\n      \"julio\": 6, \"agosto\": 7, \"septiembre\": 8, \"octubre\": 9, \"noviembre\": 10, \"diciembre\": 11\n    };\n    \n    // Extraer día, mes, año\n    const partes = fechaNormalizada.split(/\\s+/);\n    console.log(\"Partes de la fecha:\", partes);\n    \n    let dia, mes, año;\n    \n    // Intentar diferentes formatos\n    if (partes.length >= 3) {\n      // Formato \"15 abril 2025\"\n      dia = parseInt(partes[0]);\n      mes = meses[partes[1].toLowerCase()];\n      año = parseInt(partes[2]);\n    } else if (partes.length === 2) {\n      // Formato \"15 abril\" (asumimos año actual)\n      dia = parseInt(partes[0]);\n      mes = meses[partes[1].toLowerCase()];\n      año = new Date().getFullYear();\n    } else if (partes.length === 1 && /^\\d{1,2}\\/\\d{1,2}\\/\\d{2,4}$/.test(partes[0])) {\n      // Formato \"15/04/2025\"\n      const partesSlash = partes[0].split(\"/\");\n      dia = parseInt(partesSlash[0]);\n      mes = parseInt(partesSlash[1]) - 1; // Restar 1 porque en JS los meses van de 0-11\n      año = parseInt(partesSlash[2]);\n      if (año < 100) año += 2000; // Ajustar años de 2 dígitos\n    }\n    \n    // Verificar que los valores sean válidos\n    if (isNaN(dia) || mes === undefined || isNaN(mes) || isNaN(año)) {\n      throw new Error(\"Formato de fecha no reconocido: \" + fechaStr);\n    }\n    \n    // Crear el objeto Date\n    return new Date(año, mes, dia);\n  } catch (e) {\n    console.error(\"Error al parsear fecha:\", e);\n    throw e;\n  }\n}\n\n/**\n * Parsea una hora en formato español a un objeto Date\n */\nfunction parsearHora(horaStr, fechaBase) {\n  try {\n    // Normalizar la hora\n    const horaNormalizada = horaStr.toLowerCase().trim();\n    \n    // Extraer la hora y los minutos\n    let hora, minutos;\n    let esPM = false;\n    \n    // Verificar si es PM\n    if (horaNormalizada.includes(\"pm\") || \n        horaNormalizada.includes(\"p.m.\") || \n        horaNormalizada.includes(\"tarde\") ||\n        horaNormalizada.includes(\"noche\")) {\n      esPM = true;\n    }\n    \n    // Extraer la hora y minutos numéricos\n    const matchHora = horaNormalizada.match(/(\\d+)(?::(\\d+))?/);\n    if (matchHora) {\n      hora = parseInt(matchHora[1]);\n      minutos = matchHora[2] ? parseInt(matchHora[2]) : 0;\n      \n      // Convertir a formato 24 horas si es PM\n      if (esPM && hora < 12) {\n        hora += 12;\n      }\n      \n      // Convertir a formato 24 horas si es AM y son las 12\n      if (!esPM && hora === 12) {\n        hora = 0;\n      }\n    } else {\n      throw new Error(\"Formato de hora no reconocido: \" + horaStr);\n    }\n    \n    // Verificar que los valores sean válidos\n    if (isNaN(hora) || isNaN(minutos)) {\n      throw new Error(\"Formato de hora no reconocido: \" + horaStr);\n    }\n    \n    // Crear el objeto Date con la fecha base y la hora extraída\n    const resultado = new Date(fechaBase);\n    resultado.setHours(hora, minutos, 0, 0);\n    \n    return resultado;\n  } catch (e) {\n    console.error(\"Error al parsear hora:\", e);\n    throw e;\n  }\n}\n\n/**\n * Verifica si dos fechas corresponden al mismo día\n */\nfunction esMismaFecha(fecha1, fecha2) {\n  return fecha1.getDate() === fecha2.getDate() &&\n         fecha1.getMonth() === fecha2.getMonth() &&\n         fecha1.getFullYear() === fecha2.getFullYear();\n}\n\n/**\n * Verifica si la malla de la próxima semana no existe\n */\nfunction verificarMallaProximaNoExiste(mallaProximaSemana) {\n  // Verificar si la malla próxima semana existe y tiene datos\n  if (!mallaProximaSemana || !mallaProximaSemana.datosMallaProxSemana) {\n    return true;\n  }\n  \n  // Verificar si contiene el mensaje de error específico en el título\n  const titulo = mallaProximaSemana.datosMallaProxSemana.titulo;\n  if (titulo && (\n      titulo.includes(\"⚠️\") && \n      (titulo.includes(\"no existe\") || titulo.includes(\"aún no ha sido creada\"))\n    )) {\n    return true;\n  }\n  \n  return false;\n}\n\n/**\n * Verifica si ya hubo una confirmación previa en el historial\n */\nfunction verificarConfirmacionPrevia(historial, mensajeActual) {\n  // Si no hay historial, no puede haber confirmación previa\n  if (!historial) {\n    return { confirmado: false };\n  }\n\n  // Patrones para detectar solicitud de confirmación en historial\n  const patrones = [\n    /Por favor,?\\s?confirma/i,\n    /¿Confirmas/i,\n    /confirma si esta/i,\n    /deseas proceder/i\n  ];\n  \n  // Patrones para detectar confirmación en mensaje actual\n  const patronesConfirmacion = [\n    /\\bsi\\b/i,\n    /confirmo/i,\n    /exacto/i,\n    /\\bese\\b/i,\n    /correcto/i,\n    /afirmativo/i,\n    /ok\\b/i,\n    /está bien/i\n  ];\n\n  // Buscar si hay solicitud de confirmación en historial\n  let solicitudConfirmacionEncontrada = false;\n  let detalles = {\n    proveedor: \"\",\n    fecha: \"\",\n    hora: \"\",\n    categoria: \"\",\n    peso: 0,\n    unidades: 0,\n    ordenCompra: \"\"\n  };\n\n  // Buscar el último mensaje que pidió confirmación\n  const mensajes = historial.split(/\\n+/).filter(m => m.trim());\n  \n  for (let i = mensajes.length - 1; i >= 0; i--) {\n    const mensaje = mensajes[i];\n    \n    // Verificar si este mensaje pide confirmación\n    if (patrones.some(patron => patron.test(mensaje))) {\n      solicitudConfirmacionEncontrada = true;\n      \n      // Extraer proveedor\n      const matchProveedor = mensaje.match(/proveedor\\s+\\*?\\*?([^*\\n.]+)\\*?\\*?/i);\n      if (matchProveedor) {\n        detalles.proveedor = matchProveedor[1].trim();\n      }\n      \n      // Extraer fecha\n      const matchFecha = mensaje.match(/(el día|el|día)\\s+([^,]+?)(?=\\s+a las|\\s+con|\\s+en|\\s+y|$)/i);\n      if (matchFecha) {\n        detalles.fecha = matchFecha[2].trim();\n      }\n      \n      // Extraer hora\n      const matchHora = mensaje.match(/a las\\s+([^,]+?)(?=\\s+con|\\s+en|\\s+y|$)/i);\n      if (matchHora) {\n        detalles.hora = matchHora[1].trim();\n      }\n      \n      // Extraer categoría\n      const matchCategoria = mensaje.match(/categoría\\s+\\*?\\*?([^*\\n,]+)\\*?\\*?/i);\n      if (matchCategoria) {\n        detalles.categoria = matchCategoria[1].trim();\n      }\n      \n      // Extraer peso\n      const matchPeso = mensaje.match(/(\\d+)\\s+kilos/i);\n      if (matchPeso) {\n        detalles.peso = parseInt(matchPeso[1]);\n      }\n      \n      // Extraer unidades\n      const matchUnidades = mensaje.match(/(\\d+)\\s+unidades/i);\n      if (matchUnidades) {\n        detalles.unidades = parseInt(matchUnidades[1]);\n      }\n      \n      // Extraer orden de compra\n      const matchOrden = mensaje.match(/orden\\s+(?:de compra)?\\s*\\*?\\*?([^*\\n.]+)\\*?\\*?/i);\n      if (matchOrden) {\n        detalles.ordenCompra = matchOrden[1].trim();\n      }\n      \n      break;\n    }\n  }\n\n  // Si encontramos una solicitud de confirmación, verificar si el mensaje actual es una confirmación\n  if (solicitudConfirmacionEncontrada) {\n    const esConfirmacion = patronesConfirmacion.some(patron => patron.test(mensajeActual));\n    return {\n      confirmado: esConfirmacion,\n      proveedor: detalles.proveedor,\n      fecha: detalles.fecha,\n      hora: detalles.hora,\n      categoria: detalles.categoria,\n      peso: detalles.peso,\n      unidades: detalles.unidades,\n      ordenCompra: detalles.ordenCompra\n    };\n  }\n\n  return { confirmado: false };\n}\n\n/**\n * Valida el proveedor contra la lista de proveedores disponibles\n */\nfunction validarProveedor(proveedorInput, listaProveedores) {\n  if (!proveedorInput || !listaProveedores || listaProveedores.length === 0) {\n    return {\n      coincidenciaExacta: false,\n      coincidenciaParcialClara: false,\n      coincidenciasParciales: []\n    };\n  }\n\n  // Normalizar entrada (quitar puntos, comas, convertir a minúsculas)\n  const proveedorNormalizado = normalizarTexto(proveedorInput);\n  \n  // Si el input es demasiado corto y genérico (menos de 3 caracteres), exigir más información\n  if (proveedorNormalizado.length < 2) {\n    return {\n      coincidenciaExacta: false,\n      coincidenciaParcialClara: false,\n      coincidenciasParciales: []\n    };\n  }\n  \n  console.log(\"Proveedor normalizado:\", proveedorNormalizado);\n  \n  // Buscar coincidencia exacta (ignorando mayúsculas/minúsculas)\n  const coincidenciaExacta = listaProveedores.find(p => \n    normalizarTexto(p.proveedor) === proveedorNormalizado\n  );\n  \n  if (coincidenciaExacta) {\n    return {\n      coincidenciaExacta: true,\n      coincidenciaParcialClara: false,\n      coincidenciasParciales: [],\n      nombreCompleto: coincidenciaExacta.proveedor\n    };\n  }\n\n  // Buscar primero coincidencias donde el input es un prefijo exacto\n  const coincidenciasPrefijo = listaProveedores\n    .filter(p => {\n      const nombreNormalizado = normalizarTexto(p.proveedor);\n      // Verificar si el nombre del proveedor comienza con el input exacto\n      return nombreNormalizado.startsWith(proveedorNormalizado);\n    })\n    .map(p => p.proveedor);\n  \n  console.log(\"Coincidencias por prefijo:\", coincidenciasPrefijo);\n    \n  // Si solo hay una coincidencia por prefijo, es una coincidencia clara\n  if (coincidenciasPrefijo.length === 1) {\n    const proveedor = listaProveedores.find(p => p.proveedor === coincidenciasPrefijo[0]);\n    return {\n      coincidenciaExacta: false,\n      coincidenciaParcialClara: true,\n      coincidenciasParciales: [],\n      nombreCompleto: proveedor.proveedor\n    };\n  }\n  \n  // Si hay múltiples coincidencias por prefijo, solicitar clarificación específica\n  if (coincidenciasPrefijo.length > 1) {\n    return {\n      coincidenciaExacta: false,\n      coincidenciaParcialClara: false,\n      coincidenciasParciales: coincidenciasPrefijo\n    };\n  }\n\n  // Si no hay coincidencias por prefijo, buscar coincidencias parciales más generales\n  const coincidenciasParciales = listaProveedores\n    .filter(p => {\n      const nombreNormalizado = normalizarTexto(p.proveedor);\n      // Verificar si el input está contenido en el nombre del proveedor\n      return nombreNormalizado.includes(proveedorNormalizado) || \n             // O si las primeras palabras coinciden\n             nombreNormalizado.split(' ').some((palabra, index, arr) => {\n               if (index < 3) { // Solo considerar las primeras 3 palabras\n                 return proveedorNormalizado.includes(palabra) || \n                        palabra.includes(proveedorNormalizado);\n               }\n               return false;\n             });\n    })\n    .map(p => p.proveedor);\n\n  console.log(\"Coincidencias parciales generales:\", coincidenciasParciales);\n\n  // Si hay solo una coincidencia parcial y es claramente identificable\n  if (coincidenciasParciales.length === 1) {\n    const proveedor = listaProveedores.find(p => p.proveedor === coincidenciasParciales[0]);\n    const nombreNormalizado = normalizarTexto(proveedor.proveedor);\n    \n    // Calcular similitud\n    const palabrasInput = proveedorNormalizado.split(' ');\n    const palabrasProveedor = nombreNormalizado.split(' ');\n    \n    // Si el input tiene al menos 2 palabras y ambas están en el nombre del proveedor, considerarlo como claro\n    const palabrasCoincidentes = palabrasInput.filter(palabra => \n      palabrasProveedor.some(p => p.includes(palabra))\n    );\n    \n    const esClaramenteIdentificable = \n      // Si el input es un acrónimo que coincide con las iniciales del proveedor\n      (proveedorNormalizado.length <= 5 && esAcronimo(proveedorNormalizado, proveedor.proveedor)) ||\n      // O si hay suficiente coincidencia de palabras\n      (palabrasInput.length >= 2 && palabrasCoincidentes.length >= 2) ||\n      // O si el input es una parte sustancial del nombre del proveedor\n      (nombreNormalizado.startsWith(proveedorNormalizado) && proveedorNormalizado.length >= 3) ||\n      // Casos especiales para mejorar la coincidencia\n      (proveedorNormalizado.includes(\"spb\") && nombreNormalizado.includes(\"spb colombia\"));\n    \n    if (esClaramenteIdentificable) {\n      return {\n        coincidenciaExacta: false,\n        coincidenciaParcialClara: true,\n        coincidenciasParciales: [],\n        nombreCompleto: proveedor.proveedor\n      };\n    }\n  }\n\n  // En caso de múltiples coincidencias o una coincidencia no clara\n  return {\n    coincidenciaExacta: false,\n    coincidenciaParcialClara: false,\n    coincidenciasParciales: coincidenciasParciales\n  };\n}\n\n/**\n * Valida la categoría contra la lista de categorías disponibles\n */\nfunction validarCategoria(categoriaInput, listaCategorias) {\n  if (!categoriaInput || !listaCategorias || listaCategorias.length === 0) {\n    return {\n      coincidenciaExacta: false,\n      coincidenciaSimilar: false,\n      categoriasSimilares: []\n    };\n  }\n\n  // Normalizar entrada\n  const categoriaNormalizada = normalizarTexto(categoriaInput);\n  \n  // Buscar coincidencia exacta (ignorando mayúsculas/minúsculas)\n  const coincidenciaExacta = listaCategorias.find(c => \n    normalizarTexto(c.CATEGORIA) === categoriaNormalizada\n  );\n  \n  if (coincidenciaExacta) {\n    return {\n      coincidenciaExacta: true,\n      coincidenciaSimilar: false,\n      categoriasSimilares: [],\n      nombreCompleto: coincidenciaExacta.CATEGORIA\n    };\n  }\n\n  // Caso especial para \"arena\" = \"ARENAS\"\n  if (categoriaNormalizada === \"arena\" && listaCategorias.some(c => normalizarTexto(c.CATEGORIA) === \"arenas\")) {\n    const categoriaArenas = listaCategorias.find(c => normalizarTexto(c.CATEGORIA) === \"arenas\");\n    return {\n      coincidenciaExacta: false,\n      coincidenciaSimilar: true,\n      categoriasSimilares: [],\n      nombreCompleto: categoriaArenas.CATEGORIA\n    };\n  }\n\n  // Buscar variantes similares (singular/plural)\n  for (const categoria of listaCategorias) {\n    const categoriaNombre = normalizarTexto(categoria.CATEGORIA);\n    \n    // Verificar si es una variante singular/plural\n    if (\n      // Si la categoría termina en S y sin la S coincide con el input\n      (categoriaNombre.endsWith(\"s\") && categoriaNombre.slice(0, -1) === categoriaNormalizada) ||\n      // O si el input termina en S y sin la S coincide con la categoría\n      (categoriaNormalizada.endsWith(\"s\") && categoriaNormalizada.slice(0, -1) === categoriaNombre)\n    ) {\n      return {\n        coincidenciaExacta: false,\n        coincidenciaSimilar: true,\n        categoriasSimilares: [],\n        nombreCompleto: categoria.CATEGORIA\n      };\n    }\n  }\n\n  // Buscar coincidencias parciales\n  const categoriasSimilares = listaCategorias\n    .filter(c => {\n      const nombreNormalizado = normalizarTexto(c.CATEGORIA);\n      return nombreNormalizado.includes(categoriaNormalizada) || \n             categoriaNormalizada.includes(nombreNormalizado);\n    })\n    .map(c => c.CATEGORIA);\n\n  // Si hay solo una coincidencia parcial, considerarla válida\n  if (categoriasSimilares.length === 1) {\n    return {\n      coincidenciaExacta: false,\n      coincidenciaSimilar: true,\n      categoriasSimilares: [],\n      nombreCompleto: categoriasSimilares[0]\n    };\n  }\n\n  // En caso de múltiples coincidencias o ninguna coincidencia\n  return {\n    coincidenciaExacta: false,\n    coincidenciaSimilar: false,\n    categoriasSimilares: categoriasSimilares\n  };\n}\n\n/**\n * Funciones auxiliares\n */\n\n// Normaliza texto para comparaciones\nfunction normalizarTexto(texto) {\n  if (!texto) return \"\";\n  \n  return texto\n    .toLowerCase()\n    .normalize(\"NFD\")\n    .replace(/[\\u0300-\\u036f]/g, \"\") // Eliminar acentos\n    .replace(/[^\\w\\s]/g, \"\") // Eliminar puntuación\n    .trim();\n}\n\n// Verifica si un texto es un acrónimo de otro\nfunction esAcronimo(acronimo, textoCompleto) {\n  if (!acronimo || !textoCompleto || typeof textoCompleto !== \"string\") {\n    return false;                                   \n  }\n\n  acronimo = acronimo.replace(/\\./g, \"\").toLowerCase();\n\n  const palabras = textoCompleto.split(/\\s+/);\n  const iniciales = palabras.map(p => p.charAt(0).toLowerCase()).join(\"\");\n\n  const inicialesSignificativas = palabras\n    .filter(p => p.length > 2 && !/^(de|la|el|los|las|y|a|en|con|por|para)$/i.test(p))\n    .map(p => p.charAt(0).toLowerCase())\n    .join(\"\");\n\n  return iniciales.includes(acronimo) ||\n         inicialesSignificativas.includes(acronimo);\n}\n\n\n// Esta es la ejecución principal\n// Debe estar al final del archivo\nreturn procesarValidacionCita();"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -38144,
        -10432
      ],
      "id": "b44a4469-5f5d-4ba4-a924-3b4f191ffb10",
      "name": "Code RECOLECCIÓN"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "b2110549-dd58-46b3-9707-dbbe0a5004f2",
              "leftValue": "={{ $('Code estandarizar respuestas MOSTRAR_FRANJAS').item.json.standardResponse.mensajeSistema.length }}",
              "rightValue": 70,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -34800,
        -10784
      ],
      "id": "233682af-279c-4262-88cf-e704f98c21ce",
      "name": "Validación de longitud de caracteres3"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -34256,
        -10864
      ],
      "id": "ca464872-e036-4b20-9bf3-e9e621197c94",
      "name": "No Operation, do nothing5"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $('Consistencia de datos, intención consultar malla').item.json.mensaje }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -34448,
        -10864
      ],
      "id": "25d86ca0-b946-4490-8d19-962485749547",
      "name": "HTTP Request Enviar Mensaje por WhatsApp6"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d9c2ff70-4fd1-4b93-8571-6d0ac5a0093e",
              "name": "mensaje.ia",
              "value": "={{ $('Code estandarizar respuestas MOSTRAR_FRANJAS').item.json.standardResponse.mensajeSistema }}",
              "type": "string"
            },
            {
              "id": "ac8a03be-0292-4735-9580-39a385945c47",
              "name": "mensaje.longitud",
              "value": "={{ $('Code estandarizar respuestas MOSTRAR_FRANJAS').item.json.standardResponse.mensajeSistema.length }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -34448,
        -10672
      ],
      "id": "12a4cd15-30b1-41fd-b74a-0c024a5c623e",
      "name": "Organiza variables del mensaje3"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT TOP 1 *\nFROM FranjasDisponiblesTemp\nWHERE chat_id = '{{$node[\"Organiza el Mensaje\"].json[\"infoMensaje\"][\"chat_id\"]}}'\nORDER BY timestamp_enviado DESC;"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        -40912,
        -8944
      ],
      "id": "ac53e147-6513-46e1-a00c-cf6841238810",
      "name": "Microsoft SQL Obtener Alternativas",
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Versión corregida para la estructura real que estamos recibiendo\nconst resultadosSQL = $input.item.json;\n\n// Preparar respuesta por defecto\nlet respuesta = {\n  estado: \"error\",\n  mensaje: \"No se pudo procesar la confirmación.\",\n  tiempoExpirado: false,\n  alternativasDisponibles: null\n};\n\n// Verificar si hay resultados válidos\nif (!resultadosSQL) {\n  respuesta.mensaje = \"No encontramos alternativas disponibles para confirmar. Por favor, inicia el proceso de agendamiento nuevamente.\";\n  return { respuesta };\n}\n\ntry {\n  // Obtener timestamp enviado\n  const timestampEnviado = new Date(resultadosSQL.timestamp_enviado);\n  const ahora = new Date();\n  const tiempoTranscurrido = ahora.getTime() - timestampEnviado.getTime();\n  const tiempoLimiteMs = 5 * 60 * 1000; // 5 minutos en milisegundos\n\n  // Verificar si han pasado más de 5 minutos\n  if (tiempoTranscurrido > tiempoLimiteMs) {\n    respuesta.estado = \"expirado\";\n    respuesta.tiempoExpirado = true;\n    respuesta.mensaje = \"Lo sentimos, el tiempo para confirmar ha expirado (máximo 5 minutos). Por favor, iniciemos el proceso nuevamente para verificar la disponibilidad actual.\";\n    return { respuesta };\n  }\n\n  // Parsear datos de las franjas\n  const franjasJSON = resultadosSQL.franjas_json;\n  const franjas = JSON.parse(franjasJSON);\n  \n  // Todo está bien, actualizar la respuesta\n  respuesta.estado = \"ok\";\n  respuesta.tiempoExpirado = false;\n  respuesta.alternativasDisponibles = franjas;\n  \n  // Obtener datos adicionales importantes\n  if (resultadosSQL.datos_cita_json) {\n    respuesta.datosCita = JSON.parse(resultadosSQL.datos_cita_json);\n  }\n  \n  return { respuesta };\n} catch (error) {\n  console.log('Error al procesar datos:', error);\n  respuesta.mensaje = \"Ocurrió un error al procesar los datos. Por favor, inicia el proceso nuevamente.\";\n  return { respuesta };\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -40656,
        -8944
      ],
      "id": "b6a5978c-5aad-4fee-8cb9-ee279c93ffce",
      "name": "Code Verificar Tiempo Transcurrido"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "9f152a09-44e9-4eaf-9c88-2b0f1e377191",
              "leftValue": "={{ $json.respuesta.tiempoExpirado }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -40416,
        -8944
      ],
      "id": "a2b64cb7-3219-4a76-8f38-82128eb943c3",
      "name": "If Verificar Expiración"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -39152,
        -9440
      ],
      "id": "a88516fc-5a51-4007-ae54-e111e9eb6d81",
      "name": "OpenAI Chat Model9",
      "credentials": {
        "openAiApi": {
          "id": "AD8kPcNVReuclASd",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "=define",
        "text": "=Eres un asistente de un sistema de agendamiento de citas. Debes notificar que el tiempo para confirmar una cita ha expirado.\n\nGenera un mensaje directo (sin saludos iniciales ni mencionar nombres) que:\n1. Indique claramente que el sistema no permite confirmar la cita porque han pasado más de 5 minutos\n2. Explique brevemente que esta restricción existe para garantizar la disponibilidad real y la trazabilidad de las citas\n3. Mencione que debido a que el cronograma cambia constantemente con nuevas solicitudes, es necesario reiniciar el proceso\n4. Indique específicamente que debe iniciar nuevamente el proceso proporcionando toda la información requerida\n5. Agradezca la comprensión\n\nTono: profesional pero empático, reconociendo el inconveniente pero explicando la necesidad del proceso."
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        -39072,
        -9648
      ],
      "id": "52af3637-1622-4425-893c-c325245371c1",
      "name": "Basic LLM Notificar No Disponibilidad"
    },
    {
      "parameters": {
        "url": "https://graph.microsoft.com/v1.0/sites/a592f886-4560-4e62-9646-1eee7add7abe/drives/b!hviSpWBFYk6WRh7uet16vnNAUYuuQRlGj3ZyS9kSvGVZ4DSg6c5MRqYYm2MdAER8/items/01PPLUUYXY5E2GK3SJ25EZLJPUYJ43H3ME/content",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "microsoftOAuth2Api",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "file",
              "outputPropertyName": "ExcelMallaRecibido2025"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -40128,
        -8928
      ],
      "id": "33bc5e50-e90c-447b-a1c6-dcc60760ea2f",
      "name": "HTTP Request MALLA DE RECIBO ",
      "credentials": {
        "microsoftOAuth2Api": {
          "id": "mh8Z8hxFvd7LDO8D",
          "name": "CuentaMy SharePoint App Desarrollador1 Konfie "
        }
      }
    },
    {
      "parameters": {
        "operation": "xlsx",
        "binaryPropertyName": "ExcelMallaRecibido2025",
        "options": {
          "sheetName": "={{ $('Unificación y consistencia de datos').item.json.hojaSeleccionada }}"
        }
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -39872,
        -9040
      ],
      "id": "9d06a5a5-93b3-4aa4-8c83-f334d12a1b4e",
      "name": "Extract MALLA DE RECIBO "
    },
    {
      "parameters": {
        "jsCode": "// Obtener los datos del Excel\nconst excelData = $input.all();\nconst hojaSeleccionada = $('Unificación y consistencia de datos').first().json.hojaSeleccionada;\n\n// Obtener hora local en Bogotá\nconst ahora = new Date(new Date().toLocaleString(\"en-US\", { timeZone: \"America/Bogota\" }));\nconst diaSemanaActual = ahora.getDay(); // 0=domingo, 1=lunes, ..., 5=viernes\nconst horaActual = ahora.getHours();\nconst minutosActual = ahora.getMinutes();\n// Determinar si es después de las 16:30\nconst pasoLimiteDia = horaActual > 16 || (horaActual === 16 && minutosActual >= 30);\n\n// Definir estructura de la semana y los días\nconst diasSemana = ['lunes', 'martes', 'miércoles', 'jueves', 'viernes'];\n\n// Mapeo para saber qué días incluir si hoy es x día y pasó el límite\n/**\n * Dado el día de la semana actual (0=domingo ... 6=sábado),\n * devuelve qué días de la semana actual deben incluirse según si pasó el límite.\n */\nfunction diasValidosSemanaActual(diaSemanaActual, pasoLimite) {\n  const mapa = {\n    1: ['martes', 'miércoles', 'jueves', 'viernes'],   // lunes\n    2: ['miércoles', 'jueves', 'viernes'],             // martes\n    3: ['jueves', 'viernes'],                          // miércoles\n    4: ['viernes'],                                     // jueves\n    5: []                                               // viernes (muy tarde para sábado)\n  };\n  if (diaSemanaActual < 1 || diaSemanaActual > 5) {\n    return []; // sábado o domingo no se agendan en semana actual\n  }\n  if (!pasoLimite) {\n    // aún está antes de las 4:30 p.m., se puede incluir el día siguiente\n    const siguiente = diasSemana[diaSemanaActual];\n    return [siguiente, ...mapa[diaSemanaActual]];\n  }\n  return mapa[diaSemanaActual];\n}\n\n// Objeto para almacenar la malla estructurada\nconst mallaEstructurada = {\n  titulo: \"\",\n  año: \"\",\n  semana: \"\",\n  rangoDias: \"\",\n  franjas: [],\n  dias: {}\n};\n\n// Tabla de meses y días. Ajusta si necesitas contemplar bisiestos, etc.\nconst meses = {\n  \"enero\": 1,\n  \"febrero\": 2,\n  \"marzo\": 3,\n  \"abril\": 4,\n  \"mayo\": 5,\n  \"junio\": 6,\n  \"julio\": 7,\n  \"agosto\": 8,\n  \"septiembre\": 9,\n  \"octubre\": 10,\n  \"noviembre\": 11,\n  \"diciembre\": 12\n};\n\nconst nombreMes = {\n  1: \"enero\",\n  2: \"febrero\",\n  3: \"marzo\",\n  4: \"abril\",\n  5: \"mayo\",\n  6: \"junio\",\n  7: \"julio\",\n  8: \"agosto\",\n  9: \"septiembre\",\n  10: \"octubre\",\n  11: \"noviembre\",\n  12: \"diciembre\"\n};\n\n/**\n * Función para determinar si un año es bisiesto\n * Un año es bisiesto si es divisible por 4, excepto aquellos divisibles por 100 \n * que no son divisibles por 400\n */\nfunction esBisiesto(year) {\n  return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);\n}\n\n/**\n * Función para obtener el número de días en un mes, considerando años bisiestos\n */\nfunction getDiasMes(mes, año) {\n  const diasPorMes = {\n    1: 31, // enero\n    2: esBisiesto(año) ? 29 : 28, // febrero - ajustado para año bisiesto\n    3: 31, // marzo\n    4: 30, // abril\n    5: 31, // mayo\n    6: 30, // junio\n    7: 31, // julio\n    8: 31, // agosto\n    9: 30, // septiembre\n    10: 31, // octubre\n    11: 30, // noviembre\n    12: 31  // diciembre\n  };\n  \n  return diasPorMes[mes];\n}\n\n/**\n * Función para eliminar acentos y pasar a minúsculas (para buscar palabras clave sin importar tildes ni mayúsculas).\n */\nfunction normalizarTexto(texto) {\n  if (typeof texto !== 'string') return \"\";\n  // Normaliza (NFD) y elimina diacríticos, luego pasa a minúsculas.\n  return texto\n    .normalize(\"NFD\")\n    .replace(/[\\u0300-\\u036f]/g, \"\") // quita acentos\n    .toLowerCase();\n}\n\n/**\n * Dada la información de proveedor, ordenCompra, peso, categoría y unidades,\n * revisa si existe la palabra 'fuera de servicio', 'cancelado' o 'reagendado'\n * en cualquiera de esos campos. De ser así, retorna ese estado especial;\n * de lo contrario, retorna 'ocupado'.\n * \n * Se ignoran mayúsculas, minúsculas y tildes.\n */\nfunction determinarEstadoOcupado(proveedor, ordenCompra, peso, categoria, unidades) {\n  const conjunto = `${proveedor} ${ordenCompra} ${peso} ${categoria} ${unidades}`;\n  const texto = normalizarTexto(conjunto);\n\n  if (texto.includes(\"fuera de servicio\")) {\n    return \"fuera de servicio\";\n  }\n  if (texto.includes(\"cancelado\")) {\n    return \"cancelado\";\n  }\n  if (texto.includes(\"reagendado\")) {\n    return \"reagendado\";\n  }\n  return \"ocupado\";  \n}\n\n// -------------------------------------------------------------\n// 1) PROCESAR DATOS (Cabecera, Horas, Muelles, etc.)\n// -------------------------------------------------------------\nfunction procesarDatos(excelData) {\n  const datos = excelData.map(item => item.json);\n  \n  // A) Cabecera (Título, Año, Rango)\n  datos.forEach((dato, index) => {\n    // Buscar título\n    if (dato.__EMPTY_2 === \"MALLA DE RECIBO CEDI KONFIE IA\") {\n      mallaEstructurada.titulo = dato.__EMPTY_2;\n      \n      // En la siguiente fila puede estar año, semana, rango\n      if (index + 1 < datos.length) {\n        const datoSiguiente = datos[index + 1];\n        if (datoSiguiente) {\n          // Año\n          if (datoSiguiente.__EMPTY_2 && !isNaN(datoSiguiente.__EMPTY_2)) {\n            mallaEstructurada.año = datoSiguiente.__EMPTY_2;\n          }\n          // Semana\n          Object.entries(datoSiguiente).forEach(([k, v]) => {\n            if (typeof v === 'string' && v.includes(\"SEMANA\")) {\n              mallaEstructurada.semana = v;\n            }\n          });\n          // Rango: p.ej. \"LUNES 31 AL VIERNES 4 DE ABRIL\"\n          Object.entries(datoSiguiente).forEach(([k, v]) => {\n            if (typeof v === 'string' && v.includes(\"LUNES\") && v.includes(\"VIERNES\")) {\n              mallaEstructurada.rangoDias = v;\n            }\n          });\n        }\n      }\n    }\n  });\n  \n  // B) Detectar franjas horarias (.__EMPTY = fracción de día)\n  const franjasHorarias = [];\n  datos.forEach(dato => {\n    if (\n      dato.__EMPTY !== undefined &&\n      typeof dato.__EMPTY === 'number' &&\n      dato.__EMPTY > 0 &&\n      dato.__EMPTY < 1\n    ) {\n      const totalMin = Math.round(dato.__EMPTY * 24 * 60);\n      const hh = Math.floor(totalMin / 60);\n      const mm = totalMin % 60;\n      \n      let periodo = \"AM\";\n      let hora12 = hh;\n      if (hh >= 12) {\n        periodo = \"PM\";\n        hora12 = (hh === 12 ? 12 : hh - 12);\n      }\n      if (hh === 0) {\n        hora12 = 12;\n      }\n      \n      const horaStr = `${hora12}:${String(mm).padStart(2, '0')} ${periodo}`;\n      franjasHorarias.push({\n        hora: horaStr,\n        indice: datos.indexOf(dato) // fila base\n      });\n    }\n  });\n  franjasHorarias.sort((a, b) => a.indice - b.indice);\n  mallaEstructurada.franjas = franjasHorarias;\n  \n  // C) Detectar muelles (col)\n  const muellesInfo = {};\n  datos.forEach(dato => {\n    Object.entries(dato).forEach(([key, value]) => {\n      if (value === \"MUELLE 01\" || value === \"MUELLE 02\") {\n        const col = parseInt(key.replace(\"__EMPTY_\", \"\"), 10);\n        const muelleKey = (value === \"MUELLE 01\") ? 'muelle1' : 'muelle2';\n        if (!muellesInfo[muelleKey]) {\n          muellesInfo[muelleKey] = [];\n        }\n        muellesInfo[muelleKey].push(col);\n      }\n    });\n  });\n  if (muellesInfo.muelle1) muellesInfo.muelle1.sort((a, b) => a - b);\n  if (muellesInfo.muelle2) muellesInfo.muelle2.sort((a, b) => a - b);\n  \n  // D) Generar los 5 días (lunes-viernes) con su fecha\n  parsearRangoDias();\n  \n  // E) Extraer Citas\n  extraerCitas(datos, muellesInfo);\n  \n  return mallaEstructurada;\n}\n\n/**\n * Parsea la cadena \"LUNES 31 AL VIERNES 4 DE ABRIL\"\n * (o \"LUNES 31 AL VIERNES 04 DE ABRIL\") y maneja el cruce de mes.\n * Ej.: si dayStart=31 y dayEnd=4, la 1ª fecha es 31 de MARZO,\n * luego 1,2,3,4 de ABRIL, en vez de 32,33, etc.\n */\nfunction parsearRangoDias() {\n  const texto = mallaEstructurada.rangoDias;\n  // Regex simple: p.ej. \"31 AL ... 4 DE ABRIL\"\n  // Captura: dayStart, dayEnd, mesFin\n  // Ojo: si dice \"LUNES 31 DE MARZO AL VIERNES 4 DE ABRIL\",\n  // quedará: dayStart=31, dayEnd=4, month=ABRIL (al final).\n  const regex = /(\\d+)\\s+AL\\s+\\D+(\\d+)\\s+DE\\s+(\\w+)/i;\n  const match = regex.exec(texto);\n  \n  // Por defecto, creamos 5 días vacíos sin fecha\n  diasSemana.forEach(d => {\n    mallaEstructurada.dias[d] = {\n      muelle1: {},\n      muelle2: {}\n    };\n  });\n  \n  if (!match) {\n    // Sin coincidencia, dejamos los días sin fecha\n    return;\n  }\n  \n  const dayStart = parseInt(match[1], 10); // 31\n  const dayEnd   = parseInt(match[2], 10); // 4\n  const finalMonthName = match[3].toLowerCase(); // \"abril\"\n  \n  // Convertimos a número\n  const finalMonth = meses[finalMonthName] || 3; // fallback marzo\n  const yearNum = parseInt(mallaEstructurada.año, 10) || 2025;\n  \n  // Función para obtener la fecha formateada\n  function fechaFormateada(d, m, y) {\n    return `${d} de ${nombreMes[m]} de ${y}`;\n  }\n  \n  // Comprobamos cuántos días tiene el mes final, considerando bisiestos\n  const diasMesFinal = getDiasMes(finalMonth, yearNum);\n  // y del mes previo\n  const monthPrev = (finalMonth === 1) ? 12 : finalMonth - 1;\n  const yearPrev = (finalMonth === 1) ? yearNum - 1 : yearNum;\n  \n  // Arreglo final con 5 fechas\n  const fechasDias = [];\n  \n  if (dayStart <= dayEnd) {\n    // Caso \"normal\": todo en el mismo mes\n    let d = dayStart;\n    for (let i = 0; i < 5; i++) {\n      fechasDias.push({\n        diaSem: diasSemana[i],\n        diaNum: d,\n        mesNum: finalMonth,\n        yearNum: yearNum\n      });\n      d++;\n      if (d > diasMesFinal) {\n        d = 1;\n        const nextMonth = finalMonth % 12 + 1;\n        const nextYear = (nextMonth === 1) ? yearNum + 1 : yearNum;\n        fechasDias[fechasDias.length - 1].mesNum = nextMonth;\n        fechasDias[fechasDias.length - 1].yearNum = nextYear;\n      }\n    }\n  } else {\n    // Caso \"cruza de mes\": dayStart > dayEnd\n    let d = dayStart;\n    let m = monthPrev;\n    let y = yearPrev;\n    \n    for (let i = 0; i < 5; i++) {\n      fechasDias.push({\n        diaSem: diasSemana[i],\n        diaNum: d,\n        mesNum: m,\n        yearNum: y\n      });\n      d++;\n      if (d > getDiasMes(m, y)) {\n        d = 1;\n        m = m % 12 + 1;\n        if (m === 1) {\n          y++;\n        }\n      }\n    }\n  }\n  \n  // Ahora volcamos esas 5 fechas en la estructura\n  fechasDias.forEach(fd => {\n    const { diaSem, diaNum, mesNum, yearNum } = fd;\n    mallaEstructurada.dias[diaSem] = {\n      fechaDia: fechaFormateada(diaNum, mesNum, yearNum),\n      muelle1: {},\n      muelle2: {}\n    };\n  });\n  \n  // Inicializamos las franjas a 'disponible'\n  if (mallaEstructurada.franjas.length > 0) {\n    diasSemana.forEach(d => {\n      mallaEstructurada.franjas.forEach(f => {\n        mallaEstructurada.dias[d].muelle1[f.hora] = {\n          estado: \"disponible\",\n          proveedor: \"\",\n          ordenCompra: \"\",\n          peso: \"\",\n          categoria: \"\",\n          unidades: \"\"\n        };\n        mallaEstructurada.dias[d].muelle2[f.hora] = {\n          estado: \"disponible\",\n          proveedor: \"\",\n          ordenCompra: \"\",\n          peso: \"\",\n          categoria: \"\",\n          unidades: \"\"\n        };\n      });\n    });\n  }\n}\n\n/**\n * Función auxiliar: decide a qué día pertenece una columna,\n * corrigiendo 2 columnas de offset (porque 'Extract from XLSX'\n * deja todo desplazado).\n */\nfunction getDayForColumn(colNumber) {\n  // Ajuste de offset +2\n  const realCol = colNumber + 2;\n\n  // Rangos:\n  //  Lunes:      3..8\n  //  Martes:     9..14\n  //  Miércoles: 15..20\n  //  Jueves:    21..26\n  //  Viernes:   27..32\n  if (realCol >= 3 && realCol <= 8) {\n    return \"lunes\";\n  }\n  if (realCol >= 9 && realCol <= 14) {\n    return \"martes\";\n  }\n  if (realCol >= 15 && realCol <= 20) {\n    return \"miércoles\";\n  }\n  if (realCol >= 21 && realCol <= 26) {\n    return \"jueves\";\n  }\n  if (realCol >= 27 && realCol <= 32) {\n    return \"viernes\";\n  }\n  // Si nada coincide, devolvemos null\n  return null;\n}\n\n/**\n * Extraer las citas para cada franja:\n * - Para cada franja, miramos 3 filas:\n *    - Fila base => proveedor\n *    - Fila base+1 => orden\n *    - Fila base+2 => peso, categoría, unidades\n */\nfunction extraerCitas(datos, muellesInfo) {\n  mallaEstructurada.franjas.forEach(franja => {\n    const indiceBase = franja.indice;\n    if (indiceBase < 0 || indiceBase + 2 >= datos.length) {\n      return; // no hay suficientes filas\n    }\n    \n    // Recorremos muelle1, muelle2 y sus columnas\n    const asignarCita = (muelleKey, cols) => {\n      cols.forEach(col => {\n        const provKey = `__EMPTY_${col}`;\n        const filaProv = datos[indiceBase];\n        \n        // Si en esta fila hay un proveedor o algún texto\n        if (\n          filaProv &&\n          typeof filaProv[provKey] === 'string' &&\n          filaProv[provKey].length > 2\n        ) {\n          // Determinar el día real\n          const diaOk = getDayForColumn(col);\n          if (!diaOk || !mallaEstructurada.dias[diaOk]) {\n            return; // si no coincide con ninguno, saltamos\n          }\n          \n          // Recuperar valores para proveedor, ordenCompra y demás\n          const filaOrden = datos[indiceBase + 1];\n          const filaDet = datos[indiceBase + 2];\n          \n          const proveedor = filaProv[provKey] || \"\";\n          const ordenCompra = filaOrden && filaOrden[provKey] ? filaOrden[provKey] : \"\";\n          const peso = filaDet && filaDet[provKey] ? filaDet[provKey] : \"\";\n          const cat  = filaDet && filaDet[`__EMPTY_${col + 1}`] ? filaDet[`__EMPTY_${col + 1}`] : \"\";\n          const und  = filaDet && filaDet[`__EMPTY_${col + 2}`] ? filaDet[`__EMPTY_${col + 2}`] : \"\";\n          \n          // Antes poníamos estado=\"ocupado\" directamente\n          // Ahora verificamos si el texto contiene \"reagendado\", \"cancelado\" o \"fuera de servicio\".\n          const nuevoEstado = determinarEstadoOcupado(proveedor, ordenCompra, peso, cat, und);\n          \n          // Asignamos los datos\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].estado = nuevoEstado;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].proveedor = proveedor;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].ordenCompra = ordenCompra;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].peso = peso;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].categoria = cat;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].unidades = und;\n        }\n      });\n    };\n    \n    if (muellesInfo.muelle1) {\n      asignarCita('muelle1', muellesInfo.muelle1);\n    }\n    if (muellesInfo.muelle2) {\n      asignarCita('muelle2', muellesInfo.muelle2);\n    }\n  });\n}\n\n// -------------------------------------------------------------\n// 2) FUNCIONES PARA CONSULTAR LA MALLA\n// -------------------------------------------------------------\nfunction buscarFranjasDisponibles(categoria, duracionHoras) {\n  const muelle = \"muelle1\"; // Ajusta si usas \"categoria -> muelle\" real\n  \n  const franjasDisponibles = [];\n  Object.keys(mallaEstructurada.dias).forEach(dia => {\n    const libres = [];\n    for (let i = 0; i <= mallaEstructurada.franjas.length - duracionHoras; i++) {\n      let disponible = true;\n      for (let h = 0; h < duracionHoras; h++) {\n        const idxF = i + h;\n        const horaAct = mallaEstructurada.franjas[idxF].hora;\n        if (\n          mallaEstructurada.dias[dia][muelle][horaAct].estado !== 'disponible'\n        ) {\n          disponible = false;\n          break;\n        }\n      }\n      if (disponible) {\n        libres.push({\n          horaInicio: mallaEstructurada.franjas[i].hora,\n          duracion: duracionHoras\n        });\n      }\n    }\n    if (libres.length > 0) {\n      franjasDisponibles.push({ dia, franjas: libres });\n    }\n  });\n  return franjasDisponibles;\n}\n\nfunction buscarCitasProveedor(nombreProveedor) {\n  const citas = [];\n  Object.keys(mallaEstructurada.dias).forEach(dia => {\n    const muelle1 = mallaEstructurada.dias[dia].muelle1;\n    const muelle2 = mallaEstructurada.dias[dia].muelle2;\n    mallaEstructurada.franjas.forEach(f => {\n      const hora = f.hora;\n      // muelle1\n      if (normalizarTexto(muelle1[hora].proveedor) === normalizarTexto(nombreProveedor)) {\n        citas.push({\n          dia,\n          hora,\n          muelle: \"Muelle 01\",\n          ordenCompra: muelle1[hora].ordenCompra,\n          peso: muelle1[hora].peso,\n          categoria: muelle1[hora].categoria,\n          unidades: muelle1[hora].unidades,\n          estado: muelle1[hora].estado\n        });\n      }\n      // muelle2\n      if (normalizarTexto(muelle2[hora].proveedor) === normalizarTexto(nombreProveedor)) {\n        citas.push({\n          dia,\n          hora,\n          muelle: \"Muelle 02\",\n          ordenCompra: muelle2[hora].ordenCompra,\n          peso: muelle2[hora].peso,\n          categoria: muelle2[hora].categoria,\n          unidades: muelle2[hora].unidades,\n          estado: muelle2[hora].estado\n        });\n      }\n    });\n  });\n  return citas;\n}\n\nfunction consultarFranjasDisponibles(categoria, duracionHoras) {\n  return buscarFranjasDisponibles(categoria, duracionHoras);\n}\n\nfunction consultarCitasProveedor(nombreProveedor) {\n  return buscarCitasProveedor(nombreProveedor);\n}\n\nfunction obtenerInfoMalla() {\n  return {\n    titulo: mallaEstructurada.titulo,\n    año: mallaEstructurada.año,\n    semana: mallaEstructurada.semana,\n    rangoDias: mallaEstructurada.rangoDias,\n    franjas: mallaEstructurada.franjas.map(f => f.hora)\n  };\n}\n\nfunction estaDisponible(dia, hora, muelle) {\n  const info = mallaEstructurada.dias[dia]?.[muelle]?.[hora];\n  return info ? (info.estado === 'disponible') : false;\n}\n\nfunction obtenerCoordenadasCita(dia, hora, muelle) {\n  // Ajustar con tu mapeo de celdas en Excel\n  return {\n    proveedor: `${dia}_${hora}_${muelle}_proveedor`,\n    ordenCompra: `${dia}_${hora}_${muelle}_ordenCompra`,\n    peso: `${dia}_${hora}_${muelle}_peso`,\n    categoria: `${dia}_${hora}_${muelle}_categoria`,\n    unidades: `${dia}_${hora}_${muelle}_unidades`\n  };\n}\n\n// -------------------------------------------------------------\n// 3) EJECUTAR TODO Y RETORNAR\n// -------------------------------------------------------------\n// Procesar todos los datos\nconst malla = procesarDatos(excelData);\n\n// Aplicar el filtro de días válidos según la hora actual\nconst diasPermitidos = diasValidosSemanaActual(diaSemanaActual, pasoLimiteDia);\nObject.keys(malla.dias).forEach(dia => {\n  if (!diasPermitidos.includes(dia)) {\n    delete malla.dias[dia]; // eliminar días no válidos\n  }\n});\n\nconst resultado = {\n  datosMalla: malla,\n  funciones: {\n    consultarFranjasDisponibles,\n    consultarCitasProveedor,\n    obtenerInfoMalla,\n    estaDisponible,\n    obtenerCoordenadasCita\n  }\n};\n\nreturn [resultado];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -39632,
        -9040
      ],
      "id": "4ecf0e0e-153e-4390-82e9-5bb9be4408dc",
      "name": "Estructuración, Datos, Consulta, Citas1"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.1,
      "position": [
        -39312,
        -8944
      ],
      "id": "408129fd-2ff7-44eb-9294-a0d965f31dd8",
      "name": "Merge datos Excel1"
    },
    {
      "parameters": {
        "jsCode": "return [{\n  json: {\n    datosMalla: $items(\"Merge datos Excel1\")[0].json.datosMalla,\n    datosMallaProxSemana: $items(\"Merge datos Excel1\")[1].json.datosMallaProxSemana,\n    hojaSeleccionada: $items(\"Merge datos Excel1\")[0].json.datosMalla.semana\n  }\n}];\n\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -39056,
        -8944
      ],
      "id": "a66dcd0d-7f32-4bd5-9450-8bbefd98838a",
      "name": "Unificación y consistencia de datos2"
    },
    {
      "parameters": {
        "operation": "xlsx",
        "binaryPropertyName": "ExcelMallaRecibido2025",
        "options": {
          "sheetName": "={{    (function() {     const semanaActual = $('Unificación y consistencia de datos').item.json.hojaSeleccionada;     const numeroSemana = parseInt(semanaActual.replace(\"SEMANA \", \"\"));     return `SEMANA ${numeroSemana + 1}`;   })() }}"
        }
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -39872,
        -8848
      ],
      "id": "c2132c0f-03ac-407c-8879-f17fa0d38567",
      "name": "Extract MALLA DE RECIBO Semana Siguiente1",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Si el nodo anterior no devolvió datos (por error al no existir la hoja), retornamos estructura vacía con mensaje\n// Obtener los datos del Excel\nconst excelData = $input.all();\n\n// Mejora en la detección de errores: verificar si hay error explícito o si los datos no son válidos\nconst hayError = excelData.some(item => item.json && item.json.error);\nconst datosInvalidos = !excelData || excelData.length === 0 || hayError;\n\nif (datosInvalidos) {\n  return [{\n    datosMallaProxSemana: {\n      titulo: \"⚠️ La malla de la próxima semana no existe en el archivo Excel o aún no ha sido creada.\",\n      año: \"\",\n      semana: \"\",\n      rangoDias: \"\",\n      franjas: [],\n      dias: {\n        lunes: { muelle1: {}, muelle2: {} },\n        martes: { muelle1: {}, muelle2: {} },\n        miércoles: { muelle1: {}, muelle2: {} },\n        jueves: { muelle1: {}, muelle2: {} },\n        viernes: { muelle1: {}, muelle2: {} }\n      }\n    },\n    funciones: {\n      consultarFranjasDisponibles: \"function not available\",\n      consultarCitasProveedor: \"function not available\",\n      obtenerInfoMalla: \"function not available\",\n      estaDisponible: \"function not available\",\n      obtenerCoordenadasCita: \"function not available\"\n    }\n  }];\n}\n\n// El resto del código permanece igual...\nconst hojaSeleccionada = $('Unificación y consistencia de datos').first().json.hojaSeleccionada;\n\n// Definir estructura de la semana y los días\nconst diasSemana = ['lunes', 'martes', 'miércoles', 'jueves', 'viernes'];\n\n// Objeto para almacenar la malla estructurada\nconst mallaEstructurada = {\n  titulo: \"\",\n  año: \"\",\n  semana: \"\",\n  rangoDias: \"\",\n  franjas: [],\n  dias: {}\n};\n\n// Tabla de meses y días. Ajusta si necesitas contemplar bisiestos, etc.\nconst meses = {\n  \"enero\": 1,\n  \"febrero\": 2,\n  \"marzo\": 3,\n  \"abril\": 4,\n  \"mayo\": 5,\n  \"junio\": 6,\n  \"julio\": 7,\n  \"agosto\": 8,\n  \"septiembre\": 9,\n  \"octubre\": 10,\n  \"noviembre\": 11,\n  \"diciembre\": 12\n};\n\nconst nombreMes = {\n  1: \"enero\",\n  2: \"febrero\",\n  3: \"marzo\",\n  4: \"abril\",\n  5: \"mayo\",\n  6: \"junio\",\n  7: \"julio\",\n  8: \"agosto\",\n  9: \"septiembre\",\n  10: \"octubre\",\n  11: \"noviembre\",\n  12: \"diciembre\"\n};\n\n/**\n * Función para determinar si un año es bisiesto\n * Un año es bisiesto si es divisible por 4, excepto aquellos divisibles por 100 \n * que no son divisibles por 400\n */\nfunction esBisiesto(year) {\n  return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);\n}\n\n/**\n * Función para obtener el número de días en un mes, considerando años bisiestos\n */\nfunction getDiasMes(mes, año) {\n  const diasPorMes = {\n    1: 31, // enero\n    2: esBisiesto(año) ? 29 : 28, // febrero - ajustado para año bisiesto\n    3: 31, // marzo\n    4: 30, // abril\n    5: 31, // mayo\n    6: 30, // junio\n    7: 31, // julio\n    8: 31, // agosto\n    9: 30, // septiembre\n    10: 31, // octubre\n    11: 30, // noviembre\n    12: 31  // diciembre\n  };\n  \n  return diasPorMes[mes];\n}\n\n/**\n * Función para eliminar acentos y pasar a minúsculas (para buscar palabras clave sin importar tildes ni mayúsculas).\n */\nfunction normalizarTexto(texto) {\n  if (typeof texto !== 'string') return \"\";\n  // Normaliza (NFD) y elimina diacríticos, luego pasa a minúsculas.\n  return texto\n    .normalize(\"NFD\")\n    .replace(/[\\u0300-\\u036f]/g, \"\") // quita acentos\n    .toLowerCase();\n}\n\n/**\n * Dada la información de proveedor, ordenCompra, peso, categoría y unidades,\n * revisa si existe la palabra 'fuera de servicio', 'cancelado' o 'reagendado'\n * en cualquiera de esos campos. De ser así, retorna ese estado especial;\n * de lo contrario, retorna 'ocupado'.\n * \n * Se ignoran mayúsculas, minúsculas y tildes.\n */\nfunction determinarEstadoOcupado(proveedor, ordenCompra, peso, categoria, unidades) {\n  const conjunto = `${proveedor} ${ordenCompra} ${peso} ${categoria} ${unidades}`;\n  const texto = normalizarTexto(conjunto);\n\n  if (texto.includes(\"fuera de servicio\")) {\n    return \"fuera de servicio\";\n  }\n  if (texto.includes(\"cancelado\")) {\n    return \"cancelado\";\n  }\n  if (texto.includes(\"reagendado\")) {\n    return \"reagendado\";\n  }\n  return \"ocupado\";  \n}\n\n// -------------------------------------------------------------\n// 1) PROCESAR DATOS (Cabecera, Horas, Muelles, etc.)\n// -------------------------------------------------------------\nfunction procesarDatos(excelData) {\n  // Verificación adicional de datos válidos\n  if (!excelData || !Array.isArray(excelData) || excelData.length === 0) {\n    return {\n      titulo: \"⚠️ La malla de la próxima semana no existe en el archivo Excel o aún no ha sido creada.\",\n      año: \"\",\n      semana: \"\",\n      rangoDias: \"\",\n      franjas: [],\n      dias: {\n        lunes: { muelle1: {}, muelle2: {} },\n        martes: { muelle1: {}, muelle2: {} },\n        miércoles: { muelle1: {}, muelle2: {} },\n        jueves: { muelle1: {}, muelle2: {} },\n        viernes: { muelle1: {}, muelle2: {} }\n      }\n    };\n  }\n  \n  // Intentar mapear datos, con manejo de errores para cada item\n  const datos = excelData.map(item => {\n    try {\n      return item.json || {};\n    } catch (e) {\n      return {};\n    }\n  });\n  \n  // A) Cabecera (Título, Año, Rango)\n  datos.forEach((dato, index) => {\n    // Buscar título\n    if (dato.__EMPTY_2 === \"MALLA DE RECIBO CEDI KONFIE IA\") {\n      mallaEstructurada.titulo = dato.__EMPTY_2;\n      \n      // En la siguiente fila puede estar año, semana, rango\n      if (index + 1 < datos.length) {\n        const datoSiguiente = datos[index + 1];\n        if (datoSiguiente) {\n          // Año\n          if (datoSiguiente.__EMPTY_2 && !isNaN(datoSiguiente.__EMPTY_2)) {\n            mallaEstructurada.año = datoSiguiente.__EMPTY_2;\n          }\n          // Semana\n          Object.entries(datoSiguiente).forEach(([k, v]) => {\n            if (typeof v === 'string' && v.includes(\"SEMANA\")) {\n              mallaEstructurada.semana = v;\n            }\n          });\n          // Rango: p.ej. \"LUNES 31 AL VIERNES 4 DE ABRIL\"\n          Object.entries(datoSiguiente).forEach(([k, v]) => {\n            if (typeof v === 'string' && v.includes(\"LUNES\") && v.includes(\"VIERNES\")) {\n              mallaEstructurada.rangoDias = v;\n            }\n          });\n        }\n      }\n    }\n  });\n  \n  // Si después de procesar no encontramos título, es que no hay malla válida\n  if (!mallaEstructurada.titulo) {\n    mallaEstructurada.titulo = \"⚠️ La malla de la próxima semana no existe en el archivo Excel o aún no ha sido creada.\";\n    return mallaEstructurada;\n  }\n  \n  // B) Detectar franjas horarias (.__EMPTY = fracción de día)\n  const franjasHorarias = [];\n  datos.forEach(dato => {\n    if (\n      dato.__EMPTY !== undefined &&\n      typeof dato.__EMPTY === 'number' &&\n      dato.__EMPTY > 0 &&\n      dato.__EMPTY < 1\n    ) {\n      const totalMin = Math.round(dato.__EMPTY * 24 * 60);\n      const hh = Math.floor(totalMin / 60);\n      const mm = totalMin % 60;\n      \n      let periodo = \"AM\";\n      let hora12 = hh;\n      if (hh >= 12) {\n        periodo = \"PM\";\n        hora12 = (hh === 12 ? 12 : hh - 12);\n      }\n      if (hh === 0) {\n        hora12 = 12;\n      }\n      \n      const horaStr = `${hora12}:${String(mm).padStart(2, '0')} ${periodo}`;\n      franjasHorarias.push({\n        hora: horaStr,\n        indice: datos.indexOf(dato) // fila base\n      });\n    }\n  });\n  franjasHorarias.sort((a, b) => a.indice - b.indice);\n  mallaEstructurada.franjas = franjasHorarias;\n  \n  // C) Detectar muelles (col)\n  const muellesInfo = {};\n  datos.forEach(dato => {\n    Object.entries(dato).forEach(([key, value]) => {\n      if (value === \"MUELLE 01\" || value === \"MUELLE 02\") {\n        const col = parseInt(key.replace(\"__EMPTY_\", \"\"), 10);\n        const muelleKey = (value === \"MUELLE 01\") ? 'muelle1' : 'muelle2';\n        if (!muellesInfo[muelleKey]) {\n          muellesInfo[muelleKey] = [];\n        }\n        muellesInfo[muelleKey].push(col);\n      }\n    });\n  });\n  if (muellesInfo.muelle1) muellesInfo.muelle1.sort((a, b) => a - b);\n  if (muellesInfo.muelle2) muellesInfo.muelle2.sort((a, b) => a - b);\n  \n  // D) Generar los 5 días (lunes-viernes) con su fecha\n  parsearRangoDias();\n  \n  // E) Extraer Citas\n  extraerCitas(datos, muellesInfo);\n  \n  return mallaEstructurada;\n}\n\n/**\n * Parsea la cadena \"LUNES 31 AL VIERNES 4 DE ABRIL\"\n * (o \"LUNES 31 AL VIERNES 04 DE ABRIL\") y maneja el cruce de mes.\n * Ej.: si dayStart=31 y dayEnd=4, la 1ª fecha es 31 de MARZO,\n * luego 1,2,3,4 de ABRIL, en vez de 32,33, etc.\n */\nfunction parsearRangoDias() {\n  const texto = mallaEstructurada.rangoDias;\n  // Regex simple: p.ej. \"31 AL ... 4 DE ABRIL\"\n  // Captura: dayStart, dayEnd, mesFin\n  // Ojo: si dice \"LUNES 31 DE MARZO AL VIERNES 4 DE ABRIL\",\n  // quedará: dayStart=31, dayEnd=4, month=ABRIL (al final).\n  const regex = /(\\d+)\\s+AL\\s+\\D+(\\d+)\\s+DE\\s+(\\w+)/i;\n  const match = regex.exec(texto);\n  \n  // Por defecto, creamos 5 días vacíos sin fecha\n  diasSemana.forEach(d => {\n    mallaEstructurada.dias[d] = {\n      muelle1: {},\n      muelle2: {}\n    };\n  });\n  \n  if (!match) {\n    // Sin coincidencia, dejamos los días sin fecha\n    return;\n  }\n  \n  const dayStart = parseInt(match[1], 10); // 31\n  const dayEnd   = parseInt(match[2], 10); // 4\n  const finalMonthName = match[3].toLowerCase(); // \"abril\"\n  \n  // Convertimos a número\n  const finalMonth = meses[finalMonthName] || 3; // fallback marzo\n  const yearNum = parseInt(mallaEstructurada.año, 10) || 2025;\n  \n  // Función para obtener la fecha formateada\n  function fechaFormateada(d, m, y) {\n    return `${d} de ${nombreMes[m]} de ${y}`;\n  }\n  \n  // Comprobamos cuántos días tiene el mes final, considerando bisiestos\n  const diasMesFinal = getDiasMes(finalMonth, yearNum);\n  // y del mes previo\n  const monthPrev = (finalMonth === 1) ? 12 : finalMonth - 1;\n  const yearPrev = (finalMonth === 1) ? yearNum - 1 : yearNum;\n  \n  // Arreglo final con 5 fechas\n  const fechasDias = [];\n  \n  if (dayStart <= dayEnd) {\n    // Caso \"normal\": todo en el mismo mes\n    let d = dayStart;\n    for (let i = 0; i < 5; i++) {\n      fechasDias.push({\n        diaSem: diasSemana[i],\n        diaNum: d,\n        mesNum: finalMonth,\n        yearNum: yearNum\n      });\n      d++;\n      if (d > diasMesFinal) {\n        d = 1;\n        const nextMonth = finalMonth % 12 + 1;\n        const nextYear = (nextMonth === 1) ? yearNum + 1 : yearNum;\n        fechasDias[fechasDias.length - 1].mesNum = nextMonth;\n        fechasDias[fechasDias.length - 1].yearNum = nextYear;\n      }\n    }\n  } else {\n    // Caso \"cruza de mes\": dayStart > dayEnd\n    let d = dayStart;\n    let m = monthPrev;\n    let y = yearPrev;\n    \n    for (let i = 0; i < 5; i++) {\n      fechasDias.push({\n        diaSem: diasSemana[i],\n        diaNum: d,\n        mesNum: m,\n        yearNum: y\n      });\n      d++;\n      if (d > getDiasMes(m, y)) {\n        d = 1;\n        m = m % 12 + 1;\n        if (m === 1) {\n          y++;\n        }\n      }\n    }\n  }\n  \n  // Ahora volcamos esas 5 fechas en la estructura\n  fechasDias.forEach(fd => {\n    const { diaSem, diaNum, mesNum, yearNum } = fd;\n    mallaEstructurada.dias[diaSem] = {\n      fechaDia: fechaFormateada(diaNum, mesNum, yearNum),\n      muelle1: {},\n      muelle2: {}\n    };\n  });\n  \n  // Inicializamos las franjas a 'disponible'\n  if (mallaEstructurada.franjas.length > 0) {\n    diasSemana.forEach(d => {\n      mallaEstructurada.franjas.forEach(f => {\n        mallaEstructurada.dias[d].muelle1[f.hora] = {\n          estado: \"disponible\",\n          proveedor: \"\",\n          ordenCompra: \"\",\n          peso: \"\",\n          categoria: \"\",\n          unidades: \"\"\n        };\n        mallaEstructurada.dias[d].muelle2[f.hora] = {\n          estado: \"disponible\",\n          proveedor: \"\",\n          ordenCompra: \"\",\n          peso: \"\",\n          categoria: \"\",\n          unidades: \"\"\n        };\n      });\n    });\n  }\n}\n\n/**\n * Función auxiliar: decide a qué día pertenece una columna,\n * corrigiendo 2 columnas de offset (porque 'Extract from XLSX'\n * deja todo desplazado).\n */\nfunction getDayForColumn(colNumber) {\n  // Ajuste de offset +2\n  const realCol = colNumber + 2;\n\n  // Rangos:\n  //  Lunes:      3..8\n  //  Martes:     9..14\n  //  Miércoles: 15..20\n  //  Jueves:    21..26\n  //  Viernes:   27..32\n  if (realCol >= 3 && realCol <= 8) {\n    return \"lunes\";\n  }\n  if (realCol >= 9 && realCol <= 14) {\n    return \"martes\";\n  }\n  if (realCol >= 15 && realCol <= 20) {\n    return \"miércoles\";\n  }\n  if (realCol >= 21 && realCol <= 26) {\n    return \"jueves\";\n  }\n  if (realCol >= 27 && realCol <= 32) {\n    return \"viernes\";\n  }\n  // Si nada coincide, devolvemos null\n  return null;\n}\n\n/**\n * Extraer las citas para cada franja:\n * - Para cada franja, miramos 3 filas:\n *    - Fila base => proveedor\n *    - Fila base+1 => orden\n *    - Fila base+2 => peso, categoría, unidades\n */\nfunction extraerCitas(datos, muellesInfo) {\n  mallaEstructurada.franjas.forEach(franja => {\n    const indiceBase = franja.indice;\n    if (indiceBase < 0 || indiceBase + 2 >= datos.length) {\n      return; // no hay suficientes filas\n    }\n    \n    // Recorremos muelle1, muelle2 y sus columnas\n    const asignarCita = (muelleKey, cols) => {\n      cols.forEach(col => {\n        const provKey = `__EMPTY_${col}`;\n        const filaProv = datos[indiceBase];\n        \n        // Si en esta fila hay un proveedor o algún texto\n        if (\n          filaProv &&\n          typeof filaProv[provKey] === 'string' &&\n          filaProv[provKey].length > 2\n        ) {\n          // Determinar el día real\n          const diaOk = getDayForColumn(col);\n          if (!diaOk || !mallaEstructurada.dias[diaOk]) {\n            return; // si no coincide con ninguno, saltamos\n          }\n          \n          // Recuperar valores para proveedor, ordenCompra y demás\n          const filaOrden = datos[indiceBase + 1];\n          const filaDet = datos[indiceBase + 2];\n          \n          const proveedor = filaProv[provKey] || \"\";\n          const ordenCompra = filaOrden && filaOrden[provKey] ? filaOrden[provKey] : \"\";\n          const peso = filaDet && filaDet[provKey] ? filaDet[provKey] : \"\";\n          const cat  = filaDet && filaDet[`__EMPTY_${col + 1}`] ? filaDet[`__EMPTY_${col + 1}`] : \"\";\n          const und  = filaDet && filaDet[`__EMPTY_${col + 2}`] ? filaDet[`__EMPTY_${col + 2}`] : \"\";\n          \n          // Antes poníamos estado=\"ocupado\" directamente\n          // Ahora verificamos si el texto contiene \"reagendado\", \"cancelado\" o \"fuera de servicio\".\n          const nuevoEstado = determinarEstadoOcupado(proveedor, ordenCompra, peso, cat, und);\n          \n          // Asignamos los datos\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].estado = nuevoEstado;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].proveedor = proveedor;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].ordenCompra = ordenCompra;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].peso = peso;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].categoria = cat;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].unidades = und;\n        }\n      });\n    };\n    \n    if (muellesInfo.muelle1) {\n      asignarCita('muelle1', muellesInfo.muelle1);\n    }\n    if (muellesInfo.muelle2) {\n      asignarCita('muelle2', muellesInfo.muelle2);\n    }\n  });\n}\n\n// -------------------------------------------------------------\n// 2) FUNCIONES PARA CONSULTAR LA MALLA\n// -------------------------------------------------------------\nfunction buscarFranjasDisponibles(categoria, duracionHoras) {\n  const muelle = \"muelle1\"; // Ajusta si usas \"categoria -> muelle\" real\n  \n  const franjasDisponibles = [];\n  Object.keys(mallaEstructurada.dias).forEach(dia => {\n    const libres = [];\n    for (let i = 0; i <= mallaEstructurada.franjas.length - duracionHoras; i++) {\n      let disponible = true;\n      for (let h = 0; h < duracionHoras; h++) {\n        const idxF = i + h;\n        const horaAct = mallaEstructurada.franjas[idxF].hora;\n        if (\n          mallaEstructurada.dias[dia][muelle][horaAct].estado !== 'disponible'\n        ) {\n          disponible = false;\n          break;\n        }\n      }\n      if (disponible) {\n        libres.push({\n          horaInicio: mallaEstructurada.franjas[i].hora,\n          duracion: duracionHoras\n        });\n      }\n    }\n    if (libres.length > 0) {\n      franjasDisponibles.push({ dia, franjas: libres });\n    }\n  });\n  return franjasDisponibles;\n}\n\nfunction buscarCitasProveedor(nombreProveedor) {\n  const citas = [];\n  Object.keys(mallaEstructurada.dias).forEach(dia => {\n    const muelle1 = mallaEstructurada.dias[dia].muelle1;\n    const muelle2 = mallaEstructurada.dias[dia].muelle2;\n    mallaEstructurada.franjas.forEach(f => {\n      const hora = f.hora;\n      // muelle1\n      if (normalizarTexto(muelle1[hora].proveedor) === normalizarTexto(nombreProveedor)) {\n        citas.push({\n          dia,\n          hora,\n          muelle: \"Muelle 01\",\n          ordenCompra: muelle1[hora].ordenCompra,\n          peso: muelle1[hora].peso,\n          categoria: muelle1[hora].categoria,\n          unidades: muelle1[hora].unidades,\n          estado: muelle1[hora].estado\n        });\n      }\n      // muelle2\n      if (normalizarTexto(muelle2[hora].proveedor) === normalizarTexto(nombreProveedor)) {\n        citas.push({\n          dia,\n          hora,\n          muelle: \"Muelle 02\",\n          ordenCompra: muelle2[hora].ordenCompra,\n          peso: muelle2[hora].peso,\n          categoria: muelle2[hora].categoria,\n          unidades: muelle2[hora].unidades,\n          estado: muelle2[hora].estado\n        });\n      }\n    });\n  });\n  return citas;\n}\n\nfunction consultarFranjasDisponibles(categoria, duracionHoras) {\n  return buscarFranjasDisponibles(categoria, duracionHoras);\n}\n\nfunction consultarCitasProveedor(nombreProveedor) {\n  return buscarCitasProveedor(nombreProveedor);\n}\n\nfunction obtenerInfoMalla() {\n  return {\n    titulo: mallaEstructurada.titulo,\n    año: mallaEstructurada.año,\n    semana: mallaEstructurada.semana,\n    rangoDias: mallaEstructurada.rangoDias,\n    franjas: mallaEstructurada.franjas.map(f => f.hora)\n  };\n}\n\nfunction estaDisponible(dia, hora, muelle) {\n  const info = mallaEstructurada.dias[dia]?.[muelle]?.[hora];\n  return info ? (info.estado === 'disponible') : false;\n}\n\nfunction obtenerCoordenadasCita(dia, hora, muelle) {\n  // Ajustar con tu mapeo de celdas en Excel\n  return {\n    proveedor: `${dia}_${hora}_${muelle}_proveedor`,\n    ordenCompra: `${dia}_${hora}_${muelle}_ordenCompra`,\n    peso: `${dia}_${hora}_${muelle}_peso`,\n    categoria: `${dia}_${hora}_${muelle}_categoria`,\n    unidades: `${dia}_${hora}_${muelle}_unidades`\n  };\n}\n\n// -------------------------------------------------------------\n// 3) EJECUTAR TODO Y RETORNAR\n// -------------------------------------------------------------\nconst malla = procesarDatos(excelData);\n\nconst resultado = {\n  datosMallaProxSemana: malla,\n  funciones: {\n    consultarFranjasDisponibles,\n    consultarCitasProveedor,\n    obtenerInfoMalla,\n    estaDisponible,\n    obtenerCoordenadasCita\n  }\n};\n\nreturn [resultado];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -39632,
        -8848
      ],
      "id": "ce20a2eb-55db-453c-87a3-7910fb53922b",
      "name": "Estructuración, Datos, Consulta, Citas Proxima Semana1"
    },
    {
      "parameters": {
        "jsCode": "// =========  VALIDACIÓN DE CITA EN CRONOGRAMA  =========\n// Valida que la franja siga libre justo después de la confirmación del proveedor\n\n// NUEVO: Detectar retractación al inicio\nconst validacionSeleccion = $input.first().json.output;\n\nif (validacionSeleccion.esRetractacion === true) {\n  return [{\n    json: {\n      franjaDisponible: false,\n      esRetractacion: true,\n      forzarReset: true,\n      motivoRetractacion: validacionSeleccion.motivoRetractacion,\n      mensajeReset: \"🔄 **Proceso reiniciado por cambios múltiples**\\n\\nPara evitar errores, cuando te presento opciones, por favor elige una de la lista.\\n\\n📝 Proporciona todos los datos completos en un solo mensaje:\\n• Proveedor\\n• Fecha\\n• Hora\\n• Categoría\\n• Peso\\n• Unidades\\n• Orden de compra\"\n    }\n  }];\n}\n\nfunction validarDisponibilidadCitaEnCronograma(items) {\n  try {\n    /* 1. --- Datos que vienen del nodo de verificación de tiempo --- */\n    const resp = $node[\"Code Verificar Tiempo Transcurrido\"].json.respuesta.alternativasDisponibles;\n    if (!resp) {\n      return [{ json:{ franjaDisponible:false, mensaje:\"No se encontró la cita a validar.\" } }];\n    }\n\n    /* 2. --- ¿El proveedor eligió una alternativa? ------------------ */\n    const salidaLLM      = items[0].json.output ?? items[0].json;   // el LLM suele venir como root\n    const tieneAlt       = salidaLLM?.seleccionaAlternativa === true;\n    const datosValidar   = tieneAlt && salidaLLM.datosSeleccionados\n      ? salidaLLM.datosSeleccionados\n      : {\n          fecha           : resp.fecha,\n          fechaFormateada : resp.fechaFormateada,\n          horaInicio      : resp.horaInicio,\n          horaFin         : resp.horaFin,\n          muelle          : resp.muelle,\n          duracionHoras   : resp.duracionHoras       // puede venir undefined\n        };\n\n    /* --- Si no llegó duracionHoras, la calculamos ------------------ */\n    if (!datosValidar.duracionHoras) {\n      datosValidar.duracionHoras = calcularDuracionAproximada(\n        datosValidar.horaInicio, datosValidar.horaFin\n      );\n    }\n\n    /* 3. --- Mallas de la semana actual y próxima ------------------- */\n    const nodoDatos = $node[\"Unificación y consistencia de datos2\"].json;\n    const datosMalla = nodoDatos.datosMalla;\n    const datosMallaProxSemana = nodoDatos.datosMallaProxSemana;\n    \n    if (!datosMalla || !datosMallaProxSemana) {\n      return [{ json:{ franjaDisponible:false, mensaje:\"No llegó la malla horaria.\" } }];\n    }\n\n    /* 4. --- Validación propiamente dicha --------------------------- */\n    // Variable para almacenar qué malla se utilizó en la verificación\n  let mallaUtilizada = null;\n  \n  const disponible = verificarDisponibilidadHoraSolicitada(\n      datosValidar.fecha,\n      datosValidar.horaInicio,\n      datosValidar.muelle,\n      datosValidar.duracionHoras,\n      datosMalla,\n      datosMallaProxSemana,\n      (malla) => { mallaUtilizada = malla; } // Callback para capturar la malla usada\n    );\n\n    // Obtener el número de semana de la malla utilizada para la validación\n    const nombreHoja = disponible && mallaUtilizada ? mallaUtilizada.semana : null;\n    \n    const respuesta = {\n      franjaDisponible : disponible,\n      mensaje : disponible\n        ? `¡Genial! Hay espacio para el ${datosValidar.fecha}, de ` +\n          `${datosValidar.horaInicio} a ${datosValidar.horaFin} en ${datosValidar.muelle}.`\n        : \"Lo siento, la franja horaria seleccionada ya no está disponible. \" +\n          \"Por favor elige otra opción.\",\n      datosValidados : {\n        ...datosValidar,\n        disponibilidadConfirmada : disponible\n      },\n      nombreHoja : nombreHoja // Agregamos el nombre de la hoja donde se debe insertar la cita\n    };\n\n    return [{ json: respuesta }];\n\n  } catch (err) {\n    console.error(\"Error en validación:\", err);\n    return [{ json:{ franjaDisponible:false, mensaje:`Error al validar: ${err.message}` } }];\n  }\n}\n\n/* ═══════════════════════════════════════════════════════════════════\n *  UTILIDADES \n * ═════════════════════════════════════════════════════════════════ */\n\nfunction verificarDisponibilidadHoraSolicitada(\n  fechaSolicitada, horaSolicitada, muelle, horasNecesarias,\n  mallaActual, mallaProxima, callbackMalla = null\n){\n  try {\n    // --- Normalizamos -------------------------------------------------\n    if (!fechaSolicitada || !horaSolicitada || !muelle) return false;\n\n    const fechaObj  = parsearFechaEspanol(fechaSolicitada);\n    const malla     = seleccionarMallaParaFecha(fechaObj, mallaActual, mallaProxima);\n    if (!malla) return false;\n    \n    // Si se proporcionó una función callback, llamarla con la malla seleccionada\n    if (typeof callbackMalla === 'function') {\n      callbackMalla(malla);\n    }\n\n    const diaSem    = obtenerDiaSemanaEspanol(fechaObj);\n    const keyMuelle = normalizarMuelle(muelle);\n\n    if (!malla.dias[diaSem] || !malla.dias[diaSem][keyMuelle]) return false;\n\n    if (!malla.franjas || !Array.isArray(malla.franjas)) return false;\n    const franjas   = malla.franjas.map(f => f.hora);\n    const idxInicio = franjas.findIndex(h => limpiarHora(h) === limpiarHora(horaSolicitada));\n    \n    if (idxInicio === -1 || idxInicio + horasNecesarias > franjas.length) return false;\n\n    for (let i = 0; i < horasNecesarias; i++) {\n      const hora = franjas[idxInicio + i];\n      const fr   = malla.dias[diaSem][keyMuelle][hora];\n      if (!fr || (fr.estado ?? \"\").toLowerCase() !== \"disponible\") return false;\n    }\n    return true;\n  } catch(e){ \n    console.error(\"Error en verificarDisponibilidadHoraSolicitada:\", e); \n    return false; \n  }\n}\n\n/* ---------- Helpers de normalización ------------------------------ */\nconst limpiarHora = h => h.trim().replace(/^0+(?=\\d)/, \"\").toUpperCase();\n\nfunction normalizarMuelle(txt = \"\") {\n  return txt\n    .toLowerCase()\n    .normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\") // sin tildes\n    .replace(/\\s+/g, \"\");\n}\n\n/* ---- FIX: elegir malla correcta cuando el rango cruza de mes ----- */\nfunction seleccionarMallaParaFecha(fechaObj, mallaActual, mallaProxima){\n  const dentro = (malla) => {\n    if (!malla) return false;\n    const r = rangoDesdeDias(malla);\n    if (!r) return false;\n    \n    // Simplificar comparación ignorando horas/minutos/segundos\n    const fechaSimple = new Date(fechaObj.getFullYear(), fechaObj.getMonth(), fechaObj.getDate());\n    const inicioSimple = new Date(r.inicio.getFullYear(), r.inicio.getMonth(), r.inicio.getDate());\n    const finSimple = new Date(r.fin.getFullYear(), r.fin.getMonth(), r.fin.getDate());\n    \n    return fechaSimple >= inicioSimple && fechaSimple <= finSimple;\n  };\n  \n  if (dentro(mallaActual)) return mallaActual;\n  if (dentro(mallaProxima)) return mallaProxima;\n  return null;\n}\n\n/* Rango basado en las fechas reales de cada día (mín-máx) */\nfunction rangoDesdeDias(malla){\n  if (!malla || !malla.dias) return null;\n  let min=null, max=null;\n  for (const d of Object.values(malla.dias)){\n    if (d && d.fechaDia){\n      const f = parsearFechaEspanol(d.fechaDia);\n      if (!min || f < min) min=f;\n      if (!max || f > max) max=f;\n    }\n  }\n  return (min && max) ? {inicio:min, fin:max} : null;\n}\n\n// Función para calcular la duración aproximada en horas basada en las horas de inicio y fin\nfunction calcularDuracionAproximada(horaInicio, horaFin) {\n  try {\n    if (!horaInicio || !horaFin) {\n      return 3; // Valor por defecto si no se puede calcular\n    }\n    \n    // Verificar si las horas están en formato AM/PM\n    const esFormatoAMPM = /AM|PM/i.test(horaInicio) && /AM|PM/i.test(horaFin);\n    \n    if (esFormatoAMPM) {\n      // Convertir horas de formato AM/PM a 24 horas\n      const horaInicioObj = convertirHoraAMPMA24H(horaInicio);\n      const horaFinObj = convertirHoraAMPMA24H(horaFin);\n      \n      // Calcular diferencia en horas\n      let diferenciaHoras = horaFinObj.hora - horaInicioObj.hora;\n      \n      // Ajustar por diferencia en minutos\n      if (horaFinObj.minutos < horaInicioObj.minutos) {\n        diferenciaHoras--;\n      }\n      \n      // Si la diferencia es negativa, asumimos que cruza la medianoche\n      if (diferenciaHoras < 0) {\n        diferenciaHoras += 24;\n      }\n      \n      return diferenciaHoras;\n    } else {\n      // Formato 24 horas\n      const [horasInicio] = horaInicio.split(':').map(Number);\n      const [horasFin] = horaFin.split(':').map(Number);\n      \n      let diferenciaHoras = horasFin - horasInicio;\n      if (diferenciaHoras < 0) {\n        diferenciaHoras += 24;\n      }\n      \n      return diferenciaHoras;\n    }\n  } catch (error) {\n    console.error(`Error calculando duración:`, error);\n    return 3; // Valor por defecto\n  }\n}\n\n// Función auxiliar para convertir hora de formato AM/PM a formato 24 horas\nfunction convertirHoraAMPMA24H(horaAMPM) {\n  try {\n    const [tiempo, periodo] = horaAMPM.split(/\\s+/);\n    let [horas, minutos] = tiempo.split(':').map(Number);\n    \n    // Ajustar horas para formato de 24 horas\n    if (periodo.toUpperCase() === 'PM' && horas < 12) {\n      horas += 12;\n    } else if (periodo.toUpperCase() === 'AM' && horas === 12) {\n      horas = 0;\n    }\n    \n    return {\n      hora: horas,\n      minutos: minutos || 0\n    };\n  } catch (error) {\n    console.error(`Error convirtiendo hora:`, error);\n    return { hora: 0, minutos: 0 }; // Fallback\n  }\n}\n\n// Función auxiliar para calcular la hora de fin basada en la hora de inicio y la duración\nfunction calcularHoraFin(horaInicio, duracionHoras) {\n  try {\n    // Verificar si la hora de inicio tiene formato AM/PM\n    const esFormatoAMPM = /AM|PM/i.test(horaInicio);\n    \n    if (esFormatoAMPM) {\n      // Convertir hora formato AM/PM\n      const [tiempo, periodo] = horaInicio.split(/\\s+/);\n      let [horas, minutos] = tiempo.split(':').map(Number);\n      \n      // Ajustar horas para formato de 24 horas\n      if (periodo.toUpperCase() === 'PM' && horas < 12) {\n        horas += 12;\n      } else if (periodo.toUpperCase() === 'AM' && horas === 12) {\n        horas = 0;\n      }\n      \n      // Añadir duración\n      horas += duracionHoras;\n      \n      // Convertir de vuelta a AM/PM\n      let nuevoPeriodo = 'AM';\n      if (horas >= 12) {\n        nuevoPeriodo = 'PM';\n        if (horas > 12) {\n          horas -= 12;\n        }\n      }\n      if (horas === 0) {\n        horas = 12;\n        nuevoPeriodo = 'AM';\n      }\n      \n      // Formatear resultado\n      return `${horas}:${minutos.toString().padStart(2, '0')} ${nuevoPeriodo}`;\n    } else {\n      // Formato 24 horas\n      const [horas, minutos] = horaInicio.split(':').map(Number);\n      const nuevasHoras = (horas + duracionHoras) % 24;\n      return `${nuevasHoras}:${minutos.toString().padStart(2, '0')}`;\n    }\n  } catch (error) {\n    console.error(`Error calculando hora fin:`, error);\n    return \"\"; // Fallback\n  }\n}\n\n// Convertir fecha en formato español a formato ISO (YYYY-MM-DD)\nfunction convertirFechaAFormatoISO(fechaTexto) {\n  try {\n    if (!fechaTexto || typeof fechaTexto !== 'string') {\n      throw new Error(\"Texto de fecha inválido\");\n    }\n    \n    // Formato esperado: \"dd de mes de yyyy\"\n    const partes = fechaTexto.split(\" de \");\n    if (partes.length !== 3) {\n      throw new Error(`Formato de fecha inválido: ${fechaTexto}`);\n    }\n    \n    const dia = parseInt(partes[0], 10);\n    if (isNaN(dia) || dia < 1 || dia > 31) {\n      throw new Error(`Día inválido: ${partes[0]}`);\n    }\n    \n    const mes = obtenerNumeroMes(partes[1]);\n    if (mes === -1) {\n      throw new Error(`Mes inválido: ${partes[1]}`);\n    }\n    \n    const anio = parseInt(partes[2], 10);\n    if (isNaN(anio) || anio < 2000 || anio > 2100) {\n      throw new Error(`Año inválido: ${partes[2]}`);\n    }\n    \n    // Formatear como YYYY-MM-DD\n    const mesStr = (mes + 1).toString().padStart(2, '0');\n    const diaStr = dia.toString().padStart(2, '0');\n    \n    return `${anio}-${mesStr}-${diaStr}`;\n  } catch (error) {\n    console.error(`Error convirtiendo fecha: ${error.message}`);\n    return \"\"; // Cadena vacía como fallback\n  }\n}\n\n// Obtener número de mes a partir del nombre en español\nfunction obtenerNumeroMes(nombreMes) {\n  if (!nombreMes || typeof nombreMes !== 'string') {\n    return -1;\n  }\n  \n  const nombreMesLower = nombreMes.toLowerCase();\n  const meses = [\n    \"enero\", \"febrero\", \"marzo\", \"abril\", \"mayo\", \"junio\",\n    \"julio\", \"agosto\", \"septiembre\", \"octubre\", \"noviembre\", \"diciembre\"\n  ];\n  \n  return meses.indexOf(nombreMesLower);\n}\n\n// Convertir fecha en formato español a objeto Date\nfunction parsearFechaEspanol(fechaTexto) {\n  try {\n    if (!fechaTexto || typeof fechaTexto !== 'string') {\n      throw new Error(\"Texto de fecha inválido\");\n    }\n    \n    // Formato esperado: \"dd de mes de yyyy\"\n    const partes = fechaTexto.split(\" de \");\n    if (partes.length !== 3) {\n      throw new Error(`Formato de fecha inválido: ${fechaTexto}`);\n    }\n    \n    const dia = parseInt(partes[0], 10);\n    if (isNaN(dia) || dia < 1 || dia > 31) {\n      throw new Error(`Día inválido: ${partes[0]}`);\n    }\n    \n    const mes = obtenerNumeroMes(partes[1]);\n    if (mes === -1) {\n      throw new Error(`Mes inválido: ${partes[1]}`);\n    }\n    \n    const anio = parseInt(partes[2], 10);\n    if (isNaN(anio) || anio < 2000 || anio > 2100) {\n      throw new Error(`Año inválido: ${partes[2]}`);\n    }\n    \n    return new Date(anio, mes, dia);\n  } catch (error) {\n    console.error(`Error parseando fecha: ${error.message}`);\n    return new Date(); // Fecha actual como fallback\n  }\n}\n\n// Obtener día de la semana en español\nfunction obtenerDiaSemanaEspanol(fecha) {\n  if (!fecha || !(fecha instanceof Date)) {\n    console.error(\"Fecha inválida para obtener día de semana\");\n    return \"\";\n  }\n  \n  const diaSemana = fecha.getDay();\n  \n  // El código original usa días laborables (lunes a viernes)\n  // 0 = domingo, 1 = lunes, ..., 6 = sábado\n  if (diaSemana === 0 || diaSemana === 6) {\n    console.error(\"La fecha corresponde a un fin de semana (sábado o domingo)\");\n    return \"\";\n  }\n  \n  const diasSemana = [\"domingo\", \"lunes\", \"martes\", \"miércoles\", \"jueves\", \"viernes\", \"sábado\"];\n  return diasSemana[diaSemana];\n}\n\n// Parsear rango de días de una malla\nfunction parsearRangoDias(rangoTexto) {\n  try {\n    if (!rangoTexto || typeof rangoTexto !== 'string') {\n      throw new Error(\"Texto de rango inválido\");\n    }\n    \n    // Formato esperado: \"LUNES DD AL VIERNES DD DE MES\"\n    const partes = rangoTexto.toUpperCase().split(\" \");\n    \n    // Buscar día inicial\n    let diaInicio = null;\n    let indexAL = -1;\n    \n    for (let i = 0; i < partes.length; i++) {\n      if (partes[i] === \"AL\") {\n        indexAL = i;\n        break;\n      }\n      \n      // Intentar convertir a número\n      const posibleDia = parseInt(partes[i], 10);\n      if (!isNaN(posibleDia)) {\n        diaInicio = posibleDia;\n      }\n    }\n    \n    if (diaInicio === null || indexAL === -1) {\n      throw new Error(\"No se pudo identificar el día de inicio o la palabra 'AL'\");\n    }\n    \n    // Buscar día final\n    let diaFin = null;\n    let mesIndex = -1;\n    \n    for (let i = indexAL + 1; i < partes.length; i++) {\n      if (partes[i] === \"DE\") {\n        mesIndex = i;\n        break;\n      }\n      \n      // Intentar convertir a número\n      const posibleDia = parseInt(partes[i], 10);\n      if (!isNaN(posibleDia)) {\n        diaFin = posibleDia;\n      }\n    }\n    \n    if (diaFin === null || mesIndex === -1 || mesIndex + 1 >= partes.length) {\n      throw new Error(\"No se pudo identificar el día final o el mes\");\n    }\n    \n    const nombreMes = partes[mesIndex + 1].toLowerCase();\n    const mes = obtenerNumeroMes(nombreMes);\n    \n    if (mes === -1) {\n      throw new Error(`Mes inválido: ${nombreMes}`);\n    }\n    \n    const anio = new Date().getFullYear();\n    \n    return {\n      inicio: new Date(anio, mes, diaInicio),\n      fin: new Date(anio, mes, diaFin)\n    };\n  } catch (error) {\n    console.error(`Error parseando rango: ${error.message}`);\n    \n    // Rango amplio como fallback\n    const hoy = new Date();\n    const finDeMes = new Date(hoy.getFullYear(), hoy.getMonth() + 1, 0);\n    \n    return {\n      inicio: hoy,\n      fin: finDeMes\n    };\n  }\n}\n\n// Devolver la función principal para n8n\nreturn validarDisponibilidadCitaEnCronograma(items);"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -38400,
        -8944
      ],
      "id": "dc89aef4-da67-4db7-a112-188a102dbd31",
      "name": "Code VALIDACIÓN DE CITA EN CRONOGRAMA"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "15af6812-2871-4888-9658-c24f185bcbd4",
              "leftValue": "={{ $json.franjaDisponible }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            },
            {
              "id": "032ef339-3304-444d-89eb-26aa314e06b8",
              "leftValue": "={{ $json.forzarReset }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "false",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -38160,
        -8944
      ],
      "id": "e757a9fe-60a2-406b-a16d-13e754876f7a",
      "name": "If CREACION DE CITA EN CRONOGRAMA"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -36896,
        -8400
      ],
      "id": "df753b28-5cae-4fb8-90c1-82a2fc59455e",
      "name": "OpenAI Chat Model10",
      "credentials": {
        "openAiApi": {
          "id": "AD8kPcNVReuclASd",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "=define",
        "text": "=Eres un asistente de un sistema de agendamiento de citas para la entrega de mercancía en la bodega. Debes notificar que, mientras el cliente decidía confirmar la cita, otro proveedor ocupó esa franja horaria.\n\nGenera un mensaje directo (sin saludos iniciales ni mencionar nombres) que:\n\nIndique claramente que la cita no pudo confirmarse porque la franja se asignó a otro proveedor.\n\nExplique brevemente que esto sucede debido a que las franjas se confirman en tiempo real y pueden cambiar constantemente.\n\nMencione que, para revisar nuevas opciones, es necesario reiniciar el proceso y volver a proporcionar los datos solicitados.\n\nDestaque la importancia de contar con información actualizada para garantizar disponibilidad y trazabilidad.\n\nAgradezca la comprensión.\n\nTono: profesional pero empático, reconociendo el inconveniente y explicando la necesidad de reiniciar el proceso."
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        -36816,
        -8608
      ],
      "id": "46b7f97a-48cf-4e4c-bfa0-a0568ed73d49",
      "name": "Basic LLM Notificar No Disponibilidad1"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "4bfbecb3-9d4f-4425-aa76-a92abc7708fb",
              "leftValue": "={{ $('Basic LLM Notificar No Disponibilidad').item.json.text.length }}",
              "rightValue": 70,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -37968,
        -9664
      ],
      "id": "a2e5bea2-07ba-42c5-9016-315f112e8e22",
      "name": "Validación de longitud de caracteres4"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d9c2ff70-4fd1-4b93-8571-6d0ac5a0093e",
              "name": "mensaje.ia",
              "value": "={{ $('Basic LLM Notificar No Disponibilidad').item.json.text }}",
              "type": "string"
            },
            {
              "id": "ac8a03be-0292-4735-9580-39a385945c47",
              "name": "mensaje.longitud",
              "value": "={{ $('Basic LLM Notificar No Disponibilidad').item.json.text.length }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -34848,
        -9840
      ],
      "id": "536a954f-700c-4047-b571-657c4238cb0e",
      "name": "Organiza variables del mensaje4"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -37488,
        -9872
      ],
      "id": "a92d3bdb-efdc-4366-ba25-5f585a47b537",
      "name": "No Operation, do nothing6"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $('Code Respuesta Faltantes').item.json.text }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -37664,
        -9872
      ],
      "id": "0c3a3f2e-3952-4572-9af0-08c1234f3a3b",
      "name": "HTTP Request Enviar Mensaje por WhatsApp7"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "4bfbecb3-9d4f-4425-aa76-a92abc7708fb",
              "leftValue": "={{ $('Basic LLM Notificar No Disponibilidad1').item.json.text.length }}",
              "rightValue": 70,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -34960,
        -8384
      ],
      "id": "8aecafad-f556-49b3-bd8d-f545c1a7dbaf",
      "name": "Validación de longitud de caracteres5"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d9c2ff70-4fd1-4b93-8571-6d0ac5a0093e",
              "name": "mensaje.ia",
              "value": "={{ $('Basic LLM Notificar No Disponibilidad1').item.json.text }}",
              "type": "string"
            },
            {
              "id": "ac8a03be-0292-4735-9580-39a385945c47",
              "name": "mensaje.longitud",
              "value": "={{ $('Basic LLM Notificar No Disponibilidad1').item.json.text.length }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -33744,
        -8352
      ],
      "id": "05fdd7ef-b13e-4e17-9349-3aeeb1a8aa36",
      "name": "Organiza variables del mensaje5"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -34480,
        -8592
      ],
      "id": "4a662a1e-3abc-497c-88e4-8c750b3b8d7f",
      "name": "No Operation, do nothing7"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $('Code Respuesta Faltantes').item.json.text }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -34656,
        -8592
      ],
      "id": "76b40648-6976-4f74-b095-d2f6213ce44a",
      "name": "HTTP Request Enviar Mensaje por WhatsApp8"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -38864,
        -8752
      ],
      "id": "f5dd9458-a721-4449-90e3-8e265e906356",
      "name": "OpenAI Chat Model11",
      "credentials": {
        "openAiApi": {
          "id": "AD8kPcNVReuclASd",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "=define",
        "text": "=## Prompt para nodo \"Basic LLM\" - Validación de selección de alternativa\n\n## ROL Y CONTEXTO\nEres un asistente especializado en interpretar mensajes de usuarios para un sistema de agendamiento de citas logísticas. Tu tarea es determinar si el usuario está eligiendo una alternativa de horario cuando la cita original no está disponible, o si está haciendo algo diferente (como retractarse o cambiar de opinión).\n\n## CONTEXTO DEL SISTEMA\nEl sistema de agendamiento funciona así:\n1. El sistema verifica si un horario solicitado está disponible\n2. Si está disponible, muestra un mensaje de confirmación\n3. Si NO está disponible, presenta alternativas numeradas\n4. El usuario debe responder eligiendo una de esas alternativas\n5. El formato de elección puede variar: \"elijo la 1\", \"opción 2\", \"la primera\", \"la del 17 de julio a las 7am\", etc.\n\n## DATOS DISPONIBLES\n\n### Respuesta del sistema y alternativas presentadas:\n```json\n{{ JSON.stringify($node[\"Code Verificar Tiempo Transcurrido\"].json.respuesta.alternativasDisponibles, null, 2) }}\n```\n\n### Mensaje actual del usuario:\n```\n{{ $('Unificación y consistencia de datos').first().json.infoMensaje.mensajeActual }}\n```\n\n### Historial de conversación:\n```\n{{ $('Unificación y consistencia de datos').first().json.infoMensaje.historialMensajes }}\n```\n\n## LÓGICA DE ANÁLISIS\n\n### PASO 1: VERIFICACIÓN DE DISPONIBILIDAD CONFIRMADA\nPrimero, verifica el campo \"disponibilidadConfirmada\" en los datos disponibles:\n- Si **disponibilidadConfirmada = true**: El horario original estaba disponible y se confirmó. El usuario solo debe confirmar (ej: \"sí\", \"ok\", \"perfecto\").\n- Si **disponibilidadConfirmada = false**: El horario no estaba disponible y se presentaron alternativas numeradas.\n\n### PASO 2: DETECCIÓN CRÍTICA DE RETRACTACIONES\nAntes de analizar cualquier selección, detecta si el usuario está:\n\n#### ✅ COMPORTAMIENTO ESPERADO:\n- Confirmando la opción principal cuando disponibilidadConfirmada = true\n- Eligiendo una alternativa numerada cuando se presentaron opciones\n- Usando frases como: \"la 1\", \"opción 2\", \"la primera\", \"elijo la del 17 a las 7am\"\n\n#### ❌ RETRACTACIÓN DETECTADA:\n- Usuario menciona fecha/hora diferente a las opciones presentadas\n- Usuario dice \"mejor el [otra fecha]\", \"cambio de opinión\", \"prefiero el [otra fecha]\"\n- Usuario proporciona datos completamente nuevos (nuevo proveedor, nueva categoría, etc.)\n- Usuario contradice las opciones que acaba de recibir del sistema\n\n### PASO 3: ANÁLISIS CONTEXTUAL\nRevisa el historial para detectar patrones de indecisión:\n- ¿Ha cambiado de fecha múltiples veces?\n- ¿Las fechas mencionadas coinciden con las opciones presentadas?\n- ¿El mensaje actual es consistente con las alternativas ofrecidas?\n\n## FORMATO DE RESPUESTA\n\n### Para disponibilidadConfirmada = true (confirmación directa):\n```json\n{\n  \"seleccionaAlternativa\": false,\n  \"indiceSeleccionado\": null,\n  \"esRetractacion\": false,\n  \"tipoRespuesta\": \"confirmacion_directa\",\n  \"datosSeleccionados\": null,\n  \"motivoRetractacion\": null\n}\n```\n\n### Para selección válida de alternativa:\n```json\n{\n  \"seleccionaAlternativa\": true,\n  \"indiceSeleccionado\": 2,\n  \"esRetractacion\": false,\n  \"tipoRespuesta\": \"seleccion_alternativa\",\n  \"datosSeleccionados\": {\n    \"fecha\": \"17 de julio de 2025\",\n    \"fechaFormateada\": \"2025-07-17\",\n    \"horaInicio\": \"09:00 AM\",\n    \"horaFin\": \"1:00 PM\",\n    \"muelle\": \"MUELLE 2\",\n    \"duracionHoras\": 4\n  },\n  \"motivoRetractacion\": null\n}\n```\n\n### Para retractación detectada:\n```json\n{\n  \"seleccionaAlternativa\": false,\n  \"indiceSeleccionado\": null,\n  \"esRetractacion\": true,\n  \"tipoRespuesta\": \"retractacion\",\n  \"datosSeleccionados\": null,\n  \"motivoRetractacion\": \"Usuario mencionó fecha diferente a las opciones presentadas\"\n}\n```\n\n### Para respuesta ambigua o no clara:\n```json\n{\n  \"seleccionaAlternativa\": false,\n  \"indiceSeleccionado\": null,\n  \"esRetractacion\": false,\n  \"tipoRespuesta\": \"respuesta_unclear\",\n  \"datosSeleccionados\": null,\n  \"motivoRetractacion\": null\n}\n```\n\n## REGLAS IMPORTANTES\n\n1. **Para calcular duracionHoras**: Extrae el tiempo en horas entre horaInicio y horaFin. Si no puedes calcularlo con precisión, usa 4 como valor predeterminado.\n\n2. **Para fechaFormateada**: Convierte siempre al formato \"YYYY-MM-DD\".\n\n3. **Para indiceSeleccionado**: Usa base 1 (la primera alternativa es 1, no 0).\n\n4. **Detección de retractación**: Si el usuario menciona fechas que NO están en las alternativas presentadas, marca `esRetractacion: true`.\n\n5. **Campo motivoRetractacion**: Solo llenar cuando `esRetractacion: true`, explicar brevemente el motivo.\n\n6. **Prioridad de detección**: \n   - Primero: ¿Es retractación?\n   - Segundo: ¿Es confirmación directa?\n   - Tercero: ¿Es selección de alternativa?\n\n## EJEMPLOS\n\n### Ejemplo 1 - Selección válida:\n**Alternativas presentadas**: 1) 17 de julio 9:00 AM, 2) 17 de julio 10:00 AM\n**Mensaje usuario**: \"elijo la 2\"\n**Respuesta**: \n```json\n{\n  \"seleccionaAlternativa\": true,\n  \"indiceSeleccionado\": 2,\n  \"esRetractacion\": false,\n  \"tipoRespuesta\": \"seleccion_alternativa\",\n  \"datosSeleccionados\": {...},\n  \"motivoRetractacion\": null\n}\n```\n\n### Ejemplo 2 - Retractación:\n**Alternativas presentadas**: 1) 17 de julio 9:00 AM, 2) 17 de julio 10:00 AM  \n**Mensaje usuario**: \"mejor para el 18 de julio\"\n**Respuesta**: \n```json\n{\n  \"seleccionaAlternativa\": false,\n  \"indiceSeleccionado\": null,\n  \"esRetractacion\": true,\n  \"tipoRespuesta\": \"retractacion\",\n  \"datosSeleccionados\": null,\n  \"motivoRetractacion\": \"Usuario solicita fecha diferente (18 de julio) a las opciones presentadas\"\n}\n```\n\n### Ejemplo 3 - Confirmación directa:\n**disponibilidadConfirmada**: true\n**Mensaje usuario**: \"perfecto, confirmo\"\n**Respuesta**: \n```json\n{\n  \"seleccionaAlternativa\": false,\n  \"indiceSeleccionado\": null,\n  \"esRetractacion\": false,\n  \"tipoRespuesta\": \"confirmacion_directa\",\n  \"datosSeleccionados\": null,\n  \"motivoRetractacion\": null\n}\n```\n\n## INSTRUCCIONES FINALES\n1. Analiza cuidadosamente el contexto antes de responder\n2. Prioriza la detección de retractaciones para evitar loops de indecisión\n3. Solo devuelve el objeto JSON válido, sin explicaciones adicionales\n4. Asegúrate de incluir todos los campos requeridos en cada respuesta",
        "hasOutputParser": true
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        -38784,
        -8944
      ],
      "id": "ab6ed3a3-bd2a-43d4-9f07-0a7284348417",
      "name": "Basic LLM Validar selección alternativa"
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"seleccionaAlternativa\": {\n      \"type\": \"boolean\",\n      \"description\": \"Indica si el usuario seleccionó una alternativa\"\n    },\n    \"indiceSeleccionado\": {\n      \"type\": [\"number\", \"null\"],\n      \"description\": \"Índice de la alternativa seleccionada (1-basado) o null\"\n    },\n    \"esRetractacion\": {\n      \"type\": \"boolean\",\n      \"description\": \"Indica si el usuario está retractándose o cambiando de opinión\"\n    },\n    \"tipoRespuesta\": {\n      \"type\": \"string\",\n      \"description\": \"Tipo de respuesta del usuario\",\n      \"enum\": [\"confirmacion_directa\", \"seleccion_alternativa\", \"retractacion\", \"respuesta_unclear\"]\n    },\n    \"datosSeleccionados\": {\n      \"type\": [\"object\", \"null\"],\n      \"properties\": {\n        \"fecha\": {\n          \"type\": \"string\",\n          \"description\": \"Fecha en formato texto (dd de mes de yyyy)\"\n        },\n        \"fechaFormateada\": {\n          \"type\": \"string\",\n          \"description\": \"Fecha en formato ISO (YYYY-MM-DD)\"\n        },\n        \"horaInicio\": {\n          \"type\": \"string\",\n          \"description\": \"Hora de inicio de la cita\"\n        },\n        \"horaFin\": {\n          \"type\": \"string\",\n          \"description\": \"Hora de fin de la cita\"\n        },\n        \"muelle\": {\n          \"type\": \"string\",\n          \"description\": \"Identificador del muelle\"\n        },\n        \"duracionHoras\": {\n          \"type\": \"number\",\n          \"description\": \"Duración de la cita en horas\"\n        }\n      },\n      \"description\": \"Datos de la alternativa seleccionada o null\"\n    },\n    \"motivoRetractacion\": {\n      \"type\": [\"string\", \"null\"],\n      \"description\": \"Descripción del motivo de la retractación si aplica\"\n    }\n  },\n  \"required\": [\"seleccionaAlternativa\", \"indiceSeleccionado\", \"esRetractacion\", \"tipoRespuesta\", \"datosSeleccionados\"]\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.2,
      "position": [
        -38640,
        -8720
      ],
      "id": "97dd079b-3693-4976-9fbf-d628d8b02744",
      "name": "Structured Output Parser2"
    },
    {
      "parameters": {
        "jsCode": "// Código para preparar la actualización de Excel con citas\n// Este nodo SOLO prepara el formato para enviarlos a Microsoft Graph\n\n// Obtener datos de entrada: datos validados y datos de la cita\nconst datosValidados = $input.first().json.datosValidados;\nconst datosCita = $('Code Verificar Tiempo Transcurrido').first().json.respuesta.datosCita;\nconst datosMalla = $('Unificación y consistencia de datos2').first().json.datosMalla;\n\n// Extraer la información relevante\nconst {\n  fecha,\n  fechaFormateada,\n  horaInicio,\n  horaFin,\n  muelle,\n  duracionHoras\n} = datosValidados;\n\nconst {\n  proveedor = \"\",\n  ordenCompra = \"\",\n  peso = \"\",\n  categoria = \"\",\n  unidades = \"\"\n} = datosCita;\n\n// Obtener el día de la semana a partir de la fecha\nfunction obtenerDiaSemana(fechaStr) {\n  // Extrae el día, mes y año de la cadena\n  const regex = /(\\d+)\\s+de\\s+(\\w+)\\s+de\\s+(\\d+)/;\n  const match = regex.exec(fechaStr);\n  \n  if (!match) return null;\n  \n  const dia = parseInt(match[1], 10);\n  const mesStr = match[2].toLowerCase();\n  const año = parseInt(match[3], 10);\n  \n  // Mapeo de nombres de meses a números\n  const meses = {\n    \"enero\": 0,\n    \"febrero\": 1,\n    \"marzo\": 2,\n    \"abril\": 3,\n    \"mayo\": 4,\n    \"junio\": 5,\n    \"julio\": 6,\n    \"agosto\": 7,\n    \"septiembre\": 8,\n    \"octubre\": 9,\n    \"noviembre\": 10,\n    \"diciembre\": 11\n  };\n  \n  const mesNum = meses[mesStr];\n  \n  if (mesNum === undefined) return null;\n  \n  // Crear objeto Date\n  const fecha = new Date(año, mesNum, dia);\n  \n  // Obtener día de la semana (0=domingo, 1=lunes, ..., 6=sábado)\n  const diaSemana = fecha.getDay();\n  \n  // Convertir a nombre en español\n  const diasSemana = [\"domingo\", \"lunes\", \"martes\", \"miércoles\", \"jueves\", \"viernes\"];\n  \n  return diasSemana[diaSemana];\n}\n\n// Determinar el día de la semana\nconst diaSemana = obtenerDiaSemana(fecha);\n\n// Determinar el muelle (muelle1 o muelle2)\nconst muelleKey = muelle.toLowerCase().includes(\"1\") ? \"muelle1\" : \"muelle2\";\n\n// Mapeo correcto de columnas para cada día y muelle según lo proporcionado\nconst mapeoColumnas = {\n  'lunes': {\n    'muelle1': 'C', \n    'muelle2': 'F' \n  },\n  'martes': {\n    'muelle1': 'I', \n    'muelle2': 'L'  \n  },\n  'miércoles': {\n    'muelle1': 'O', \n    'muelle2': 'R'  \n  },\n  'jueves': {\n    'muelle1': 'U', \n    'muelle2': 'X' \n  },\n  'viernes': {\n    'muelle1': 'AA', \n    'muelle2': 'AD'  \n  }\n};\n\n// Verificar si tenemos mapeo para este día\nif (!mapeoColumnas[diaSemana]) {\n  console.log(`Día no soportado: ${diaSemana}`);\n  return {\n    json: {\n      success: false,\n      mensaje: `Día no soportado: ${diaSemana}`,\n      error: \"DIA_NO_SOPORTADO\"\n    }\n  };\n}\n\n// Obtener la columna base para el día y muelle específicos\nconst columnaBase = mapeoColumnas[diaSemana][muelleKey];\nif (!columnaBase) {\n  console.log(`Configuración no soportada: día=${diaSemana}, muelle=${muelleKey}`);\n  return {\n    json: {\n      success: false,\n      mensaje: `Configuración no soportada: día=${diaSemana}, muelle=${muelleKey}`,\n      error: \"CONFIGURACION_NO_SOPORTADA\"\n    }\n  };\n}\n\n// Calcular la siguiente columna en Excel\nfunction siguienteColumna(columna) {\n  if (columna.length === 1) {\n    // Para columnas de una letra (A-Z)\n    return String.fromCharCode(columna.charCodeAt(0) + 1);\n  } else {\n    // Para columnas de dos letras (AA-ZZ)\n    const primerChar = columna.charAt(0);\n    const segundoChar = columna.charAt(1);\n    \n    if (segundoChar === 'Z') {\n      // Si es 'Z', pasar a la siguiente letra para el primer carácter\n      return String.fromCharCode(primerChar.charCodeAt(0) + 1) + 'A';\n    } else {\n      // Incrementar solo el segundo carácter\n      return primerChar + String.fromCharCode(segundoChar.charCodeAt(0) + 1);\n    }\n  }\n}\n\n// Función para comparar horas de forma flexible\nfunction horasIguales(h1, h2) {\n  const normalizar = (h) =>\n    h\n      .toString()\n      .trim()\n      .toLowerCase()\n      .replace(/\\./g, '')            // quita puntos (por si viene \"a.m.\")\n      .replace(/\\s+/g, '')           // quita espacios\n      .replace(/^0+/, '');           // quita ceros a la izquierda\n  return normalizar(h1) === normalizar(h2);\n}\n\n// Ordenar franjas por hora\nfunction obtenerFranjasOrdenadas(franjas) {\n  return [...franjas].sort((a, b) => {\n    // Convertir horas a formato comparable (número de minutos desde medianoche)\n    function horaAMinutos(hora) {\n      const match = hora.match(/(\\d+):(\\d+)\\s*([AP]M)/i);\n      if (!match) return 0;\n      \n      let horas = parseInt(match[1], 10);\n      const minutos = parseInt(match[2], 10);\n      const periodo = match[3].toUpperCase();\n      \n      // Convertir a formato 24 horas\n      if (periodo === 'PM' && horas !== 12) {\n        horas += 12;\n      } else if (periodo === 'AM' && horas === 12) {\n        horas = 0;\n      }\n      \n      return horas * 60 + minutos;\n    }\n    \n    return horaAMinutos(a.hora) - horaAMinutos(b.hora);\n  });\n}\n\n// Obtener la posición de la franja en el array ordenado\nfunction obtenerPosicionFranja(hora, franjas) {\n  const franjasOrdenadas = obtenerFranjasOrdenadas(franjas);\n  return franjasOrdenadas.findIndex(f => horasIguales(f.hora, hora));\n}\n\n// Función corregida para calcular la fila Excel basada en la posición de la franja\nfunction calcularFilaExcel(hora, franjas) {\n  const posicion = obtenerPosicionFranja(hora, franjas);\n  \n  if (posicion === -1) {\n    console.log(`No se encontró la posición para la hora ${hora}`);\n    return null;\n  }\n  \n  // Mapeo de posiciones a filas base en Excel\n  // Basado en las observaciones del Excel:\n  const FILA_PRIMERA_FRANJA = 12;  // 6:00 AM\n  const INCREMENTO_ESTANDAR = 3;   // Incremento estándar entre franjas\n  \n  // Caso especial para 9:00 AM\n  if (posicion === 3) {\n    return 21;  // Fila exacta para 9:00 AM\n  } else if (posicion === 4) {\n    return 24;  // Fila exacta para 10:00 AM\n  } else if (posicion === 5) {\n    return 27;  // Fila exacta para 11:00 AM\n  } else if (posicion < 3) {\n    // Para posiciones antes de 9:00 AM, usamos el incremento estándar\n    return FILA_PRIMERA_FRANJA + (posicion * INCREMENTO_ESTANDAR);\n  } else {\n    // Para posiciones después de 11:00 AM, calculamos a partir de 11:00 AM\n    return 27 + ((posicion - 5) * INCREMENTO_ESTANDAR);\n  }\n}\n\n// Función para encontrar la franja horaria siguiente\nfunction encontrarSiguienteFranja(horaActual, franjas) {\n  const franjasOrdenadas = obtenerFranjasOrdenadas(franjas);\n  const posicionActual = franjasOrdenadas.findIndex(f => horasIguales(f.hora, horaActual));\n  \n  if (posicionActual === -1 || posicionActual >= franjasOrdenadas.length - 1) {\n    return null; // No hay siguiente franja\n  }\n  \n  return franjasOrdenadas[posicionActual + 1];\n}\n\n// Encontrar información de la franja horaria inicial en los datos de la malla\nconst franjaInicio = datosMalla.franjas.find(f => horasIguales(f.hora, horaInicio));\nif (!franjaInicio) {\n  console.log(`No se encontró la franja de inicio: ${horaInicio}`);\n  return {\n    json: {\n      success: false,\n      mensaje: `No se encontró la franja de inicio: ${horaInicio}`,\n      error: \"FRANJA_NO_ENCONTRADA\"\n    }\n  };\n}\n\n// Array para almacenar todas las actualizaciones\nlet todasLasActualizaciones = [];\n\n// Procesar cada hora de la cita (según duracionHoras)\nlet horaActual = horaInicio;\nlet horasRestantes = duracionHoras;\n\nwhile (horasRestantes > 0) {\n  // Encontrar la franja actual\n  const franjaActual = datosMalla.franjas.find(f => horasIguales(f.hora, horaActual));\n  \n  if (!franjaActual) {\n    console.log(`No se encontró información para la franja: ${horaActual}`);\n    break;\n  }\n  \n  // Calcular la fila base de forma dinámica\n  const filaBase = calcularFilaExcel(horaActual, datosMalla.franjas);\n  \n  if (!filaBase) {\n    console.log(`No se pudo determinar la fila para la franja: ${horaActual}`);\n    break;\n  }\n  \n  console.log(`Calculando celdas para: ${horaActual}, fila base: ${filaBase}`);\n  \n  const columnaLineas = siguienteColumna(columnaBase);\n  const columnaUnd = siguienteColumna(columnaLineas);\n  \n  // Calcular las celdas para esta franja\n  const rangoCeldas = {\n    proveedor: `${columnaBase}${filaBase}`,\n    ordenCompra: `${columnaBase}${filaBase + 1}`,\n    peso: `${columnaBase}${filaBase + 2}`,\n    categoria: `${columnaLineas}${filaBase + 2}`,\n    unidades: `${columnaUnd}${filaBase + 2}`\n  };\n  \n  console.log(`Celdas para ${horaActual}, ${diaSemana}, ${muelleKey}:`, JSON.stringify(rangoCeldas));\n  \n  // Agregar actualizaciones para esta franja horaria\n  todasLasActualizaciones.push(\n    {\n      celda: rangoCeldas.proveedor,\n      valor: proveedor\n    },\n    {\n      celda: rangoCeldas.ordenCompra,\n      valor: ordenCompra\n    },\n    {\n      celda: rangoCeldas.peso,\n      valor: peso\n    },\n    {\n      celda: rangoCeldas.categoria,\n      valor: categoria\n    },\n    {\n      celda: rangoCeldas.unidades,\n      valor: unidades\n    }\n  );\n  \n  // Preparar para la siguiente hora\n  horasRestantes--;\n  \n  if (horasRestantes > 0) {\n    const siguienteFranja = encontrarSiguienteFranja(horaActual, datosMalla.franjas);\n    \n    if (siguienteFranja) {\n      horaActual = siguienteFranja.hora;\n    } else {\n      console.log(`No se encontró la siguiente franja horaria después de ${horaActual}`);\n      break;\n    }\n  }\n}\n\n// Preparar el formato final para la petición a Microsoft Graph\nconst actualizacionesGraph = todasLasActualizaciones.map(act => ({\n  address: act.celda,\n  values: [[act.valor]]\n}));\n\n// Usar el nombre correcto de la hoja desde datosMalla\nconst nombreHojaExcel = $('Code VALIDACIÓN DE CITA EN CRONOGRAMA').first().json.nombreHoja;\n\n// Preparar el resultado para el siguiente nodo\nreturn {\n  json: {\n    success: true,\n    mensaje: `Preparadas ${todasLasActualizaciones.length} actualizaciones para la cita del ${fecha} de ${horaInicio} a ${horaFin} en ${muelle} (${duracionHoras} horas)`,\n    nombreHoja: nombreHojaExcel,\n    // Datos para Microsoft Graph API\n    graphRequestData: {\n      updates: actualizacionesGraph\n    },\n    // Información más detallada para debugging o uso interno\n    detalles: {\n      actualizacionesDetalladas: todasLasActualizaciones,\n      diaSemana,\n      informacionCita: {\n        fecha,\n        horaInicio,\n        horaFin,\n        muelle,\n        proveedor,\n        ordenCompra,\n        peso,\n        categoria,\n        unidades,\n        duracionHoras\n      }\n    }\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -37664,
        -9280
      ],
      "id": "2d274623-cd73-4865-a7ba-5a66ac2cf632",
      "name": "Code (Preparar Cuerpo de Petición)"
    },
    {
      "parameters": {
        "jsCode": "// Código modificado para \"Code Agrupar Franjas\"\n// Ahora devuelve los valores individuales en lugar de franjas agrupadas\n// pero conservando la información de indice, nombreHoja e informacionCita\nconst input = $input.first().json;\n\n// Verificar que tenemos la estructura esperada\nif (!input || !input.graphRequestData || !input.graphRequestData.updates) {\n  console.log('Estructura de datos de entrada no válida');\n  return {\n    json: {\n      error: \"FORMATO_INVALIDO\",\n      mensaje: \"La estructura de datos de entrada no es válida\"\n    }\n  };\n}\n\nconst updates = input.graphRequestData.updates;\nconst UPDATES_PER_FRANJA = 5;\nconst numFranjas = Math.ceil(updates.length / UPDATES_PER_FRANJA);\nconst resultados = [];\n\n// Primero, creamos todas las franjas como en el código original\nconst franjas = [];\nfor (let i = 0; i < numFranjas; i++) {\n  const inicio = i * UPDATES_PER_FRANJA;\n  const fin = Math.min(inicio + UPDATES_PER_FRANJA, updates.length);\n  \n  // Obtener las actualizaciones de esta franja\n  const actualizacionesFranja = updates.slice(inicio, fin);\n  \n  franjas.push({\n    indice: i + 1,\n    nombreHoja: input.nombreHoja,\n    updates: actualizacionesFranja,\n    informacionCita: input.detalles?.informacionCita\n  });\n}\n\n// Ahora, recorremos cada franja y extraemos los valores individuales\n// pero conservando la información adicional\nfranjas.forEach(franja => {\n  franja.updates.forEach(update => {\n    if (update.values && update.values.length > 0 && update.values[0].length > 0) {\n      const valor = update.values[0][0];\n      \n      // Creamos un objeto que contiene el valor y la información adicional\n      resultados.push({\n        json: {\n          valor: valor,\n          indice: franja.indice,\n          nombreHoja: franja.nombreHoja,\n          address: update.address,\n          informacionCita: franja.informacionCita\n        }\n      });\n    }\n  });\n});\n\nconsole.log(`Se extrajeron ${resultados.length} valores individuales para inserción en orden`);\nreturn resultados;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -37456,
        -9280
      ],
      "id": "6fec1673-ca68-44ca-97a4-4d4fac109586",
      "name": "Code Agrupar Franjas"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        -37168,
        -9280
      ],
      "id": "d7b14f08-1320-443e-8d45-f4679e1418ec",
      "name": "Loop Over Uno a Uno"
    },
    {
      "parameters": {
        "jsCode": "// Código para preparar cada inserción para Microsoft Graph API mediante $batch\n// Basado en el flujo de trabajo original y adaptado para procesar elementos individuales\nconst input = $input.first().json;\n\n// Constantes para los IDs de SharePoint/OneDrive\nconst siteId = \"gexpresscargo.sharepoint.com,a592f886-4560-4e62-9646-1eee7add7abe,8b514073-41ae-4619-8f76-724bd912bc65\";\nconst driveId = \"b!hviSpWBFYk6WRh7uet16vnNAUYuuQRlGj3ZyS9kSvGVZ4DSg6c5MRqYYm2MdAER8\";\nconst itemId = \"01PPLUUYXY5E2GK3SJ25EZLJPUYJ43H3ME\";\n\n// Verificar que tenemos la estructura esperada\nif (!input || input.valor === undefined || !input.address || !input.nombreHoja) {\n  console.log('Estructura de datos de entrada no válida para la inserción');\n  return {\n    json: {\n      error: \"FORMATO_INVALIDO\",\n      mensaje: \"La estructura de datos de entrada no es válida para la inserción\"\n    }\n  };\n}\n\n// Preparar el valor para la actualización según su tipo\nlet valorFormateado;\nif (typeof input.valor === 'number') {\n  valorFormateado = [[input.valor]]; // Para números mantenemos el tipo\n} else {\n  valorFormateado = [[input.valor.toString()]]; // Para otros tipos convertimos a string\n}\n\n// Generar un ID único para esta solicitud\nconst requestId = `${input.address}_${input.indice}_${Date.now()}`;\n\n// Crear la estructura de solicitud para Microsoft Graph $batch\nconst requestBody = {\n  requests: [\n    {\n      id: requestId,\n      method: \"PATCH\",\n      url: `/sites/${siteId}/drives/${driveId}/items/${itemId}/workbook/worksheets/${encodeURIComponent(input.nombreHoja)}/range(address='${input.address}')`,\n      body: {\n        values: valorFormateado\n      },\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    }\n  ],\n  _metadata: {\n    celda: input.address,\n    valor: input.valor,\n    indice: input.indice,\n    informacionCita: input.informacionCita || {}\n  }\n};\n\nconsole.log(`Preparada solicitud ${requestId} para insertar valor \"${input.valor}\" en la celda ${input.address} de la hoja \"${input.nombreHoja}\"`);\n\n// Retornar el objeto request listo para ser enviado a Microsoft Graph $batch\nreturn {\n  json: requestBody\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -36896,
        -9184
      ],
      "id": "11ff4bcc-660f-4bec-9447-2b5906dc7e88",
      "name": "Code Preparar cada Insercion"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://graph.microsoft.com/v1.0/$batch",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "microsoftOAuth2Api",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -36640,
        -9184
      ],
      "id": "ebfa5761-81fa-4644-b534-5e6dee8281c8",
      "name": "HTTP Request Actualizar Excel1",
      "credentials": {
        "microsoftOAuth2Api": {
          "id": "mh8Z8hxFvd7LDO8D",
          "name": "CuentaMy SharePoint App Desarrollador1 Konfie "
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Código para verificar si la inserción fue exitosa (sin acciones correctivas)\nconst input = $input.first().json;\n\n// Verificar que tenemos la estructura esperada en la respuesta\nif (!input || !input.responses || !Array.isArray(input.responses) || input.responses.length === 0) {\n  console.log('Estructura de datos de respuesta no válida');\n  return {\n    json: {\n      error: \"RESPUESTA_INVALIDA\",\n      mensaje: \"La estructura de datos de la respuesta no es válida\",\n      exito: false\n    }\n  };\n}\n\n// Obtener la primera respuesta\nconst response = input.responses[0];\n\n// Extraer información de la solicitud original del ID\n// El formato del ID es: \"CELDA_INDICE_TIMESTAMP\"\nconst idPartes = response.id.split('_');\nconst celdaOriginal = idPartes[0];\nconst indice = idPartes[1];\n\n// Verificar que la respuesta tiene un cuerpo\nif (!response.body || !response.body.address) {\n  console.log(`Error: La respuesta no contiene información sobre la dirección de celda`);\n  return {\n    json: {\n      error: \"RESPUESTA_SIN_DIRECCION\",\n      mensaje: \"La respuesta no incluye información sobre la dirección de celda\",\n      requestId: response.id,\n      status: response.status,\n      celdaOriginal: celdaOriginal,\n      exito: false\n    }\n  };\n}\n\n// Extraer la dirección de celda de la respuesta\nlet direccionRespuesta = \"\";\nif (response.body && response.body.address) {\n  const partesDireccion = response.body.address.split('!');\n  if (partesDireccion.length > 1) {\n    direccionRespuesta = partesDireccion[1];\n  }\n}\n\n// Obtener el valor insertado de la respuesta\nconst valorInsertado = response.body.values && response.body.values[0] && response.body.values[0][0];\n\n// Verificar si la inserción se realizó en la celda correcta\nconst insercionCorrecta = direccionRespuesta === celdaOriginal;\n\n// Verificar el código de estado HTTP\nconst estadoExitoso = response.status >= 200 && response.status < 300;\n\n// Crear objeto para almacenar el resultado de la verificación\nconst resultado = {\n  exito: insercionCorrecta && estadoExitoso,\n  celdaOriginal: celdaOriginal,\n  celdaInsertada: direccionRespuesta,\n  valorInsertado: valorInsertado,\n  statusCode: response.status,\n  requestId: response.id,\n  indice: indice,\n  celdasDiferentes: !insercionCorrecta && estadoExitoso,\n  falloEstado: !estadoExitoso\n};\n\nconst chatId = $('Organiza el Mensaje').first().json.infoMensaje.chat_id;\n\nif (!insercionCorrecta || !estadoExitoso) {\n  console.log(`Error en inserción: celda original=${celdaOriginal}, celda insertada=${direccionRespuesta}, status=${response.status}`);\n} else {\n  console.log(`Inserción correcta en celda ${celdaOriginal} con valor \"${valorInsertado}\"`);\n}\n\n// Incluir la respuesta original para tener toda la información\nresultado.respuestaOriginal = response;\n\n// Retornar el resultado de la verificación\nreturn {\n  json: resultado, \n  chat_id: chatId\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -36416,
        -9184
      ],
      "id": "18b54414-6f52-4733-859d-1a168ac6d891",
      "name": "Code Verificar Inserción"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "fb1eda05-eb5e-4683-8556-1cf2b5b8e4d5",
              "leftValue": "={{ $json.exito }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -36176,
        -9120
      ],
      "id": "3e33b06a-654c-473c-8030-20a64c55b0ef",
      "name": "If Verificar Inserción"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "15a95144-dd82-4ea5-b9ba-9eb924d2ae5c",
              "leftValue": "={{ $json.celdasDiferentes }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -35968,
        -9040
      ],
      "id": "4e49289a-72a4-4c23-bfb8-b16c40a48ede",
      "name": "If Diferente Caso"
    },
    {
      "parameters": {
        "jsCode": "// Código para limpiar una celda donde se insertó incorrectamente un valor\nconst input = $input.first().json;\n\n// Constantes para los IDs de SharePoint/OneDrive\nconst siteId = \"gexpresscargo.sharepoint.com,a592f886-4560-4e62-9646-1eee7add7abe,8b514073-41ae-4619-8f76-724bd912bc65\";\nconst driveId = \"b!hviSpWBFYk6WRh7uet16vnNAUYuuQRlGj3ZyS9kSvGVZ4DSg6c5MRqYYm2MdAER8\";\nconst itemId = \"01PPLUUYXY5E2GK3SJ25EZLJPUYJ43H3ME\";\n\n// Verificar que tenemos la información necesaria\nif (!input || !input.celdaInsertada || !input.respuestaOriginal) {\n  console.log('Información insuficiente para limpiar la celda incorrecta');\n  return {\n    json: {\n      error: \"INFORMACION_INSUFICIENTE\",\n      mensaje: \"No hay suficiente información para limpiar la celda incorrecta\"\n    }\n  };\n}\n\n// Obtener la celda a limpiar y la información de la hoja\nconst celdaALimpiar = input.celdaInsertada;\nlet hojaExcel = input.nombreHoja || \"\"; // Usar el nombreHoja del input\n\n// Intentar extraer el nombre de la hoja de la dirección en la respuesta si no está disponible\nif ((!hojaExcel || hojaExcel === \"\") && input.respuestaOriginal.body && input.respuestaOriginal.body.address) {\n  const direccionCompleta = input.respuestaOriginal.body.address;\n  hojaExcel = direccionCompleta.split('!')[0].replace(/'/g, '');\n}\n\nconsole.log(`Limpiando celda incorrecta ${celdaALimpiar} en hoja ${hojaExcel}`);\n\n// Crear la solicitud para limpiar la celda\nconst requestBody = {\n  requests: [\n    {\n      id: `Limpiar_${celdaALimpiar}_${Date.now()}`,\n      method: \"PATCH\",\n      url: `/sites/${siteId}/drives/${driveId}/items/${itemId}/workbook/worksheets/${encodeURIComponent(hojaExcel)}/range(address='${celdaALimpiar}')`,\n      body: {\n        values: [[\"\"]] // Valor vacío para limpiar la celda\n      },\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    }\n  ],\n  _metadata: {\n    accion: \"limpiar\",\n    celda: celdaALimpiar,\n    hoja: hojaExcel,\n    datoOriginal: input\n  }\n};\n\n// Retornar el request para limpiar la celda\nreturn {\n  json: requestBody\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -35664,
        -9232
      ],
      "id": "a8c6ef95-c4f5-4987-9659-d9498ce7405b",
      "name": "Code Limpiar Celda Incorrecta",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://graph.microsoft.com/v1.0/$batch",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "microsoftOAuth2Api",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -35440,
        -9232
      ],
      "id": "1c267dbd-899e-475d-a2fb-a8b94cedc5ae",
      "name": "HTTP Request Limpiar Celda",
      "credentials": {
        "microsoftOAuth2Api": {
          "id": "mh8Z8hxFvd7LDO8D",
          "name": "CuentaMy SharePoint App Desarrollador1 Konfie "
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "e570827e-13d0-4d6f-b23e-184ca2d3368c",
              "leftValue": "={{ $json.falloEstado }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -35504,
        -8848
      ],
      "id": "26f7fd3e-630c-4b6c-9377-be2144ae3fb6",
      "name": "If fallo Estado"
    },
    {
      "parameters": {
        "jsCode": "// Código para reintentar la inserción en la celda correcta\nconst input = $input.first().json;\n\n// Constantes para los IDs de SharePoint/OneDrive\nconst siteId = \"gexpresscargo.sharepoint.com,a592f886-4560-4e62-9646-1eee7add7abe,8b514073-41ae-4619-8f76-724bd912bc65\";\nconst driveId = \"b!hviSpWBFYk6WRh7uet16vnNAUYuuQRlGj3ZyS9kSvGVZ4DSg6c5MRqYYm2MdAER8\";\nconst itemId = \"01PPLUUYXY5E2GK3SJ25EZLJPUYJ43H3ME\";\n\n// Si el input viene del nodo anterior de limpiar celda, extraer el dato original\nconst datoOriginal = input._metadata?.datoOriginal || input;\n\n// Verificar que tenemos la información necesaria\nif (!datoOriginal || !datoOriginal.celdaOriginal) {\n  console.log('Información insuficiente para reintentar la inserción');\n  return {\n    json: {\n      error: \"INFORMACION_INSUFICIENTE\",\n      mensaje: \"No hay suficiente información para reintentar la inserción\"\n    }\n  };\n}\n\n// Obtener la celda correcta donde insertar y el valor a insertar\nconst celdaCorrecta = datoOriginal.celdaOriginal;\n\n// Intentar obtener el valor correcto a insertar\nlet valorAInsertar;\n\n// Primero, verificar si tenemos el valor de la respuesta original\nif (datoOriginal.valorInsertado !== undefined) {\n  valorAInsertar = datoOriginal.valorInsertado;\n} \n// Si no, intentar obtenerlo del body de la respuesta\nelse if (datoOriginal.respuestaOriginal?.body?.values?.[0]?.[0] !== undefined) {\n  valorAInsertar = datoOriginal.respuestaOriginal.body.values[0][0];\n} \n// Como último recurso, usar un valor vacío\nelse {\n  valorAInsertar = \"\";\n  console.log('No se pudo determinar el valor a insertar, usando valor vacío');\n}\n\n// Determinar el tipo de valor y formatearlo adecuadamente\nlet valorFormateado;\nif (typeof valorAInsertar === 'number') {\n  valorFormateado = [[valorAInsertar]]; // Mantener el tipo numérico\n} else {\n  valorFormateado = [[valorAInsertar.toString()]]; // Convertir a string para otros tipos\n}\n\n// Obtener la hoja de Excel - primero del dato original\nlet hojaExcel = datoOriginal.nombreHoja || \"\"; \n\n// Si no está disponible en el objeto principal, intentar obtenerlo de otros lugares\nif (!hojaExcel || hojaExcel === \"\") {\n  // Verificar si está en el _metadata\n  hojaExcel = input._metadata?.hoja || \"\";\n  \n  // Como último recurso, extraer de la dirección en la respuesta\n  if ((!hojaExcel || hojaExcel === \"\") && datoOriginal.respuestaOriginal?.body?.address) {\n    const direccionCompleta = datoOriginal.respuestaOriginal.body.address;\n    hojaExcel = direccionCompleta.split('!')[0].replace(/'/g, '');\n  }\n}\n\nconsole.log(`Reintentando inserción en celda ${celdaCorrecta} de la hoja ${hojaExcel} con valor \"${valorAInsertar}\"`);\n\n// Crear la solicitud para reintentar la inserción\nconst requestBody = {\n  requests: [\n    {\n      id: `Reintento_${celdaCorrecta}_${Date.now()}`,\n      method: \"PATCH\",\n      url: `/sites/${siteId}/drives/${driveId}/items/${itemId}/workbook/worksheets/${encodeURIComponent(hojaExcel)}/range(address='${celdaCorrecta}')`,\n      body: {\n        values: valorFormateado\n      },\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    }\n  ],\n  _metadata: {\n    accion: \"reintentar\",\n    celda: celdaCorrecta,\n    hoja: hojaExcel,\n    valor: valorAInsertar,\n    datoOriginal: datoOriginal,\n    intentos: (datoOriginal._metadata?.intentos || 0) + 1\n  }\n};\n\n// Retornar el request para reintentar la inserción\nreturn {\n  json: requestBody\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -35168,
        -9168
      ],
      "id": "fc593779-c69e-411a-8e53-be0bca33d091",
      "name": "Code Reintentar Inserción",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://graph.microsoft.com/v1.0/$batch",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "microsoftOAuth2Api",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -34928,
        -9040
      ],
      "id": "88d30abe-141a-4315-b350-371e00e81323",
      "name": "HTTP Request Reintentar Inserción",
      "credentials": {
        "microsoftOAuth2Api": {
          "id": "mh8Z8hxFvd7LDO8D",
          "name": "CuentaMy SharePoint App Desarrollador1 Konfie "
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Código para verificar si la inserción fue exitosa (sin acciones correctivas)\nconst input = $input.first().json;\n\n// Verificar que tenemos la estructura esperada en la respuesta\nif (!input || !input.responses || !Array.isArray(input.responses) || input.responses.length === 0) {\n  console.log('Estructura de datos de respuesta no válida');\n  return {\n    json: {\n      error: \"RESPUESTA_INVALIDA\",\n      mensaje: \"La estructura de datos de la respuesta no es válida\",\n      exito: false\n    }\n  };\n}\n\n// Obtener la primera respuesta\nconst response = input.responses[0];\n\n// Extraer información de la solicitud original del ID\n// El formato del ID es: \"CELDA_INDICE_TIMESTAMP\"\nconst idPartes = response.id.split('_');\nconst celdaOriginal = idPartes[0];\nconst indice = idPartes[1];\n\n// Verificar que la respuesta tiene un cuerpo\nif (!response.body || !response.body.address) {\n  console.log(`Error: La respuesta no contiene información sobre la dirección de celda`);\n  return {\n    json: {\n      error: \"RESPUESTA_SIN_DIRECCION\",\n      mensaje: \"La respuesta no incluye información sobre la dirección de celda\",\n      requestId: response.id,\n      status: response.status,\n      celdaOriginal: celdaOriginal,\n      exito: false\n    }\n  };\n}\n\n// Extraer la dirección de celda de la respuesta\nlet direccionRespuesta = \"\";\nif (response.body && response.body.address) {\n  const partesDireccion = response.body.address.split('!');\n  if (partesDireccion.length > 1) {\n    direccionRespuesta = partesDireccion[1];\n  }\n}\n\n// Obtener el valor insertado de la respuesta\nconst valorInsertado = response.body.values && response.body.values[0] && response.body.values[0][0];\n\n// Verificar si la inserción se realizó en la celda correcta\nconst insercionCorrecta = direccionRespuesta === celdaOriginal;\n\n// Verificar el código de estado HTTP\nconst estadoExitoso = response.status >= 200 && response.status < 300;\n\n// Crear objeto para almacenar el resultado de la verificación\nconst resultado = {\n  exito: insercionCorrecta && estadoExitoso,\n  celdaOriginal: celdaOriginal,\n  celdaInsertada: direccionRespuesta,\n  valorInsertado: valorInsertado,\n  statusCode: response.status,\n  requestId: response.id,\n  indice: indice,\n  celdasDiferentes: !insercionCorrecta && estadoExitoso,\n  falloEstado: !estadoExitoso\n};\n\nif (!insercionCorrecta || !estadoExitoso) {\n  console.log(`Error en inserción: celda original=${celdaOriginal}, celda insertada=${direccionRespuesta}, status=${response.status}`);\n} else {\n  console.log(`Inserción correcta en celda ${celdaOriginal} con valor \"${valorInsertado}\"`);\n}\n\n// Incluir la respuesta original para tener toda la información\nresultado.respuestaOriginal = response;\n\n// Retornar el resultado de la verificación\nreturn {\n  json: resultado\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -34704,
        -9040
      ],
      "id": "0c9e9768-de38-43a7-a694-49b8961525b9",
      "name": "Code Volver a validar Inserción",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "f7205e4e-147c-4e77-8fa8-08d082980b48",
              "leftValue": "={{ $json.exito }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -34480,
        -9040
      ],
      "id": "7742d22c-2aba-4ade-808c-77bd16d314b7",
      "name": "If Verificar Inserción 2"
    },
    {
      "parameters": {
        "amount": 3
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        -35584,
        -9040
      ],
      "id": "45126b59-6b43-473d-a558-95f913df33e7",
      "name": "Wait2",
      "webhookId": "a4bbf2b1-ea0c-4b02-af2c-64b29f2bdb5c"
    },
    {
      "parameters": {
        "amount": 3
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        -34176,
        -8864
      ],
      "id": "e8cd6c41-8ade-4c20-b751-609d5a317aff",
      "name": "Wait3",
      "webhookId": "9d944db7-9c4f-439e-9990-d9937f2fb18e"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -33744,
        -8512
      ],
      "id": "fcf877f1-114d-41c9-aedf-09c8d378d7e5",
      "name": "OpenAI Chat Model12",
      "credentials": {
        "openAiApi": {
          "id": "AD8kPcNVReuclASd",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "=define",
        "text": "=Eres un asistente de un sistema de agendamiento de citas para la entrega de mercancía en bodega. Debes notificar al cliente que ha ocurrido un error en el sistema durante el proceso de inserción de la cita en el sistema de Excel.\n\nGenera un mensaje directo (sin saludos iniciales ni mencionar nombres) que:\n\n1. Comunique claramente que se produjo un error técnico al intentar registrar la cita en el sistema.\n\n2. Indique que es urgente que se comunique con el área de bodega en los próximos 5 minutos para que puedan agendar la cita manualmente.\n\n4. Mencione que, de no establecer contacto en ese tiempo, existe el riesgo de perder la franja horaria seleccionada debido a la alta demanda de los muelles.\n\n5. Aclare que esta situación es poco común y se debe a un inconveniente técnico en el sistema de agendamiento.\n\n6. Pida disculpas por los inconvenientes ocasionados y agradezca la comprensión.\n\nTono: urgente pero profesional, enfatizando la importancia de la acción inmediata para mantener la franja horaria seleccionada.\n"
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        -33664,
        -8720
      ],
      "id": "1bb5d2cb-2434-4c0a-86ad-1467b6a70da8",
      "name": "Basic LLM Notificar No Disponibilidad2",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "4bfbecb3-9d4f-4425-aa76-a92abc7708fb",
              "leftValue": "={{ $('Basic LLM Notificar No Disponibilidad2').item.json.text.length }}",
              "rightValue": 70,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -33264,
        -8544
      ],
      "id": "aca59b64-2759-49e3-9de8-f6f06158dc87",
      "name": "Validación de longitud de caracteres6"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d9c2ff70-4fd1-4b93-8571-6d0ac5a0093e",
              "name": "mensaje.ia",
              "value": "={{ $('Basic LLM Notificar No Disponibilidad2').item.json.text }}",
              "type": "string"
            },
            {
              "id": "ac8a03be-0292-4735-9580-39a385945c47",
              "name": "mensaje.longitud",
              "value": "={{ $('Basic LLM Notificar No Disponibilidad2').item.json.text.length }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -32960,
        -8528
      ],
      "id": "b4166905-9ceb-429b-80bb-3a260a095649",
      "name": "Organiza variables del mensaje6"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -32784,
        -8752
      ],
      "id": "0f28262a-4f60-4bd5-a40f-bd475bd7643e",
      "name": "No Operation, do nothing8"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $('Code Respuesta Faltantes').item.json.text }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -32960,
        -8752
      ],
      "id": "81f2fed1-6801-4087-a247-3829a56deb79",
      "name": "HTTP Request Enviar Mensaje por WhatsApp9"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -38640,
        -10192
      ],
      "id": "44a78892-b8d3-4959-90a0-9543da70a244",
      "name": "OpenAI Chat Model",
      "credentials": {
        "openAiApi": {
          "id": "AD8kPcNVReuclASd",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "=define",
        "text": "=# Extracción de información para citas de logística\n\nAnaliza TODOS los mensajes de la conversación (tanto el mensaje actual como el historial completo) para extraer la información necesaria para agendar una cita de logística. \n\n## Contexto \nLos usuarios pueden proporcionar información de forma parcial a lo largo de varios mensajes. Tu tarea es acumular y consolidar toda esta información. Debes extraer cualquier dato relevante sin importar en qué mensaje aparezca (actual o histórico).\n\n## Campos a extraer\n- Nombre del proveedor\n- Fecha de entrega (formato: DD de MMMM de YYYY)\n- Hora de entrega (formato: HH:MM AM/PM)\n- Categoría del material\n- Peso en kilos (extraer solo el valor numérico entero, ej: de '3.500 kilos' extraer 3500)\n- Número de unidades (extraer solo el valor numérico entero, ej: de '7,000 unidades' extraer 7000)\n- Número de orden de compra\n\n## Fuentes de información\n- Mensaje actual: {{ $('Unificación y consistencia de datos').first().json.infoMensaje.mensajeActual }}\n- Historial de mensajes: {{$node[\"Unificación y consistencia de datos\"].json.infoMensaje.historialMensajes}}\n- Hora actual: {{$node[\"Organiza el Mensaje\"].json.infoMensaje.horaMensajeActual}}\n- Fecha actual: {{$node[\"Organiza el Mensaje\"].json.infoMensaje.fechaMensajeActual}}\n\n## Instrucciones específicas para interpretación de fechas\n1. NUNCA interpretes fechas que estén en el pasado. Toda fecha debe ser igual o posterior a la fecha actual.\n2. Para fechas específicas numéricas:\n   - Si el usuario menciona \"30 de abril\" o \"el 30 de abril\", usa exactamente esa fecha.\n   - Si el usuario dice algo como \"para el 28\", interpreta como el día 28 del mes actual según la fecha del sistema.\n3. Para fechas con día de la semana y fecha numérica (ej: \"miércoles 30 de abril\"):\n   - Prioriza SIEMPRE la fecha numérica (30 de abril) aunque el día de la semana mencionado sea incorrecto.\n4. Para fechas que solo mencionan el día de la semana (ej: \"el martes\"):\n   - Si ese día ya pasó en la semana actual, asume que se refiere a la próxima semana.\n   - Ejemplo: Si hoy es jueves y dicen \"el miércoles\", debe interpretarse como el miércoles de la próxima semana.\n5. Para expresiones relativas:\n   - \"hoy\" = fecha actual del sistema\n   - \"mañana\" = fecha actual + 1 día\n   - \"pasado mañana\" = fecha actual + 2 días\n6. Si hay información contradictoria sobre la fecha en diferentes mensajes, prioriza la información del mensaje más reciente.\n\n## Instrucciones específicas para interpretación de números\n1.  Los campos 'peso' y 'unidades' deben ser valores numéricos enteros.\n2.  Los usuarios pueden usar puntos (.) o comas (,) como separadores de miles. Tu tarea es ignorar estos separadores y extraer el número completo.\n3.  **Ejemplos de interpretación correcta:**\n    - \"3.500 kilos\" debe interpretarse como el número `3500`.\n    - \"3,500 kilos\" debe interpretarse como el número `3500`.\n    - \"3500 kilos\" debe interpretarse como el número `3500`.\n    - \"7.000 unidades\" debe interpretarse como el número `7000`.\n4.  Extrae únicamente la parte numérica. Ignora texto como \"kilos\", \"unidades\", \"kg\", etc.\n\n## Instrucciones generales\n1. Analiza PRIMERO el historial de mensajes completo, luego el mensaje actual.\n2. Si un dato aparece en múltiples mensajes, prioriza la versión más reciente (mensaje actual).\n3. Si encuentras un mensaje que parece ser una respuesta directa a una pregunta sobre un dato específico (ej. \"¿Cuál es el peso?\" → \"300 kilos\"), considera esto como información válida.\n4. NO generes ni inventes información que no esté presente en los mensajes.\n5. Extrae solo la información factual, no interpretes intenciones o deseos del usuario.\n6. NO incluyas notas, explicaciones o campos adicionales en el JSON final.\n7. Si un dato no se encuentra en ninguna parte de la conversación, déjalo en blanco o como valor predeterminado (0 para valores numéricos, \"\" para texto).\n\n## Formato de respuesta\nDevuelve ÚNICAMENTE un objeto JSON limpio con el siguiente formato exacto:\n\n{\n  \"proveedor\": \"\",\n  \"fecha\": \"\",\n  \"hora\": \"\",\n  \"categoria\": \"\",\n  \"peso\": 0,\n  \"unidades\": 0,\n  \"ordenCompra\": \"\"\n}",
        "hasOutputParser": true
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        -38544,
        -10400
      ],
      "id": "e179bf97-aeec-4525-90ec-a42df95a5a34",
      "name": "Basic LLM Chain RECOLECCIÓN1"
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n  \"proveedor\": \"SPB COLOMBIA S.A.S.\",\n  \"fecha\": \"30 de abril de 2025\",\n  \"hora\": \"08:00 AM\",\n  \"categoria\": \"ARENAS\",\n  \"peso\": 300,\n  \"unidades\": 600,\n  \"ordenCompra\": \"ARGM47896\"\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.2,
      "position": [
        -38448,
        -10192
      ],
      "id": "6bf9c79f-71d3-4e1a-bbb1-9ba4a3d13f75",
      "name": "Structured Output Parser3"
    },
    {
      "parameters": {
        "jsCode": "/*\n===========================================================\n  Nodo Code - VALIDAR INSERCIONES EN EXCEL (n8n)\n  • Analiza la salida del “Loop Over Uno a Uno”.\n  • Agrupa los ítems por franja (campo `indice` si existe;\n    de lo contrario, cada bloque de 5 ítems forma una franja).\n  • Verifica que cada inserción tenga:\n        exito === true\n        statusCode === 200\n        falloEstado === false\n  • Devuelve un único objeto JSON con:\n        – Resumen global.\n        – Detalle por franja (éxitos / fallos y celdas con error).\n===========================================================\n*/\n\n// 1) Obtener todos los ítems que llegan al nodo\nconst items = $input.all();\n\n// 2) Función auxiliar para determinar el identificador de la franja\nfunction obtenerIdFranja(item, idx) {\n  // Si existe 'indice', úsalo; de lo contrario agrupa cada 5 ítems\n  if (item.json && item.json.indice !== undefined && item.json.indice !== null) {\n    return String(item.json.indice).trim();\n  }\n  // +1 para que las franjas queden 1-basadas\n  return String(Math.floor(idx / 5) + 1);\n}\n\n// 3) Agrupar ítems por franja\nconst franjas = {};\nitems.forEach((item, idx) => {\n  const idFranja = obtenerIdFranja(item, idx);\n  if (!franjas[idFranja]) {\n    franjas[idFranja] = { id: idFranja, items: [] };\n  }\n  franjas[idFranja].items.push(item.json);\n});\n\n// 4) Analizar cada franja y construir el detalle\nconst detallesPorFranja = Object.values(franjas).map(franja => {\n  const totalOps   = franja.items.length;\n  const exitosas   = franja.items.filter(i =>\n    i.exito === true &&\n    i.statusCode === 200 &&\n    i.falloEstado === false\n  ).length;\n\n  const fallidas   = totalOps - exitosas;\n  const exitoTotal = fallidas === 0;\n\n  // Celdas con error para un diagnóstico claro\n  const celdasFallidas = franja.items\n    .filter(i => !(i.exito && i.statusCode === 200 && !i.falloEstado))\n    .map(i => ({\n      celdaOriginal   : i.celdaOriginal,\n      celdaInsertada  : i.celdaInsertada,\n      statusCode      : i.statusCode,\n      falloEstado     : i.falloEstado,\n      celdasDiferentes: i.celdasDiferentes,\n      mensaje         : 'Inserción fallida'\n    }));\n\n  return {\n    idFranja                : franja.id,\n    exitoFranja             : exitoTotal,\n    operacionesTotales      : totalOps,\n    operacionesExitosas     : exitosas,\n    operacionesFallidas     : fallidas,\n    porcentajeExitosas      : ((exitosas / totalOps) * 100).toFixed(2) + '%',\n    celdasFallidas\n  };\n});\n\n// 5) Resumen global\nconst operacionesTotales   = items.length;\nconst operacionesExitosas  = detallesPorFranja.reduce((sum, f) => sum + f.operacionesExitosas, 0);\nconst operacionesFallidas  = operacionesTotales - operacionesExitosas;\n\nconst franjasTotales   = detallesPorFranja.length;\nconst franjasExitosas  = detallesPorFranja.filter(f => f.exitoFranja).length;\nconst franjasFallidas  = franjasTotales - franjasExitosas;\n\n\nconst resumen = {\n  estadoGeneral              : franjasFallidas === 0 ? 'ÉXITO_COMPLETO' : 'ÉXITO_PARCIAL',\n  franjasTotales,\n  franjasExitosas,\n  franjasFallidas,\n  porcentajeFranjasExitosas  : ((franjasExitosas / franjasTotales) * 100).toFixed(2) + '%',\n  operacionesTotales,\n  operacionesExitosas,\n  operacionesFallidas,\n  porcentajeOperacionesExitosas : ((operacionesExitosas / operacionesTotales) * 100).toFixed(2) + '%',\n  detallesPorFranja\n};\n\n// 6) Devolver un único ítem con el resumen\nreturn [\n  {\n    json: resumen\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -36784,
        -9392
      ],
      "id": "334ce6ab-e6a5-476b-82c7-25070a2c1f49",
      "name": "Code Validar inserciones"
    },
    {
      "parameters": {
        "jsCode": "// 1) Leer chat_id una sola vez\nconst chatId = $node[\"Organiza el Mensaje\"].json.infoMensaje.chat_id;\n\n// 2) Tomamos los datos de informacionCita una sola vez\nconst cita = $input.first().json.informacionCita || {};\nconst historialMensajes = $('Unificación y consistencia de datos').first().json.infoMensaje.historialMensajes;\n\n// Función para convertir fechas en formato \"06 de mayo de 2025\" a \"YYYY-MM-DD HH:mm:ss\"\nfunction convertirFecha(fechaTexto) {\n  const meses = {\n    enero: '01', febrero: '02', marzo: '03', abril: '04', mayo: '05',\n    junio: '06', julio: '07', agosto: '08', septiembre: '09',\n    octubre: '10', noviembre: '11', diciembre: '12'\n  };\n\n  // Dividir la fecha y mapear el mes\n  const [dia, de, mes, deNuevo, anio] = fechaTexto.split(' ');\n  const mesNumerico = meses[mes.toLowerCase()]; // Convertir el mes a número\n  return `${anio}-${mesNumerico}-${dia.padStart(2, '0')} 00:00:00`; // Formato DATETIME\n}\n\n// Convertimos la fecha aquí\nconst fechaCitaConvertida = convertirFecha(cita.fecha);\n\n// 3) Retornamos un solo objeto con todos los datos necesarios\nreturn {\n  json: {\n    chat_id: chatId,\n    proveedor: cita.proveedor,\n    orden_compra: cita.ordenCompra,\n    peso: cita.peso,\n    unidades: cita.unidades,\n    categoria: cita.categoria,\n    muelle: cita.muelle,\n    fecha_cita: fechaCitaConvertida, // Fecha ya convertida\n    hora_inicio: cita.horaInicio,\n    hora_fin: cita.horaFin,\n    chat_historial: historialMensajes,\n    // Incluimos cualquier otro dato que necesites\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -37040,
        -9504
      ],
      "id": "d56eae58-a0f6-439e-abf6-5ccd0590afeb",
      "name": "Code Datos Insert Cita"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT id, chat_id, franjas_json\nFROM FranjasDisponiblesTemp\nWHERE chat_id = '{{ $json.chat_id }}'\nORDER BY timestamp_enviado ASC;\n"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        -36784,
        -9584
      ],
      "id": "c627fcab-b248-4007-b68f-9f681a3bbaae",
      "name": "Microsoft SQL Franjas Temporales",
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "8c501d95-bdf3-4635-a037-224926c2528d",
              "leftValue": "={{ $json.estadoGeneral }}",
              "rightValue": "ÉXITO_COMPLETO",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -36448,
        -9392
      ],
      "id": "3d41f0b6-83b8-4b0d-83ce-07c743c874d2",
      "name": "If Validar inserciones"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.1,
      "position": [
        -36144,
        -9504
      ],
      "id": "ee615a95-3115-447a-a3b9-6aa65d0c260c",
      "name": "Merge"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Nodo Code – “Unir Franjas en Historial”\n * Coloca este nodo inmediatamente después de “Microsoft SQL Franjas Temporales”.\n * No requiere parámetros adicionales.\n */\n\n// 1) Tomamos todos los ítems que llegan desde el nodo SQL\nconst items = $input.all();   // ← cada item = { id, chat_id, franjas_json }\n\n// 2) Armamos la cadena tipo historial:  \"Franja 1: {...}\\n\\nFranja 2: {...}\\n\\n…\"\nlet historial = '';\nitems.forEach((item, idx) => {\n  const numero = idx + 1;                                 // 1, 2, 3, …\n  const cuerpoFranja = JSON.stringify(JSON.parse(item.json.franjas_json), null, 2);    // viene como string desde SQL\n  historial += `Franja ${numero}: ${cuerpoFranja}\\n\\n`;\n});\n\n// 3) (Opcional) quitamos el último salto de línea doble\nhistorial = historial.trimEnd();\n\n// 4) Devolvemos **UN** ítem con **UNA** propiedad (ajusta el nombre si quieres)\nreturn [\n  {\n    json: {\n      franjas_historial: historial            // ← cadena final\n    }\n  }\n];\n\n/* -------------------------------------------------------------------------\n   Ejemplo de salida cuando hay 3 filas:\n\n   {\n     \"franjas_historial\": \"Franja 1: {\\\"disponibilidadConfirmada\\\":false,...}\\n\\n\n                           Franja 2: {\\\"disponibilidadConfirmada\\\":true,...}\\n\\n\n                           Franja 3: {...}\"\n   }\n--------------------------------------------------------------------------- */\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -36448,
        -9584
      ],
      "id": "39037d43-f6e6-402c-98c6-3c3d819c21d1",
      "name": "Code Estructuración de franjas temporales"
    },
    {
      "parameters": {
        "numberInputs": 3
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.1,
      "position": [
        -33296,
        -9072
      ],
      "id": "e4b0b833-786c-42b1-84d2-c1a5f7d7980c",
      "name": "Merge1"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO CitasRecepcion\n(\n    chat_id,\n    nombre,              \n    orden_compra,\n    peso,\n    unidades,\n    horas_entrega,\n    categoria,\n    muelle,\n    fecha_cita,\n    hora_inicio,\n    hora_fin,\n    estado,\n    fecha_creacion,\n    fecha_modificacion,\n    chat_historial,\n    chat_historial_datos\n)\n/* ─── AQUÍ ─── */\nOUTPUT INSERTED.id          --  ←  devolverá el IDENTITY de la fila recién insertada\nVALUES\n(\n    '{{ $('Code Datos Insert Cita').first().json.chat_id }}',\n    '{{ $('Code Datos Insert Cita').first().json.proveedor }}',\n    '{{ $('Code Datos Insert Cita').first().json.orden_compra }}',\n     {{ $('Code Datos Insert Cita').first().json.peso }},              \n     {{ $('Code Datos Insert Cita').first().json.unidades }},          {{ $('Code Agrupar Franjas').first().json.informacionCita.duracionHoras }},\n    '{{ $('Code Datos Insert Cita').first().json.categoria }}',\n    '{{ $('Code Datos Insert Cita').first().json.muelle }}',\n    '{{ $('Code Datos Insert Cita').first().json.fecha_cita }}',\n    '{{ $('Code Datos Insert Cita').first().json.hora_inicio }}',      \n    '{{ $('Code Datos Insert Cita').first().json.hora_fin }}',   \n      'PROGRAMADA',                   \n    (SYSDATETIMEOFFSET() AT TIME ZONE 'SA Pacific Standard Time'), \n    NULL,                            \n    '{{ $items(\"Code Datos Insert Cita\")\n        .map(i => i.json.chat_historial)\n        .join(\"\\n\")\n        .replace(/'/g,\"''\") }}',\n    '{{ $items('Merge')\n        .map(i => i.json.franjas_historial)\n        .join('\\n')\n        .replace(/'/g, \"''\") }}'\n);\n\n"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        -34736,
        -9360
      ],
      "id": "393b6355-ab27-418c-bb87-47dbc11ae4b0",
      "name": "Microsoft SQL Insertar Cita",
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "BEGIN TRANSACTION;\n\nDELETE FROM MensajesWhatsApp\nWHERE chat_id = '{{ $('Unificación y consistencia de datos').first().json.infoMensaje.chat_id }}'\n   OR (chat_id = 'agenteAI'\n       AND message_id IN (\n           SELECT message_id \n           FROM MensajesWhatsApp\n           WHERE chat_id = '{{ $('Unificación y consistencia de datos').first().json.infoMensaje.chat_id }}'\n       )\n   );\n\nDELETE FROM FranjasDisponiblesTemp \nWHERE chat_id = '{{ $('Unificación y consistencia de datos').first().json.infoMensaje.chat_id }}';\n\nCOMMIT;"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        -10880,
        -4240
      ],
      "id": "ed7e905f-b44e-4668-97fd-e394a1ef064d",
      "name": "Microsoft SQL Eliminar Mensajes",
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -32976,
        -8960
      ],
      "id": "4d60672e-8f81-4399-b945-baf13b9fc214",
      "name": "OpenAI Chat Model13",
      "credentials": {
        "openAiApi": {
          "id": "AD8kPcNVReuclASd",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "4bfbecb3-9d4f-4425-aa76-a92abc7708fb",
              "leftValue": "={{ $('Basic LLM Notificar Cita Exitosa').item.json.text.length }}",
              "rightValue": 70,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -32448,
        -9008
      ],
      "id": "f38d5482-ff7d-40fa-bf44-2e404b32def0",
      "name": "Validación de longitud de caracteres7"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d9c2ff70-4fd1-4b93-8571-6d0ac5a0093e",
              "name": "mensaje.ia",
              "value": "={{ $('Basic LLM Notificar Cita Exitosa').item.json.text }}",
              "type": "string"
            },
            {
              "id": "ac8a03be-0292-4735-9580-39a385945c47",
              "name": "mensaje.longitud",
              "value": "={{ $('Basic LLM Notificar Cita Exitosa').item.json.text.length }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -32144,
        -8880
      ],
      "id": "39687c0f-204d-4488-8cf4-c47b5782e285",
      "name": "Organiza variables del mensaje7"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -31984,
        -9104
      ],
      "id": "c76b150d-3c2e-49df-a9b3-a977169d3bee",
      "name": "No Operation, do nothing9"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $('Code Respuesta Faltantes').item.json.text }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -32160,
        -9104
      ],
      "id": "8091365f-6ea4-44ab-829c-b4a390ca406c",
      "name": "HTTP Request Enviar Mensaje por WhatsApp10"
    },
    {
      "parameters": {
        "promptType": "=define",
        "text": "=# Rol\nEres el asistente virtual de Konfíe Logistics.  \nTu objetivo es notificar al proveedor que su cita se registró con éxito en el cronograma.\n\n# Datos disponibles\n- idCita           = {{ $(\"Microsoft SQL Insertar Cita\").first().json.id }}\n- fechaCita        = {{ $(\"Code Datos Insert Cita\").first().json.fecha_cita }}\n- horaInicio       = {{ $(\"Code Datos Insert Cita\").first().json.hora_inicio }}\n- horaFin          = {{ $(\"Code Datos Insert Cita\").first().json.hora_fin }}\n- muelle           = {{ $(\"Code Datos Insert Cita\").first().json.muelle }}\n- ordenCompra      = {{ $(\"Code Datos Insert Cita\").first().json.orden_compra }}\n- categoria        = {{ $(\"Code Datos Insert Cita\").first().json.categoria }}\n- pesoKg           = {{ $(\"Code Datos Insert Cita\").first().json.peso }}\n- unidades         = {{ $(\"Code Datos Insert Cita\").first().json.unidades }}\n\n# Instrucciones de redacción\n1. Mantén un tono profesional, cordial y positivo (feliz pero sin exagerar).\n2. Empieza con una breve expresión de entusiasmo por la confirmación exitosa (ej.: “¡Excelente!” o “¡Cita confirmada!”).\n3. Muestra los detalles de la cita en una lista con viñetas y emojis apropiados:\n   • 🆔 **Número de cita:** resáltalo con el emoji 🔖 antes del `idCita` → 🔖 {{ $(\"Microsoft SQL Insertar Cita\").first().json.id }}\n   • 📅 **Fecha:** {{ $(\"Code Datos Insert Cita\").first().json.fecha_cita.split(\" \")[0] }}\n   • ⏰ **Horario:** {{ $(\"Code Datos Insert Cita\").first().json.hora_inicio }} – {{ $(\"Code Datos Insert Cita\").first().json.hora_fin }} \n   • 🚩 **Muelle:** {{ $(\"Code Datos Insert Cita\").first().json.muelle }} \n   • 🏷️ **O/C:** {{ $(\"Code Datos Insert Cita\").first().json.orden_compra }} \n   • 📦 **Categoría:** {{ $(\"Code Datos Insert Cita\").first().json.categoria }}\n   • ⚖️ **Peso:** {{ $(\"Code Datos Insert Cita\").first().json.peso }} kg  \n   • 📦 **Unidades:** {{ $(\"Code Datos Insert Cita\").first().json.unidades }}\n4. Reitera el número de cita con el emoji 🔖 y aclara que con ese número el proveedor podrá **modificar o cancelar** la cita.\n5. Explica claramente la política: “Las modificaciones o cancelaciones deben solicitarse **hasta un día hábil antes** y **antes de las 4:30 p. m.**; después de ese plazo no podremos realizar cambios.”\n6. Cierra agradeciendo su colaboración y confirmando que estaremos atentos a su llegada.\n7. Devuelve **solo** el mensaje final, sin encabezados ni explicaciones adicionales.\n\n# Salida esperada (ejemplo de estilo)\n¡Excelente! 🎉  \n🔖 Numero de la Cita: 12345  \n📅 El 06 de mayo de 2025  \n⏰ A las 08:00 – 10:00  \n🚩 En el Muelle 1  \n🏷️ O/C ARGM47896  \n📦 Categoría Arenas  \n⚖️ 300 kg | 📦 600 u\n\nGuarda tu número de cita 🔖 12345 para futuras gestiones ya sea reprogramar o cancelar.  \nPodrás modificarla o cancelarla hasta un día hábil antes y antes de las 4:30 p. m.  \n¡Muchas gracias por tu confianza!\n"
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        -32880,
        -9152
      ],
      "id": "c625ea05-67d9-4b9d-b2a2-957c3598f939",
      "name": "Basic LLM Notificar Cita Exitosa",
      "alwaysOutputData": true,
      "executeOnce": true
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "BEGIN TRANSACTION;\n\nDELETE FROM MensajesWhatsApp\nWHERE chat_id = '{{ $('Unificación y consistencia de datos').first().json.infoMensaje.chat_id }}'\n   OR (chat_id = 'agenteAI'\n       AND message_id IN (\n           SELECT message_id \n           FROM MensajesWhatsApp\n           WHERE chat_id = '{{ $('Unificación y consistencia de datos').first().json.infoMensaje.chat_id }}'\n       )\n   );\n\nDELETE FROM FranjasDisponiblesTemp \nWHERE chat_id = '{{ $('Unificación y consistencia de datos').first().json.infoMensaje.chat_id }}';\n\nCOMMIT;\n"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        -33856,
        -8848
      ],
      "id": "382b10ae-a6af-4326-b7a6-bb204db3559b",
      "name": "Microsoft SQL Eliminar Mensajes2",
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -40864,
        -6528
      ],
      "id": "2cc95e5d-6144-4619-8add-e04f036a9e66",
      "name": "OpenAI Chat Model14",
      "credentials": {
        "openAiApi": {
          "id": "AD8kPcNVReuclASd",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n\"idCita\": \"\",\n\"ordenCompra\": \"\",\n\"nuevaFecha\": \"\",\n\"nuevaHora\": \"\",\n\"camposFaltantes\": [],\n\"fechaActual\": \"\",\n\"horaActual\": \"\"\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.2,
      "position": [
        -40704,
        -6528
      ],
      "id": "2862245c-2dcb-4780-b376-1f851fe7fcac",
      "name": "Structured Output Parser4"
    },
    {
      "parameters": {
        "promptType": "=define",
        "text": "=# Extracción de datos para edición de citas\n\n## SISTEMA\nEres un asistente especializado en interpretar mensajes de usuarios para reprogramación de citas logísticas. Tu función es extraer los datos necesarios para reprogramar una cita existente (ID de cita, orden de compra, nueva fecha, nueva hora) y validar que sean coherentes.\n\n**Tu única responsabilidad es extraer datos, no validarlos ni tomar decisiones.**\n\n## DETECCIÓN DE RETRACTACIONES EN EDICIÓN\nSi detectas múltiples cambios de fecha/hora contradictorios en el historial:\n- Verifica si el usuario ha mencionado diferentes fechas para la reprogramación\n- Si encuentra fechas contradictorias, marca como rechazado con motivo \"retractaciones_multiples\"\n- Sugiere reiniciar el proceso\n\n## Datos a extraer\n- ID de la cita (por ejemplo, \"Cita 12345\", \"Número 12345\", etc.)\n- Número de orden de compra asociado a la cita\n- Nueva fecha deseada\n- Nueva hora deseada\n\n## Fuentes de datos a analizar\n- Mensaje actual: {{ $('Unificación y consistencia de datos').first().json.infoMensaje.mensajeActual }}\n- Historial de mensajes: {{ $node[\"Unificación y consistencia de datos\"].json[\"infoMensaje\"][\"historialMensajes\"] }}\n- Hora actual: {{$node[\"Organiza el Mensaje\"].json.infoMensaje.horaMensajeActual}}\n- Fecha actual: {{$node[\"Organiza el Mensaje\"].json.infoMensaje.fechaMensajeActual}}\n\n## Procesamiento del historial completo de mensajes\n1. IMPORTANTE: Analiza el historial COMPLETO de mensajes como una conversación\n2. Busca información relevante a lo largo de TODOS los mensajes, no solo en el mensaje actual\n3. Considera que la información puede estar distribuida en varios mensajes (por ejemplo, ID en un mensaje, orden de compra en otro, fecha en otro, hora en otro)\n4. Une la información proporcionada en mensajes separados para construir la solicitud completa\n5. Si el mensaje actual contiene solo un dato (como \"a las 7am\"), conéctalo con datos previos de mensajes anteriores\n\n## Detección de retractaciones específica\n6. CRÍTICO: Detecta si el usuario ha proporcionado fechas contradictorias para la reprogramación:\n   - Ejemplo: Primer mensaje \"reprogramar para el 17 de julio\", segundo mensaje \"mejor para el 18 de julio\"\n   - Si detectas esto, marca motivoRechazo como \"retractaciones_multiples\"\n\n## Instrucciones específicas\n1. Busca PRIMERO el ID de la cita en formato numérico en CUALQUIER mensaje previo\n2. Busca el número de orden de compra en CUALQUIER mensaje previo\n3. Si encuentras ID y orden de compra, busca la fecha nueva que desea el proveedor en CUALQUIER mensaje previo o actual\n4. Si encuentras ID, orden de compra y fecha, busca la hora nueva que desea el proveedor en CUALQUIER mensaje previo o actual\n5. Si un mensaje solo menciona la hora (por ejemplo, \"7am\"), conéctalo con la fecha mencionada en mensajes anteriores\n6. Si un mensaje solo menciona una fecha (por ejemplo, \"jueves 8 de mayo\"), busca si hay información sobre la hora en otros mensajes\n7. Considera expresiones como \"para mañana\", \"para el lunes\", \"para el 20\", etc. encontradas en CUALQUIER mensaje\n8. Normaliza la fecha al formato \"DD de [mes] de YYYY\" (usando el año actual si no se especifica)\n9. Normaliza la hora al formato \"HH:MM AM/PM\"\n10. NUEVO: Verifica si hay fechas contradictorias en diferentes mensajes del historial\n\n## Reglas de validación temporal\n1. Si la nueva fecha es anterior a la fecha actual → motivoRechazo: \"fecha_pasada\"\n2. Si la nueva fecha es para el mismo día después de las 4:30 PM → motivoRechazo: \"mismo_dia_tarde\"\n3. Si la nueva fecha es para el día siguiente y son más de las 4:30 PM → motivoRechazo: \"dia_siguiente_tarde\"\n4. Si hay múltiples fechas contradictorias → motivoRechazo: \"retractaciones_multiples\"\n\n## Formato de respuesta (JSON)\n```json\n{\n  \"idCita\": \"12345\",\n  \"ordenCompra\": \"ARGM47896\", \n  \"nuevaFecha\": \"20 de mayo de 2025\",\n  \"nuevaHora\": \"10:00 AM\",\n  \"camposFaltantes\": [],\n  \"fechaActual\": \"19 de mayo de 2025\",\n  \"horaActual\": \"14:30\",\n  \"motivoRechazo\": \"retractaciones_multiples\",\n  \"mensajeUsuario\": \"Usuario ha proporcionado fechas contradictorias para reprogramación\"\n}\n```\n\n## Ejemplos de campos faltantes\n- Si no hay ID: camposFaltantes: [\"idCita\"]  \n- Si no hay orden: camposFaltantes: [\"ordenCompra\"]\n- Si no hay fecha: camposFaltantes: [\"nuevaFecha\"]\n- Si no hay hora: camposFaltantes: [\"nuevaHora\"]\n\n## Casos especiales de retractación\n- Usuario dice: \"reprogramar mi cita 123 para el 17\", luego \"mejor para el 18\" → motivoRechazo: \"retractaciones_multiples\"\n- Usuario cambia fecha múltiples veces en la misma conversación → motivoRechazo: \"retractaciones_multiples\"\n\nIMPORTANTE: Solo extrae datos, no valides fechas pasadas ni horarios de oficina. Esa validación la hace otro nodo.",
        "hasOutputParser": true
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        -40784,
        -6720
      ],
      "id": "79ce5530-b4fe-417e-a6ea-7df15c2f29ca",
      "name": "Basic LLM Extracción y Validacion de Datos Editar Cita"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "f0ba0488-a2ee-439f-ac12-ff4f15d14c58",
              "leftValue": "={{ $json.todoCorrecto }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -40192,
        -6720
      ],
      "id": "250b2cfc-dd6f-4a6d-a1da-9b389f885842",
      "name": "If Validar si la operación es posible (todoCorrecto)"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "b8d93581-02fd-4502-8346-e5f35dd7a430",
              "leftValue": "={{ $json.output.intentaModificarDatos }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -39792,
        -6544
      ],
      "id": "418be759-ef66-455c-883c-085a528dbb6a",
      "name": "If Verificar si se intenta modificar datos no permitidos"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "17546f72-2b59-46c3-b92b-e87f10cf0799",
              "leftValue": "={{ $json.output.rechazoTemporal }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -39536,
        -6320
      ],
      "id": "2fe4226e-1214-41e9-805f-942abf06c7ca",
      "name": "If Verificar si es un rechazo por motivos temporales"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "46e5638b-d64b-47e5-9cac-984fb79f107c",
              "leftValue": "={{ $json.output.camposFaltantes.length }}",
              "rightValue": 0,
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -39264,
        -6112
      ],
      "id": "54c06b04-b2e0-47d2-98c6-09549a9337f0",
      "name": "If Verificar si faltan datos"
    },
    {
      "parameters": {
        "jsCode": "// Create a generic error message\nconst errorMessage = {\n  output: {\n    mensajeSistema: \"Lo sentimos, ha ocurrido un error interno. Por favor, vuelva a empezar nuevamente con su solicitud de reprogramación de cita.\"\n  }\n};\n\n// Return the formatted message that can be used by your response node\nreturn errorMessage;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -39056,
        -5872
      ],
      "id": "1d684417-a3a9-47fd-9ba1-efeae2af3206",
      "name": "Code Mensaje Error"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "b2110549-dd58-46b3-9707-dbbe0a5004f2",
              "leftValue": "={{ $('Basic LLM Extracción y Validacion de Datos Editar Cita').first().json.output.mensajeSistema.length }}",
              "rightValue": 70,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            },
            {
              "id": "f250763e-e4ab-4054-8bf5-84d61e39f87b",
              "leftValue": "={{ $json.output.mensajeSistema.length }}",
              "rightValue": 70,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -38624,
        -6464
      ],
      "id": "1834ba4d-0833-4316-90dc-3f8d9e543ecd",
      "name": "Validación de longitud de caracteres8"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -38128,
        -6528
      ],
      "id": "966c8b97-1ffe-4889-8d80-4cfa80220209",
      "name": "No Operation, do nothing11"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $('Consistencia de datos, intención consultar malla').item.json.mensaje }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -38304,
        -6528
      ],
      "id": "62ce7117-116e-429a-8bf7-1735eb4b4e89",
      "name": "HTTP Request Enviar Mensaje por WhatsApp11"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d9c2ff70-4fd1-4b93-8571-6d0ac5a0093e",
              "name": "mensaje.ia",
              "value": "={{ $json.output.mensajeSistema }}",
              "type": "string"
            },
            {
              "id": "ac8a03be-0292-4735-9580-39a385945c47",
              "name": "mensaje.longitud",
              "value": "={{ $json.output.mensajeSistema.length }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -38304,
        -6320
      ],
      "id": "e52582fb-5183-4ce5-a200-87444ca84629",
      "name": "Organiza variables del mensaje8"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "DECLARE @Id INT = {{ $json.idCita }};\n\nIF EXISTS (SELECT 1\n           FROM   CitasRecepcion\n           WHERE  id = @Id\n             AND  estado = 'PROGRAMADA')\nBEGIN\n    SELECT *\n    FROM   CitasRecepcion\n    WHERE  id = @Id\n      AND  estado = 'PROGRAMADA';\nEND\nELSE\nBEGIN\n    -- Código 50001 y nivel 16: error de aplicación personalizado\n    THROW 50001, 'La cita no se encuentra en estado PROGRAMADA.', 16;\nEND"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        -39968,
        -6832
      ],
      "id": "97edfb35-b760-4975-9841-6f436d19d94f",
      "name": "Microsoft SQL Obtener Cita",
      "alwaysOutputData": true,
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "0c011567-205a-4ff9-a41a-5c1cd00a6f04",
              "leftValue": "={{ $json.id }}",
              "rightValue": "",
              "operator": {
                "type": "number",
                "operation": "exists",
                "singleValue": true
              }
            },
            {
              "id": "07596852-0256-421d-be90-26f9e2e932ba",
              "leftValue": "={{ $json.chat_id }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "exists",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -39744,
        -6832
      ],
      "id": "ccff2084-2747-4504-b2c3-ee615e4a0c6c",
      "name": "If existe cita"
    },
    {
      "parameters": {
        "jsCode": "// Create a generic error message\nconst errorMessage = {\n  output: {\n    mensajeSistema: \"El número de identificación de la cita proporcionado no existe en el cronograma. O es una cita ya cancelada o reprogramada, por motivos de trazabilidad, es necesario reiniciar el proceso de reprogramación. Por favor, proporciona nuevamente todos los datos, asegurándote de que sean correctos. Gracias por tu colaboración.\"\n  }\n};\n\n// Return the formatted message that can be used by your response node\nreturn errorMessage;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -39312,
        -6704
      ],
      "id": "9010ce4c-1f0d-4a61-b1fb-99614f897b18",
      "name": "Code Mensaje Error1"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.1,
      "position": [
        -11744,
        -4240
      ],
      "id": "4f06f112-9dbb-4fa2-96e0-ce0b986f16f5",
      "name": "Merge2"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -10688,
        -4240
      ],
      "id": "a06180f5-0c38-439a-b137-e2fb47134de0",
      "name": "No Operation, do nothing10"
    },
    {
      "parameters": {
        "jsCode": "// Obtener todos los datos de entrada\nconst datosEntrada = $input.all();\n// Filtrar solo los objetos que contienen un mensaje, descartando estadísticas\nconst mensajes = datosEntrada.filter(item => item.json.message_id);\n\n// Extraer chat_id del primer mensaje del usuario (no del agente)\nconst userMessage = mensajes.find(item => item.json.chat_id !== 'agenteAI');\nconst chat_id = userMessage ? userMessage.json.chat_id : \"No hay chat_id disponible\";\n\n// Función para convertir la fecha a formato Colombia (UTC-5) en formato de 12 horas\nfunction convertirHoraColombia(fechaUTC) {\n    if (!fechaUTC) return \"[Hora no encontrada]\";\n    let fecha = new Date(fechaUTC);\n    fecha.setHours(fecha.getHours()); // Convertir a UTC-5\n    return fecha.toLocaleTimeString('es-CO', { hour: '2-digit', minute: '2-digit', hour12: true });\n}\n// Función para dar formato de fecha en español sin hora\nfunction formatearFecha(fechaUTC) {\n    if (!fechaUTC) return \"[Fecha no encontrada]\";\n    let fecha = new Date(fechaUTC);\n    return fecha.toLocaleDateString('es-CO', { year: 'numeric', month: 'long', day: 'numeric' });\n}\n// Estructurar los mensajes en un formato claro para el agente IA\nconst mensajesEstructurados = mensajes.map((mensaje, index) => {\n    let fecha = mensaje.json.fecha ? formatearFecha(mensaje.json.fecha) : \"[Fecha no encontrada]\";\n    let hora = mensaje.json.fecha ? convertirHoraColombia(mensaje.json.fecha) : \"[Hora no encontrada]\";\n    let contenido = mensaje.json.contenido || \"[Sin contenido]\";\n    \n    // Determinar si el mensaje es del usuario o del agente IA\n    let remitente = mensaje.json.chat_id === 'agenteAI' ? 'El Agente ChatBot IA dice:' : 'El usuario dice:';\n    \n    return `Mensaje ${index + 1} enviado el ${fecha} a las ${hora}.\\n${remitente} \"${contenido}\".`;\n});\n// Unir todos los mensajes en un solo texto estructurado\nconst historialMensajes = mensajesEstructurados.join('\\n\\n');\n// Retornar los datos estructurados incluyendo chat_id\nreturn [{ chat_id, historialMensajes }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -11328,
        -4240
      ],
      "id": "b826165d-aa84-49d3-84ec-38118a11afd0",
      "name": "Code integracion de mensajes"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT * FROM MensajesWhatsApp\nWHERE chat_id = '{{ $('Unificación y consistencia de datos').first().json.infoMensaje.chat_id }}'\n   OR (chat_id = 'agenteAI' AND message_id IN (\n       SELECT message_id \n       FROM MensajesWhatsApp \n       WHERE chat_id = '{{ $('Unificación y consistencia de datos').first().json.infoMensaje.chat_id }}'\n   ))\nORDER BY fecha ASC;"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        -11536,
        -4240
      ],
      "id": "624b3c07-5367-4a9a-bc0e-9ae0aa9a1b83",
      "name": "Recupera todos los mensajes1",
      "alwaysOutputData": true,
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE CitasRecepcion\nSET chat_historial = '{{ \n  $items(\"Code integracion de mensajes\")\n    .map(i => i.json.historialMensajes)\n    .join(\"\\n\")\n    .replace(/'/g, \"''\")\n}}'\nWHERE id = '{{ \n  $('Microsoft SQL Insertar Cita').isExecuted\n    ? $('Microsoft SQL Insertar Cita').first().json.id\n    : $('Microsoft SQL Insertar Cita1').isExecuted\n      ? $('Microsoft SQL Insertar Cita1').first().json.id\n      : $('Microsoft SQL Obtener Cita').isExecuted\n        ? $('Microsoft SQL Obtener Cita').first().json.id\n        : $('Code Datos Cancelar Cita').first().json.id \n}}';"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        -11104,
        -4240
      ],
      "id": "9f872b85-0460-49ff-a030-78df33bbbb3c",
      "name": "Microsoft SQL Actualiza la Cita",
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Nodo Code: Validación de datos para reprogramación de citas\n// Recibe los datos extraídos del nodo LLM y aplica las validaciones de negocio\n\n// Obtener los datos del nodo anterior usando la ruta específica\nconst datosExtraidos = $('Basic LLM Extracción y Validacion de Datos Editar Cita').first().json.output;\n\n// Mostrar datos extraídos para debug\nconsole.log(\"Datos recibidos del nodo anterior:\", JSON.stringify(datosExtraidos, null, 2));\n\n// Función principal que procesa los datos de entrada\nfunction procesarDatosReprogramacion(datos) {\n  try {\n    // Estructura de respuesta final (siguiendo el formato del prompt original)\n    const respuesta = {\n      todoCorrecto: false,\n      datosPreviamenteConfirmados: false,\n      idCita: datos.idCita || \"\",\n      ordenCompra: datos.ordenCompra || \"\",\n      nuevaFecha: datos.nuevaFecha || \"\",\n      nuevaHora: datos.nuevaHora || \"\",\n      camposFaltantes: datos.camposFaltantes || [],\n      mensajeSistema: \"\",\n      rechazoTemporal: false,\n      motivoRechazo: \"\",\n      intentaModificarDatos: false\n    };\n\n    console.log(\"Datos iniciales en respuesta:\", JSON.stringify(respuesta, null, 2));\n\n    // 1. Verificar si hay campos faltantes\n    if (respuesta.camposFaltantes && respuesta.camposFaltantes.length > 0) {\n      respuesta.todoCorrecto = false;\n      respuesta.mensajeSistema = generarMensajeCamposFaltantes(respuesta.camposFaltantes);\n      return respuesta;\n    }\n\n    // 2. Validar las fechas y reglas temporales\n    const validacionTemporal = validarReglasTemporales(respuesta.nuevaFecha, datos.fechaActual, datos.horaActual);\n    console.log(\"Resultado de validación temporal:\", JSON.stringify(validacionTemporal, null, 2));\n    \n    if (validacionTemporal.esValido === false) {\n      respuesta.todoCorrecto = false;\n      respuesta.rechazoTemporal = true;\n      respuesta.motivoRechazo = validacionTemporal.motivoRechazo;\n      respuesta.mensajeSistema = validacionTemporal.mensaje;\n      return respuesta;\n    }\n\n    // 3. Si todo está correcto, preparar mensaje de confirmación\n    respuesta.todoCorrecto = true;\n    respuesta.mensajeSistema = `Entendido. Estás solicitando reprogramar la cita 🔖 ${respuesta.idCita} con orden de compra ${respuesta.ordenCompra} para el ${respuesta.nuevaFecha} a las ${respuesta.nuevaHora}. Verificaré la disponibilidad para este horario.`;\n    \n    return respuesta;\n  } catch (error) {\n    console.error(\"Error al procesar datos de reprogramación:\", error);\n    return {\n      todoCorrecto: false,\n      datosPreviamenteConfirmados: false,\n      idCita: datos.idCita || \"\",\n      ordenCompra: datos.ordenCompra || \"\",\n      nuevaFecha: datos.nuevaFecha || \"\",\n      nuevaHora: datos.nuevaHora || \"\",\n      camposFaltantes: [\"error_procesamiento\"],\n      mensajeSistema: \"Ha ocurrido un error al procesar tu solicitud. Por favor, intenta nuevamente proporcionando todos los datos necesarios.\",\n      rechazoTemporal: false,\n      motivoRechazo: \"error_sistema\",\n      intentaModificarDatos: false\n    };\n  }\n}\n\n// Genera mensaje para campos faltantes\nfunction generarMensajeCamposFaltantes(camposFaltantes) {\n  let mensaje = \"Para poder reprogramar tu cita, necesito \";\n  \n  if (camposFaltantes.includes(\"idCita\")) {\n    mensaje += \"el número de cita 🔖 que aparece en tu confirmación anterior, \";\n  }\n  \n  if (camposFaltantes.includes(\"ordenCompra\")) {\n    mensaje += \"el número de orden de compra para verificación, \";\n  }\n  \n  if (camposFaltantes.includes(\"nuevaFecha\")) {\n    mensaje += \"la nueva fecha que prefieres, \";\n  }\n  \n  if (camposFaltantes.includes(\"nuevaHora\")) {\n    mensaje += \"la nueva hora que prefieres, \";\n  }\n  \n  mensaje = mensaje.slice(0, -2) + \". \";\n  mensaje += \"Por ejemplo: 'Quiero reprogramar mi cita 12345 con orden de compra ARGM47896 para el 20 de mayo a las 10:00 AM'.\";\n  \n  return mensaje;\n}\n\n// Validar reglas temporales (mismo día, día siguiente, etc.)\nfunction validarReglasTemporales(nuevaFecha, fechaActual, horaActual) {\n  try {\n    console.log(`Validando fechas - Nueva: ${nuevaFecha}, Actual: ${fechaActual}, Hora: ${horaActual}`);\n    \n    // Convertir fechas a objetos Date para comparación\n    const fechaNueva = parsearFecha(nuevaFecha);\n    const fechaHoy = parsearFechaActual(fechaActual);\n    \n    console.log(`Fechas parseadas - Nueva: ${fechaNueva.toISOString()}, Hoy: ${fechaHoy.toISOString()}`);\n    \n    // Calcular fecha de mañana\n    const fechaManana = new Date(fechaHoy);\n    fechaManana.setDate(fechaManana.getDate() + 1);\n    console.log(`Fecha mañana: ${fechaManana.toISOString()}`);\n    \n    // 1. Validar si es el mismo día\n    if (\n      fechaNueva.getFullYear() === fechaHoy.getFullYear() &&\n      fechaNueva.getMonth() === fechaHoy.getMonth() &&\n      fechaNueva.getDate() === fechaHoy.getDate()\n    ) {\n      console.log(\"Es el mismo día - RECHAZADO\");\n      return {\n        esValido: false,\n        motivoRechazo: \"mismo_dia\",\n        mensaje: \"Lo siento, pero no es posible reprogramar citas para el mismo día. Por políticas internas, las modificaciones deben hacerse con al menos un día de anticipación. Por favor, selecciona una fecha futura a partir de mañana.\"\n      };\n    }\n    \n    // 2. Validar si es el día siguiente y es después de las 4:30 PM\n    const esMañana = \n      fechaNueva.getFullYear() === fechaManana.getFullYear() &&\n      fechaNueva.getMonth() === fechaManana.getMonth() &&\n      fechaNueva.getDate() === fechaManana.getDate();\n    \n    const esTarde = esHoraPosteriorA430PM(horaActual);\n    \n    console.log(`Es mañana: ${esMañana}, Es tarde (post 4:30pm): ${esTarde}`);\n    \n    if (esMañana && esTarde) {\n      console.log(\"Es para mañana después de las 4:30 PM - RECHAZADO\");\n      return {\n        esValido: false,\n        motivoRechazo: \"tarde_para_manana\",\n        mensaje: `Lo siento, pero no es posible reprogramar citas para mañana después de las 4:30 PM del día actual. Por favor, selecciona una fecha a partir del ${formatearFecha(new Date(fechaManana.getTime() + 86400000))}. Las modificaciones para el día siguiente solo pueden realizarse antes de las 4:30 PM.`\n      };\n    }\n    \n    // Si pasa todas las validaciones\n    console.log(\"Validación temporal APROBADA\");\n    return {\n      esValido: true\n    };\n  } catch (error) {\n    console.error(\"Error al validar reglas temporales:\", error);\n    return {\n      esValido: true // En caso de error, permitimos continuar para no bloquear al usuario\n    };\n  }\n}\n\n// Funciones auxiliares para manipulación de fechas\n\n// Parsea una fecha en formato \"DD de mes de YYYY\"\nfunction parsearFecha(fechaStr) {\n  try {\n    console.log(`Parseando fecha: \"${fechaStr}\"`);\n    const partes = fechaStr.split(\" de \");\n    \n    if (partes.length < 3) {\n      console.error(`Formato de fecha incorrecto: \"${fechaStr}\"`);\n      return new Date(); // Devolver fecha actual en caso de error de formato\n    }\n    \n    const dia = parseInt(partes[0], 10);\n    \n    const meses = {\n      \"enero\": 0, \"febrero\": 1, \"marzo\": 2, \"abril\": 3, \"mayo\": 4, \"junio\": 5,\n      \"julio\": 6, \"agosto\": 7, \"septiembre\": 8, \"octubre\": 9, \"noviembre\": 10, \"diciembre\": 11\n    };\n    \n    const mes = meses[partes[1].toLowerCase()];\n    const anio = parseInt(partes[2], 10);\n    \n    console.log(`Día: ${dia}, Mes: ${mes}, Año: ${anio}`);\n    \n    if (isNaN(dia) || mes === undefined || isNaN(anio)) {\n      console.error(`Valores de fecha inválidos: día=${dia}, mes=${mes}, año=${anio}`);\n      return new Date();\n    }\n    \n    return new Date(anio, mes, dia);\n  } catch (error) {\n    console.error(\"Error al parsear fecha:\", error);\n    return new Date(); // Devuelve fecha actual en caso de error\n  }\n}\n\n// Parsea la fecha actual en formato YYYY-MM-DD\nfunction parsearFechaActual(fechaStr) {\n  try {\n    console.log(`Parseando fecha actual: \"${fechaStr}\"`);\n    \n    if (!fechaStr || typeof fechaStr !== 'string') {\n      console.error(`Formato de fecha actual inválido: \"${fechaStr}\"`);\n      return new Date();\n    }\n    \n    const [anio, mes, dia] = fechaStr.split(\"-\").map(num => parseInt(num, 10));\n    \n    if (isNaN(anio) || isNaN(mes) || isNaN(dia)) {\n      console.error(`Valores de fecha actual inválidos: año=${anio}, mes=${mes}, día=${dia}`);\n      return new Date();\n    }\n    \n    return new Date(anio, mes - 1, dia); // Restar 1 al mes porque en JS los meses van de 0-11\n  } catch (error) {\n    console.error(\"Error al parsear fecha actual:\", error);\n    return new Date(); // Devuelve fecha actual en caso de error\n  }\n}\n\n// Verifica si la hora es posterior a las 4:30 PM\nfunction esHoraPosteriorA430PM(horaStr) {\n  try {\n    console.log(`Verificando si hora es posterior a 4:30 PM: \"${horaStr}\"`);\n    \n    if (!horaStr || typeof horaStr !== 'string') {\n      console.error(`Formato de hora inválido: \"${horaStr}\"`);\n      return false;\n    }\n    \n    // Convierte la hora a minutos para facilitar la comparación\n    let horas = 0;\n    let minutos = 0;\n    \n    // Manejar varios formatos posibles de hora\n    if (horaStr.includes(\":\")) {\n      // Formato HH:MM (am/pm)\n      const [hora, resto] = horaStr.split(\":\");\n      horas = parseInt(hora, 10);\n      \n      // Extraer minutos y posible AM/PM\n      if (resto.toLowerCase().includes(\"p.m.\") || resto.toLowerCase().includes(\"pm\")) {\n        if (horas !== 12) horas += 12; // Convertir a formato 24h\n        minutos = parseInt(resto.replace(/[^\\d]/g, \"\"), 10);\n      } else {\n        if (horas === 12) horas = 0; // Mediodía en formato 12h es 0 en formato 24h\n        minutos = parseInt(resto.replace(/[^\\d]/g, \"\"), 10);\n      }\n    } else {\n      // Intentar otros formatos\n      const match = horaStr.match(/(\\d+)(?:\\D+)(\\d*)\\s*([ap]\\.?m\\.?)?/i);\n      if (match) {\n        horas = parseInt(match[1], 10);\n        minutos = match[2] ? parseInt(match[2], 10) : 0;\n        \n        const periodo = match[3] ? match[3].toLowerCase() : \"\";\n        if (periodo.includes(\"p\")) {\n          if (horas !== 12) horas += 12;\n        } else if (periodo.includes(\"a\") && horas === 12) {\n          horas = 0;\n        }\n      }\n    }\n    \n    // Convertir todo a minutos\n    const totalMinutos = horas * 60 + minutos;\n    console.log(`Hora convertida a minutos: ${totalMinutos} (${horas}:${minutos})`);\n    \n    // 4:30 PM = 16:30 = 990 minutos\n    return totalMinutos > 990;\n    \n  } catch (error) {\n    console.error(\"Error al evaluar la hora:\", error);\n    return false; // En caso de error, asumimos que no es después de las 4:30 PM\n  }\n}\n\n// Formatea una fecha como \"DD de mes de YYYY\"\nfunction formatearFecha(fecha) {\n  try {\n    const dia = fecha.getDate();\n    \n    const meses = [\n      \"enero\", \"febrero\", \"marzo\", \"abril\", \"mayo\", \"junio\",\n      \"julio\", \"agosto\", \"septiembre\", \"octubre\", \"noviembre\", \"diciembre\"\n    ];\n    \n    const mes = meses[fecha.getMonth()];\n    const anio = fecha.getFullYear();\n    \n    return `${dia} de ${mes} de ${anio}`;\n  } catch (error) {\n    console.error(\"Error al formatear fecha:\", error);\n    return \"\"; // Devuelve string vacío en caso de error\n  }\n}\n\n// Aplicar la función principal a los datos extraídos\nconst resultado = procesarDatosReprogramacion(datosExtraidos);\nconsole.log(\"Resultado final:\", JSON.stringify(resultado, null, 2));\n\n// Devolver el resultado procesado\nreturn resultado;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -40416,
        -6720
      ],
      "id": "b41d923c-f787-4273-b9cc-84b128e14294",
      "name": "Code Validación de datos para reprogramación de citas"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.1,
      "position": [
        -11616,
        -3984
      ],
      "id": "5d8e8bb1-21ae-41e1-a049-dd9a590c7b3e",
      "name": "Merge3"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "BEGIN TRANSACTION;\n\nDELETE FROM MensajesWhatsApp\nWHERE chat_id = '{{ $('Unificación y consistencia de datos').first().json.infoMensaje.chat_id }}'\n   OR (chat_id = 'agenteAI'\n       AND message_id IN (\n           SELECT message_id \n           FROM MensajesWhatsApp\n           WHERE chat_id = '{{ $('Unificación y consistencia de datos').first().json.infoMensaje.chat_id }}'\n       )\n   );\n\nDELETE FROM FranjasDisponiblesTemp \nWHERE chat_id = '{{ $('Unificación y consistencia de datos').first().json.infoMensaje.chat_id }}';\n\nCOMMIT;"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        -11408,
        -3984
      ],
      "id": "ff82fa11-34ab-4282-9e0c-9004155b0d4b",
      "name": "Microsoft SQL Eliminar Mensajes3",
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -11184,
        -3984
      ],
      "id": "4a606ec1-73a8-4d4a-a7d4-1ba136cf367b",
      "name": "No Operation, do nothing12"
    },
    {
      "parameters": {
        "url": "https://graph.microsoft.com/v1.0/sites/a592f886-4560-4e62-9646-1eee7add7abe/drives/b!hviSpWBFYk6WRh7uet16vnNAUYuuQRlGj3ZyS9kSvGVZ4DSg6c5MRqYYm2MdAER8/items/01PPLUUYXY5E2GK3SJ25EZLJPUYJ43H3ME/content",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "microsoftOAuth2Api",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "file",
              "outputPropertyName": "ExcelMallaRecibido2025"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -39408,
        -6960
      ],
      "id": "0ac7ddd8-81ac-41cc-91d7-f64c3b8d2f9f",
      "name": "HTTP Request MALLA DE RECIBO 2",
      "credentials": {
        "microsoftOAuth2Api": {
          "id": "mh8Z8hxFvd7LDO8D",
          "name": "CuentaMy SharePoint App Desarrollador1 Konfie "
        }
      }
    },
    {
      "parameters": {
        "operation": "xlsx",
        "binaryPropertyName": "ExcelMallaRecibido2025",
        "options": {
          "sheetName": "={{ $('Unificación y consistencia de datos').item.json.hojaSeleccionada }}"
        }
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -39152,
        -7088
      ],
      "id": "1076da97-fa9d-4a46-ae84-630982506750",
      "name": "Extract MALLA DE RECIBO 2"
    },
    {
      "parameters": {
        "jsCode": "// Obtener los datos del Excel\nconst excelData = $input.all();\nconst hojaSeleccionada = $('Unificación y consistencia de datos').first().json.hojaSeleccionada;\n\n// Obtener hora local en Bogotá\nconst ahora = new Date(new Date().toLocaleString(\"en-US\", { timeZone: \"America/Bogota\" }));\nconst diaSemanaActual = ahora.getDay(); // 0=domingo, 1=lunes, ..., 5=viernes\nconst horaActual = ahora.getHours();\nconst minutosActual = ahora.getMinutes();\n// Determinar si es después de las 16:30\nconst pasoLimiteDia = horaActual > 16 || (horaActual === 16 && minutosActual >= 30);\n\n// Definir estructura de la semana y los días\nconst diasSemana = ['lunes', 'martes', 'miércoles', 'jueves', 'viernes'];\n\n// Mapeo para saber qué días incluir si hoy es x día y pasó el límite\n/**\n * Dado el día de la semana actual (0=domingo ... 6=sábado),\n * devuelve qué días de la semana actual deben incluirse según si pasó el límite.\n */\nfunction diasValidosSemanaActual(diaSemanaActual, pasoLimite) {\n  const mapa = {\n    1: ['martes', 'miércoles', 'jueves', 'viernes'],   // lunes\n    2: ['miércoles', 'jueves', 'viernes'],             // martes\n    3: ['jueves', 'viernes'],                          // miércoles\n    4: ['viernes'],                                     // jueves\n    5: []                                               // viernes (muy tarde para sábado)\n  };\n  if (diaSemanaActual < 1 || diaSemanaActual > 5) {\n    return []; // sábado o domingo no se agendan en semana actual\n  }\n  if (!pasoLimite) {\n    // aún está antes de las 4:30 p.m., se puede incluir el día siguiente\n    const siguiente = diasSemana[diaSemanaActual];\n    return [siguiente, ...mapa[diaSemanaActual]];\n  }\n  return mapa[diaSemanaActual];\n}\n\n// Objeto para almacenar la malla estructurada\nconst mallaEstructurada = {\n  titulo: \"\",\n  año: \"\",\n  semana: \"\",\n  rangoDias: \"\",\n  franjas: [],\n  dias: {}\n};\n\n// Tabla de meses y días. Ajusta si necesitas contemplar bisiestos, etc.\nconst meses = {\n  \"enero\": 1,\n  \"febrero\": 2,\n  \"marzo\": 3,\n  \"abril\": 4,\n  \"mayo\": 5,\n  \"junio\": 6,\n  \"julio\": 7,\n  \"agosto\": 8,\n  \"septiembre\": 9,\n  \"octubre\": 10,\n  \"noviembre\": 11,\n  \"diciembre\": 12\n};\n\nconst nombreMes = {\n  1: \"enero\",\n  2: \"febrero\",\n  3: \"marzo\",\n  4: \"abril\",\n  5: \"mayo\",\n  6: \"junio\",\n  7: \"julio\",\n  8: \"agosto\",\n  9: \"septiembre\",\n  10: \"octubre\",\n  11: \"noviembre\",\n  12: \"diciembre\"\n};\n\n/**\n * Función para determinar si un año es bisiesto\n * Un año es bisiesto si es divisible por 4, excepto aquellos divisibles por 100 \n * que no son divisibles por 400\n */\nfunction esBisiesto(year) {\n  return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);\n}\n\n/**\n * Función para obtener el número de días en un mes, considerando años bisiestos\n */\nfunction getDiasMes(mes, año) {\n  const diasPorMes = {\n    1: 31, // enero\n    2: esBisiesto(año) ? 29 : 28, // febrero - ajustado para año bisiesto\n    3: 31, // marzo\n    4: 30, // abril\n    5: 31, // mayo\n    6: 30, // junio\n    7: 31, // julio\n    8: 31, // agosto\n    9: 30, // septiembre\n    10: 31, // octubre\n    11: 30, // noviembre\n    12: 31  // diciembre\n  };\n  \n  return diasPorMes[mes];\n}\n\n/**\n * Función para eliminar acentos y pasar a minúsculas (para buscar palabras clave sin importar tildes ni mayúsculas).\n */\nfunction normalizarTexto(texto) {\n  if (typeof texto !== 'string') return \"\";\n  // Normaliza (NFD) y elimina diacríticos, luego pasa a minúsculas.\n  return texto\n    .normalize(\"NFD\")\n    .replace(/[\\u0300-\\u036f]/g, \"\") // quita acentos\n    .toLowerCase();\n}\n\n/**\n * Dada la información de proveedor, ordenCompra, peso, categoría y unidades,\n * revisa si existe la palabra 'fuera de servicio', 'cancelado' o 'reagendado'\n * en cualquiera de esos campos. De ser así, retorna ese estado especial;\n * de lo contrario, retorna 'ocupado'.\n * \n * Se ignoran mayúsculas, minúsculas y tildes.\n */\nfunction determinarEstadoOcupado(proveedor, ordenCompra, peso, categoria, unidades) {\n  const conjunto = `${proveedor} ${ordenCompra} ${peso} ${categoria} ${unidades}`;\n  const texto = normalizarTexto(conjunto);\n\n  if (texto.includes(\"fuera de servicio\")) {\n    return \"fuera de servicio\";\n  }\n  if (texto.includes(\"cancelado\")) {\n    return \"cancelado\";\n  }\n  if (texto.includes(\"reagendado\")) {\n    return \"reagendado\";\n  }\n  return \"ocupado\";  \n}\n\n// -------------------------------------------------------------\n// 1) PROCESAR DATOS (Cabecera, Horas, Muelles, etc.)\n// -------------------------------------------------------------\nfunction procesarDatos(excelData) {\n  const datos = excelData.map(item => item.json);\n  \n  // A) Cabecera (Título, Año, Rango)\n  datos.forEach((dato, index) => {\n    // Buscar título\n    if (dato.__EMPTY_2 === \"MALLA DE RECIBO CEDI KONFIE IA\") {\n      mallaEstructurada.titulo = dato.__EMPTY_2;\n      \n      // En la siguiente fila puede estar año, semana, rango\n      if (index + 1 < datos.length) {\n        const datoSiguiente = datos[index + 1];\n        if (datoSiguiente) {\n          // Año\n          if (datoSiguiente.__EMPTY_2 && !isNaN(datoSiguiente.__EMPTY_2)) {\n            mallaEstructurada.año = datoSiguiente.__EMPTY_2;\n          }\n          // Semana\n          Object.entries(datoSiguiente).forEach(([k, v]) => {\n            if (typeof v === 'string' && v.includes(\"SEMANA\")) {\n              mallaEstructurada.semana = v;\n            }\n          });\n          // Rango: p.ej. \"LUNES 31 AL VIERNES 4 DE ABRIL\"\n          Object.entries(datoSiguiente).forEach(([k, v]) => {\n            if (typeof v === 'string' && v.includes(\"LUNES\") && v.includes(\"VIERNES\")) {\n              mallaEstructurada.rangoDias = v;\n            }\n          });\n        }\n      }\n    }\n  });\n  \n  // B) Detectar franjas horarias (.__EMPTY = fracción de día)\n  const franjasHorarias = [];\n  datos.forEach(dato => {\n    if (\n      dato.__EMPTY !== undefined &&\n      typeof dato.__EMPTY === 'number' &&\n      dato.__EMPTY > 0 &&\n      dato.__EMPTY < 1\n    ) {\n      const totalMin = Math.round(dato.__EMPTY * 24 * 60);\n      const hh = Math.floor(totalMin / 60);\n      const mm = totalMin % 60;\n      \n      let periodo = \"AM\";\n      let hora12 = hh;\n      if (hh >= 12) {\n        periodo = \"PM\";\n        hora12 = (hh === 12 ? 12 : hh - 12);\n      }\n      if (hh === 0) {\n        hora12 = 12;\n      }\n      \n      const horaStr = `${hora12}:${String(mm).padStart(2, '0')} ${periodo}`;\n      franjasHorarias.push({\n        hora: horaStr,\n        indice: datos.indexOf(dato) // fila base\n      });\n    }\n  });\n  franjasHorarias.sort((a, b) => a.indice - b.indice);\n  mallaEstructurada.franjas = franjasHorarias;\n  \n  // C) Detectar muelles (col)\n  const muellesInfo = {};\n  datos.forEach(dato => {\n    Object.entries(dato).forEach(([key, value]) => {\n      if (value === \"MUELLE 01\" || value === \"MUELLE 02\") {\n        const col = parseInt(key.replace(\"__EMPTY_\", \"\"), 10);\n        const muelleKey = (value === \"MUELLE 01\") ? 'muelle1' : 'muelle2';\n        if (!muellesInfo[muelleKey]) {\n          muellesInfo[muelleKey] = [];\n        }\n        muellesInfo[muelleKey].push(col);\n      }\n    });\n  });\n  if (muellesInfo.muelle1) muellesInfo.muelle1.sort((a, b) => a - b);\n  if (muellesInfo.muelle2) muellesInfo.muelle2.sort((a, b) => a - b);\n  \n  // D) Generar los 5 días (lunes-viernes) con su fecha\n  parsearRangoDias();\n  \n  // E) Extraer Citas\n  extraerCitas(datos, muellesInfo);\n  \n  return mallaEstructurada;\n}\n\n/**\n * Parsea la cadena \"LUNES 31 AL VIERNES 4 DE ABRIL\"\n * (o \"LUNES 31 AL VIERNES 04 DE ABRIL\") y maneja el cruce de mes.\n * Ej.: si dayStart=31 y dayEnd=4, la 1ª fecha es 31 de MARZO,\n * luego 1,2,3,4 de ABRIL, en vez de 32,33, etc.\n */\nfunction parsearRangoDias() {\n  const texto = mallaEstructurada.rangoDias;\n  // Regex simple: p.ej. \"31 AL ... 4 DE ABRIL\"\n  // Captura: dayStart, dayEnd, mesFin\n  // Ojo: si dice \"LUNES 31 DE MARZO AL VIERNES 4 DE ABRIL\",\n  // quedará: dayStart=31, dayEnd=4, month=ABRIL (al final).\n  const regex = /(\\d+)\\s+AL\\s+\\D+(\\d+)\\s+DE\\s+(\\w+)/i;\n  const match = regex.exec(texto);\n  \n  // Por defecto, creamos 5 días vacíos sin fecha\n  diasSemana.forEach(d => {\n    mallaEstructurada.dias[d] = {\n      muelle1: {},\n      muelle2: {}\n    };\n  });\n  \n  if (!match) {\n    // Sin coincidencia, dejamos los días sin fecha\n    return;\n  }\n  \n  const dayStart = parseInt(match[1], 10); // 31\n  const dayEnd   = parseInt(match[2], 10); // 4\n  const finalMonthName = match[3].toLowerCase(); // \"abril\"\n  \n  // Convertimos a número\n  const finalMonth = meses[finalMonthName] || 3; // fallback marzo\n  const yearNum = parseInt(mallaEstructurada.año, 10) || 2025;\n  \n  // Función para obtener la fecha formateada\n  function fechaFormateada(d, m, y) {\n    return `${d} de ${nombreMes[m]} de ${y}`;\n  }\n  \n  // Comprobamos cuántos días tiene el mes final, considerando bisiestos\n  const diasMesFinal = getDiasMes(finalMonth, yearNum);\n  // y del mes previo\n  const monthPrev = (finalMonth === 1) ? 12 : finalMonth - 1;\n  const yearPrev = (finalMonth === 1) ? yearNum - 1 : yearNum;\n  \n  // Arreglo final con 5 fechas\n  const fechasDias = [];\n  \n  if (dayStart <= dayEnd) {\n    // Caso \"normal\": todo en el mismo mes\n    let d = dayStart;\n    for (let i = 0; i < 5; i++) {\n      fechasDias.push({\n        diaSem: diasSemana[i],\n        diaNum: d,\n        mesNum: finalMonth,\n        yearNum: yearNum\n      });\n      d++;\n      if (d > diasMesFinal) {\n        d = 1;\n        const nextMonth = finalMonth % 12 + 1;\n        const nextYear = (nextMonth === 1) ? yearNum + 1 : yearNum;\n        fechasDias[fechasDias.length - 1].mesNum = nextMonth;\n        fechasDias[fechasDias.length - 1].yearNum = nextYear;\n      }\n    }\n  } else {\n    // Caso \"cruza de mes\": dayStart > dayEnd\n    let d = dayStart;\n    let m = monthPrev;\n    let y = yearPrev;\n    \n    for (let i = 0; i < 5; i++) {\n      fechasDias.push({\n        diaSem: diasSemana[i],\n        diaNum: d,\n        mesNum: m,\n        yearNum: y\n      });\n      d++;\n      if (d > getDiasMes(m, y)) {\n        d = 1;\n        m = m % 12 + 1;\n        if (m === 1) {\n          y++;\n        }\n      }\n    }\n  }\n  \n  // Ahora volcamos esas 5 fechas en la estructura\n  fechasDias.forEach(fd => {\n    const { diaSem, diaNum, mesNum, yearNum } = fd;\n    mallaEstructurada.dias[diaSem] = {\n      fechaDia: fechaFormateada(diaNum, mesNum, yearNum),\n      muelle1: {},\n      muelle2: {}\n    };\n  });\n  \n  // Inicializamos las franjas a 'disponible'\n  if (mallaEstructurada.franjas.length > 0) {\n    diasSemana.forEach(d => {\n      mallaEstructurada.franjas.forEach(f => {\n        mallaEstructurada.dias[d].muelle1[f.hora] = {\n          estado: \"disponible\",\n          proveedor: \"\",\n          ordenCompra: \"\",\n          peso: \"\",\n          categoria: \"\",\n          unidades: \"\"\n        };\n        mallaEstructurada.dias[d].muelle2[f.hora] = {\n          estado: \"disponible\",\n          proveedor: \"\",\n          ordenCompra: \"\",\n          peso: \"\",\n          categoria: \"\",\n          unidades: \"\"\n        };\n      });\n    });\n  }\n}\n\n/**\n * Función auxiliar: decide a qué día pertenece una columna,\n * corrigiendo 2 columnas de offset (porque 'Extract from XLSX'\n * deja todo desplazado).\n */\nfunction getDayForColumn(colNumber) {\n  // Ajuste de offset +2\n  const realCol = colNumber + 2;\n\n  // Rangos:\n  //  Lunes:      3..8\n  //  Martes:     9..14\n  //  Miércoles: 15..20\n  //  Jueves:    21..26\n  //  Viernes:   27..32\n  if (realCol >= 3 && realCol <= 8) {\n    return \"lunes\";\n  }\n  if (realCol >= 9 && realCol <= 14) {\n    return \"martes\";\n  }\n  if (realCol >= 15 && realCol <= 20) {\n    return \"miércoles\";\n  }\n  if (realCol >= 21 && realCol <= 26) {\n    return \"jueves\";\n  }\n  if (realCol >= 27 && realCol <= 32) {\n    return \"viernes\";\n  }\n  // Si nada coincide, devolvemos null\n  return null;\n}\n\n/**\n * Extraer las citas para cada franja:\n * - Para cada franja, miramos 3 filas:\n *    - Fila base => proveedor\n *    - Fila base+1 => orden\n *    - Fila base+2 => peso, categoría, unidades\n */\nfunction extraerCitas(datos, muellesInfo) {\n  mallaEstructurada.franjas.forEach(franja => {\n    const indiceBase = franja.indice;\n    if (indiceBase < 0 || indiceBase + 2 >= datos.length) {\n      return; // no hay suficientes filas\n    }\n    \n    // Recorremos muelle1, muelle2 y sus columnas\n    const asignarCita = (muelleKey, cols) => {\n      cols.forEach(col => {\n        const provKey = `__EMPTY_${col}`;\n        const filaProv = datos[indiceBase];\n        \n        // Si en esta fila hay un proveedor o algún texto\n        if (\n          filaProv &&\n          typeof filaProv[provKey] === 'string' &&\n          filaProv[provKey].length > 2\n        ) {\n          // Determinar el día real\n          const diaOk = getDayForColumn(col);\n          if (!diaOk || !mallaEstructurada.dias[diaOk]) {\n            return; // si no coincide con ninguno, saltamos\n          }\n          \n          // Recuperar valores para proveedor, ordenCompra y demás\n          const filaOrden = datos[indiceBase + 1];\n          const filaDet = datos[indiceBase + 2];\n          \n          const proveedor = filaProv[provKey] || \"\";\n          const ordenCompra = filaOrden && filaOrden[provKey] ? filaOrden[provKey] : \"\";\n          const peso = filaDet && filaDet[provKey] ? filaDet[provKey] : \"\";\n          const cat  = filaDet && filaDet[`__EMPTY_${col + 1}`] ? filaDet[`__EMPTY_${col + 1}`] : \"\";\n          const und  = filaDet && filaDet[`__EMPTY_${col + 2}`] ? filaDet[`__EMPTY_${col + 2}`] : \"\";\n          \n          // Antes poníamos estado=\"ocupado\" directamente\n          // Ahora verificamos si el texto contiene \"reagendado\", \"cancelado\" o \"fuera de servicio\".\n          const nuevoEstado = determinarEstadoOcupado(proveedor, ordenCompra, peso, cat, und);\n          \n          // Asignamos los datos\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].estado = nuevoEstado;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].proveedor = proveedor;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].ordenCompra = ordenCompra;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].peso = peso;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].categoria = cat;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].unidades = und;\n        }\n      });\n    };\n    \n    if (muellesInfo.muelle1) {\n      asignarCita('muelle1', muellesInfo.muelle1);\n    }\n    if (muellesInfo.muelle2) {\n      asignarCita('muelle2', muellesInfo.muelle2);\n    }\n  });\n}\n\n// -------------------------------------------------------------\n// 2) FUNCIONES PARA CONSULTAR LA MALLA\n// -------------------------------------------------------------\nfunction buscarFranjasDisponibles(categoria, duracionHoras) {\n  const muelle = \"muelle1\"; // Ajusta si usas \"categoria -> muelle\" real\n  \n  const franjasDisponibles = [];\n  Object.keys(mallaEstructurada.dias).forEach(dia => {\n    const libres = [];\n    for (let i = 0; i <= mallaEstructurada.franjas.length - duracionHoras; i++) {\n      let disponible = true;\n      for (let h = 0; h < duracionHoras; h++) {\n        const idxF = i + h;\n        const horaAct = mallaEstructurada.franjas[idxF].hora;\n        if (\n          mallaEstructurada.dias[dia][muelle][horaAct].estado !== 'disponible'\n        ) {\n          disponible = false;\n          break;\n        }\n      }\n      if (disponible) {\n        libres.push({\n          horaInicio: mallaEstructurada.franjas[i].hora,\n          duracion: duracionHoras\n        });\n      }\n    }\n    if (libres.length > 0) {\n      franjasDisponibles.push({ dia, franjas: libres });\n    }\n  });\n  return franjasDisponibles;\n}\n\nfunction buscarCitasProveedor(nombreProveedor) {\n  const citas = [];\n  Object.keys(mallaEstructurada.dias).forEach(dia => {\n    const muelle1 = mallaEstructurada.dias[dia].muelle1;\n    const muelle2 = mallaEstructurada.dias[dia].muelle2;\n    mallaEstructurada.franjas.forEach(f => {\n      const hora = f.hora;\n      // muelle1\n      if (normalizarTexto(muelle1[hora].proveedor) === normalizarTexto(nombreProveedor)) {\n        citas.push({\n          dia,\n          hora,\n          muelle: \"Muelle 01\",\n          ordenCompra: muelle1[hora].ordenCompra,\n          peso: muelle1[hora].peso,\n          categoria: muelle1[hora].categoria,\n          unidades: muelle1[hora].unidades,\n          estado: muelle1[hora].estado\n        });\n      }\n      // muelle2\n      if (normalizarTexto(muelle2[hora].proveedor) === normalizarTexto(nombreProveedor)) {\n        citas.push({\n          dia,\n          hora,\n          muelle: \"Muelle 02\",\n          ordenCompra: muelle2[hora].ordenCompra,\n          peso: muelle2[hora].peso,\n          categoria: muelle2[hora].categoria,\n          unidades: muelle2[hora].unidades,\n          estado: muelle2[hora].estado\n        });\n      }\n    });\n  });\n  return citas;\n}\n\nfunction consultarFranjasDisponibles(categoria, duracionHoras) {\n  return buscarFranjasDisponibles(categoria, duracionHoras);\n}\n\nfunction consultarCitasProveedor(nombreProveedor) {\n  return buscarCitasProveedor(nombreProveedor);\n}\n\nfunction obtenerInfoMalla() {\n  return {\n    titulo: mallaEstructurada.titulo,\n    año: mallaEstructurada.año,\n    semana: mallaEstructurada.semana,\n    rangoDias: mallaEstructurada.rangoDias,\n    franjas: mallaEstructurada.franjas.map(f => f.hora)\n  };\n}\n\nfunction estaDisponible(dia, hora, muelle) {\n  const info = mallaEstructurada.dias[dia]?.[muelle]?.[hora];\n  return info ? (info.estado === 'disponible') : false;\n}\n\nfunction obtenerCoordenadasCita(dia, hora, muelle) {\n  // Ajustar con tu mapeo de celdas en Excel\n  return {\n    proveedor: `${dia}_${hora}_${muelle}_proveedor`,\n    ordenCompra: `${dia}_${hora}_${muelle}_ordenCompra`,\n    peso: `${dia}_${hora}_${muelle}_peso`,\n    categoria: `${dia}_${hora}_${muelle}_categoria`,\n    unidades: `${dia}_${hora}_${muelle}_unidades`\n  };\n}\n\n// -------------------------------------------------------------\n// 3) EJECUTAR TODO Y RETORNAR\n// -------------------------------------------------------------\n// Procesar todos los datos\nconst malla = procesarDatos(excelData);\n\n// Aplicar el filtro de días válidos según la hora actual\nconst diasPermitidos = diasValidosSemanaActual(diaSemanaActual, pasoLimiteDia);\nObject.keys(malla.dias).forEach(dia => {\n  if (!diasPermitidos.includes(dia)) {\n    delete malla.dias[dia]; // eliminar días no válidos\n  }\n});\n\nconst resultado = {\n  datosMalla: malla,\n  funciones: {\n    consultarFranjasDisponibles,\n    consultarCitasProveedor,\n    obtenerInfoMalla,\n    estaDisponible,\n    obtenerCoordenadasCita\n  }\n};\n\nreturn [resultado];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -38896,
        -7088
      ],
      "id": "33344d8e-313f-4b8c-8006-c00120719330",
      "name": "Estructuración, Datos, Consulta, Citas3"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.1,
      "position": [
        -38576,
        -6992
      ],
      "id": "73951b40-e3fc-4071-8d88-90f6ffe72ef5",
      "name": "Merge datos Excel3"
    },
    {
      "parameters": {
        "jsCode": "return [{\n  json: {\n    datosMalla: $items(\"Merge datos Excel3\")[0].json.datosMalla,\n    datosMallaProxSemana: $items(\"Merge datos Excel3\")[1].json.datosMallaProxSemana,\n    hojaSeleccionada: $items(\"Merge datos Excel3\")[0].json.datosMalla.semana\n  }\n}];\n\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -38336,
        -6992
      ],
      "id": "4dbb54b1-c360-485d-bc10-1def793754b8",
      "name": "Unificación y consistencia de datos4"
    },
    {
      "parameters": {
        "operation": "xlsx",
        "binaryPropertyName": "ExcelMallaRecibido2025",
        "options": {
          "sheetName": "={{    (function() {     const semanaActual = $('Unificación y consistencia de datos').item.json.hojaSeleccionada;     const numeroSemana = parseInt(semanaActual.replace(\"SEMANA \", \"\"));     return `SEMANA ${numeroSemana + 1}`;   })() }}"
        }
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -39152,
        -6880
      ],
      "id": "8ac41c21-9e3f-4f48-b046-004f6d124f08",
      "name": "Extract MALLA DE RECIBO Semana Siguiente3",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Si el nodo anterior no devolvió datos (por error al no existir la hoja), retornamos estructura vacía con mensaje\n// Obtener los datos del Excel\nconst excelData = $input.all();\n\n// Mejora en la detección de errores: verificar si hay error explícito o si los datos no son válidos\nconst hayError = excelData.some(item => item.json && item.json.error);\nconst datosInvalidos = !excelData || excelData.length === 0 || hayError;\n\nif (datosInvalidos) {\n  return [{\n    datosMallaProxSemana: {\n      titulo: \"⚠️ La malla de la próxima semana no existe en el archivo Excel o aún no ha sido creada.\",\n      año: \"\",\n      semana: \"\",\n      rangoDias: \"\",\n      franjas: [],\n      dias: {\n        lunes: { muelle1: {}, muelle2: {} },\n        martes: { muelle1: {}, muelle2: {} },\n        miércoles: { muelle1: {}, muelle2: {} },\n        jueves: { muelle1: {}, muelle2: {} },\n        viernes: { muelle1: {}, muelle2: {} }\n      }\n    },\n    funciones: {\n      consultarFranjasDisponibles: \"function not available\",\n      consultarCitasProveedor: \"function not available\",\n      obtenerInfoMalla: \"function not available\",\n      estaDisponible: \"function not available\",\n      obtenerCoordenadasCita: \"function not available\"\n    }\n  }];\n}\n\n// El resto del código permanece igual...\nconst hojaSeleccionada = $('Unificación y consistencia de datos').first().json.hojaSeleccionada;\n\n// Definir estructura de la semana y los días\nconst diasSemana = ['lunes', 'martes', 'miércoles', 'jueves', 'viernes'];\n\n// Objeto para almacenar la malla estructurada\nconst mallaEstructurada = {\n  titulo: \"\",\n  año: \"\",\n  semana: \"\",\n  rangoDias: \"\",\n  franjas: [],\n  dias: {}\n};\n\n// Tabla de meses y días. Ajusta si necesitas contemplar bisiestos, etc.\nconst meses = {\n  \"enero\": 1,\n  \"febrero\": 2,\n  \"marzo\": 3,\n  \"abril\": 4,\n  \"mayo\": 5,\n  \"junio\": 6,\n  \"julio\": 7,\n  \"agosto\": 8,\n  \"septiembre\": 9,\n  \"octubre\": 10,\n  \"noviembre\": 11,\n  \"diciembre\": 12\n};\n\nconst nombreMes = {\n  1: \"enero\",\n  2: \"febrero\",\n  3: \"marzo\",\n  4: \"abril\",\n  5: \"mayo\",\n  6: \"junio\",\n  7: \"julio\",\n  8: \"agosto\",\n  9: \"septiembre\",\n  10: \"octubre\",\n  11: \"noviembre\",\n  12: \"diciembre\"\n};\n\n/**\n * Función para determinar si un año es bisiesto\n * Un año es bisiesto si es divisible por 4, excepto aquellos divisibles por 100 \n * que no son divisibles por 400\n */\nfunction esBisiesto(year) {\n  return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);\n}\n\n/**\n * Función para obtener el número de días en un mes, considerando años bisiestos\n */\nfunction getDiasMes(mes, año) {\n  const diasPorMes = {\n    1: 31, // enero\n    2: esBisiesto(año) ? 29 : 28, // febrero - ajustado para año bisiesto\n    3: 31, // marzo\n    4: 30, // abril\n    5: 31, // mayo\n    6: 30, // junio\n    7: 31, // julio\n    8: 31, // agosto\n    9: 30, // septiembre\n    10: 31, // octubre\n    11: 30, // noviembre\n    12: 31  // diciembre\n  };\n  \n  return diasPorMes[mes];\n}\n\n/**\n * Función para eliminar acentos y pasar a minúsculas (para buscar palabras clave sin importar tildes ni mayúsculas).\n */\nfunction normalizarTexto(texto) {\n  if (typeof texto !== 'string') return \"\";\n  // Normaliza (NFD) y elimina diacríticos, luego pasa a minúsculas.\n  return texto\n    .normalize(\"NFD\")\n    .replace(/[\\u0300-\\u036f]/g, \"\") // quita acentos\n    .toLowerCase();\n}\n\n/**\n * Dada la información de proveedor, ordenCompra, peso, categoría y unidades,\n * revisa si existe la palabra 'fuera de servicio', 'cancelado' o 'reagendado'\n * en cualquiera de esos campos. De ser así, retorna ese estado especial;\n * de lo contrario, retorna 'ocupado'.\n * \n * Se ignoran mayúsculas, minúsculas y tildes.\n */\nfunction determinarEstadoOcupado(proveedor, ordenCompra, peso, categoria, unidades) {\n  const conjunto = `${proveedor} ${ordenCompra} ${peso} ${categoria} ${unidades}`;\n  const texto = normalizarTexto(conjunto);\n\n  if (texto.includes(\"fuera de servicio\")) {\n    return \"fuera de servicio\";\n  }\n  if (texto.includes(\"cancelado\")) {\n    return \"cancelado\";\n  }\n  if (texto.includes(\"reagendado\")) {\n    return \"reagendado\";\n  }\n  return \"ocupado\";  \n}\n\n// -------------------------------------------------------------\n// 1) PROCESAR DATOS (Cabecera, Horas, Muelles, etc.)\n// -------------------------------------------------------------\nfunction procesarDatos(excelData) {\n  // Verificación adicional de datos válidos\n  if (!excelData || !Array.isArray(excelData) || excelData.length === 0) {\n    return {\n      titulo: \"⚠️ La malla de la próxima semana no existe en el archivo Excel o aún no ha sido creada.\",\n      año: \"\",\n      semana: \"\",\n      rangoDias: \"\",\n      franjas: [],\n      dias: {\n        lunes: { muelle1: {}, muelle2: {} },\n        martes: { muelle1: {}, muelle2: {} },\n        miércoles: { muelle1: {}, muelle2: {} },\n        jueves: { muelle1: {}, muelle2: {} },\n        viernes: { muelle1: {}, muelle2: {} }\n      }\n    };\n  }\n  \n  // Intentar mapear datos, con manejo de errores para cada item\n  const datos = excelData.map(item => {\n    try {\n      return item.json || {};\n    } catch (e) {\n      return {};\n    }\n  });\n  \n  // A) Cabecera (Título, Año, Rango)\n  datos.forEach((dato, index) => {\n    // Buscar título\n    if (dato.__EMPTY_2 === \"MALLA DE RECIBO CEDI KONFIE IA\") {\n      mallaEstructurada.titulo = dato.__EMPTY_2;\n      \n      // En la siguiente fila puede estar año, semana, rango\n      if (index + 1 < datos.length) {\n        const datoSiguiente = datos[index + 1];\n        if (datoSiguiente) {\n          // Año\n          if (datoSiguiente.__EMPTY_2 && !isNaN(datoSiguiente.__EMPTY_2)) {\n            mallaEstructurada.año = datoSiguiente.__EMPTY_2;\n          }\n          // Semana\n          Object.entries(datoSiguiente).forEach(([k, v]) => {\n            if (typeof v === 'string' && v.includes(\"SEMANA\")) {\n              mallaEstructurada.semana = v;\n            }\n          });\n          // Rango: p.ej. \"LUNES 31 AL VIERNES 4 DE ABRIL\"\n          Object.entries(datoSiguiente).forEach(([k, v]) => {\n            if (typeof v === 'string' && v.includes(\"LUNES\") && v.includes(\"VIERNES\")) {\n              mallaEstructurada.rangoDias = v;\n            }\n          });\n        }\n      }\n    }\n  });\n  \n  // Si después de procesar no encontramos título, es que no hay malla válida\n  if (!mallaEstructurada.titulo) {\n    mallaEstructurada.titulo = \"⚠️ La malla de la próxima semana no existe en el archivo Excel o aún no ha sido creada.\";\n    return mallaEstructurada;\n  }\n  \n  // B) Detectar franjas horarias (.__EMPTY = fracción de día)\n  const franjasHorarias = [];\n  datos.forEach(dato => {\n    if (\n      dato.__EMPTY !== undefined &&\n      typeof dato.__EMPTY === 'number' &&\n      dato.__EMPTY > 0 &&\n      dato.__EMPTY < 1\n    ) {\n      const totalMin = Math.round(dato.__EMPTY * 24 * 60);\n      const hh = Math.floor(totalMin / 60);\n      const mm = totalMin % 60;\n      \n      let periodo = \"AM\";\n      let hora12 = hh;\n      if (hh >= 12) {\n        periodo = \"PM\";\n        hora12 = (hh === 12 ? 12 : hh - 12);\n      }\n      if (hh === 0) {\n        hora12 = 12;\n      }\n      \n      const horaStr = `${hora12}:${String(mm).padStart(2, '0')} ${periodo}`;\n      franjasHorarias.push({\n        hora: horaStr,\n        indice: datos.indexOf(dato) // fila base\n      });\n    }\n  });\n  franjasHorarias.sort((a, b) => a.indice - b.indice);\n  mallaEstructurada.franjas = franjasHorarias;\n  \n  // C) Detectar muelles (col)\n  const muellesInfo = {};\n  datos.forEach(dato => {\n    Object.entries(dato).forEach(([key, value]) => {\n      if (value === \"MUELLE 01\" || value === \"MUELLE 02\") {\n        const col = parseInt(key.replace(\"__EMPTY_\", \"\"), 10);\n        const muelleKey = (value === \"MUELLE 01\") ? 'muelle1' : 'muelle2';\n        if (!muellesInfo[muelleKey]) {\n          muellesInfo[muelleKey] = [];\n        }\n        muellesInfo[muelleKey].push(col);\n      }\n    });\n  });\n  if (muellesInfo.muelle1) muellesInfo.muelle1.sort((a, b) => a - b);\n  if (muellesInfo.muelle2) muellesInfo.muelle2.sort((a, b) => a - b);\n  \n  // D) Generar los 5 días (lunes-viernes) con su fecha\n  parsearRangoDias();\n  \n  // E) Extraer Citas\n  extraerCitas(datos, muellesInfo);\n  \n  return mallaEstructurada;\n}\n\n/**\n * Parsea la cadena \"LUNES 31 AL VIERNES 4 DE ABRIL\"\n * (o \"LUNES 31 AL VIERNES 04 DE ABRIL\") y maneja el cruce de mes.\n * Ej.: si dayStart=31 y dayEnd=4, la 1ª fecha es 31 de MARZO,\n * luego 1,2,3,4 de ABRIL, en vez de 32,33, etc.\n */\nfunction parsearRangoDias() {\n  const texto = mallaEstructurada.rangoDias;\n  // Regex simple: p.ej. \"31 AL ... 4 DE ABRIL\"\n  // Captura: dayStart, dayEnd, mesFin\n  // Ojo: si dice \"LUNES 31 DE MARZO AL VIERNES 4 DE ABRIL\",\n  // quedará: dayStart=31, dayEnd=4, month=ABRIL (al final).\n  const regex = /(\\d+)\\s+AL\\s+\\D+(\\d+)\\s+DE\\s+(\\w+)/i;\n  const match = regex.exec(texto);\n  \n  // Por defecto, creamos 5 días vacíos sin fecha\n  diasSemana.forEach(d => {\n    mallaEstructurada.dias[d] = {\n      muelle1: {},\n      muelle2: {}\n    };\n  });\n  \n  if (!match) {\n    // Sin coincidencia, dejamos los días sin fecha\n    return;\n  }\n  \n  const dayStart = parseInt(match[1], 10); // 31\n  const dayEnd   = parseInt(match[2], 10); // 4\n  const finalMonthName = match[3].toLowerCase(); // \"abril\"\n  \n  // Convertimos a número\n  const finalMonth = meses[finalMonthName] || 3; // fallback marzo\n  const yearNum = parseInt(mallaEstructurada.año, 10) || 2025;\n  \n  // Función para obtener la fecha formateada\n  function fechaFormateada(d, m, y) {\n    return `${d} de ${nombreMes[m]} de ${y}`;\n  }\n  \n  // Comprobamos cuántos días tiene el mes final, considerando bisiestos\n  const diasMesFinal = getDiasMes(finalMonth, yearNum);\n  // y del mes previo\n  const monthPrev = (finalMonth === 1) ? 12 : finalMonth - 1;\n  const yearPrev = (finalMonth === 1) ? yearNum - 1 : yearNum;\n  \n  // Arreglo final con 5 fechas\n  const fechasDias = [];\n  \n  if (dayStart <= dayEnd) {\n    // Caso \"normal\": todo en el mismo mes\n    let d = dayStart;\n    for (let i = 0; i < 5; i++) {\n      fechasDias.push({\n        diaSem: diasSemana[i],\n        diaNum: d,\n        mesNum: finalMonth,\n        yearNum: yearNum\n      });\n      d++;\n      if (d > diasMesFinal) {\n        d = 1;\n        const nextMonth = finalMonth % 12 + 1;\n        const nextYear = (nextMonth === 1) ? yearNum + 1 : yearNum;\n        fechasDias[fechasDias.length - 1].mesNum = nextMonth;\n        fechasDias[fechasDias.length - 1].yearNum = nextYear;\n      }\n    }\n  } else {\n    // Caso \"cruza de mes\": dayStart > dayEnd\n    let d = dayStart;\n    let m = monthPrev;\n    let y = yearPrev;\n    \n    for (let i = 0; i < 5; i++) {\n      fechasDias.push({\n        diaSem: diasSemana[i],\n        diaNum: d,\n        mesNum: m,\n        yearNum: y\n      });\n      d++;\n      if (d > getDiasMes(m, y)) {\n        d = 1;\n        m = m % 12 + 1;\n        if (m === 1) {\n          y++;\n        }\n      }\n    }\n  }\n  \n  // Ahora volcamos esas 5 fechas en la estructura\n  fechasDias.forEach(fd => {\n    const { diaSem, diaNum, mesNum, yearNum } = fd;\n    mallaEstructurada.dias[diaSem] = {\n      fechaDia: fechaFormateada(diaNum, mesNum, yearNum),\n      muelle1: {},\n      muelle2: {}\n    };\n  });\n  \n  // Inicializamos las franjas a 'disponible'\n  if (mallaEstructurada.franjas.length > 0) {\n    diasSemana.forEach(d => {\n      mallaEstructurada.franjas.forEach(f => {\n        mallaEstructurada.dias[d].muelle1[f.hora] = {\n          estado: \"disponible\",\n          proveedor: \"\",\n          ordenCompra: \"\",\n          peso: \"\",\n          categoria: \"\",\n          unidades: \"\"\n        };\n        mallaEstructurada.dias[d].muelle2[f.hora] = {\n          estado: \"disponible\",\n          proveedor: \"\",\n          ordenCompra: \"\",\n          peso: \"\",\n          categoria: \"\",\n          unidades: \"\"\n        };\n      });\n    });\n  }\n}\n\n/**\n * Función auxiliar: decide a qué día pertenece una columna,\n * corrigiendo 2 columnas de offset (porque 'Extract from XLSX'\n * deja todo desplazado).\n */\nfunction getDayForColumn(colNumber) {\n  // Ajuste de offset +2\n  const realCol = colNumber + 2;\n\n  // Rangos:\n  //  Lunes:      3..8\n  //  Martes:     9..14\n  //  Miércoles: 15..20\n  //  Jueves:    21..26\n  //  Viernes:   27..32\n  if (realCol >= 3 && realCol <= 8) {\n    return \"lunes\";\n  }\n  if (realCol >= 9 && realCol <= 14) {\n    return \"martes\";\n  }\n  if (realCol >= 15 && realCol <= 20) {\n    return \"miércoles\";\n  }\n  if (realCol >= 21 && realCol <= 26) {\n    return \"jueves\";\n  }\n  if (realCol >= 27 && realCol <= 32) {\n    return \"viernes\";\n  }\n  // Si nada coincide, devolvemos null\n  return null;\n}\n\n/**\n * Extraer las citas para cada franja:\n * - Para cada franja, miramos 3 filas:\n *    - Fila base => proveedor\n *    - Fila base+1 => orden\n *    - Fila base+2 => peso, categoría, unidades\n */\nfunction extraerCitas(datos, muellesInfo) {\n  mallaEstructurada.franjas.forEach(franja => {\n    const indiceBase = franja.indice;\n    if (indiceBase < 0 || indiceBase + 2 >= datos.length) {\n      return; // no hay suficientes filas\n    }\n    \n    // Recorremos muelle1, muelle2 y sus columnas\n    const asignarCita = (muelleKey, cols) => {\n      cols.forEach(col => {\n        const provKey = `__EMPTY_${col}`;\n        const filaProv = datos[indiceBase];\n        \n        // Si en esta fila hay un proveedor o algún texto\n        if (\n          filaProv &&\n          typeof filaProv[provKey] === 'string' &&\n          filaProv[provKey].length > 2\n        ) {\n          // Determinar el día real\n          const diaOk = getDayForColumn(col);\n          if (!diaOk || !mallaEstructurada.dias[diaOk]) {\n            return; // si no coincide con ninguno, saltamos\n          }\n          \n          // Recuperar valores para proveedor, ordenCompra y demás\n          const filaOrden = datos[indiceBase + 1];\n          const filaDet = datos[indiceBase + 2];\n          \n          const proveedor = filaProv[provKey] || \"\";\n          const ordenCompra = filaOrden && filaOrden[provKey] ? filaOrden[provKey] : \"\";\n          const peso = filaDet && filaDet[provKey] ? filaDet[provKey] : \"\";\n          const cat  = filaDet && filaDet[`__EMPTY_${col + 1}`] ? filaDet[`__EMPTY_${col + 1}`] : \"\";\n          const und  = filaDet && filaDet[`__EMPTY_${col + 2}`] ? filaDet[`__EMPTY_${col + 2}`] : \"\";\n          \n          // Antes poníamos estado=\"ocupado\" directamente\n          // Ahora verificamos si el texto contiene \"reagendado\", \"cancelado\" o \"fuera de servicio\".\n          const nuevoEstado = determinarEstadoOcupado(proveedor, ordenCompra, peso, cat, und);\n          \n          // Asignamos los datos\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].estado = nuevoEstado;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].proveedor = proveedor;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].ordenCompra = ordenCompra;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].peso = peso;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].categoria = cat;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].unidades = und;\n        }\n      });\n    };\n    \n    if (muellesInfo.muelle1) {\n      asignarCita('muelle1', muellesInfo.muelle1);\n    }\n    if (muellesInfo.muelle2) {\n      asignarCita('muelle2', muellesInfo.muelle2);\n    }\n  });\n}\n\n// -------------------------------------------------------------\n// 2) FUNCIONES PARA CONSULTAR LA MALLA\n// -------------------------------------------------------------\nfunction buscarFranjasDisponibles(categoria, duracionHoras) {\n  const muelle = \"muelle1\"; // Ajusta si usas \"categoria -> muelle\" real\n  \n  const franjasDisponibles = [];\n  Object.keys(mallaEstructurada.dias).forEach(dia => {\n    const libres = [];\n    for (let i = 0; i <= mallaEstructurada.franjas.length - duracionHoras; i++) {\n      let disponible = true;\n      for (let h = 0; h < duracionHoras; h++) {\n        const idxF = i + h;\n        const horaAct = mallaEstructurada.franjas[idxF].hora;\n        if (\n          mallaEstructurada.dias[dia][muelle][horaAct].estado !== 'disponible'\n        ) {\n          disponible = false;\n          break;\n        }\n      }\n      if (disponible) {\n        libres.push({\n          horaInicio: mallaEstructurada.franjas[i].hora,\n          duracion: duracionHoras\n        });\n      }\n    }\n    if (libres.length > 0) {\n      franjasDisponibles.push({ dia, franjas: libres });\n    }\n  });\n  return franjasDisponibles;\n}\n\nfunction buscarCitasProveedor(nombreProveedor) {\n  const citas = [];\n  Object.keys(mallaEstructurada.dias).forEach(dia => {\n    const muelle1 = mallaEstructurada.dias[dia].muelle1;\n    const muelle2 = mallaEstructurada.dias[dia].muelle2;\n    mallaEstructurada.franjas.forEach(f => {\n      const hora = f.hora;\n      // muelle1\n      if (normalizarTexto(muelle1[hora].proveedor) === normalizarTexto(nombreProveedor)) {\n        citas.push({\n          dia,\n          hora,\n          muelle: \"Muelle 01\",\n          ordenCompra: muelle1[hora].ordenCompra,\n          peso: muelle1[hora].peso,\n          categoria: muelle1[hora].categoria,\n          unidades: muelle1[hora].unidades,\n          estado: muelle1[hora].estado\n        });\n      }\n      // muelle2\n      if (normalizarTexto(muelle2[hora].proveedor) === normalizarTexto(nombreProveedor)) {\n        citas.push({\n          dia,\n          hora,\n          muelle: \"Muelle 02\",\n          ordenCompra: muelle2[hora].ordenCompra,\n          peso: muelle2[hora].peso,\n          categoria: muelle2[hora].categoria,\n          unidades: muelle2[hora].unidades,\n          estado: muelle2[hora].estado\n        });\n      }\n    });\n  });\n  return citas;\n}\n\nfunction consultarFranjasDisponibles(categoria, duracionHoras) {\n  return buscarFranjasDisponibles(categoria, duracionHoras);\n}\n\nfunction consultarCitasProveedor(nombreProveedor) {\n  return buscarCitasProveedor(nombreProveedor);\n}\n\nfunction obtenerInfoMalla() {\n  return {\n    titulo: mallaEstructurada.titulo,\n    año: mallaEstructurada.año,\n    semana: mallaEstructurada.semana,\n    rangoDias: mallaEstructurada.rangoDias,\n    franjas: mallaEstructurada.franjas.map(f => f.hora)\n  };\n}\n\nfunction estaDisponible(dia, hora, muelle) {\n  const info = mallaEstructurada.dias[dia]?.[muelle]?.[hora];\n  return info ? (info.estado === 'disponible') : false;\n}\n\nfunction obtenerCoordenadasCita(dia, hora, muelle) {\n  // Ajustar con tu mapeo de celdas en Excel\n  return {\n    proveedor: `${dia}_${hora}_${muelle}_proveedor`,\n    ordenCompra: `${dia}_${hora}_${muelle}_ordenCompra`,\n    peso: `${dia}_${hora}_${muelle}_peso`,\n    categoria: `${dia}_${hora}_${muelle}_categoria`,\n    unidades: `${dia}_${hora}_${muelle}_unidades`\n  };\n}\n\n// -------------------------------------------------------------\n// 3) EJECUTAR TODO Y RETORNAR\n// -------------------------------------------------------------\nconst malla = procesarDatos(excelData);\n\nconst resultado = {\n  datosMallaProxSemana: malla,\n  funciones: {\n    consultarFranjasDisponibles,\n    consultarCitasProveedor,\n    obtenerInfoMalla,\n    estaDisponible,\n    obtenerCoordenadasCita\n  }\n};\n\nreturn [resultado];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -38896,
        -6880
      ],
      "id": "dd689eb5-b337-4e33-b4a1-2b6af7377689",
      "name": "Estructuración, Datos, Consulta, Citas Proxima Semana3"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Validación de reprogramación de citas - SOLUCIÓN CORREGIDA\n * \n * Correcciones aplicadas:\n * 1. Referencias dinámicas en lugar de hardcodeadas (SEMANA 20/21)\n * 2. Permite reprogramación cuando es la misma cita\n * 3. Normalización flexible de fechas (06 ↔ 6)\n * 4. Normalización flexible de horas (09:00 AM ↔ 9:00 AM)\n */\n\n// Función principal\ntry {\n    // 1. Obtener datos necesarios\n    const datosReprogramacion = $node[\"Code Validación de datos para reprogramación de citas\"].json;\n    const citaOriginal = $node[\"Microsoft SQL Obtener Cita\"].json;\n    const mallas = $node[\"Unificación y consistencia de datos4\"].json;\n    \n    // Extraer los datos importantes\n    const idCita = datosReprogramacion.idCita;\n    const ordenCompra = datosReprogramacion.ordenCompra;\n    const nuevaFecha = datosReprogramacion.nuevaFecha; // \"06 de junio de 2025\"\n    const nuevaHoraConFormato = datosReprogramacion.nuevaHora; // \"10:00 AM\"\n    \n    // Normalizar el formato de hora para que coincida con las mallas\n    const nuevaHora = normalizarHora(nuevaHoraConFormato);\n    \n    console.log(`Hora original: \"${nuevaHoraConFormato}\", hora normalizada: \"${nuevaHora}\"`);\n    \n    // Extraer datos de la cita original\n    const idCitaDB = citaOriginal.id;\n    const ordenCompraDB = citaOriginal.orden_compra;\n    const horasEntrega = parseInt(citaOriginal.horas_entrega);\n    const muelleOriginal = citaOriginal.muelle;\n    const horaInicioOriginal = citaOriginal.hora_inicio;\n    const horaFinOriginal = citaOriginal.hora_fin;\n    const proveedorOriginal = citaOriginal.nombre; // Para verificar si es la misma cita\n    \n    // Normalizar número de muelle\n    let numeroMuelle = 1;\n    if (muelleOriginal && muelleOriginal.toLowerCase().includes(\"muelle\")) {\n        const match = muelleOriginal.match(/\\d+/);\n        if (match) numeroMuelle = parseInt(match[0]);\n    }\n    \n    // 2. Validar coincidencia de ID y orden de compra\n    if (idCita != idCitaDB || ordenCompra !== ordenCompraDB) {\n        return [{\n            json: {\n                franjaDisponible: false,\n                mensaje: `La información de la cita no coincide. ID Cita proporcionado: ${idCita}, ID en sistema: ${idCitaDB}. Orden de compra proporcionada: ${ordenCompra}, Orden en sistema: ${ordenCompraDB}.`\n            }\n        }];\n    }\n    \n    // 3. Buscar la fecha en AMBAS mallas usando normalización flexible\n    let fechaEncontrada = false;\n    let nombreHoja = null;\n    let diaSemana = null;\n    let datosDia = null;\n    \n    // Buscar primero en la malla principal\n    for (const dia in mallas.datosMalla.dias) {\n        if (compararFechasFlexible(mallas.datosMalla.dias[dia].fechaDia, nuevaFecha)) {\n            console.log(`Fecha encontrada en ${mallas.datosMalla.semana} (${dia})`);\n            fechaEncontrada = true;\n            diaSemana = dia;\n            datosDia = mallas.datosMalla.dias[dia];\n            nombreHoja = mallas.datosMalla.semana;\n            break;\n        }\n    }\n    \n    // Si no se encuentra en la malla principal, buscar en la próxima semana\n    if (!fechaEncontrada) {\n        for (const dia in mallas.datosMallaProxSemana.dias) {\n            if (compararFechasFlexible(mallas.datosMallaProxSemana.dias[dia].fechaDia, nuevaFecha)) {\n                console.log(`Fecha encontrada en ${mallas.datosMallaProxSemana.semana} (${dia})`);\n                fechaEncontrada = true;\n                diaSemana = dia;\n                datosDia = mallas.datosMallaProxSemana.dias[dia];\n                nombreHoja = mallas.datosMallaProxSemana.semana;\n                break;\n            }\n        }\n    }\n    \n    // Si la fecha no se encuentra en ninguna malla\n    if (!fechaEncontrada) {\n        return [{\n            json: {\n                franjaDisponible: false,\n                mensaje: `La fecha ${nuevaFecha} no se encuentra en la programación disponible.`\n            }\n        }];\n    }\n    \n    // 4. Verificar disponibilidad en la malla correcta\n    // Verificar que exista el muelle para ese día\n    const muelleKey = `muelle${numeroMuelle}`;\n    if (!datosDia[muelleKey]) {\n        return [{\n            json: {\n                franjaDisponible: false,\n                mensaje: `No existe el muelle ${numeroMuelle} para el día ${diaSemana}.`\n            }\n        }];\n    }\n    \n    // Verificar que la hora exista en el muelle\n    const muelle = datosDia[muelleKey];\n    \n    console.log(`Verificando hora: ${nuevaHora} en muelle ${numeroMuelle}`);\n    console.log(`Estado: ${muelle[nuevaHora]?.estado || 'no definido'}`);\n    \n    if (!muelle[nuevaHora]) {\n        return [{\n            json: {\n                franjaDisponible: false,\n                mensaje: `La hora ${nuevaHoraConFormato} no está definida para el día ${diaSemana}.`\n            }\n        }];\n    }\n    \n    // Verificar disponibilidad para horas consecutivas\n    let disponible = true;\n    let franjasNoDisponibles = [];\n    let esMismaCita = false; // Nueva bandera para verificar si es reprogramación de la misma cita\n    \n    // Encontrar la hora en las franjas\n    const franjas = nombreHoja === mallas.datosMalla.semana \n        ? mallas.datosMalla.franjas \n        : mallas.datosMallaProxSemana.franjas;\n    \n    let indiceInicio = -1;\n    \n    // Buscar usando normalización flexible de horas\n    for (let i = 0; i < franjas.length; i++) {\n        if (compararHorasFlexible(franjas[i].hora, nuevaHora)) {\n            indiceInicio = i;\n            console.log(`¡Coincidencia encontrada en índice ${i}!`);\n            break;\n        }\n    }\n    \n    if (indiceInicio === -1) {\n        console.log(\"No se encontró la hora en las franjas\");\n        return [{\n            json: {\n                franjaDisponible: false,\n                mensaje: `La hora ${nuevaHoraConFormato} no se encuentra en las franjas horarias disponibles.`\n            }\n        }];\n    }\n    \n    // Verificar disponibilidad para cada hora necesaria\n    for (let i = 0; i < horasEntrega; i++) {\n        if (indiceInicio + i >= franjas.length) {\n            disponible = false;\n            console.log(\"No hay suficientes horas disponibles en el día\");\n            break;\n        }\n        \n        const franja = franjas[indiceInicio + i];\n        const estadoFranja = muelle[franja.hora];\n        \n        console.log(`Verificando franja ${franja.hora}: ${estadoFranja?.estado || 'no definido'}`);\n        \n        if (!estadoFranja) {\n            disponible = false;\n            franjasNoDisponibles.push(franja.hora);\n        } else if (estadoFranja.estado === \"disponible\") {\n            // Franja disponible, todo bien\n            continue;\n        } else if (estadoFranja.estado === \"ocupado\") {\n            // Verificar si está ocupada por la misma cita\n            if (estadoFranja.ordenCompra === ordenCompra && \n                estadoFranja.proveedor === proveedorOriginal) {\n                console.log(`Franja ${franja.hora} ocupada por la misma cita - permitir reprogramación`);\n                esMismaCita = true;\n                continue;\n            } else {\n                // Ocupada por otra cita\n                disponible = false;\n                franjasNoDisponibles.push(franja.hora);\n            }\n        } else {\n            // Fuera de servicio u otro estado\n            disponible = false;\n            franjasNoDisponibles.push(franja.hora);\n        }\n    }\n    \n    // CÁLCULO PRECISO DEL nombreHoja PARA LA CITA ORIGINAL\n    let nombreHojaOriginal = calcularNombreHojaOriginal(citaOriginal.fecha_cita, mallas);\n    \n    // Si hay disponibilidad o es reprogramación de la misma cita, retornar respuesta positiva\n    if (disponible || esMismaCita) {\n        const horaFin = calcularHoraFin(nuevaHoraConFormato, horasEntrega);\n        const fechaFormateada = convertirFechaAFormatoISO(nuevaFecha);\n        \n        // Normalizar horaInicio para la respuesta (quitar cero inicial si existe)\n        const horaInicioNormalizada = nuevaHoraConFormato.replace(/^0(\\d:00 [AP]M)$/, \"$1\");\n        \n        const tipoOperacion = esMismaCita ? \"reprogramación\" : \"nueva programación\";\n        \n        const respuesta = {\n            franjaDisponible: true,\n            mensaje: `¡Genial! Hay espacio para la ${tipoOperacion} el ${nuevaFecha}, de ${horaInicioNormalizada} a ${horaFin} en MUELLE ${numeroMuelle}.`,\n            datosValidados: {\n                fecha: nuevaFecha,\n                fechaFormateada: fechaFormateada,\n                horaInicio: horaInicioNormalizada,\n                horaFin: horaFin,\n                muelle: `MUELLE ${numeroMuelle}`,\n                duracionHoras: horasEntrega,\n                disponibilidadConfirmada: true,\n                tipoOperacion: tipoOperacion\n            },\n            nombreHoja: nombreHoja,\n            citaAntigua: {\n                id: idCitaDB,\n                fechaFormateada: citaOriginal.fecha_cita ? citaOriginal.fecha_cita.split('T')[0] : \"\",\n                horaInicio: horaInicioOriginal,\n                horaFin: horaFinOriginal,\n                muelle: muelleOriginal,\n                nombreHoja: nombreHojaOriginal || nombreHoja // Usar valor calculado o default\n            }\n        };\n        \n        return [{ json: respuesta }];\n    } else {\n        // Si no hay disponibilidad, buscar alternativas\n        const franjasSemana = nombreHoja === mallas.datosMalla.semana \n            ? mallas.datosMalla.franjas \n            : mallas.datosMallaProxSemana.franjas;\n            \n        const alternativas = buscarAlternativasParaDia(\n            datosDia,\n            franjasSemana,\n            horasEntrega,\n            numeroMuelle\n        );\n        \n        let mensajeAlternativas = `Lo siento, la franja horaria seleccionada ya no está disponible. `;\n        \n        if (alternativas.length > 0) {\n            mensajeAlternativas += `Aquí hay algunas alternativas disponibles en el muelle ${numeroMuelle}:\\n\\n`;\n            \n            alternativas.forEach((alt, index) => {\n                mensajeAlternativas += `Opción ${index + 1}: ${alt.fecha} - Muelle ${alt.muelle} - De ${alt.horaInicio} a ${alt.horaFin}\\n`;\n            });\n            \n            mensajeAlternativas += \"\\nSi desea elegir una de estas alternativas, por favor envíe un nuevo mensaje con todos los datos de reprogramación. Este chat se reiniciará para evitar confusiones con mensajes anteriores.\";\n        } else {\n            mensajeAlternativas += `No se encontraron horarios alternativos disponibles para el muelle ${numeroMuelle} en las próximas fechas. Por favor, intente con otra fecha u horario. Este chat se reiniciará para evitar confusiones con mensajes anteriores.`;\n        }\n        \n        return [{\n            json: {\n                franjaDisponible: false,\n                mensaje: mensajeAlternativas,\n                alternativas: alternativas\n            }\n        }];\n    }\n} catch (error) {\n    console.error(\"Error en la validación:\", error);\n    return [{\n        json: {\n            franjaDisponible: false,\n            mensaje: \"Error en el proceso de validación: \" + error.message\n        }\n    }];\n}\n\n// FUNCIONES AUXILIARES MEJORADAS\n\n// Función para normalizar horas (maneja ambas direcciones)\nfunction normalizarHora(hora) {\n    if (!hora) return hora;\n    \n    // Convertir a string si no lo es\n    const horaStr = hora.toString().trim();\n    \n    // Patrón para capturar horas con posible cero inicial\n    const patron = /^(0?)(\\d{1,2}):(\\d{2})\\s*([AP]M)$/i;\n    const match = horaStr.match(patron);\n    \n    if (match) {\n        const [, ceroInicial, hora, minutos, periodo] = match;\n        // Quitar cero inicial si existe y la hora es de un dígito\n        const horaSinCero = parseInt(hora, 10);\n        return `${horaSinCero}:${minutos} ${periodo.toUpperCase()}`;\n    }\n    \n    return horaStr;\n}\n\n// Función para comparar horas de manera flexible\nfunction compararHorasFlexible(hora1, hora2) {\n    const horaNormalizada1 = normalizarHora(hora1);\n    const horaNormalizada2 = normalizarHora(hora2);\n    \n    console.log(`Comparando horas: \"${horaNormalizada1}\" con \"${horaNormalizada2}\"`);\n    \n    return horaNormalizada1 === horaNormalizada2;\n}\n\n// Función para normalizar fechas (maneja ambas direcciones)\nfunction normalizarFecha(fecha) {\n    if (!fecha) return fecha;\n    \n    const fechaStr = fecha.toString().trim();\n    \n    // Patrón para capturar fecha con posible cero inicial en el día\n    const patron = /^(0?)(\\d{1,2})\\s+de\\s+(\\w+)(?:\\s+de\\s+(\\d{4}))?$/i;\n    const match = fechaStr.match(patron);\n    \n    if (match) {\n        const [, ceroInicial, dia, mes, año] = match;\n        // Quitar cero inicial si existe\n        const diaSinCero = parseInt(dia, 10);\n        \n        if (año) {\n            return `${diaSinCero} de ${mes.toLowerCase()} de ${año}`;\n        } else {\n            return `${diaSinCero} de ${mes.toLowerCase()}`;\n        }\n    }\n    \n    return fechaStr;\n}\n\n// Función para comparar fechas de manera flexible\nfunction compararFechasFlexible(fecha1, fecha2) {\n    const fechaNormalizada1 = normalizarFecha(fecha1);\n    const fechaNormalizada2 = normalizarFecha(fecha2);\n    \n    console.log(`Comparando fechas: \"${fechaNormalizada1}\" con \"${fechaNormalizada2}\"`);\n    \n    // Comparación exacta\n    if (fechaNormalizada1 === fechaNormalizada2) {\n        return true;\n    }\n    \n    // Comparación sin año (para casos donde una tiene año y otra no)\n    const fecha1SinAño = fechaNormalizada1.replace(/\\s+de\\s+\\d{4}$/, '');\n    const fecha2SinAño = fechaNormalizada2.replace(/\\s+de\\s+\\d{4}$/, '');\n    \n    return fecha1SinAño === fecha2SinAño;\n}\n\n// Función para calcular el nombreHoja de la cita original\nfunction calcularNombreHojaOriginal(fechaCitaOriginal, mallas) {\n    if (!fechaCitaOriginal) return null;\n    \n    const formatosFechaOriginal = convertirFechaISOaLegible(fechaCitaOriginal);\n    console.log(\"Formatos de fecha original:\", formatosFechaOriginal);\n    \n    // Buscar en malla principal\n    for (const dia in mallas.datosMalla.dias) {\n        const fechaDiaMalla = mallas.datosMalla.dias[dia].fechaDia;\n        \n        if (compararFechasFlexible(fechaDiaMalla, formatosFechaOriginal.conAño) || \n            compararFechasFlexible(fechaDiaMalla, formatosFechaOriginal.sinAño)) {\n            console.log(`¡Cita original encontrada en ${mallas.datosMalla.semana}!`);\n            return mallas.datosMalla.semana;\n        }\n    }\n    \n    // Buscar en próxima semana\n    for (const dia in mallas.datosMallaProxSemana.dias) {\n        const fechaDiaMalla = mallas.datosMallaProxSemana.dias[dia].fechaDia;\n        \n        if (compararFechasFlexible(fechaDiaMalla, formatosFechaOriginal.conAño) || \n            compararFechasFlexible(fechaDiaMalla, formatosFechaOriginal.sinAño)) {\n            console.log(`¡Cita original encontrada en ${mallas.datosMallaProxSemana.semana}!`);\n            return mallas.datosMallaProxSemana.semana;\n        }\n    }\n    \n    // Método adicional: por día de la semana y rango de fechas\n    const fechaISO = new Date(fechaCitaOriginal);\n    const diaNumerico = fechaISO.getDate();\n    const mes = fechaISO.getMonth();\n    \n    // Función para extraer rango de días de un string como \"LUNES 02 AL VIERNES 06 DE JUNIO\"\n    function extraerRangoDias(rango) {\n        const partes = rango.split(\" \");\n        let diaInicio = null;\n        let diaFin = null;\n        let mesTexto = null;\n        \n        for (let i = 0; i < partes.length; i++) {\n            if (/^\\d+$/.test(partes[i])) {\n                if (diaInicio === null) {\n                    diaInicio = parseInt(partes[i]);\n                } else {\n                    diaFin = parseInt(partes[i]);\n                }\n            }\n            if (i > 0 && partes[i-1] === \"DE\") {\n                mesTexto = partes[i].toLowerCase();\n            }\n        }\n        \n        const meses = {\n            'enero': 0, 'febrero': 1, 'marzo': 2, 'abril': 3, 'mayo': 4, 'junio': 5,\n            'julio': 6, 'agosto': 7, 'septiembre': 8, 'octubre': 9, 'noviembre': 10, 'diciembre': 11\n        };\n        \n        return { diaInicio, diaFin, mes: meses[mesTexto] };\n    }\n    \n    // Verificar rangos\n    const rangoMallaPrincipal = extraerRangoDias(mallas.datosMalla.rangoDias);\n    console.log(\"Rango malla principal:\", rangoMallaPrincipal);\n    \n    if (mes === rangoMallaPrincipal.mes && \n        diaNumerico >= rangoMallaPrincipal.diaInicio && \n        diaNumerico <= rangoMallaPrincipal.diaFin) {\n        console.log(`Cita original en rango de ${mallas.datosMalla.semana}`);\n        return mallas.datosMalla.semana;\n    }\n    \n    const rangoProxSemana = extraerRangoDias(mallas.datosMallaProxSemana.rangoDias);\n    console.log(\"Rango próxima semana:\", rangoProxSemana);\n    \n    if (mes === rangoProxSemana.mes && \n        diaNumerico >= rangoProxSemana.diaInicio && \n        diaNumerico <= rangoProxSemana.diaFin) {\n        console.log(`Cita original en rango de ${mallas.datosMallaProxSemana.semana}`);\n        return mallas.datosMallaProxSemana.semana;\n    }\n    \n    console.log(`No se pudo determinar la hoja original, usando default: ${mallas.datosMalla.semana}`);\n    return mallas.datosMalla.semana;\n}\n\n// Función para convertir una fecha ISO a un formato legible\nfunction convertirFechaISOaLegible(fechaISO) {\n    const fechaObj = new Date(fechaISO);\n    const dia = fechaObj.getDate();\n    const meses = ['enero', 'febrero', 'marzo', 'abril', 'mayo', 'junio', 'julio', 'agosto', 'septiembre', 'octubre', 'noviembre', 'diciembre'];\n    const mes = meses[fechaObj.getMonth()];\n    const año = fechaObj.getFullYear();\n    \n    return {\n        conAño: `${dia} de ${mes} de ${año}`,\n        sinAño: `${dia} de ${mes}`\n    };\n}\n\n// Función para calcular la hora final\nfunction calcularHoraFin(horaInicio, horasNecesarias) {\n    try {\n        const partes = horaInicio.trim().split(/\\s+/);\n        const horaMinutos = partes[0].split(':');\n        const periodo = partes[1]; // AM o PM\n        \n        let hora = parseInt(horaMinutos[0], 10);\n        let minutos = parseInt(horaMinutos[1] || \"0\", 10);\n        \n        // Convertir a formato 24 horas para el cálculo\n        if (periodo.toUpperCase() === \"PM\" && hora < 12) {\n            hora += 12;\n        } else if (periodo.toUpperCase() === \"AM\" && hora === 12) {\n            hora = 0;\n        }\n        \n        // Sumar las horas necesarias\n        hora = (hora + horasNecesarias) % 24;\n        \n        // Convertir de nuevo a formato 12 horas\n        let nuevoPeriodo = \"AM\";\n        if (hora >= 12) {\n            nuevoPeriodo = \"PM\";\n            if (hora > 12) {\n                hora -= 12;\n            }\n        }\n        if (hora === 0) {\n            hora = 12;\n        }\n        \n        return `${hora}:${minutos.toString().padStart(2, '0')} ${nuevoPeriodo}`;\n    } catch (error) {\n        console.error(\"Error al calcular hora fin:\", error);\n        return \"Hora desconocida\";\n    }\n}\n\n// Función para convertir fecha a formato ISO\nfunction convertirFechaAFormatoISO(fechaTexto) {\n    try {\n        const partes = fechaTexto.split(\" de \");\n        const dia = parseInt(partes[0], 10);\n        const mes = partes[1].toLowerCase();\n        \n        const meses = {\n            'enero': 0, 'febrero': 1, 'marzo': 2, 'abril': 3, 'mayo': 4, 'junio': 5,\n            'julio': 6, 'agosto': 7, 'septiembre': 8, 'octubre': 9, 'noviembre': 10, 'diciembre': 11\n        };\n        \n        const mesNum = meses[mes];\n        if (mesNum === undefined) {\n            throw new Error(`Mes no válido: ${mes}`);\n        }\n        \n        let anio = new Date().getFullYear();\n        if (partes.length > 2) {\n            anio = parseInt(partes[2], 10);\n        }\n        \n        return `${anio}-${(mesNum + 1).toString().padStart(2, '0')}-${dia.toString().padStart(2, '0')}`;\n    } catch (error) {\n        console.error(\"Error al convertir fecha a formato ISO:\", error);\n        return \"\";\n    }\n}\n\n// Función para buscar alternativas en un día\nfunction buscarAlternativasParaDia(datoDia, franjas, horasNecesarias, numeroMuelle) {\n    const alternativas = [];\n    const muelleKey = `muelle${numeroMuelle}`;\n    const muelle = datoDia[muelleKey];\n    \n    if (!muelle) return alternativas;\n    \n    // Para cada posible hora de inicio\n    for (let i = 0; i <= franjas.length - horasNecesarias; i++) {\n        let disponible = true;\n        \n        // Verificar franjas consecutivas\n        for (let j = 0; j < horasNecesarias; j++) {\n            const franja = franjas[i + j];\n            if (!muelle[franja.hora] || muelle[franja.hora].estado !== \"disponible\") {\n                disponible = false;\n                break;\n            }\n        }\n        \n        if (disponible) {\n            const horaInicio = franjas[i].hora;\n            const horaFin = calcularHoraFin(horaInicio, horasNecesarias);\n            \n            alternativas.push({\n                fecha: datoDia.fechaDia,\n                muelle: numeroMuelle,\n                horaInicio: horaInicio,\n                horaFin: horaFin,\n                franjasHorarias: franjas.slice(i, i + horasNecesarias).map(f => f.hora)\n            });\n        }\n    }\n    \n    return alternativas;\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -38096,
        -6992
      ],
      "id": "67e1c047-32c6-4aeb-8be1-2cd6b7b57cd2",
      "name": "Code Validacion de Cita en cronograma para reprogramación"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "de7a1d59-037e-48c1-8ef4-b5667443ca11",
              "leftValue": "={{ $json.franjaDisponible }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -37888,
        -6992
      ],
      "id": "9351e8fb-74d9-46d2-8bb7-8f3e13afecc8",
      "name": "If validacion de reprogramacion"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "4bfbecb3-9d4f-4425-aa76-a92abc7708fb",
              "leftValue": "={{ $('Code Validacion de Cita en cronograma para reprogramación').first().json.mensaje.length }}",
              "rightValue": 70,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -37440,
        -6912
      ],
      "id": "b83c7460-4a1b-4b54-b1a4-699a882168d5",
      "name": "Validación de longitud de caracteres9"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d9c2ff70-4fd1-4b93-8571-6d0ac5a0093e",
              "name": "mensaje.ia",
              "value": "={{ $('Code Validacion de Cita en cronograma para reprogramación').first().json.mensaje }}",
              "type": "string"
            },
            {
              "id": "ac8a03be-0292-4735-9580-39a385945c47",
              "name": "mensaje.longitud",
              "value": "={{ $('Code Validacion de Cita en cronograma para reprogramación').first().json.mensaje.length }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -37168,
        -6848
      ],
      "id": "41a3076e-1e37-4632-b9b6-3c1accb0e651",
      "name": "Organiza variables del mensaje9"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -36976,
        -7040
      ],
      "id": "76e43901-1c4e-47c0-8011-317cd10465e5",
      "name": "No Operation, do nothing13"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $('Code Respuesta Faltantes').item.json.text }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -37168,
        -7040
      ],
      "id": "30c23f72-95bc-4ae5-a464-40adce4e6c87",
      "name": "HTTP Request Enviar Mensaje por WhatsApp12"
    },
    {
      "parameters": {
        "jsCode": "// Código optimizado para el nodo \"Code (Preparar Cuerpo de Petición)1\"\nconst datosValidados = $input.first().json.datosValidados;\nconst datosCita = $('Microsoft SQL Obtener Cita').first().json;\n// Obtener ambas mallas\nconst mallaActual = $('Unificación y consistencia de datos4').first().json.datosMalla;\nconst mallaProxima = $('Unificación y consistencia de datos4').first().json.datosMallaProxSemana;\n\n// Usar fecha de cita original para determinar malla\nconst fechaCitaOriginal = new Date(datosCita.fecha_cita);\n\nfunction fechaEnMalla(fecha, malla) {\n  if (!malla.dias) return false;\n  \n  const fechaBuscada = fecha.toLocaleDateString('es-ES', { \n    day: 'numeric', \n    month: 'long', \n    year: 'numeric' \n  });\n  \n  for (const dia of Object.keys(malla.dias)) {\n    const diaData = malla.dias[dia];\n    if (diaData.fechaDia && diaData.fechaDia === fechaBuscada) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// Seleccionar malla correcta\nlet datosMalla;\nif (fechaEnMalla(fechaCitaOriginal, mallaActual)) {\n  datosMalla = mallaActual;\n  console.log(\"Usando malla actual para edición\");\n} else if (fechaEnMalla(fechaCitaOriginal, mallaProxima)) {\n  datosMalla = mallaProxima;\n  console.log(\"Usando malla próxima para edición\");\n} else {\n  return {\n    json: {\n      error: true,\n      mensaje: \"No se encontró la cita original en ninguna malla\"\n    }\n  };\n}\n\nconst citaAntigua = $input.first().json.citaAntigua || null;\nconst nombreHojaActual = $input.first().json.nombreHoja || datosMalla.semana || \"\";\n\n// Extraer la información relevante para la nueva cita\nconst {\n  fecha,\n  fechaFormateada,\n  horaInicio,\n  horaFin,\n  muelle,\n  duracionHoras\n} = datosValidados;\n\n// Mapear correctamente los campos del nodo \"Microsoft SQL Obtener Cita\"\nconst {\n  nombre: proveedor = \"\",\n  orden_compra: ordenCompra = \"\",\n  peso = \"\",\n  categoria = \"\",\n  unidades = \"\"\n} = datosCita;\n\n// **NUEVA FUNCIONALIDAD: Optimización de franjas cruzadas**\nfunction calcularFranjasOptimizadas() {\n  if (!citaAntigua) {\n    // Si no hay cita antigua, proceder normalmente\n    return {\n      franjasAEliminar: [],\n      franjasAInsertar: generarFranjasNuevas(),\n      optimizacionAplicada: false,\n      tipoOperacion: \"nueva_cita\"\n    };\n  }\n\n  // Verificar si es el mismo día\n  const fechaNueva = new Date(fechaFormateada);\n  const fechaAntigua = new Date(citaAntigua.fechaFormateada);\n  \n  const esMismoDia = fechaNueva.toDateString() === fechaAntigua.toDateString();\n  \n  if (!esMismoDia) {\n    // Días diferentes: eliminar todas las antiguas, insertar todas las nuevas\n    return {\n      franjasAEliminar: generarFranjasAntiguas(),\n      franjasAInsertar: generarFranjasNuevas(),\n      optimizacionAplicada: false,\n      tipoOperacion: \"cambio_dia\"\n    };\n  }\n\n  // **MISMO DÍA: Aplicar optimización**\n  const franjasAntiguas = generarFranjasAntiguas();\n  const franjasNuevas = generarFranjasNuevas();\n  \n  // Calcular intersección (franjas que se cruzan)\n  const franjasAntiguasSet = new Set(franjasAntiguas.map(f => f.hora));\n  const franjasNuevasSet = new Set(franjasNuevas.map(f => f.hora));\n  \n  const franjasComunes = franjasAntiguas.filter(f => franjasNuevasSet.has(f.hora));\n  const franjasComnesSet = new Set(franjasComunes.map(f => f.hora));\n  \n  // Calcular operaciones optimizadas\n  const franjasAEliminar = franjasAntiguas.filter(f => !franjasComnesSet.has(f.hora));\n  const franjasAInsertar = franjasNuevas.filter(f => !franjasComnesSet.has(f.hora));\n  \n  console.log(`Optimización aplicada:\n    - Franjas antiguas: ${franjasAntiguas.length}\n    - Franjas nuevas: ${franjasNuevas.length}\n    - Franjas comunes (mantenidas): ${franjasComunes.length}\n    - Franjas a eliminar: ${franjasAEliminar.length}\n    - Franjas a insertar: ${franjasAInsertar.length}\n    - Operaciones evitadas: ${franjasComunes.length * 2}`);\n\n  return {\n    franjasAEliminar,\n    franjasAInsertar,\n    franjasComunes,\n    optimizacionAplicada: true,\n    tipoOperacion: \"mismo_dia_optimizado\",\n    estadisticas: {\n      operacionesEvitadas: franjasComunes.length * 2,\n      eficiencia: ((franjasComunes.length * 2) / (franjasAntiguas.length + franjasNuevas.length) * 100).toFixed(2) + '%'\n    }\n  };\n}\n\nfunction generarFranjasNuevas() {\n  const franjas = [];\n  let horaActual = horaInicio;\n  let horasRestantes = duracionHoras;\n  \n  while (horasRestantes > 0) {\n    const franjaActual = datosMalla.franjas.find(f => horasIguales(f.hora, horaActual));\n    \n    if (!franjaActual) {\n      console.log(`No se encontró información para la franja: ${horaActual}`);\n      break;\n    }\n    \n    const filaBase = calcularFilaExcel(horaActual, datosMalla.franjas);\n    if (!filaBase) {\n      console.log(`No se pudo determinar la fila para la franja: ${horaActual}`);\n      break;\n    }\n\n    franjas.push({\n      hora: horaActual,\n      fila: filaBase,\n      datos: {\n        proveedor,\n        ordenCompra,\n        peso,\n        categoria,\n        unidades\n      }\n    });\n    \n    horasRestantes--;\n    if (horasRestantes > 0) {\n      const siguienteFranja = encontrarSiguienteFranja(horaActual, datosMalla.franjas);\n      if (siguienteFranja) {\n        horaActual = siguienteFranja.hora;\n      } else {\n        break;\n      }\n    }\n  }\n  \n  return franjas;\n}\n\nfunction generarFranjasAntiguas() {\n  if (!citaAntigua) return [];\n  \n  const franjas = [];\n  let horaActual = citaAntigua.horaInicio;\n  let horasRestantes = duracionHoras; // Usar la misma duración\n  \n  while (horasRestantes > 0) {\n    const franjaActual = datosMalla.franjas.find(f => horasIguales(f.hora, horaActual));\n    \n    if (!franjaActual) {\n      console.log(`No se encontró información para la franja antigua: ${horaActual}`);\n      break;\n    }\n    \n    const filaBase = calcularFilaExcel(horaActual, datosMalla.franjas);\n    if (!filaBase) {\n      console.log(`No se pudo determinar la fila para la franja antigua: ${horaActual}`);\n      break;\n    }\n\n    franjas.push({\n      hora: horaActual,\n      fila: filaBase,\n      datos: {\n        proveedor: \"\",\n        ordenCompra: \"\",\n        peso: \"\",\n        categoria: \"\",\n        unidades: \"\"\n      }\n    });\n    \n    horasRestantes--;\n    if (horasRestantes > 0) {\n      const siguienteFranja = encontrarSiguienteFranja(horaActual, datosMalla.franjas);\n      if (siguienteFranja) {\n        horaActual = siguienteFranja.hora;\n      } else {\n        break;\n      }\n    }\n  }\n  \n  return franjas;\n}\n\n// Funciones auxiliares (mantener las existentes)\nfunction obtenerDiaSemanaDesdeTexto(fechaStr) {\n  const regex = /(\\d+)\\s+de\\s+(\\w+)\\s+de\\s+(\\d+)/;\n  const match = regex.exec(fechaStr);\n  \n  if (!match) return null;\n  \n  const dia = parseInt(match[1], 10);\n  const mesStr = match[2].toLowerCase();\n  const año = parseInt(match[3], 10);\n  \n  const meses = {\n    \"enero\": 0, \"febrero\": 1, \"marzo\": 2, \"abril\": 3, \"mayo\": 4, \"junio\": 5,\n    \"julio\": 6, \"agosto\": 7, \"septiembre\": 8, \"octubre\": 9, \"noviembre\": 10, \"diciembre\": 11\n  };\n  \n  const mesNum = meses[mesStr];\n  if (mesNum === undefined) return null;\n  \n  const fecha = new Date(año, mesNum, dia);\n  const diaSemana = fecha.getDay();\n  const diasSemana = [\"domingo\", \"lunes\", \"martes\", \"miércoles\", \"jueves\", \"viernes\", \"sábado\"];\n  \n  return diasSemana[diaSemana];\n}\n\nfunction horasIguales(h1, h2) {\n  const normalizar = (h) =>\n    h.toString().trim().toLowerCase().replace(/\\./g, '').replace(/\\s+/g, '').replace(/^0+/, '');\n  return normalizar(h1) === normalizar(h2);\n}\n\nfunction calcularFilaExcel(hora, franjas) {\n  const franjasOrdenadas = [...franjas].sort((a, b) => {\n    function horaAMinutos(hora) {\n      const match = hora.match(/(\\d+):(\\d+)\\s*([AP]M)/i);\n      if (!match) return 0;\n      \n      let horas = parseInt(match[1], 10);\n      const minutos = parseInt(match[2], 10);\n      const periodo = match[3].toUpperCase();\n      \n      if (periodo === 'PM' && horas !== 12) {\n        horas += 12;\n      } else if (periodo === 'AM' && horas === 12) {\n        horas = 0;\n      }\n      \n      return horas * 60 + minutos;\n    }\n    \n    return horaAMinutos(a.hora) - horaAMinutos(b.hora);\n  });\n  \n  const posicion = franjasOrdenadas.findIndex(f => horasIguales(f.hora, hora));\n  \n  if (posicion === -1) {\n    console.log(`No se encontró la posición para la hora ${hora}`);\n    return null;\n  }\n  \n  const FILA_PRIMERA_FRANJA = 12;\n  const INCREMENTO_ESTANDAR = 3;\n  \n  if (posicion === 3) {\n    return 21;\n  } else if (posicion === 4) {\n    return 24;\n  } else if (posicion === 5) {\n    return 27;\n  } else if (posicion < 3) {\n    return FILA_PRIMERA_FRANJA + (posicion * INCREMENTO_ESTANDAR);\n  } else {\n    return 27 + ((posicion - 5) * INCREMENTO_ESTANDAR);\n  }\n}\n\nfunction encontrarSiguienteFranja(horaActual, franjas) {\n  const franjasOrdenadas = [...franjas].sort((a, b) => {\n    function horaAMinutos(hora) {\n      const match = hora.match(/(\\d+):(\\d+)\\s*([AP]M)/i);\n      if (!match) return 0;\n      \n      let horas = parseInt(match[1], 10);\n      const minutos = parseInt(match[2], 10);\n      const periodo = match[3].toUpperCase();\n      \n      if (periodo === 'PM' && horas !== 12) {\n        horas += 12;\n      } else if (periodo === 'AM' && horas === 12) {\n        horas = 0;\n      }\n      \n      return horas * 60 + minutos;\n    }\n    \n    return horaAMinutos(a.hora) - horaAMinutos(b.hora);\n  });\n  \n  const posicionActual = franjasOrdenadas.findIndex(f => horasIguales(f.hora, horaActual));\n  \n  if (posicionActual === -1 || posicionActual >= franjasOrdenadas.length - 1) {\n    return null;\n  }\n  \n  return franjasOrdenadas[posicionActual + 1];\n}\n\n// **EJECUTAR OPTIMIZACIÓN**\nconst resultadoOptimizacion = calcularFranjasOptimizadas();\n\nfunction procesarFranjas(franjas, nombreHoja, operacion) {\n  let actualizaciones = [];\n  \n  // Resto del código para procesar las franjas (mantener la lógica existente)\n  const diaSemana = obtenerDiaSemanaDesdeTexto(fecha);\n  const muelleKey = muelle.toLowerCase().includes(\"1\") ? \"muelle1\" : \"muelle2\";\n  \n  const mapeoColumnas = {\n    'lunes': { 'muelle1': 'C', 'muelle2': 'F' },\n    'martes': { 'muelle1': 'I', 'muelle2': 'L' },\n    'miércoles': { 'muelle1': 'O', 'muelle2': 'R' },\n    'jueves': { 'muelle1': 'U', 'muelle2': 'X' },\n    'viernes': { 'muelle1': 'AA', 'muelle2': 'AD' }\n  };\n  \n  if (!mapeoColumnas[diaSemana] || !mapeoColumnas[diaSemana][muelleKey]) {\n    console.log(`No hay mapeo para: día=${diaSemana}, muelle=${muelleKey}`);\n    return [];\n  }\n  \n  const columnaBase = mapeoColumnas[diaSemana][muelleKey];\n  \n  function siguienteColumna(columna) {\n    if (columna.length === 1) {\n      return String.fromCharCode(columna.charCodeAt(0) + 1);\n    } else {\n      const primerChar = columna.charAt(0);\n      const segundoChar = columna.charAt(1);\n      \n      if (segundoChar === 'Z') {\n        return String.fromCharCode(primerChar.charCodeAt(0) + 1) + 'A';\n      } else {\n        return primerChar + String.fromCharCode(segundoChar.charCodeAt(0) + 1);\n      }\n    }\n  }\n  \n  franjas.forEach(franja => {\n    const filaBase = franja.fila;\n    const columnaLineas = siguienteColumna(columnaBase);\n    const columnaUnd = siguienteColumna(columnaLineas);\n    \n    const rangoCeldas = {\n      proveedor: `${columnaBase}${filaBase}`,\n      ordenCompra: `${columnaBase}${filaBase + 1}`,\n      peso: `${columnaBase}${filaBase + 2}`,\n      categoria: `${columnaLineas}${filaBase + 2}`,\n      unidades: `${columnaUnd}${filaBase + 2}`\n    };\n    \n    actualizaciones.push(\n      { celda: rangoCeldas.proveedor, valor: franja.datos.proveedor, nombreHoja },\n      { celda: rangoCeldas.ordenCompra, valor: franja.datos.ordenCompra, nombreHoja },\n      { celda: rangoCeldas.peso, valor: franja.datos.peso, nombreHoja },\n      { celda: rangoCeldas.categoria, valor: franja.datos.categoria, nombreHoja },\n      { celda: rangoCeldas.unidades, valor: franja.datos.unidades, nombreHoja }\n    );\n  });\n  \n  return actualizaciones;\n}\n\n// Procesar las operaciones optimizadas\nconst actualizacionesNuevaCita = procesarFranjas(resultadoOptimizacion.franjasAInsertar, nombreHojaActual, \"insercion\");\nconst actualizacionesCitaAntigua = citaAntigua ? \n  procesarFranjas(resultadoOptimizacion.franjasAEliminar, citaAntigua.nombreHoja || nombreHojaActual, \"eliminacion\") : [];\n\n// Combinar todas las actualizaciones\nconst todasLasActualizaciones = [...actualizacionesNuevaCita, ...actualizacionesCitaAntigua];\n\n// Preparar el formato final para la petición a Microsoft Graph\nconst actualizacionesGraph = todasLasActualizaciones.map(act => ({\n  address: act.celda,\n  values: [[act.valor]],\n  nombreHoja: act.nombreHoja\n}));\n\n// Preparar el resultado para el siguiente nodo\nreturn {\n  json: {\n    success: true,\n    mensaje: `Preparadas ${todasLasActualizaciones.length} actualizaciones optimizadas para la cita del ${fecha} de ${horaInicio} a ${horaFin} en ${muelle} (${duracionHoras} horas)`,\n    nombreHoja: nombreHojaActual,\n    optimizacion: resultadoOptimizacion,\n    graphRequestData: {\n      updates: actualizacionesGraph\n    },\n    detalles: {\n      actualizacionesDetalladas: todasLasActualizaciones,\n      diaSemana: obtenerDiaSemanaDesdeTexto(fecha),\n      informacionCita: {\n        fecha, horaInicio, horaFin, muelle, proveedor, ordenCompra, peso, categoria, unidades, duracionHoras\n      }\n    }\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -37424,
        -7808
      ],
      "id": "b41de4ba-06b2-4286-98d9-3172269503a0",
      "name": "Code (Preparar Cuerpo de Petición)1"
    },
    {
      "parameters": {
        "jsCode": "// Código optimizado para \"Code Agrupar Franjas2\"\nconst input = $input.first().json;\n\n// Verificar que tenemos la estructura esperada\nif (!input || !input.graphRequestData || !input.graphRequestData.updates) {\n  console.log('Estructura de datos de entrada no válida');\n  return {\n    json: {\n      error: \"FORMATO_INVALIDO\",\n      mensaje: \"La estructura de datos de entrada no es válida\"\n    }\n  };\n}\n\nconst updates = input.graphRequestData.updates;\nconst optimizacion = input.optimizacion || {};\n\nconsole.log(`Procesando con optimización: ${optimizacion.optimizacionAplicada ? 'SÍ' : 'NO'}`);\nif (optimizacion.optimizacionAplicada) {\n  console.log(`Tipo de operación: ${optimizacion.tipoOperacion}`);\n  console.log(`Estadísticas: ${JSON.stringify(optimizacion.estadisticas)}`);\n}\n\n// **NUEVA LÓGICA: Agrupar considerando optimización**\nfunction agruparActualizacionesOptimizada() {\n  const actualizacionesInsercion = updates.filter(u => u.values[0][0] !== \"\");\n  const actualizacionesEliminacion = updates.filter(u => u.values[0][0] === \"\");\n  \n  // Si no hay optimización, usar la lógica original\n  if (!optimizacion.optimizacionAplicada) {\n    return agruparModeLegacy(actualizacionesInsercion, actualizacionesEliminacion);\n  }\n  \n  // **MODO OPTIMIZADO**: Agrupar solo las operaciones necesarias\n  console.log(`Modo optimizado activado:\n    - Inserciones necesarias: ${actualizacionesInsercion.length}\n    - Eliminaciones necesarias: ${actualizacionesEliminacion.length}\n    - Operaciones evitadas: ${optimizacion.estadisticas?.operacionesEvitadas || 0}`);\n  \n  const resultados = [];\n  const maxOperaciones = Math.max(actualizacionesInsercion.length, actualizacionesEliminacion.length);\n  \n  for (let i = 0; i < maxOperaciones; i++) {\n    const insercion = i < actualizacionesInsercion.length ? actualizacionesInsercion[i] : null;\n    const eliminacion = i < actualizacionesEliminacion.length ? actualizacionesEliminacion[i] : null;\n    \n    const parActualizaciones = {\n      json: {\n        insercion: insercion ? {\n          address: insercion.address,\n          values: insercion.values,\n          nombreHoja: insercion.nombreHoja || input.nombreHoja\n        } : null,\n        eliminacion: eliminacion ? {\n          address: eliminacion.address,\n          values: eliminacion.values,\n          nombreHoja: eliminacion.nombreHoja || input.nombreHoja\n        } : null,\n        indice: i + 1,\n        informacionCita: input.detalles?.informacionCita,\n        optimizacion: {\n          aplicada: true,\n          tipo: optimizacion.tipoOperacion,\n          estadisticas: optimizacion.estadisticas\n        }\n      }\n    };\n    \n    resultados.push(parActualizaciones);\n  }\n  \n  return resultados;\n}\n\nfunction agruparModeLegacy(actualizacionesInsercion, actualizacionesEliminacion) {\n  console.log('Usando modo legacy - sin optimización');\n  \n  const resultados = [];\n  const maxOperaciones = Math.max(actualizacionesInsercion.length, actualizacionesEliminacion.length);\n  \n  for (let i = 0; i < maxOperaciones; i++) {\n    const insercion = i < actualizacionesInsercion.length ? actualizacionesInsercion[i] : null;\n    const eliminacion = i < actualizacionesEliminacion.length ? actualizacionesEliminacion[i] : null;\n    \n    const parActualizaciones = {\n      json: {\n        insercion: insercion ? {\n          address: insercion.address,\n          values: insercion.values,\n          nombreHoja: insercion.nombreHoja || input.nombreHoja\n        } : null,\n        eliminacion: eliminacion ? {\n          address: eliminacion.address,\n          values: eliminacion.values,\n          nombreHoja: eliminacion.nombreHoja || input.nombreHoja\n        } : null,\n        indice: i + 1,\n        informacionCita: input.detalles?.informacionCita,\n        optimizacion: {\n          aplicada: false,\n          tipo: optimizacion.tipoOperacion || 'legacy',\n          estadisticas: { operacionesEvitadas: 0, eficiencia: '0%' }\n        }\n      }\n    };\n    \n    resultados.push(parActualizaciones);\n  }\n  \n  return resultados;\n}\n\n// Ejecutar agrupación\nconst resultados = agruparActualizacionesOptimizada();\n\nconsole.log(`Se crearon ${resultados.length} pares de actualizaciones`);\n\nreturn resultados;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -37216,
        -7808
      ],
      "id": "e265980f-4f83-444e-bfaf-30377989a641",
      "name": "Code Agrupar Franjas2"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        -36928,
        -7808
      ],
      "id": "bc2a265e-3ea3-4901-84bb-057a78351d9c",
      "name": "Loop Over Uno a Uno1"
    },
    {
      "parameters": {
        "jsCode": "// Código optimizado para \"Code Preparar cada Insercion1\"\nconst input = $input.first().json;\n\n// Constantes para los IDs de SharePoint/OneDrive\nconst siteId = \"gexpresscargo.sharepoint.com,a592f886-4560-4e62-9646-1eee7add7abe,8b514073-41ae-4619-8f76-724bd912bc65\";\nconst driveId = \"b!hviSpWBFYk6WRh7uet16vnNAUYuuQRlGj3ZyS9kSvGVZ4DSg6c5MRqYYm2MdAER8\";\nconst itemId = \"01PPLUUYXY5E2GK3SJ25EZLJPUYJ43H3ME\";\n\n// Verificar que tenemos la estructura esperada\nif (!input || (!input.insercion && !input.eliminacion)) {\n  console.log('Estructura de datos de entrada no válida para las operaciones');\n  return {\n    json: {\n      error: \"FORMATO_INVALIDO\",\n      mensaje: \"La estructura de datos de entrada no es válida para las operaciones combinadas\"\n    }\n  };\n}\n\nconst optimizacion = input.optimizacion || { aplicada: false };\nconst indice = input.indice;\nconst informacionCita = input.informacionCita || {};\n\n// **NUEVA LÓGICA: Preparar solicitudes considerando optimización**\nfunction prepararSolicitudOptimizada() {\n  const solicitudes = [];\n  \n  // Log de optimización\n  if (optimizacion.aplicada) {\n    console.log(`Preparando solicitud optimizada - Tipo: ${optimizacion.tipo}`);\n    console.log(`Estadísticas de optimización: ${JSON.stringify(optimizacion.estadisticas)}`);\n  } else {\n    console.log('Preparando solicitud en modo legacy');\n  }\n  \n  // Preparar solicitud de inserción si existe\n  if (input.insercion && input.insercion.address && input.insercion.values) {\n    const requestIdInsercion = `insercion_${input.insercion.address}_${indice}_${Date.now()}`;\n    const nombreHojaInsercion = input.insercion.nombreHoja;\n    \n    if (!nombreHojaInsercion) {\n      console.log('Nombre de hoja faltante para inserción');\n      return {\n        json: {\n          error: \"HOJA_NO_ESPECIFICADA\",\n          mensaje: \"No se especificó el nombre de la hoja para la inserción\"\n        }\n      };\n    }\n    \n    solicitudes.push({\n      id: requestIdInsercion,\n      method: \"PATCH\",\n      url: `/sites/${siteId}/drives/${driveId}/items/${itemId}/workbook/worksheets/${encodeURIComponent(nombreHojaInsercion)}/range(address='${input.insercion.address}')`,\n      body: {\n        values: input.insercion.values\n      },\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    });\n    \n    console.log(`Solicitud de inserción: \"${input.insercion.values[0][0]}\" en celda ${input.insercion.address} de hoja \"${nombreHojaInsercion}\"`);\n  }\n  \n  // Preparar solicitud de eliminación si existe\n  if (input.eliminacion && input.eliminacion.address && input.eliminacion.values) {\n    const requestIdEliminacion = `eliminacion_${input.eliminacion.address}_${indice}_${Date.now()}`;\n    const nombreHojaEliminacion = input.eliminacion.nombreHoja;\n    \n    if (!nombreHojaEliminacion) {\n      console.log('Nombre de hoja faltante para eliminación');\n      return {\n        json: {\n          error: \"HOJA_NO_ESPECIFICADA\",\n          mensaje: \"No se especificó el nombre de la hoja para la eliminación\"\n        }\n      };\n    }\n    \n    solicitudes.push({\n      id: requestIdEliminacion,\n      method: \"PATCH\",\n      url: `/sites/${siteId}/drives/${driveId}/items/${itemId}/workbook/worksheets/${encodeURIComponent(nombreHojaEliminacion)}/range(address='${input.eliminacion.address}')`,\n      body: {\n        values: input.eliminacion.values\n      },\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    });\n    \n    console.log(`Solicitud de eliminación: limpiar celda ${input.eliminacion.address} en hoja \"${nombreHojaEliminacion}\"`);\n  }\n  \n  // **VALIDACIÓN DE OPTIMIZACIÓN**: Verificar que no estamos procesando franjas innecesarias\n  if (optimizacion.aplicada && optimizacion.tipo === \"mismo_dia_optimizado\") {\n    // En este caso, deberíamos tener menos solicitudes que en el modo legacy\n    console.log(`Optimización aplicada: procesando ${solicitudes.length} solicitudes en lugar de las operaciones completas`);\n  }\n  \n  return {\n    requests: solicitudes,\n    _metadata: {\n      indice: indice,\n      optimizacion: optimizacion,\n      operaciones: {\n        insercion: input.insercion ? {\n          celda: input.insercion.address,\n          valor: input.insercion.values[0][0],\n          hoja: input.insercion.nombreHoja\n        } : null,\n        eliminacion: input.eliminacion ? {\n          celda: input.eliminacion.address,\n          valor: \"\",\n          hoja: input.eliminacion.nombreHoja\n        } : null\n      },\n      informacionCita: informacionCita\n    }\n  };\n}\n\n// Verificar si alguna operación es realmente necesaria\nif (!input.insercion && !input.eliminacion) {\n  console.log('No hay operaciones que procesar - posible optimización completa');\n  return {\n    json: {\n      requests: [],\n      _metadata: {\n        indice: indice,\n        optimizacion: { ...optimizacion, operacionCompleta: true },\n        mensaje: \"No se requieren operaciones - franjas mantenidas por optimización\"\n      }\n    }\n  };\n}\n\n// Preparar y retornar la solicitud\nconst requestBody = prepararSolicitudOptimizada();\n\nconsole.log(`Solicitud preparada con ${requestBody.requests.length} operaciones`);\n\nreturn {\n  json: requestBody\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -36656,
        -7712
      ],
      "id": "8f8f469c-6905-43ce-8bd2-25adc34ad7d7",
      "name": "Code Preparar cada Insercion1"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://graph.microsoft.com/v1.0/$batch",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "microsoftOAuth2Api",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -36400,
        -7712
      ],
      "id": "4bbc9970-3b1a-403c-ac2d-403dd2cfbb8d",
      "name": "HTTP Request Actualizar Excel",
      "credentials": {
        "microsoftOAuth2Api": {
          "id": "mh8Z8hxFvd7LDO8D",
          "name": "CuentaMy SharePoint App Desarrollador1 Konfie "
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Código actualizado para verificar tanto la inserción como la eliminación\nconst input = $input.first().json;\n\n// Verificar que tenemos la estructura esperada en la respuesta\nif (!input || !input.responses || !Array.isArray(input.responses) || input.responses.length === 0) {\n  console.log('Estructura de datos de respuesta no válida');\n  return {\n    json: {\n      error: \"RESPUESTA_INVALIDA\",\n      mensaje: \"La estructura de datos de la respuesta no es válida\",\n      exito: false\n    }\n  };\n}\n\n// Buscar las respuestas de inserción y eliminación\nconst respuestaInsercion = input.responses.find(r => r.id && r.id.includes('insercion_'));\nconst respuestaEliminacion = input.responses.find(r => r.id && r.id.includes('eliminacion_'));\n\n// Verificar si encontramos ambas respuestas\nif (!respuestaInsercion || !respuestaEliminacion) {\n  console.log('No se encontraron respuestas para inserción y/o eliminación');\n  return {\n    json: {\n      error: \"RESPUESTAS_INCOMPLETAS\",\n      mensaje: \"No se encontraron respuestas para inserción y/o eliminación\",\n      exito: false,\n      respuestasDisponibles: input.responses.map(r => r.id)\n    }\n  };\n}\n\n// Extraer información de las respuestas\nfunction extraerInfoCelda(respuesta) {\n  // Extraer información del ID\n  const idPartes = respuesta.id.split('_');\n  const tipoOperacion = idPartes[0]; // \"insercion\" o \"eliminacion\"\n  const celda = idPartes[1];         // Por ejemplo \"I21\"\n  \n  // Extraer información de dirección de la respuesta\n  let direccionRespuesta = \"\";\n  let hoja = \"\";\n  \n  if (respuesta.body && respuesta.body.address) {\n    // Formato típico: 'SEMANA 21'!I21\n    const direccionCompleta = respuesta.body.address;\n    const partesDireccion = direccionCompleta.split('!');\n    \n    if (partesDireccion.length > 1) {\n      // Eliminar comillas simples y extraer el nombre de la hoja\n      hoja = partesDireccion[0].replace(/'/g, '');\n      direccionRespuesta = partesDireccion[1];\n    }\n  }\n  \n  // Obtener el valor de la celda\n  const valor = respuesta.body && respuesta.body.values && \n                respuesta.body.values[0] && respuesta.body.values[0][0] !== undefined ? \n                respuesta.body.values[0][0] : null;\n  \n  // Verificar el código de estado HTTP\n  const estadoExitoso = respuesta.status >= 200 && respuesta.status < 300;\n  \n  return {\n    id: respuesta.id,\n    tipoOperacion,\n    celda,\n    direccionRespuesta,\n    hoja,\n    valor,\n    estadoExitoso,\n    statusCode: respuesta.status\n  };\n}\n\n// Procesar ambas respuestas\nconst infoInsercion = extraerInfoCelda(respuestaInsercion);\nconst infoEliminacion = extraerInfoCelda(respuestaEliminacion);\n\n// Determinar éxito global\nconst exitoGlobal = infoInsercion.estadoExitoso && infoEliminacion.estadoExitoso;\n\n// Crear resultado detallado\nconst resultado = {\n  exito: exitoGlobal,\n  operaciones: {\n    insercion: {\n      exito: infoInsercion.estadoExitoso,\n      celda: infoInsercion.celda,\n      celdaRespuesta: infoInsercion.direccionRespuesta,\n      hoja: infoInsercion.hoja,\n      valor: infoInsercion.valor,\n      statusCode: infoInsercion.statusCode\n    },\n    eliminacion: {\n      exito: infoEliminacion.estadoExitoso,\n      celda: infoEliminacion.celda,\n      celdaRespuesta: infoEliminacion.direccionRespuesta,\n      hoja: infoEliminacion.hoja,\n      valor: infoEliminacion.valor,\n      statusCode: infoEliminacion.statusCode\n    }\n  },\n  mensaje: exitoGlobal ? \n    `Operaciones completadas exitosamente - Inserción en ${infoInsercion.hoja} y eliminación en ${infoEliminacion.hoja}` :\n    `Hubo problemas con una o ambas operaciones`,\n  respuestasOriginales: {\n    insercion: respuestaInsercion,\n    eliminacion: respuestaEliminacion\n  }\n};\n\n// Mantener compatibilidad con el formato antiguo para no romper flujos subsiguientes\nconst resultadoCompatible = {\n  exito: exitoGlobal,\n  celdaOriginal: infoInsercion.tipoOperacion,\n  celdaInsertada: infoInsercion.celda,\n  valorInsertado: infoInsercion.valor,\n  statusCode: infoInsercion.statusCode,\n  requestId: infoInsercion.id,\n  indice: infoInsercion.celda,\n  celdasDiferentes: false, // Ya no es relevante con la nueva estructura\n  falloEstado: !exitoGlobal,\n  respuestaOriginal: respuestaInsercion,\n  // Nuevos campos para la versión mejorada\n  resultadoDetallado: resultado\n};\n\n// Obtener chat_id si existe\nconst chatId = $('Organiza el Mensaje').first()?.json?.infoMensaje?.chat_id;\n\n// Registrar resultado en consola\nif (exitoGlobal) {\n  console.log(`Operaciones completadas exitosamente:`);\n  console.log(`- Inserción en hoja ${infoInsercion.hoja}, celda ${infoInsercion.celda}, valor: \"${infoInsercion.valor}\"`);\n  console.log(`- Eliminación en hoja ${infoEliminacion.hoja}, celda ${infoEliminacion.celda}`);\n} else {\n  console.log(`Hubo problemas con una o ambas operaciones:`);\n  if (!infoInsercion.estadoExitoso) {\n    console.log(`- Fallo en inserción: status ${infoInsercion.statusCode}`);\n  }\n  if (!infoEliminacion.estadoExitoso) {\n    console.log(`- Fallo en eliminación: status ${infoEliminacion.statusCode}`);\n  }\n}\n\n// Retornar el resultado\nreturn {\n  json: resultadoCompatible,\n  chat_id: chatId\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -36176,
        -7712
      ],
      "id": "9581238a-9736-44a2-acd6-2fe9b70428f9",
      "name": "Code Verificar Inserción1"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "fb1eda05-eb5e-4683-8556-1cf2b5b8e4d5",
              "leftValue": "={{ $json.exito }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -35936,
        -7648
      ],
      "id": "ae9fb808-dfd3-4438-8e4b-66f5b0fba67a",
      "name": "If Verificar Inserción1"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "15a95144-dd82-4ea5-b9ba-9eb924d2ae5c",
              "leftValue": "={{ $json.celdasDiferentes }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -35728,
        -7568
      ],
      "id": "222a3983-4dc8-4a2a-bbd8-5e5d22e38eb4",
      "name": "If Diferente Caso1"
    },
    {
      "parameters": {
        "jsCode": "// Código para limpiar una celda donde se insertó incorrectamente un valor\n// Actualizado para manejar la nueva estructura con operaciones de inserción y eliminación\nconst input = $input.first().json;\n\n// Constantes para los IDs de SharePoint/OneDrive\nconst siteId = \"gexpresscargo.sharepoint.com,a592f886-4560-4e62-9646-1eee7add7abe,8b514073-41ae-4619-8f76-724bd912bc65\";\nconst driveId = \"b!hviSpWBFYk6WRh7uet16vnNAUYuuQRlGj3ZyS9kSvGVZ4DSg6c5MRqYYm2MdAER8\";\nconst itemId = \"01PPLUUYXY5E2GK3SJ25EZLJPUYJ43H3ME\";\n\n// Verificar que tenemos la información necesaria\nif (!input || (!input.operaciones && !input.celdaInsertada)) {\n  console.log('Información insuficiente para limpiar la celda incorrecta');\n  return {\n    json: {\n      error: \"INFORMACION_INSUFICIENTE\",\n      mensaje: \"No hay suficiente información para limpiar la celda incorrecta\"\n    }\n  };\n}\n\n// Determinar qué celdas necesitan limpieza\nconst celdasALimpiar = [];\n\n// Verificar si estamos usando la nueva estructura con operaciones\nif (input.operaciones) {\n  // Nueva estructura: usar información de las operaciones\n  const { insercion, eliminacion } = input.operaciones;\n  \n  // Si la inserción falló, agregarla para limpieza\n  if (insercion && !insercion.exito && insercion.celdaRespuesta) {\n    celdasALimpiar.push({\n      celda: insercion.celdaRespuesta,\n      hoja: insercion.hoja || \"\"\n    });\n  }\n  \n  // Si la eliminación falló, agregarla para limpieza\n  if (eliminacion && !eliminacion.exito && eliminacion.celdaRespuesta) {\n    celdasALimpiar.push({\n      celda: eliminacion.celdaRespuesta,\n      hoja: eliminacion.hoja || \"\"\n    });\n  }\n} else {\n  // Estructura anterior: solo tenemos información de inserción\n  // Obtener la celda a limpiar y la información de la hoja\n  const celdaALimpiar = input.celdaInsertada;\n  let hojaExcel = input.nombreHoja || \"\"; // Usar el nombreHoja del input\n  \n  // Intentar extraer el nombre de la hoja de la dirección en la respuesta si no está disponible\n  if ((!hojaExcel || hojaExcel === \"\") && input.respuestaOriginal?.body?.address) {\n    const direccionCompleta = input.respuestaOriginal.body.address;\n    hojaExcel = direccionCompleta.split('!')[0].replace(/'/g, '');\n  }\n  \n  celdasALimpiar.push({\n    celda: celdaALimpiar,\n    hoja: hojaExcel\n  });\n}\n\n// Si no hay celdas para limpiar, devolver error\nif (celdasALimpiar.length === 0) {\n  console.log('No se identificaron celdas para limpiar');\n  return {\n    json: {\n      error: \"NO_HAY_CELDAS\",\n      mensaje: \"No se identificaron celdas que necesiten limpieza\",\n      input: input\n    }\n  };\n}\n\n// Crear solicitudes para limpiar cada celda identificada\nconst solicitudes = celdasALimpiar.map((info, index) => {\n  console.log(`Limpiando celda incorrecta ${info.celda} en hoja ${info.hoja}`);\n  \n  return {\n    id: `Limpiar_${info.celda}_${Date.now()}_${index}`,\n    method: \"PATCH\",\n    url: `/sites/${siteId}/drives/${driveId}/items/${itemId}/workbook/worksheets/${encodeURIComponent(info.hoja)}/range(address='${info.celda}')`,\n    body: {\n      values: [[\"\"]] // Valor vacío para limpiar la celda\n    },\n    headers: {\n      \"Content-Type\": \"application/json\"\n    }\n  };\n});\n\n// Crear la solicitud para limpiar las celdas\nconst requestBody = {\n  requests: solicitudes,\n  _metadata: {\n    accion: \"limpiar\",\n    celdasLimpiadas: celdasALimpiar,\n    datoOriginal: input\n  }\n};\n\n// Retornar el request para limpiar la celda\nreturn {\n  json: requestBody\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -35424,
        -7744
      ],
      "id": "675f401e-3e75-4b31-9f34-e3b06e7dac0a",
      "name": "Code Limpiar Celda Incorrecta1",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://graph.microsoft.com/v1.0/$batch",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "microsoftOAuth2Api",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -35200,
        -7744
      ],
      "id": "3bbec5eb-7fc7-4d99-a2db-ccce4a8ba0bf",
      "name": "HTTP Request Limpiar Celda1",
      "credentials": {
        "microsoftOAuth2Api": {
          "id": "mh8Z8hxFvd7LDO8D",
          "name": "CuentaMy SharePoint App Desarrollador1 Konfie "
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "e570827e-13d0-4d6f-b23e-184ca2d3368c",
              "leftValue": "={{ $json.falloEstado }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -35264,
        -7360
      ],
      "id": "8e627dfd-56fb-4a06-9cbc-c1aea9b1a4fe",
      "name": "If fallo Estado1"
    },
    {
      "parameters": {
        "jsCode": "// Código para reintentar la inserción en la celda correcta\n// Actualizado para manejar la nueva estructura con operaciones de inserción y eliminación\nconst input = $input.first().json;\n\n// Constantes para los IDs de SharePoint/OneDrive\nconst siteId = \"gexpresscargo.sharepoint.com,a592f886-4560-4e62-9646-1eee7add7abe,8b514073-41ae-4619-8f76-724bd912bc65\";\nconst driveId = \"b!hviSpWBFYk6WRh7uet16vnNAUYuuQRlGj3ZyS9kSvGVZ4DSg6c5MRqYYm2MdAER8\";\nconst itemId = \"01PPLUUYXY5E2GK3SJ25EZLJPUYJ43H3ME\";\n\n// Si el input viene del nodo anterior de limpiar celda, extraer el dato original\nconst datoOriginal = input._metadata?.datoOriginal || input;\n\n// Verificar que tenemos la información necesaria\nif (!datoOriginal) {\n  console.log('Información insuficiente para reintentar la inserción/eliminación');\n  return {\n    json: {\n      error: \"INFORMACION_INSUFICIENTE\",\n      mensaje: \"No hay suficiente información para reintentar las operaciones\"\n    }\n  };\n}\n\n// Operaciones a reintentar\nconst operacionesAReintentar = [];\n\n// Determinar qué operaciones necesitan reintento\nif (datoOriginal.operaciones) {\n  // Nueva estructura: evaluar inserción y eliminación\n  const { insercion, eliminacion } = datoOriginal.operaciones;\n  \n  // Verificar si la inserción necesita reintento\n  if (insercion && !insercion.exito) {\n    operacionesAReintentar.push({\n      tipo: \"insercion\",\n      celda: insercion.celda,\n      valor: insercion.valor,\n      hoja: insercion.hoja || datoOriginal.resultadoDetallado?.operaciones?.insercion?.hoja || \"\"\n    });\n  }\n  \n  // Verificar si la eliminación necesita reintento\n  if (eliminacion && !eliminacion.exito) {\n    operacionesAReintentar.push({\n      tipo: \"eliminacion\",\n      celda: eliminacion.celda,\n      valor: \"\", // Para eliminación, siempre usamos valor vacío\n      hoja: eliminacion.hoja || datoOriginal.resultadoDetallado?.operaciones?.eliminacion?.hoja || \"\"\n    });\n  }\n} else {\n  // Estructura anterior: solo tenemos información de inserción\n  // Obtener la celda correcta donde insertar y el valor a insertar\n  const celdaCorrecta = datoOriginal.celdaOriginal;\n  \n  // Intentar obtener el valor correcto a insertar\n  let valorAInsertar;\n  \n  // Primero, verificar si tenemos el valor de la respuesta original\n  if (datoOriginal.valorInsertado !== undefined) {\n    valorAInsertar = datoOriginal.valorInsertado;\n  } \n  // Si no, intentar obtenerlo del body de la respuesta\n  else if (datoOriginal.respuestaOriginal?.body?.values?.[0]?.[0] !== undefined) {\n    valorAInsertar = datoOriginal.respuestaOriginal.body.values[0][0];\n  } \n  // Como último recurso, usar un valor vacío\n  else {\n    valorAInsertar = \"\";\n    console.log('No se pudo determinar el valor a insertar, usando valor vacío');\n  }\n  \n  // Obtener la hoja de Excel - primero del dato original\n  let hojaExcel = datoOriginal.nombreHoja || \"\"; \n  \n  // Si no está disponible en el objeto principal, intentar obtenerlo de otros lugares\n  if (!hojaExcel || hojaExcel === \"\") {\n    // Verificar si está en el _metadata\n    hojaExcel = input._metadata?.hoja || \"\";\n    \n    // Como último recurso, extraer de la dirección en la respuesta\n    if ((!hojaExcel || hojaExcel === \"\") && datoOriginal.respuestaOriginal?.body?.address) {\n      const direccionCompleta = datoOriginal.respuestaOriginal.body.address;\n      hojaExcel = direccionCompleta.split('!')[0].replace(/'/g, '');\n    }\n  }\n  \n  operacionesAReintentar.push({\n    tipo: \"insercion\",\n    celda: celdaCorrecta,\n    valor: valorAInsertar,\n    hoja: hojaExcel\n  });\n}\n\n// Si no hay operaciones para reintentar, devolver error\nif (operacionesAReintentar.length === 0) {\n  console.log('No se identificaron operaciones para reintentar');\n  return {\n    json: {\n      error: \"NO_HAY_OPERACIONES\",\n      mensaje: \"No se identificaron operaciones que necesiten reintento\",\n      input: datoOriginal\n    }\n  };\n}\n\n// Crear solicitudes para cada operación a reintentar\nconst solicitudes = operacionesAReintentar.map((op, index) => {\n  // Determinar el tipo de valor y formatearlo adecuadamente\n  let valorFormateado;\n  if (typeof op.valor === 'number') {\n    valorFormateado = [[op.valor]]; // Mantener el tipo numérico\n  } else {\n    valorFormateado = [[op.valor.toString()]]; // Convertir a string para otros tipos\n  }\n  \n  console.log(`Reintentando ${op.tipo} en celda ${op.celda} de la hoja ${op.hoja} con valor \"${op.valor}\"`);\n  \n  return {\n    id: `Reintento_${op.tipo}_${op.celda}_${Date.now()}_${index}`,\n    method: \"PATCH\",\n    url: `/sites/${siteId}/drives/${driveId}/items/${itemId}/workbook/worksheets/${encodeURIComponent(op.hoja)}/range(address='${op.celda}')`,\n    body: {\n      values: valorFormateado\n    },\n    headers: {\n      \"Content-Type\": \"application/json\"\n    }\n  };\n});\n\n// Crear la solicitud para reintentar las operaciones\nconst requestBody = {\n  requests: solicitudes,\n  _metadata: {\n    accion: \"reintentar\",\n    operaciones: operacionesAReintentar,\n    datoOriginal: datoOriginal,\n    intentos: (datoOriginal._metadata?.intentos || 0) + 1\n  }\n};\n\n// Retornar el request para reintentar las operaciones\nreturn {\n  json: requestBody\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -34928,
        -7680
      ],
      "id": "6ffd1ca8-b3bb-418a-81b3-2af10c1a919f",
      "name": "Code Reintentar Inserción1",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://graph.microsoft.com/v1.0/$batch",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "microsoftOAuth2Api",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -34688,
        -7568
      ],
      "id": "67c8c945-b7f8-4f87-aec7-6f1a603ed221",
      "name": "HTTP Request Reintentar Inserción1",
      "credentials": {
        "microsoftOAuth2Api": {
          "id": "mh8Z8hxFvd7LDO8D",
          "name": "CuentaMy SharePoint App Desarrollador1 Konfie "
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Código para verificar si la inserción y eliminación fueron exitosas\n// Actualizado para manejar la nueva estructura\nconst input = $input.first().json;\n\n// Verificar que tenemos la estructura esperada en la respuesta\nif (!input || !input.responses || !Array.isArray(input.responses)) {\n  console.log('Estructura de datos de respuesta no válida');\n  return {\n    json: {\n      error: \"RESPUESTA_INVALIDA\",\n      mensaje: \"La estructura de datos de la respuesta no es válida\",\n      exito: false\n    }\n  };\n}\n\n// Si no hay respuestas, devolver error\nif (input.responses.length === 0) {\n  console.log('No se recibieron respuestas del servidor');\n  return {\n    json: {\n      error: \"SIN_RESPUESTAS\",\n      mensaje: \"No se recibieron respuestas del servidor\",\n      exito: false\n    }\n  };\n}\n\n// Analizar las respuestas para determinar a qué operación corresponde cada una\nconst respuestas = input.responses.map(response => {\n  // Extraer información del ID de la respuesta\n  const idPartes = response.id.split('_');\n  const tipoOperacion = idPartes[0].toLowerCase(); // \"reintento\", \"limpiar\", etc.\n  const tipoEntidad = idPartes[1]?.toLowerCase(); // \"insercion\", \"eliminacion\", etc.\n  const celda = idPartes[2] || \"\"; // La celda como I21, K23, etc.\n  \n  // Extraer información de la dirección en la respuesta\n  let direccionRespuesta = \"\";\n  let hojaExcel = \"\";\n  \n  if (response.body && response.body.address) {\n    const direccionCompleta = response.body.address;\n    const partesDireccion = direccionCompleta.split('!');\n    \n    if (partesDireccion.length > 1) {\n      // Quitar las comillas simples del nombre de la hoja\n      hojaExcel = partesDireccion[0].replace(/'/g, '');\n      direccionRespuesta = partesDireccion[1];\n    }\n  }\n  \n  // Obtener el valor de la respuesta\n  const valor = response.body?.values?.[0]?.[0];\n  \n  // Verificar si la operación fue exitosa (código 200-299)\n  const estadoExitoso = response.status >= 200 && response.status < 300;\n  \n  // Verificar si la celda en la respuesta coincide con la esperada\n  const celdaCorrecta = direccionRespuesta === celda;\n  \n  return {\n    id: response.id,\n    tipoOperacion,\n    tipoEntidad,\n    celda,\n    direccionRespuesta,\n    hoja: hojaExcel,\n    valor,\n    estadoExitoso,\n    celdaCorrecta,\n    statusCode: response.status,\n    respuesta: response\n  };\n});\n\n// Separar las respuestas por tipo de operación\nconst respuestasInsercion = respuestas.filter(r => \n  r.tipoEntidad === \"insercion\" || \n  (r.tipoOperacion === \"reintento\" && input._metadata?.operaciones?.[0]?.tipo === \"insercion\")\n);\n\nconst respuestasEliminacion = respuestas.filter(r => \n  r.tipoEntidad === \"eliminacion\" || \n  (r.tipoOperacion === \"reintento\" && input._metadata?.operaciones?.[0]?.tipo === \"eliminacion\")\n);\n\n// Determinar éxito por tipo de operación\nconst insercionExitosa = respuestasInsercion.length > 0 && \n                        respuestasInsercion.every(r => r.estadoExitoso && r.celdaCorrecta);\n\nconst eliminacionExitosa = respuestasEliminacion.length > 0 && \n                          respuestasEliminacion.every(r => r.estadoExitoso && r.celdaCorrecta);\n\n// Determinar éxito global basado en las operaciones presentes\nlet exitoGlobal;\n\nif (respuestasInsercion.length > 0 && respuestasEliminacion.length > 0) {\n  // Si hay ambas operaciones, ambas deben ser exitosas\n  exitoGlobal = insercionExitosa && eliminacionExitosa;\n} else if (respuestasInsercion.length > 0) {\n  // Si solo hay inserción, solo esa debe ser exitosa\n  exitoGlobal = insercionExitosa;\n} else if (respuestasEliminacion.length > 0) {\n  // Si solo hay eliminación, solo esa debe ser exitosa\n  exitoGlobal = eliminacionExitosa;\n} else {\n  // Si no hay operaciones identificables, considerar como no exitoso\n  exitoGlobal = false;\n}\n\n// Obtener la información más relevante para cada tipo de operación\nconst infoInsercion = respuestasInsercion.length > 0 ? respuestasInsercion[0] : null;\nconst infoEliminacion = respuestasEliminacion.length > 0 ? respuestasEliminacion[0] : null;\n\n// Crear el resultado detallado\nconst resultadoDetallado = {\n  exito: exitoGlobal,\n  operaciones: {\n    insercion: infoInsercion ? {\n      exito: infoInsercion.estadoExitoso && infoInsercion.celdaCorrecta,\n      celda: infoInsercion.celda,\n      direccionRespuesta: infoInsercion.direccionRespuesta,\n      hoja: infoInsercion.hoja,\n      valor: infoInsercion.valor,\n      statusCode: infoInsercion.statusCode\n    } : null,\n    eliminacion: infoEliminacion ? {\n      exito: infoEliminacion.estadoExitoso && infoEliminacion.celdaCorrecta,\n      celda: infoEliminacion.celda,\n      direccionRespuesta: infoEliminacion.direccionRespuesta,\n      hoja: infoEliminacion.hoja,\n      valor: infoEliminacion.valor,\n      statusCode: infoEliminacion.statusCode\n    } : null\n  },\n  mensaje: exitoGlobal ? \n    \"Todas las operaciones se completaron exitosamente\" : \n    \"Hubo problemas con una o más operaciones\",\n  respuestasCompletas: respuestas\n};\n\n// Crear el resultado compatible con el formato anterior\nconst resultadoCompatible = {\n  exito: exitoGlobal,\n  // Usar la primera respuesta para compatibilidad\n  celdaOriginal: infoInsercion?.celda || infoEliminacion?.celda || \"\",\n  celdaInsertada: infoInsercion?.direccionRespuesta || infoEliminacion?.direccionRespuesta || \"\",\n  valorInsertado: infoInsercion?.valor || infoEliminacion?.valor || \"\",\n  statusCode: infoInsercion?.statusCode || infoEliminacion?.statusCode || 0,\n  requestId: infoInsercion?.id || infoEliminacion?.id || \"\",\n  indice: infoInsercion?.celda || infoEliminacion?.celda || \"\",\n  celdasDiferentes: (infoInsercion && infoInsercion.celda !== infoInsercion.direccionRespuesta) ||\n                   (infoEliminacion && infoEliminacion.celda !== infoEliminacion.direccionRespuesta),\n  falloEstado: !exitoGlobal,\n  // Información adicional para la versión mejorada\n  resultadoDetallado: resultadoDetallado\n};\n\n// Registrar el resultado en consola\nif (exitoGlobal) {\n  console.log(\"Operaciones completadas exitosamente:\");\n  if (infoInsercion) {\n    console.log(`- Inserción en hoja ${infoInsercion.hoja}, celda ${infoInsercion.celda}, valor: \"${infoInsercion.valor}\"`);\n  }\n  if (infoEliminacion) {\n    console.log(`- Eliminación en hoja ${infoEliminacion.hoja}, celda ${infoEliminacion.celda}`);\n  }\n} else {\n  console.log(\"Problemas detectados en las operaciones:\");\n  if (infoInsercion && (!infoInsercion.estadoExitoso || !infoInsercion.celdaCorrecta)) {\n    console.log(`- Fallo en inserción: celda=${infoInsercion.celda}, dirección respuesta=${infoInsercion.direccionRespuesta}, status=${infoInsercion.statusCode}`);\n  }\n  if (infoEliminacion && (!infoEliminacion.estadoExitoso || !infoEliminacion.celdaCorrecta)) {\n    console.log(`- Fallo en eliminación: celda=${infoEliminacion.celda}, dirección respuesta=${infoEliminacion.direccionRespuesta}, status=${infoEliminacion.statusCode}`);\n  }\n}\n\n// Retornar el resultado\nreturn {\n  json: resultadoCompatible\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -34464,
        -7568
      ],
      "id": "f9a099a3-4a25-45ca-aa83-64268b402db1",
      "name": "Code Volver a validar Inserción1",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "f7205e4e-147c-4e77-8fa8-08d082980b48",
              "leftValue": "={{ $json.exito }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -34240,
        -7568
      ],
      "id": "06dad336-8fe4-4481-86b6-af8a46b413b1",
      "name": "If Verificar Inserción "
    },
    {
      "parameters": {
        "amount": 3
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        -35344,
        -7568
      ],
      "id": "58f77fb6-bfeb-45b9-9cb5-41851d63b438",
      "name": "Wait4",
      "webhookId": "a4bbf2b1-ea0c-4b02-af2c-64b29f2bdb5c"
    },
    {
      "parameters": {
        "amount": 3
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        -33936,
        -7392
      ],
      "id": "9dcf7c43-8a9d-4d87-9e07-c3459a2d7f33",
      "name": "Wait5",
      "webhookId": "9d944db7-9c4f-439e-9990-d9937f2fb18e"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -33504,
        -7024
      ],
      "id": "cba3e143-113f-463d-b307-599bebd0375a",
      "name": "OpenAI Chat Model15",
      "credentials": {
        "openAiApi": {
          "id": "AD8kPcNVReuclASd",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "=define",
        "text": "=Eres un asistente de un sistema de agendamiento de citas para la entrega de mercancía en bodega. Debes notificar al cliente que ha ocurrido un error en el sistema durante el proceso de inserción de la cita en el sistema de Excel.\n\nGenera un mensaje directo (sin saludos iniciales ni mencionar nombres) que:\n\n1. Comunique claramente que se produjo un error técnico al intentar registrar la cita en el sistema.\n\n2. Indique que es urgente que se comunique con el área de bodega en los próximos 5 minutos para que puedan agendar la cita manualmente.\n\n4. Mencione que, de no establecer contacto en ese tiempo, existe el riesgo de perder la franja horaria seleccionada debido a la alta demanda de los muelles.\n\n5. Aclare que esta situación es poco común y se debe a un inconveniente técnico en el sistema de agendamiento.\n\n6. Pida disculpas por los inconvenientes ocasionados y agradezca la comprensión.\n\nTono: urgente pero profesional, enfatizando la importancia de la acción inmediata para mantener la franja horaria seleccionada.\n"
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        -33424,
        -7248
      ],
      "id": "33217e96-d51c-455e-a2ba-8439ffda3331",
      "name": "Basic LLM Notificar No Disponibilidad3",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "4bfbecb3-9d4f-4425-aa76-a92abc7708fb",
              "leftValue": "={{ $('Basic LLM Notificar No Disponibilidad3').item.json.text.length }}",
              "rightValue": 70,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -33024,
        -7072
      ],
      "id": "e1876146-5275-428b-813f-d7b66a9ad885",
      "name": "Validación de longitud de caracteres10"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d9c2ff70-4fd1-4b93-8571-6d0ac5a0093e",
              "name": "mensaje.ia",
              "value": "={{ $('Basic LLM Notificar No Disponibilidad3').item.json.text }}",
              "type": "string"
            },
            {
              "id": "ac8a03be-0292-4735-9580-39a385945c47",
              "name": "mensaje.longitud",
              "value": "={{ $('Basic LLM Notificar No Disponibilidad3').item.json.text.length }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -32720,
        -7040
      ],
      "id": "a28046a8-cef7-4295-a022-1bc7ae93f7ee",
      "name": "Organiza variables del mensaje10"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -32544,
        -7264
      ],
      "id": "d8a8c643-ce67-4eaf-acc4-cf0fb038ed7f",
      "name": "No Operation, do nothing14"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $('Code Respuesta Faltantes').item.json.text }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -32720,
        -7264
      ],
      "id": "60fe29d1-4f41-40f4-89af-83e9001493f0",
      "name": "HTTP Request Enviar Mensaje por WhatsApp13"
    },
    {
      "parameters": {
        "jsCode": "/*\n===========================================================\n  Nodo Code - VALIDAR INSERCIONES EN EXCEL (n8n)\n  • Analiza la salida del “Loop Over Uno a Uno”.\n  • Agrupa los ítems por franja (campo `indice` si existe;\n    de lo contrario, cada bloque de 5 ítems forma una franja).\n  • Verifica que cada inserción tenga:\n        exito === true\n        statusCode === 200\n        falloEstado === false\n  • Devuelve un único objeto JSON con:\n        – Resumen global.\n        – Detalle por franja (éxitos / fallos y celdas con error).\n===========================================================\n*/\n\n// 1) Obtener todos los ítems que llegan al nodo\nconst items = $input.all();\n\n// 2) Función auxiliar para determinar el identificador de la franja\nfunction obtenerIdFranja(item, idx) {\n  // Si existe 'indice', úsalo; de lo contrario agrupa cada 5 ítems\n  if (item.json && item.json.indice !== undefined && item.json.indice !== null) {\n    return String(item.json.indice).trim();\n  }\n  // +1 para que las franjas queden 1-basadas\n  return String(Math.floor(idx / 5) + 1);\n}\n\n// 3) Agrupar ítems por franja\nconst franjas = {};\nitems.forEach((item, idx) => {\n  const idFranja = obtenerIdFranja(item, idx);\n  if (!franjas[idFranja]) {\n    franjas[idFranja] = { id: idFranja, items: [] };\n  }\n  franjas[idFranja].items.push(item.json);\n});\n\n// 4) Analizar cada franja y construir el detalle\nconst detallesPorFranja = Object.values(franjas).map(franja => {\n  const totalOps   = franja.items.length;\n  const exitosas   = franja.items.filter(i =>\n    i.exito === true &&\n    i.statusCode === 200 &&\n    i.falloEstado === false\n  ).length;\n\n  const fallidas   = totalOps - exitosas;\n  const exitoTotal = fallidas === 0;\n\n  // Celdas con error para un diagnóstico claro\n  const celdasFallidas = franja.items\n    .filter(i => !(i.exito && i.statusCode === 200 && !i.falloEstado))\n    .map(i => ({\n      celdaOriginal   : i.celdaOriginal,\n      celdaInsertada  : i.celdaInsertada,\n      statusCode      : i.statusCode,\n      falloEstado     : i.falloEstado,\n      celdasDiferentes: i.celdasDiferentes,\n      mensaje         : 'Inserción fallida'\n    }));\n\n  return {\n    idFranja                : franja.id,\n    exitoFranja             : exitoTotal,\n    operacionesTotales      : totalOps,\n    operacionesExitosas     : exitosas,\n    operacionesFallidas     : fallidas,\n    porcentajeExitosas      : ((exitosas / totalOps) * 100).toFixed(2) + '%',\n    celdasFallidas\n  };\n});\n\n// 5) Resumen global\nconst operacionesTotales   = items.length;\nconst operacionesExitosas  = detallesPorFranja.reduce((sum, f) => sum + f.operacionesExitosas, 0);\nconst operacionesFallidas  = operacionesTotales - operacionesExitosas;\n\nconst franjasTotales   = detallesPorFranja.length;\nconst franjasExitosas  = detallesPorFranja.filter(f => f.exitoFranja).length;\nconst franjasFallidas  = franjasTotales - franjasExitosas;\n\n\nconst resumen = {\n  estadoGeneral              : franjasFallidas === 0 ? 'ÉXITO_COMPLETO' : 'ÉXITO_PARCIAL',\n  franjasTotales,\n  franjasExitosas,\n  franjasFallidas,\n  porcentajeFranjasExitosas  : ((franjasExitosas / franjasTotales) * 100).toFixed(2) + '%',\n  operacionesTotales,\n  operacionesExitosas,\n  operacionesFallidas,\n  porcentajeOperacionesExitosas : ((operacionesExitosas / operacionesTotales) * 100).toFixed(2) + '%',\n  detallesPorFranja\n};\n\n// 6) Devolver un único ítem con el resumen\nreturn [\n  {\n    json: resumen\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -36544,
        -7904
      ],
      "id": "8a02b0f2-1f55-4541-b031-8248a7f4bc91",
      "name": "Code Validar inserciones1"
    },
    {
      "parameters": {
        "jsCode": "// 1) Leer chat_id una sola vez\nconst chatId = $node[\"Organiza el Mensaje\"].json.infoMensaje.chat_id;\n\n// 2) Tomamos los datos de informacionCita una sola vez\nconst cita = $input.first().json.informacionCita || {};\nconst historialMensajes = $('Unificación y consistencia de datos').first().json.infoMensaje.historialMensajes;\n\n// Función para convertir fechas en formato \"06 de mayo de 2025\" a \"YYYY-MM-DD HH:mm:ss\"\nfunction convertirFecha(fechaTexto) {\n  const meses = {\n    enero: '01', febrero: '02', marzo: '03', abril: '04', mayo: '05',\n    junio: '06', julio: '07', agosto: '08', septiembre: '09',\n    octubre: '10', noviembre: '11', diciembre: '12'\n  };\n\n  // Dividir la fecha y mapear el mes\n  const [dia, de, mes, deNuevo, anio] = fechaTexto.split(' ');\n  const mesNumerico = meses[mes.toLowerCase()]; // Convertir el mes a número\n  return `${anio}-${mesNumerico}-${dia.padStart(2, '0')} 00:00:00`; // Formato DATETIME\n}\n\n// Convertimos la fecha aquí\nconst fechaCitaConvertida = convertirFecha(cita.fecha);\n\n// 3) Retornamos un solo objeto con todos los datos necesarios\nreturn {\n  json: {\n    chat_id: chatId,\n    proveedor: cita.proveedor,\n    orden_compra: cita.ordenCompra,\n    peso: cita.peso,\n    unidades: cita.unidades,\n    categoria: cita.categoria,\n    muelle: cita.muelle,\n    fecha_cita: fechaCitaConvertida, // Fecha ya convertida\n    hora_inicio: cita.horaInicio,\n    hora_fin: cita.horaFin,\n    chat_historial: historialMensajes,\n    // Incluimos cualquier otro dato que necesites\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -36544,
        -8048
      ],
      "id": "edab6b85-656f-41fc-867a-fc301ae70ca4",
      "name": "Code Datos Insert Cita1"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "8c501d95-bdf3-4635-a037-224926c2528d",
              "leftValue": "={{ $json.estadoGeneral }}",
              "rightValue": "ÉXITO_COMPLETO",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -36208,
        -7904
      ],
      "id": "483898d1-8445-470c-bf13-9f76567beb8c",
      "name": "If Validar inserciones1"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.1,
      "position": [
        -35904,
        -8032
      ],
      "id": "b0f9ad2a-57f0-4fa4-8941-6243d3588dea",
      "name": "Merge4"
    },
    {
      "parameters": {
        "numberInputs": 3
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.1,
      "position": [
        -33056,
        -7584
      ],
      "id": "7af09118-ad12-404c-b0c2-bfb12d4622b8",
      "name": "Merge5"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO CitasRecepcion\n(\n    chat_id,\n    nombre,              \n    orden_compra,\n    peso,\n    unidades,\n    horas_entrega,\n    categoria,\n    muelle,\n    fecha_cita,\n    hora_inicio,\n    hora_fin,\n    estado,\n    fecha_creacion,\n    fecha_modificacion,\n    chat_historial,\n    chat_historial_datos\n)\n/* ─── AQUÍ ─── */\nOUTPUT INSERTED.id          --  ←  devolverá el IDENTITY de la fila recién insertada\nVALUES\n(\n    '{{ $('Code Datos Insert Cita1').item.json.chat_id }}',\n    '{{ $('Code Datos Insert Cita1').item.json.proveedor }}',\n    '{{ $('Code Datos Insert Cita1').item.json.orden_compra }}',\n     {{ $('Code Datos Insert Cita1').item.json.peso }},\n     {{ $('Code Datos Insert Cita1').item.json.unidades }},\n     {{ $json.horas_entrega }},\n    '{{ $('Code Datos Insert Cita1').item.json.categoria }}',\n    '{{ $('Code Datos Insert Cita1').item.json.muelle }}',\n    '{{ $('Code Datos Insert Cita1').item.json.fecha_cita }}',\n    '{{ $('Code Datos Insert Cita1').item.json.hora_inicio }}',\n    '{{ $('Code Datos Insert Cita1').item.json.hora_fin }}',   \n      'PROGRAMADA',                   \n    (SYSDATETIMEOFFSET() AT TIME ZONE 'SA Pacific Standard Time'), \n    NULL,                            \n    '{{ $items(\"Code Datos Insert Cita1\")\n        .map(i => i.json.chat_historial)\n        .join(\"\\n\")\n        .replace(/'/g,\"''\") }}',\n    'SIN DATOS'\n);\n\n"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        -33616,
        -7824
      ],
      "id": "fa33e3e9-2d2f-486c-893a-1808dc993733",
      "name": "Microsoft SQL Insertar Cita1",
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -32736,
        -7488
      ],
      "id": "0b6570ae-514d-4b33-a627-52f3fc311f83",
      "name": "OpenAI Chat Model16",
      "credentials": {
        "openAiApi": {
          "id": "AD8kPcNVReuclASd",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "4bfbecb3-9d4f-4425-aa76-a92abc7708fb",
              "leftValue": "={{ $('Basic LLM Notificar Cita Exitosa1').item.json.text.length }}",
              "rightValue": 70,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -32208,
        -7520
      ],
      "id": "2f040621-6b32-4e13-adc1-1cd8febdabb2",
      "name": "Validación de longitud de caracteres11"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d9c2ff70-4fd1-4b93-8571-6d0ac5a0093e",
              "name": "mensaje.ia",
              "value": "={{ $('Basic LLM Notificar Cita Exitosa1').item.json.text }}",
              "type": "string"
            },
            {
              "id": "ac8a03be-0292-4735-9580-39a385945c47",
              "name": "mensaje.longitud",
              "value": "={{ $('Basic LLM Notificar Cita Exitosa1').item.json.text.length }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -31904,
        -7408
      ],
      "id": "4ac077fa-e9c2-475b-9191-cbf173297eb6",
      "name": "Organiza variables del mensaje11"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -31744,
        -7632
      ],
      "id": "efe075ad-9b16-4ada-a5e9-18a1e616e40c",
      "name": "No Operation, do nothing15"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $('Code Respuesta Faltantes').item.json.text }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -31920,
        -7632
      ],
      "id": "651ed70b-479f-43a4-b6dc-5e8836effb46",
      "name": "HTTP Request Enviar Mensaje por WhatsApp14"
    },
    {
      "parameters": {
        "promptType": "=define",
        "text": "=# Rol\nEres el asistente virtual de **Konfíe Logistics**.  \nTu objetivo es notificar al proveedor que su cita se **reprogramó con éxito** en el cronograma.\n\n# Datos disponibles  \n- idCita           = {{ $(\"Microsoft SQL Insertar Cita1\").first().json.id }}  \n- fechaCita        = {{ $(\"Code Datos Insert Cita1\").first().json.fecha_cita }}  \n- horaInicio       = {{ $(\"Code Datos Insert Cita1\").first().json.hora_inicio }}  \n- horaFin          = {{ $(\"Code Datos Insert Cita1\").first().json.hora_fin }}  \n- muelle           = {{ $(\"Code Datos Insert Cita1\").first().json.muelle }}  \n- ordenCompra      = {{ $(\"Code Datos Insert Cita1\").first().json.orden_compra }}  \n- categoria        = {{ $(\"Code Datos Insert Cita1\").first().json.categoria }}  \n- pesoKg           = {{ $(\"Code Datos Insert Cita1\").first().json.peso }}  \n- unidades         = {{ $(\"Code Datos Insert Cita1\").first().json.unidades }}\n\n> Ajusta los nombres de nodos/propiedades si tu flujo usa otros.\n\n# Instrucciones de redacción\n1. Mantén un tono profesional, cordial y positivo.  \n2. Empieza con una breve expresión de entusiasmo por la **reprogramación exitosa** (p. ej.: “¡Cita reprogramada con éxito!” o “¡Reprogramación confirmada!”).  \n3. Presenta los **nuevos detalles** de la cita en una lista con viñetas y emojis adecuados:  \n   • 🆔 **Número de cita:** antepón 🔖 → 🔖 {{ $(\"Microsoft SQL Insertar Cita1\").first().json.id }}   \n   • 📅 **Fecha:** {{ $(\"Code Datos Insert Cita1\").first().json.fecha_cita.split(\" \")[0] }}  \n   • ⏰ **Horario:** {{ $(\"Code Datos Insert Cita1\").first().json.hora_inicio }} – {{ $(\"Code Datos Insert Cita1\").first().json.hora_fin }}  \n   • 🚩 **Muelle:** {{ $(\"Code Datos Insert Cita1\").first().json.muelle }}  \n   • 🏷️ **O/C:** {{ $(\"Code Datos Insert Cita1\").first().json.orden_compra }}  \n   • 📦 **Categoría:** {{ $(\"Code Datos Insert Cita1\").first().json.categoria }}  \n   • ⚖️ **Peso:** {{ $(\"Code Datos Insert Cita1\").first().json.peso }} kg  \n   • 📦 **Unidades:** {{ $(\"Code Datos Insert Cita1\").first().json.unidades }}  \n4. Reitera el número de cita con el emoji 🔖 y aclara que con ese número el proveedor podrá **volver a modificar o cancelar** la cita si lo necesita.  \n5. Explica claramente la política: “Las modificaciones o cancelaciones deben solicitarse **hasta un día hábil antes** y **antes de las 4:30 p. m.**; después de ese plazo no podremos realizar cambios.”  \n6. Cierra agradeciendo su colaboración y confirmando que estaremos atentos a su llegada.  \n7. Devuelve **solo** el mensaje final, sin encabezados ni explicaciones adicionales.\n\n# Salida esperada (ejemplo de estilo)\n\n¡Cita reprogramada con éxito! 🎉  \n🔖 Número de cita: 12345  \n📅 El 10 de junio de 2025  \n⏰ De 14:00 a 16:00  \n🚩 Muelle 3  \n🏷️ O/C OC-98765  \n📦 Categoría Electrodomésticos  \n⚖️ 500 kg | 📦 800 u  \n\nRecuerda tu número de cita 🔖 12345 para futuras modificaciones o cancelación.  \nPodrás gestionarla hasta un día hábil antes y antes de las 4:30 p. m.  \n¡Muchas gracias por tu confianza y te esperamos!\n"
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        -32640,
        -7664
      ],
      "id": "086597bd-4a41-44ac-9000-65070c9a3e53",
      "name": "Basic LLM Notificar Cita Exitosa1",
      "alwaysOutputData": true,
      "executeOnce": true
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "BEGIN TRANSACTION;\n\nDELETE FROM MensajesWhatsApp\nWHERE chat_id = '{{ $('Unificación y consistencia de datos').first().json.infoMensaje.chat_id }}'\n   OR (chat_id = 'agenteAI'\n       AND message_id IN (\n           SELECT message_id \n           FROM MensajesWhatsApp\n           WHERE chat_id = '{{ $('Unificación y consistencia de datos').first().json.infoMensaje.chat_id }}'\n       )\n   );\n\nDELETE FROM FranjasDisponiblesTemp \nWHERE chat_id = '{{ $('Unificación y consistencia de datos').first().json.infoMensaje.chat_id }}';\n\nCOMMIT;\n"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        -33616,
        -7360
      ],
      "id": "eb085163-8189-4ae1-b14f-51a41493b417",
      "name": "Microsoft SQL Eliminar Mensajes4",
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "/*  ⬇⬇  PEGAR TODO ESTO EN EL CAMPO “Query” DEL NODO SQL  ⬇⬇  */\n\n/* ───────────────────────────\n   Parámetro recibido de n8n\n   ───────────────────────────\n   Asume que en la sección “Query Parameters” del nodo tienes\n   un parámetro llamado  id   con el valor  {{ $json.id }}\n   (o la propiedad que traiga tu flujo).\n*/\nDECLARE @id           INT = {{ $('Code Validacion de Cita en cronograma para reprogramación').first().json.citaAntigua.id }};          -- parámetro que llega de n8n\nDECLARE @nowBogota    DATETIME;\n\n/* Obtener la fecha/hora actual en zona horaria de Bogotá           */\n/* (SQL Server 2016+ ‑ requiere soporte AT TIME ZONE)                */\nSET @nowBogota =\n    CONVERT(DATETIME, SYSDATETIMEOFFSET() AT TIME ZONE 'SA Pacific Standard Time');\n\n/* ─────────────  UPDATE  ───────────── */\nUPDATE  dbo.CitasRecepcion\nSET     estado            = N'REPROGRAMADA',\n        fecha_modificacion = @nowBogota\nWHERE   id = @id;\n\n/* Devuelve la fila modificada (útil para depurar en n8n) */\nSELECT  *\nFROM    dbo.CitasRecepcion\nWHERE   id = @id;\n"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        -34000,
        -7824
      ],
      "id": "358ebf5f-1c57-489c-8434-15f302675689",
      "name": "Microsoft SQLUpdate Cita Anterior",
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -42032,
        -3440
      ],
      "id": "a99ef981-d81f-4f8d-bbe1-aaa704c7ce21",
      "name": "OpenAI Chat Model17",
      "credentials": {
        "openAiApi": {
          "id": "AD8kPcNVReuclASd",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n\"idCita\": \"\",\n\"ordenCompra\": \"\",\n\"camposFaltantes\": []\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.2,
      "position": [
        -41872,
        -3440
      ],
      "id": "56d3bf01-7dab-421d-a062-a3c4e7931513",
      "name": "Structured Output Parser5"
    },
    {
      "parameters": {
        "promptType": "=define",
        "text": "=# Extracción de datos para cancelación de citas\n\nAnaliza el historial completo de mensajes y el mensaje actual para extraer los datos necesarios para cancelar una cita existente. **Tu única responsabilidad es extraer datos, no validarlos ni tomar decisiones.**\n\n## Datos a extraer\n- ID de la cita (por ejemplo, \"Cita 12345\", \"Número 12345\", etc.)\n- Número de orden de compra asociado a la cita\n\n## Fuentes de datos a analizar\n- Mensaje actual: {{ $('Unificación y consistencia de datos').first().json.infoMensaje.mensajeActual }}\n- Historial de mensajes: {{ $node[\"Unificación y consistencia de datos\"].json[\"infoMensaje\"][\"historialMensajes\"] }}\n\n## Instrucciones específicas\n1. Buscar PRIMERO el ID de la cita en formato numérico en CUALQUIER mensaje previo\n2. Buscar el número de orden de compra en CUALQUIER mensaje previo\n3. Considera expresiones como \"cancelar cita\", \"anular cita\", \"no puedo asistir\", etc.\n4. Si no encuentras alguno de los datos requeridos, márcalo como faltante\n\n## Estructura de salida JSON\n{\n  \"idCita\": string,          // ID de la cita\n  \"ordenCompra\": string,     // Número de orden de compra\n  \"camposFaltantes\": array   // Lista de campos que no pudieron ser extraídos\n}",
        "hasOutputParser": true
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        -41952,
        -3648
      ],
      "id": "9b796e15-865b-4e91-9a0c-b26812d5608f",
      "name": "Basic LLM Extracción Datos Cancelar Cita"
    },
    {
      "parameters": {
        "jsCode": "// Obtener los datos extraídos\nconst datosExtraidos = $('Basic LLM Extracción Datos Cancelar Cita').first().json.output;\n\n// Estructura de respuesta\nconst respuesta = {\n  todoCorrecto: false,\n  idCita: datosExtraidos.idCita || \"\",\n  ordenCompra: datosExtraidos.ordenCompra || \"\",\n  camposFaltantes: datosExtraidos.camposFaltantes || [],\n  mensajeSistema: \"\"\n};\n\n// Verificar si hay campos faltantes\nif (respuesta.camposFaltantes && respuesta.camposFaltantes.length > 0) {\n  respuesta.todoCorrecto = false;\n  respuesta.mensajeSistema = generarMensajeCamposFaltantes(respuesta.camposFaltantes);\n} else {\n  respuesta.todoCorrecto = true;\n  respuesta.mensajeSistema = `Entendido. Estás solicitando cancelar la cita 🔖 ${respuesta.idCita} con orden de compra ${respuesta.ordenCompra}. Verificaré si es posible realizar la cancelación.`;\n}\n\nfunction generarMensajeCamposFaltantes(camposFaltantes) {\n  let mensaje = \"Para poder cancelar tu cita, necesito \";\n  \n  if (camposFaltantes.includes(\"idCita\")) {\n    mensaje += \"el número de cita 🔖 que aparece en tu confirmación, \";\n  }\n  \n  if (camposFaltantes.includes(\"ordenCompra\")) {\n    mensaje += \"el número de orden de compra para verificación, \";\n  }\n  \n  mensaje = mensaje.slice(0, -2) + \". \";\n  mensaje += \"Por ejemplo: 'Quiero cancelar mi cita 12345 con orden de compra ARGM47896'.\";\n  \n  return mensaje;\n}\n\nreturn respuesta;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -41584,
        -3648
      ],
      "id": "26c8ddd8-cb83-4b83-a789-aa3e3665002e",
      "name": "Code Validación datos para cancelación de citas"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "2b68e9c6-bb33-49e0-b323-c6ed61e3d98e",
              "leftValue": "={{ $json.todoCorrecto }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -41376,
        -3648
      ],
      "id": "77d07655-3eb0-48bf-8e7b-1324c460a431",
      "name": "If Validar si los datos están completos"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "DECLARE @Id          INT          = {{ $json.idCita }};\nDECLARE @OrdenCompra VARCHAR(50)  = '{{ $json.ordenCompra }}';\n\nIF EXISTS (SELECT 1\n           FROM   CitasRecepcion\n           WHERE  id           = @Id\n             AND  orden_compra = @OrdenCompra\n             AND  estado       = 'PROGRAMADA')\nBEGIN\n    SELECT *\n    FROM   CitasRecepcion\n    WHERE  id           = @Id\n      AND  orden_compra = @OrdenCompra\n      AND  estado       = 'PROGRAMADA';\nEND\nELSE\nBEGIN\n    -- Código y severidad personalizados\n    THROW 50001, 'La cita no se encuentra en estado PROGRAMADA o los datos no coinciden.', 16;\nEND\n"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        -40944,
        -3824
      ],
      "id": "5826b251-5ec7-40e2-b5bf-8fae15964eae",
      "name": "Microsoft SQL Obtener Cita para Cancelar",
      "alwaysOutputData": true,
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "4bfbecb3-9d4f-4425-aa76-a92abc7708fb",
              "leftValue": "={{ $('If Validar si los datos están completos').first().json.mensajeSistema.length }}",
              "rightValue": 70,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -40352,
        -2944
      ],
      "id": "c250ccd6-a1e9-4669-866b-bc4b4d91158b",
      "name": "Validación de longitud de caracteres12"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d9c2ff70-4fd1-4b93-8571-6d0ac5a0093e",
              "name": "mensaje.ia",
              "value": "={{ $('If Validar si los datos están completos').first().json.mensajeSistema }}",
              "type": "string"
            },
            {
              "id": "ac8a03be-0292-4735-9580-39a385945c47",
              "name": "mensaje.longitud",
              "value": "={{ $('If Validar si los datos están completos').first().json.mensajeSistema.length }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -40048,
        -2864
      ],
      "id": "eb414bff-9899-4d19-a315-9d398276613e",
      "name": "Organiza variables del mensaje12"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -39888,
        -3088
      ],
      "id": "64cb45f2-f6d1-42c8-8978-a016cc13fb66",
      "name": "No Operation, do nothing16"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $('Code Respuesta Faltantes').item.json.text }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -40064,
        -3088
      ],
      "id": "c020b005-7d55-4001-a6de-89557c5208db",
      "name": "HTTP Request Enviar Mensaje por WhatsApp15"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "1cc112df-9a2d-4ad5-acf5-74b0fbadc479",
              "leftValue": "={{ $json.error === undefined }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -40736,
        -3824
      ],
      "id": "94937597-79db-4947-bfe4-c810ce0cf83f",
      "name": "If cita para cancelar"
    },
    {
      "parameters": {
        "jsCode": "// Generar respuesta de error para cita no programada\nfor (const item of $input.all()) {\n  item.json = {\n    \"error\": true,\n    \"mensaje\": \"❌ **Error de validación de datos**\\n\\n\" +\n              \"Los datos ingresados corresponden a una cita que ya fue **cancelada** o **reprogramada**, \" +\n              \"por lo tanto no es posible proceder con la cancelación solicitada.\\n\\n\" +\n              \"📋 **Acciones requeridas:**\\n\" +\n              \"• Verifique que el **número de cita** y **orden de compra** sean correctos\\n\" +\n              \"• Confirme que la cita se encuentre en estado **PROGRAMADA**\\n\" +\n              \"• Intente nuevamente con los datos correctos\\n\\n\" +\n              \"🔄 **Por temas de trazabilidad del historial de mensajes, esta conversación será eliminada.**\\n\\n\" +\n              \"Por favor inicie un **nuevo chat** y proporcione la información correcta para proceder con la cancelación.\",\n    \"codigo_error\": \"CITA_NO_PROGRAMADA\",\n    \"accion_requerida\": \"REINICIAR_CONVERSACION\",\n    \"timestamp\": new Date().toISOString()\n  };\n}\n\nreturn $input.all();"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -40448,
        -3648
      ],
      "id": "670c7543-e0dc-48d8-9350-593082a20ee2",
      "name": "Code respuesta cita no programada"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "4bfbecb3-9d4f-4425-aa76-a92abc7708fb",
              "leftValue": "={{ $('Code respuesta cita no programada').first().json.mensaje.length }}",
              "rightValue": 70,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -40096,
        -3408
      ],
      "id": "29ba6f12-3841-4fe3-bb66-33cf279b5753",
      "name": "Validación de longitud de caracteres13"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d9c2ff70-4fd1-4b93-8571-6d0ac5a0093e",
              "name": "mensaje.ia",
              "value": "={{ $('Code respuesta cita no programada').first().json.mensaje }}",
              "type": "string"
            },
            {
              "id": "ac8a03be-0292-4735-9580-39a385945c47",
              "name": "mensaje.longitud",
              "value": "={{ $('Code respuesta cita no programada').first().json.mensaje.length }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -39808,
        -3312
      ],
      "id": "7ef60f4e-15b6-4923-b7aa-96c40c2ba241",
      "name": "Organiza variables del mensaje13"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -39632,
        -3552
      ],
      "id": "3de6ddec-bac8-4e27-8e3c-a258eb3ab431",
      "name": "No Operation, do nothing17"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $('Code Respuesta Faltantes').item.json.text }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -39808,
        -3552
      ],
      "id": "90ceadbf-bb10-40f2-927f-2457eb6851ea",
      "name": "HTTP Request Enviar Mensaje por WhatsApp16"
    },
    {
      "parameters": {
        "url": "https://graph.microsoft.com/v1.0/sites/a592f886-4560-4e62-9646-1eee7add7abe/drives/b!hviSpWBFYk6WRh7uet16vnNAUYuuQRlGj3ZyS9kSvGVZ4DSg6c5MRqYYm2MdAER8/items/01PPLUUYXY5E2GK3SJ25EZLJPUYJ43H3ME/content",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "microsoftOAuth2Api",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "file",
              "outputPropertyName": "ExcelMallaRecibido2025"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -40304,
        -4352
      ],
      "id": "0cbad914-c5f4-4510-b2d9-16254ee6de22",
      "name": "HTTP Request MALLA DE RECIBO 3",
      "credentials": {
        "microsoftOAuth2Api": {
          "id": "mh8Z8hxFvd7LDO8D",
          "name": "CuentaMy SharePoint App Desarrollador1 Konfie "
        }
      }
    },
    {
      "parameters": {
        "operation": "xlsx",
        "binaryPropertyName": "ExcelMallaRecibido2025",
        "options": {
          "sheetName": "={{ $('Unificación y consistencia de datos').item.json.hojaSeleccionada }}"
        }
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -40048,
        -4464
      ],
      "id": "bc8870dd-6f3a-4443-b599-d5b0db364d9a",
      "name": "Extract MALLA DE RECIBO 3"
    },
    {
      "parameters": {
        "jsCode": "// Obtener los datos del Excel\nconst excelData = $input.all();\nconst hojaSeleccionada = $('Unificación y consistencia de datos').first().json.hojaSeleccionada;\n\n// Obtener hora local en Bogotá\nconst ahora = new Date(new Date().toLocaleString(\"en-US\", { timeZone: \"America/Bogota\" }));\nconst diaSemanaActual = ahora.getDay(); // 0=domingo, 1=lunes, ..., 5=viernes\nconst horaActual = ahora.getHours();\nconst minutosActual = ahora.getMinutes();\n// Determinar si es después de las 16:30\nconst pasoLimiteDia = horaActual > 16 || (horaActual === 16 && minutosActual >= 30);\n\n// Definir estructura de la semana y los días\nconst diasSemana = ['lunes', 'martes', 'miércoles', 'jueves', 'viernes'];\n\n// Mapeo para saber qué días incluir si hoy es x día y pasó el límite\n/**\n * Dado el día de la semana actual (0=domingo ... 6=sábado),\n * devuelve qué días de la semana actual deben incluirse según si pasó el límite.\n */\nfunction diasValidosSemanaActual(diaSemanaActual, pasoLimite) {\n  const mapa = {\n    1: ['martes', 'miércoles', 'jueves', 'viernes'],   // lunes\n    2: ['miércoles', 'jueves', 'viernes'],             // martes\n    3: ['jueves', 'viernes'],                          // miércoles\n    4: ['viernes'],                                     // jueves\n    5: []                                               // viernes (muy tarde para sábado)\n  };\n  if (diaSemanaActual < 1 || diaSemanaActual > 5) {\n    return []; // sábado o domingo no se agendan en semana actual\n  }\n  if (!pasoLimite) {\n    // aún está antes de las 4:30 p.m., se puede incluir el día siguiente\n    const siguiente = diasSemana[diaSemanaActual];\n    return [siguiente, ...mapa[diaSemanaActual]];\n  }\n  return mapa[diaSemanaActual];\n}\n\n// Objeto para almacenar la malla estructurada\nconst mallaEstructurada = {\n  titulo: \"\",\n  año: \"\",\n  semana: \"\",\n  rangoDias: \"\",\n  franjas: [],\n  dias: {}\n};\n\n// Tabla de meses y días. Ajusta si necesitas contemplar bisiestos, etc.\nconst meses = {\n  \"enero\": 1,\n  \"febrero\": 2,\n  \"marzo\": 3,\n  \"abril\": 4,\n  \"mayo\": 5,\n  \"junio\": 6,\n  \"julio\": 7,\n  \"agosto\": 8,\n  \"septiembre\": 9,\n  \"octubre\": 10,\n  \"noviembre\": 11,\n  \"diciembre\": 12\n};\n\nconst nombreMes = {\n  1: \"enero\",\n  2: \"febrero\",\n  3: \"marzo\",\n  4: \"abril\",\n  5: \"mayo\",\n  6: \"junio\",\n  7: \"julio\",\n  8: \"agosto\",\n  9: \"septiembre\",\n  10: \"octubre\",\n  11: \"noviembre\",\n  12: \"diciembre\"\n};\n\n/**\n * Función para determinar si un año es bisiesto\n * Un año es bisiesto si es divisible por 4, excepto aquellos divisibles por 100 \n * que no son divisibles por 400\n */\nfunction esBisiesto(year) {\n  return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);\n}\n\n/**\n * Función para obtener el número de días en un mes, considerando años bisiestos\n */\nfunction getDiasMes(mes, año) {\n  const diasPorMes = {\n    1: 31, // enero\n    2: esBisiesto(año) ? 29 : 28, // febrero - ajustado para año bisiesto\n    3: 31, // marzo\n    4: 30, // abril\n    5: 31, // mayo\n    6: 30, // junio\n    7: 31, // julio\n    8: 31, // agosto\n    9: 30, // septiembre\n    10: 31, // octubre\n    11: 30, // noviembre\n    12: 31  // diciembre\n  };\n  \n  return diasPorMes[mes];\n}\n\n/**\n * Función para eliminar acentos y pasar a minúsculas (para buscar palabras clave sin importar tildes ni mayúsculas).\n */\nfunction normalizarTexto(texto) {\n  if (typeof texto !== 'string') return \"\";\n  // Normaliza (NFD) y elimina diacríticos, luego pasa a minúsculas.\n  return texto\n    .normalize(\"NFD\")\n    .replace(/[\\u0300-\\u036f]/g, \"\") // quita acentos\n    .toLowerCase();\n}\n\n/**\n * Dada la información de proveedor, ordenCompra, peso, categoría y unidades,\n * revisa si existe la palabra 'fuera de servicio', 'cancelado' o 'reagendado'\n * en cualquiera de esos campos. De ser así, retorna ese estado especial;\n * de lo contrario, retorna 'ocupado'.\n * \n * Se ignoran mayúsculas, minúsculas y tildes.\n */\nfunction determinarEstadoOcupado(proveedor, ordenCompra, peso, categoria, unidades) {\n  const conjunto = `${proveedor} ${ordenCompra} ${peso} ${categoria} ${unidades}`;\n  const texto = normalizarTexto(conjunto);\n\n  if (texto.includes(\"fuera de servicio\")) {\n    return \"fuera de servicio\";\n  }\n  if (texto.includes(\"cancelado\")) {\n    return \"cancelado\";\n  }\n  if (texto.includes(\"reagendado\")) {\n    return \"reagendado\";\n  }\n  return \"ocupado\";  \n}\n\n// -------------------------------------------------------------\n// 1) PROCESAR DATOS (Cabecera, Horas, Muelles, etc.)\n// -------------------------------------------------------------\nfunction procesarDatos(excelData) {\n  const datos = excelData.map(item => item.json);\n  \n  // A) Cabecera (Título, Año, Rango)\n  datos.forEach((dato, index) => {\n    // Buscar título\n    if (dato.__EMPTY_2 === \"MALLA DE RECIBO CEDI KONFIE IA\") {\n      mallaEstructurada.titulo = dato.__EMPTY_2;\n      \n      // En la siguiente fila puede estar año, semana, rango\n      if (index + 1 < datos.length) {\n        const datoSiguiente = datos[index + 1];\n        if (datoSiguiente) {\n          // Año\n          if (datoSiguiente.__EMPTY_2 && !isNaN(datoSiguiente.__EMPTY_2)) {\n            mallaEstructurada.año = datoSiguiente.__EMPTY_2;\n          }\n          // Semana\n          Object.entries(datoSiguiente).forEach(([k, v]) => {\n            if (typeof v === 'string' && v.includes(\"SEMANA\")) {\n              mallaEstructurada.semana = v;\n            }\n          });\n          // Rango: p.ej. \"LUNES 31 AL VIERNES 4 DE ABRIL\"\n          Object.entries(datoSiguiente).forEach(([k, v]) => {\n            if (typeof v === 'string' && v.includes(\"LUNES\") && v.includes(\"VIERNES\")) {\n              mallaEstructurada.rangoDias = v;\n            }\n          });\n        }\n      }\n    }\n  });\n  \n  // B) Detectar franjas horarias (.__EMPTY = fracción de día)\n  const franjasHorarias = [];\n  datos.forEach(dato => {\n    if (\n      dato.__EMPTY !== undefined &&\n      typeof dato.__EMPTY === 'number' &&\n      dato.__EMPTY > 0 &&\n      dato.__EMPTY < 1\n    ) {\n      const totalMin = Math.round(dato.__EMPTY * 24 * 60);\n      const hh = Math.floor(totalMin / 60);\n      const mm = totalMin % 60;\n      \n      let periodo = \"AM\";\n      let hora12 = hh;\n      if (hh >= 12) {\n        periodo = \"PM\";\n        hora12 = (hh === 12 ? 12 : hh - 12);\n      }\n      if (hh === 0) {\n        hora12 = 12;\n      }\n      \n      const horaStr = `${hora12}:${String(mm).padStart(2, '0')} ${periodo}`;\n      franjasHorarias.push({\n        hora: horaStr,\n        indice: datos.indexOf(dato) // fila base\n      });\n    }\n  });\n  franjasHorarias.sort((a, b) => a.indice - b.indice);\n  mallaEstructurada.franjas = franjasHorarias;\n  \n  // C) Detectar muelles (col)\n  const muellesInfo = {};\n  datos.forEach(dato => {\n    Object.entries(dato).forEach(([key, value]) => {\n      if (value === \"MUELLE 01\" || value === \"MUELLE 02\") {\n        const col = parseInt(key.replace(\"__EMPTY_\", \"\"), 10);\n        const muelleKey = (value === \"MUELLE 01\") ? 'muelle1' : 'muelle2';\n        if (!muellesInfo[muelleKey]) {\n          muellesInfo[muelleKey] = [];\n        }\n        muellesInfo[muelleKey].push(col);\n      }\n    });\n  });\n  if (muellesInfo.muelle1) muellesInfo.muelle1.sort((a, b) => a - b);\n  if (muellesInfo.muelle2) muellesInfo.muelle2.sort((a, b) => a - b);\n  \n  // D) Generar los 5 días (lunes-viernes) con su fecha\n  parsearRangoDias();\n  \n  // E) Extraer Citas\n  extraerCitas(datos, muellesInfo);\n  \n  return mallaEstructurada;\n}\n\n/**\n * Parsea la cadena \"LUNES 31 AL VIERNES 4 DE ABRIL\"\n * (o \"LUNES 31 AL VIERNES 04 DE ABRIL\") y maneja el cruce de mes.\n * Ej.: si dayStart=31 y dayEnd=4, la 1ª fecha es 31 de MARZO,\n * luego 1,2,3,4 de ABRIL, en vez de 32,33, etc.\n */\nfunction parsearRangoDias() {\n  const texto = mallaEstructurada.rangoDias;\n  // Regex simple: p.ej. \"31 AL ... 4 DE ABRIL\"\n  // Captura: dayStart, dayEnd, mesFin\n  // Ojo: si dice \"LUNES 31 DE MARZO AL VIERNES 4 DE ABRIL\",\n  // quedará: dayStart=31, dayEnd=4, month=ABRIL (al final).\n  const regex = /(\\d+)\\s+AL\\s+\\D+(\\d+)\\s+DE\\s+(\\w+)/i;\n  const match = regex.exec(texto);\n  \n  // Por defecto, creamos 5 días vacíos sin fecha\n  diasSemana.forEach(d => {\n    mallaEstructurada.dias[d] = {\n      muelle1: {},\n      muelle2: {}\n    };\n  });\n  \n  if (!match) {\n    // Sin coincidencia, dejamos los días sin fecha\n    return;\n  }\n  \n  const dayStart = parseInt(match[1], 10); // 31\n  const dayEnd   = parseInt(match[2], 10); // 4\n  const finalMonthName = match[3].toLowerCase(); // \"abril\"\n  \n  // Convertimos a número\n  const finalMonth = meses[finalMonthName] || 3; // fallback marzo\n  const yearNum = parseInt(mallaEstructurada.año, 10) || 2025;\n  \n  // Función para obtener la fecha formateada\n  function fechaFormateada(d, m, y) {\n    return `${d} de ${nombreMes[m]} de ${y}`;\n  }\n  \n  // Comprobamos cuántos días tiene el mes final, considerando bisiestos\n  const diasMesFinal = getDiasMes(finalMonth, yearNum);\n  // y del mes previo\n  const monthPrev = (finalMonth === 1) ? 12 : finalMonth - 1;\n  const yearPrev = (finalMonth === 1) ? yearNum - 1 : yearNum;\n  \n  // Arreglo final con 5 fechas\n  const fechasDias = [];\n  \n  if (dayStart <= dayEnd) {\n    // Caso \"normal\": todo en el mismo mes\n    let d = dayStart;\n    for (let i = 0; i < 5; i++) {\n      fechasDias.push({\n        diaSem: diasSemana[i],\n        diaNum: d,\n        mesNum: finalMonth,\n        yearNum: yearNum\n      });\n      d++;\n      if (d > diasMesFinal) {\n        d = 1;\n        const nextMonth = finalMonth % 12 + 1;\n        const nextYear = (nextMonth === 1) ? yearNum + 1 : yearNum;\n        fechasDias[fechasDias.length - 1].mesNum = nextMonth;\n        fechasDias[fechasDias.length - 1].yearNum = nextYear;\n      }\n    }\n  } else {\n    // Caso \"cruza de mes\": dayStart > dayEnd\n    let d = dayStart;\n    let m = monthPrev;\n    let y = yearPrev;\n    \n    for (let i = 0; i < 5; i++) {\n      fechasDias.push({\n        diaSem: diasSemana[i],\n        diaNum: d,\n        mesNum: m,\n        yearNum: y\n      });\n      d++;\n      if (d > getDiasMes(m, y)) {\n        d = 1;\n        m = m % 12 + 1;\n        if (m === 1) {\n          y++;\n        }\n      }\n    }\n  }\n  \n  // Ahora volcamos esas 5 fechas en la estructura\n  fechasDias.forEach(fd => {\n    const { diaSem, diaNum, mesNum, yearNum } = fd;\n    mallaEstructurada.dias[diaSem] = {\n      fechaDia: fechaFormateada(diaNum, mesNum, yearNum),\n      muelle1: {},\n      muelle2: {}\n    };\n  });\n  \n  // Inicializamos las franjas a 'disponible'\n  if (mallaEstructurada.franjas.length > 0) {\n    diasSemana.forEach(d => {\n      mallaEstructurada.franjas.forEach(f => {\n        mallaEstructurada.dias[d].muelle1[f.hora] = {\n          estado: \"disponible\",\n          proveedor: \"\",\n          ordenCompra: \"\",\n          peso: \"\",\n          categoria: \"\",\n          unidades: \"\"\n        };\n        mallaEstructurada.dias[d].muelle2[f.hora] = {\n          estado: \"disponible\",\n          proveedor: \"\",\n          ordenCompra: \"\",\n          peso: \"\",\n          categoria: \"\",\n          unidades: \"\"\n        };\n      });\n    });\n  }\n}\n\n/**\n * Función auxiliar: decide a qué día pertenece una columna,\n * corrigiendo 2 columnas de offset (porque 'Extract from XLSX'\n * deja todo desplazado).\n */\nfunction getDayForColumn(colNumber) {\n  // Ajuste de offset +2\n  const realCol = colNumber + 2;\n\n  // Rangos:\n  //  Lunes:      3..8\n  //  Martes:     9..14\n  //  Miércoles: 15..20\n  //  Jueves:    21..26\n  //  Viernes:   27..32\n  if (realCol >= 3 && realCol <= 8) {\n    return \"lunes\";\n  }\n  if (realCol >= 9 && realCol <= 14) {\n    return \"martes\";\n  }\n  if (realCol >= 15 && realCol <= 20) {\n    return \"miércoles\";\n  }\n  if (realCol >= 21 && realCol <= 26) {\n    return \"jueves\";\n  }\n  if (realCol >= 27 && realCol <= 32) {\n    return \"viernes\";\n  }\n  // Si nada coincide, devolvemos null\n  return null;\n}\n\n/**\n * Extraer las citas para cada franja:\n * - Para cada franja, miramos 3 filas:\n *    - Fila base => proveedor\n *    - Fila base+1 => orden\n *    - Fila base+2 => peso, categoría, unidades\n */\nfunction extraerCitas(datos, muellesInfo) {\n  mallaEstructurada.franjas.forEach(franja => {\n    const indiceBase = franja.indice;\n    if (indiceBase < 0 || indiceBase + 2 >= datos.length) {\n      return; // no hay suficientes filas\n    }\n    \n    // Recorremos muelle1, muelle2 y sus columnas\n    const asignarCita = (muelleKey, cols) => {\n      cols.forEach(col => {\n        const provKey = `__EMPTY_${col}`;\n        const filaProv = datos[indiceBase];\n        \n        // Si en esta fila hay un proveedor o algún texto\n        if (\n          filaProv &&\n          typeof filaProv[provKey] === 'string' &&\n          filaProv[provKey].length > 2\n        ) {\n          // Determinar el día real\n          const diaOk = getDayForColumn(col);\n          if (!diaOk || !mallaEstructurada.dias[diaOk]) {\n            return; // si no coincide con ninguno, saltamos\n          }\n          \n          // Recuperar valores para proveedor, ordenCompra y demás\n          const filaOrden = datos[indiceBase + 1];\n          const filaDet = datos[indiceBase + 2];\n          \n          const proveedor = filaProv[provKey] || \"\";\n          const ordenCompra = filaOrden && filaOrden[provKey] ? filaOrden[provKey] : \"\";\n          const peso = filaDet && filaDet[provKey] ? filaDet[provKey] : \"\";\n          const cat  = filaDet && filaDet[`__EMPTY_${col + 1}`] ? filaDet[`__EMPTY_${col + 1}`] : \"\";\n          const und  = filaDet && filaDet[`__EMPTY_${col + 2}`] ? filaDet[`__EMPTY_${col + 2}`] : \"\";\n          \n          // Antes poníamos estado=\"ocupado\" directamente\n          // Ahora verificamos si el texto contiene \"reagendado\", \"cancelado\" o \"fuera de servicio\".\n          const nuevoEstado = determinarEstadoOcupado(proveedor, ordenCompra, peso, cat, und);\n          \n          // Asignamos los datos\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].estado = nuevoEstado;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].proveedor = proveedor;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].ordenCompra = ordenCompra;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].peso = peso;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].categoria = cat;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].unidades = und;\n        }\n      });\n    };\n    \n    if (muellesInfo.muelle1) {\n      asignarCita('muelle1', muellesInfo.muelle1);\n    }\n    if (muellesInfo.muelle2) {\n      asignarCita('muelle2', muellesInfo.muelle2);\n    }\n  });\n}\n\n// -------------------------------------------------------------\n// 2) FUNCIONES PARA CONSULTAR LA MALLA\n// -------------------------------------------------------------\nfunction buscarFranjasDisponibles(categoria, duracionHoras) {\n  const muelle = \"muelle1\"; // Ajusta si usas \"categoria -> muelle\" real\n  \n  const franjasDisponibles = [];\n  Object.keys(mallaEstructurada.dias).forEach(dia => {\n    const libres = [];\n    for (let i = 0; i <= mallaEstructurada.franjas.length - duracionHoras; i++) {\n      let disponible = true;\n      for (let h = 0; h < duracionHoras; h++) {\n        const idxF = i + h;\n        const horaAct = mallaEstructurada.franjas[idxF].hora;\n        if (\n          mallaEstructurada.dias[dia][muelle][horaAct].estado !== 'disponible'\n        ) {\n          disponible = false;\n          break;\n        }\n      }\n      if (disponible) {\n        libres.push({\n          horaInicio: mallaEstructurada.franjas[i].hora,\n          duracion: duracionHoras\n        });\n      }\n    }\n    if (libres.length > 0) {\n      franjasDisponibles.push({ dia, franjas: libres });\n    }\n  });\n  return franjasDisponibles;\n}\n\nfunction buscarCitasProveedor(nombreProveedor) {\n  const citas = [];\n  Object.keys(mallaEstructurada.dias).forEach(dia => {\n    const muelle1 = mallaEstructurada.dias[dia].muelle1;\n    const muelle2 = mallaEstructurada.dias[dia].muelle2;\n    mallaEstructurada.franjas.forEach(f => {\n      const hora = f.hora;\n      // muelle1\n      if (normalizarTexto(muelle1[hora].proveedor) === normalizarTexto(nombreProveedor)) {\n        citas.push({\n          dia,\n          hora,\n          muelle: \"Muelle 01\",\n          ordenCompra: muelle1[hora].ordenCompra,\n          peso: muelle1[hora].peso,\n          categoria: muelle1[hora].categoria,\n          unidades: muelle1[hora].unidades,\n          estado: muelle1[hora].estado\n        });\n      }\n      // muelle2\n      if (normalizarTexto(muelle2[hora].proveedor) === normalizarTexto(nombreProveedor)) {\n        citas.push({\n          dia,\n          hora,\n          muelle: \"Muelle 02\",\n          ordenCompra: muelle2[hora].ordenCompra,\n          peso: muelle2[hora].peso,\n          categoria: muelle2[hora].categoria,\n          unidades: muelle2[hora].unidades,\n          estado: muelle2[hora].estado\n        });\n      }\n    });\n  });\n  return citas;\n}\n\nfunction consultarFranjasDisponibles(categoria, duracionHoras) {\n  return buscarFranjasDisponibles(categoria, duracionHoras);\n}\n\nfunction consultarCitasProveedor(nombreProveedor) {\n  return buscarCitasProveedor(nombreProveedor);\n}\n\nfunction obtenerInfoMalla() {\n  return {\n    titulo: mallaEstructurada.titulo,\n    año: mallaEstructurada.año,\n    semana: mallaEstructurada.semana,\n    rangoDias: mallaEstructurada.rangoDias,\n    franjas: mallaEstructurada.franjas.map(f => f.hora)\n  };\n}\n\nfunction estaDisponible(dia, hora, muelle) {\n  const info = mallaEstructurada.dias[dia]?.[muelle]?.[hora];\n  return info ? (info.estado === 'disponible') : false;\n}\n\nfunction obtenerCoordenadasCita(dia, hora, muelle) {\n  // Ajustar con tu mapeo de celdas en Excel\n  return {\n    proveedor: `${dia}_${hora}_${muelle}_proveedor`,\n    ordenCompra: `${dia}_${hora}_${muelle}_ordenCompra`,\n    peso: `${dia}_${hora}_${muelle}_peso`,\n    categoria: `${dia}_${hora}_${muelle}_categoria`,\n    unidades: `${dia}_${hora}_${muelle}_unidades`\n  };\n}\n\n// -------------------------------------------------------------\n// 3) EJECUTAR TODO Y RETORNAR\n// -------------------------------------------------------------\n// Procesar todos los datos\nconst malla = procesarDatos(excelData);\n\n// Aplicar el filtro de días válidos según la hora actual\nconst diasPermitidos = diasValidosSemanaActual(diaSemanaActual, pasoLimiteDia);\nObject.keys(malla.dias).forEach(dia => {\n  if (!diasPermitidos.includes(dia)) {\n    delete malla.dias[dia]; // eliminar días no válidos\n  }\n});\n\nconst resultado = {\n  datosMalla: malla,\n  funciones: {\n    consultarFranjasDisponibles,\n    consultarCitasProveedor,\n    obtenerInfoMalla,\n    estaDisponible,\n    obtenerCoordenadasCita\n  }\n};\n\nreturn [resultado];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -39808,
        -4464
      ],
      "id": "6407f372-d1a3-4253-88ad-33e39eeb4e0e",
      "name": "Estructuración, Datos, Consulta, Citas4"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.1,
      "position": [
        -39488,
        -4368
      ],
      "id": "2a9f26e9-d6c7-4113-a114-2e246d768701",
      "name": "Merge datos Excel4"
    },
    {
      "parameters": {
        "jsCode": "return [{\n  json: {\n    datosMalla: $items(\"Merge datos Excel4\")[0].json.datosMalla,\n    datosMallaProxSemana: $items(\"Merge datos Excel4\")[1].json.datosMallaProxSemana,\n    hojaSeleccionada: $items(\"Merge datos Excel4\")[0].json.datosMalla.semana\n  }\n}];\n\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -39248,
        -4368
      ],
      "id": "10d5ac60-236c-4c6b-99eb-27529295fa0c",
      "name": "Unificación y consistencia de datos5"
    },
    {
      "parameters": {
        "operation": "xlsx",
        "binaryPropertyName": "ExcelMallaRecibido2025",
        "options": {
          "sheetName": "={{    (function() {     const semanaActual = $('Unificación y consistencia de datos').item.json.hojaSeleccionada;     const numeroSemana = parseInt(semanaActual.replace(\"SEMANA \", \"\"));     return `SEMANA ${numeroSemana + 1}`;   })() }}"
        }
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -40048,
        -4272
      ],
      "id": "03e05664-282c-4008-94b3-bbcddb90139c",
      "name": "Extract MALLA DE RECIBO Semana Siguiente4",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Si el nodo anterior no devolvió datos (por error al no existir la hoja), retornamos estructura vacía con mensaje\n// Obtener los datos del Excel\nconst excelData = $input.all();\n\n// Mejora en la detección de errores: verificar si hay error explícito o si los datos no son válidos\nconst hayError = excelData.some(item => item.json && item.json.error);\nconst datosInvalidos = !excelData || excelData.length === 0 || hayError;\n\nif (datosInvalidos) {\n  return [{\n    datosMallaProxSemana: {\n      titulo: \"⚠️ La malla de la próxima semana no existe en el archivo Excel o aún no ha sido creada.\",\n      año: \"\",\n      semana: \"\",\n      rangoDias: \"\",\n      franjas: [],\n      dias: {\n        lunes: { muelle1: {}, muelle2: {} },\n        martes: { muelle1: {}, muelle2: {} },\n        miércoles: { muelle1: {}, muelle2: {} },\n        jueves: { muelle1: {}, muelle2: {} },\n        viernes: { muelle1: {}, muelle2: {} }\n      }\n    },\n    funciones: {\n      consultarFranjasDisponibles: \"function not available\",\n      consultarCitasProveedor: \"function not available\",\n      obtenerInfoMalla: \"function not available\",\n      estaDisponible: \"function not available\",\n      obtenerCoordenadasCita: \"function not available\"\n    }\n  }];\n}\n\n// El resto del código permanece igual...\nconst hojaSeleccionada = $('Unificación y consistencia de datos').first().json.hojaSeleccionada;\n\n// Definir estructura de la semana y los días\nconst diasSemana = ['lunes', 'martes', 'miércoles', 'jueves', 'viernes'];\n\n// Objeto para almacenar la malla estructurada\nconst mallaEstructurada = {\n  titulo: \"\",\n  año: \"\",\n  semana: \"\",\n  rangoDias: \"\",\n  franjas: [],\n  dias: {}\n};\n\n// Tabla de meses y días. Ajusta si necesitas contemplar bisiestos, etc.\nconst meses = {\n  \"enero\": 1,\n  \"febrero\": 2,\n  \"marzo\": 3,\n  \"abril\": 4,\n  \"mayo\": 5,\n  \"junio\": 6,\n  \"julio\": 7,\n  \"agosto\": 8,\n  \"septiembre\": 9,\n  \"octubre\": 10,\n  \"noviembre\": 11,\n  \"diciembre\": 12\n};\n\nconst nombreMes = {\n  1: \"enero\",\n  2: \"febrero\",\n  3: \"marzo\",\n  4: \"abril\",\n  5: \"mayo\",\n  6: \"junio\",\n  7: \"julio\",\n  8: \"agosto\",\n  9: \"septiembre\",\n  10: \"octubre\",\n  11: \"noviembre\",\n  12: \"diciembre\"\n};\n\n/**\n * Función para determinar si un año es bisiesto\n * Un año es bisiesto si es divisible por 4, excepto aquellos divisibles por 100 \n * que no son divisibles por 400\n */\nfunction esBisiesto(year) {\n  return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);\n}\n\n/**\n * Función para obtener el número de días en un mes, considerando años bisiestos\n */\nfunction getDiasMes(mes, año) {\n  const diasPorMes = {\n    1: 31, // enero\n    2: esBisiesto(año) ? 29 : 28, // febrero - ajustado para año bisiesto\n    3: 31, // marzo\n    4: 30, // abril\n    5: 31, // mayo\n    6: 30, // junio\n    7: 31, // julio\n    8: 31, // agosto\n    9: 30, // septiembre\n    10: 31, // octubre\n    11: 30, // noviembre\n    12: 31  // diciembre\n  };\n  \n  return diasPorMes[mes];\n}\n\n/**\n * Función para eliminar acentos y pasar a minúsculas (para buscar palabras clave sin importar tildes ni mayúsculas).\n */\nfunction normalizarTexto(texto) {\n  if (typeof texto !== 'string') return \"\";\n  // Normaliza (NFD) y elimina diacríticos, luego pasa a minúsculas.\n  return texto\n    .normalize(\"NFD\")\n    .replace(/[\\u0300-\\u036f]/g, \"\") // quita acentos\n    .toLowerCase();\n}\n\n/**\n * Dada la información de proveedor, ordenCompra, peso, categoría y unidades,\n * revisa si existe la palabra 'fuera de servicio', 'cancelado' o 'reagendado'\n * en cualquiera de esos campos. De ser así, retorna ese estado especial;\n * de lo contrario, retorna 'ocupado'.\n * \n * Se ignoran mayúsculas, minúsculas y tildes.\n */\nfunction determinarEstadoOcupado(proveedor, ordenCompra, peso, categoria, unidades) {\n  const conjunto = `${proveedor} ${ordenCompra} ${peso} ${categoria} ${unidades}`;\n  const texto = normalizarTexto(conjunto);\n\n  if (texto.includes(\"fuera de servicio\")) {\n    return \"fuera de servicio\";\n  }\n  if (texto.includes(\"cancelado\")) {\n    return \"cancelado\";\n  }\n  if (texto.includes(\"reagendado\")) {\n    return \"reagendado\";\n  }\n  return \"ocupado\";  \n}\n\n// -------------------------------------------------------------\n// 1) PROCESAR DATOS (Cabecera, Horas, Muelles, etc.)\n// -------------------------------------------------------------\nfunction procesarDatos(excelData) {\n  // Verificación adicional de datos válidos\n  if (!excelData || !Array.isArray(excelData) || excelData.length === 0) {\n    return {\n      titulo: \"⚠️ La malla de la próxima semana no existe en el archivo Excel o aún no ha sido creada.\",\n      año: \"\",\n      semana: \"\",\n      rangoDias: \"\",\n      franjas: [],\n      dias: {\n        lunes: { muelle1: {}, muelle2: {} },\n        martes: { muelle1: {}, muelle2: {} },\n        miércoles: { muelle1: {}, muelle2: {} },\n        jueves: { muelle1: {}, muelle2: {} },\n        viernes: { muelle1: {}, muelle2: {} }\n      }\n    };\n  }\n  \n  // Intentar mapear datos, con manejo de errores para cada item\n  const datos = excelData.map(item => {\n    try {\n      return item.json || {};\n    } catch (e) {\n      return {};\n    }\n  });\n  \n  // A) Cabecera (Título, Año, Rango)\n  datos.forEach((dato, index) => {\n    // Buscar título\n    if (dato.__EMPTY_2 === \"MALLA DE RECIBO CEDI KONFIE IA\") {\n      mallaEstructurada.titulo = dato.__EMPTY_2;\n      \n      // En la siguiente fila puede estar año, semana, rango\n      if (index + 1 < datos.length) {\n        const datoSiguiente = datos[index + 1];\n        if (datoSiguiente) {\n          // Año\n          if (datoSiguiente.__EMPTY_2 && !isNaN(datoSiguiente.__EMPTY_2)) {\n            mallaEstructurada.año = datoSiguiente.__EMPTY_2;\n          }\n          // Semana\n          Object.entries(datoSiguiente).forEach(([k, v]) => {\n            if (typeof v === 'string' && v.includes(\"SEMANA\")) {\n              mallaEstructurada.semana = v;\n            }\n          });\n          // Rango: p.ej. \"LUNES 31 AL VIERNES 4 DE ABRIL\"\n          Object.entries(datoSiguiente).forEach(([k, v]) => {\n            if (typeof v === 'string' && v.includes(\"LUNES\") && v.includes(\"VIERNES\")) {\n              mallaEstructurada.rangoDias = v;\n            }\n          });\n        }\n      }\n    }\n  });\n  \n  // Si después de procesar no encontramos título, es que no hay malla válida\n  if (!mallaEstructurada.titulo) {\n    mallaEstructurada.titulo = \"⚠️ La malla de la próxima semana no existe en el archivo Excel o aún no ha sido creada.\";\n    return mallaEstructurada;\n  }\n  \n  // B) Detectar franjas horarias (.__EMPTY = fracción de día)\n  const franjasHorarias = [];\n  datos.forEach(dato => {\n    if (\n      dato.__EMPTY !== undefined &&\n      typeof dato.__EMPTY === 'number' &&\n      dato.__EMPTY > 0 &&\n      dato.__EMPTY < 1\n    ) {\n      const totalMin = Math.round(dato.__EMPTY * 24 * 60);\n      const hh = Math.floor(totalMin / 60);\n      const mm = totalMin % 60;\n      \n      let periodo = \"AM\";\n      let hora12 = hh;\n      if (hh >= 12) {\n        periodo = \"PM\";\n        hora12 = (hh === 12 ? 12 : hh - 12);\n      }\n      if (hh === 0) {\n        hora12 = 12;\n      }\n      \n      const horaStr = `${hora12}:${String(mm).padStart(2, '0')} ${periodo}`;\n      franjasHorarias.push({\n        hora: horaStr,\n        indice: datos.indexOf(dato) // fila base\n      });\n    }\n  });\n  franjasHorarias.sort((a, b) => a.indice - b.indice);\n  mallaEstructurada.franjas = franjasHorarias;\n  \n  // C) Detectar muelles (col)\n  const muellesInfo = {};\n  datos.forEach(dato => {\n    Object.entries(dato).forEach(([key, value]) => {\n      if (value === \"MUELLE 01\" || value === \"MUELLE 02\") {\n        const col = parseInt(key.replace(\"__EMPTY_\", \"\"), 10);\n        const muelleKey = (value === \"MUELLE 01\") ? 'muelle1' : 'muelle2';\n        if (!muellesInfo[muelleKey]) {\n          muellesInfo[muelleKey] = [];\n        }\n        muellesInfo[muelleKey].push(col);\n      }\n    });\n  });\n  if (muellesInfo.muelle1) muellesInfo.muelle1.sort((a, b) => a - b);\n  if (muellesInfo.muelle2) muellesInfo.muelle2.sort((a, b) => a - b);\n  \n  // D) Generar los 5 días (lunes-viernes) con su fecha\n  parsearRangoDias();\n  \n  // E) Extraer Citas\n  extraerCitas(datos, muellesInfo);\n  \n  return mallaEstructurada;\n}\n\n/**\n * Parsea la cadena \"LUNES 31 AL VIERNES 4 DE ABRIL\"\n * (o \"LUNES 31 AL VIERNES 04 DE ABRIL\") y maneja el cruce de mes.\n * Ej.: si dayStart=31 y dayEnd=4, la 1ª fecha es 31 de MARZO,\n * luego 1,2,3,4 de ABRIL, en vez de 32,33, etc.\n */\nfunction parsearRangoDias() {\n  const texto = mallaEstructurada.rangoDias;\n  // Regex simple: p.ej. \"31 AL ... 4 DE ABRIL\"\n  // Captura: dayStart, dayEnd, mesFin\n  // Ojo: si dice \"LUNES 31 DE MARZO AL VIERNES 4 DE ABRIL\",\n  // quedará: dayStart=31, dayEnd=4, month=ABRIL (al final).\n  const regex = /(\\d+)\\s+AL\\s+\\D+(\\d+)\\s+DE\\s+(\\w+)/i;\n  const match = regex.exec(texto);\n  \n  // Por defecto, creamos 5 días vacíos sin fecha\n  diasSemana.forEach(d => {\n    mallaEstructurada.dias[d] = {\n      muelle1: {},\n      muelle2: {}\n    };\n  });\n  \n  if (!match) {\n    // Sin coincidencia, dejamos los días sin fecha\n    return;\n  }\n  \n  const dayStart = parseInt(match[1], 10); // 31\n  const dayEnd   = parseInt(match[2], 10); // 4\n  const finalMonthName = match[3].toLowerCase(); // \"abril\"\n  \n  // Convertimos a número\n  const finalMonth = meses[finalMonthName] || 3; // fallback marzo\n  const yearNum = parseInt(mallaEstructurada.año, 10) || 2025;\n  \n  // Función para obtener la fecha formateada\n  function fechaFormateada(d, m, y) {\n    return `${d} de ${nombreMes[m]} de ${y}`;\n  }\n  \n  // Comprobamos cuántos días tiene el mes final, considerando bisiestos\n  const diasMesFinal = getDiasMes(finalMonth, yearNum);\n  // y del mes previo\n  const monthPrev = (finalMonth === 1) ? 12 : finalMonth - 1;\n  const yearPrev = (finalMonth === 1) ? yearNum - 1 : yearNum;\n  \n  // Arreglo final con 5 fechas\n  const fechasDias = [];\n  \n  if (dayStart <= dayEnd) {\n    // Caso \"normal\": todo en el mismo mes\n    let d = dayStart;\n    for (let i = 0; i < 5; i++) {\n      fechasDias.push({\n        diaSem: diasSemana[i],\n        diaNum: d,\n        mesNum: finalMonth,\n        yearNum: yearNum\n      });\n      d++;\n      if (d > diasMesFinal) {\n        d = 1;\n        const nextMonth = finalMonth % 12 + 1;\n        const nextYear = (nextMonth === 1) ? yearNum + 1 : yearNum;\n        fechasDias[fechasDias.length - 1].mesNum = nextMonth;\n        fechasDias[fechasDias.length - 1].yearNum = nextYear;\n      }\n    }\n  } else {\n    // Caso \"cruza de mes\": dayStart > dayEnd\n    let d = dayStart;\n    let m = monthPrev;\n    let y = yearPrev;\n    \n    for (let i = 0; i < 5; i++) {\n      fechasDias.push({\n        diaSem: diasSemana[i],\n        diaNum: d,\n        mesNum: m,\n        yearNum: y\n      });\n      d++;\n      if (d > getDiasMes(m, y)) {\n        d = 1;\n        m = m % 12 + 1;\n        if (m === 1) {\n          y++;\n        }\n      }\n    }\n  }\n  \n  // Ahora volcamos esas 5 fechas en la estructura\n  fechasDias.forEach(fd => {\n    const { diaSem, diaNum, mesNum, yearNum } = fd;\n    mallaEstructurada.dias[diaSem] = {\n      fechaDia: fechaFormateada(diaNum, mesNum, yearNum),\n      muelle1: {},\n      muelle2: {}\n    };\n  });\n  \n  // Inicializamos las franjas a 'disponible'\n  if (mallaEstructurada.franjas.length > 0) {\n    diasSemana.forEach(d => {\n      mallaEstructurada.franjas.forEach(f => {\n        mallaEstructurada.dias[d].muelle1[f.hora] = {\n          estado: \"disponible\",\n          proveedor: \"\",\n          ordenCompra: \"\",\n          peso: \"\",\n          categoria: \"\",\n          unidades: \"\"\n        };\n        mallaEstructurada.dias[d].muelle2[f.hora] = {\n          estado: \"disponible\",\n          proveedor: \"\",\n          ordenCompra: \"\",\n          peso: \"\",\n          categoria: \"\",\n          unidades: \"\"\n        };\n      });\n    });\n  }\n}\n\n/**\n * Función auxiliar: decide a qué día pertenece una columna,\n * corrigiendo 2 columnas de offset (porque 'Extract from XLSX'\n * deja todo desplazado).\n */\nfunction getDayForColumn(colNumber) {\n  // Ajuste de offset +2\n  const realCol = colNumber + 2;\n\n  // Rangos:\n  //  Lunes:      3..8\n  //  Martes:     9..14\n  //  Miércoles: 15..20\n  //  Jueves:    21..26\n  //  Viernes:   27..32\n  if (realCol >= 3 && realCol <= 8) {\n    return \"lunes\";\n  }\n  if (realCol >= 9 && realCol <= 14) {\n    return \"martes\";\n  }\n  if (realCol >= 15 && realCol <= 20) {\n    return \"miércoles\";\n  }\n  if (realCol >= 21 && realCol <= 26) {\n    return \"jueves\";\n  }\n  if (realCol >= 27 && realCol <= 32) {\n    return \"viernes\";\n  }\n  // Si nada coincide, devolvemos null\n  return null;\n}\n\n/**\n * Extraer las citas para cada franja:\n * - Para cada franja, miramos 3 filas:\n *    - Fila base => proveedor\n *    - Fila base+1 => orden\n *    - Fila base+2 => peso, categoría, unidades\n */\nfunction extraerCitas(datos, muellesInfo) {\n  mallaEstructurada.franjas.forEach(franja => {\n    const indiceBase = franja.indice;\n    if (indiceBase < 0 || indiceBase + 2 >= datos.length) {\n      return; // no hay suficientes filas\n    }\n    \n    // Recorremos muelle1, muelle2 y sus columnas\n    const asignarCita = (muelleKey, cols) => {\n      cols.forEach(col => {\n        const provKey = `__EMPTY_${col}`;\n        const filaProv = datos[indiceBase];\n        \n        // Si en esta fila hay un proveedor o algún texto\n        if (\n          filaProv &&\n          typeof filaProv[provKey] === 'string' &&\n          filaProv[provKey].length > 2\n        ) {\n          // Determinar el día real\n          const diaOk = getDayForColumn(col);\n          if (!diaOk || !mallaEstructurada.dias[diaOk]) {\n            return; // si no coincide con ninguno, saltamos\n          }\n          \n          // Recuperar valores para proveedor, ordenCompra y demás\n          const filaOrden = datos[indiceBase + 1];\n          const filaDet = datos[indiceBase + 2];\n          \n          const proveedor = filaProv[provKey] || \"\";\n          const ordenCompra = filaOrden && filaOrden[provKey] ? filaOrden[provKey] : \"\";\n          const peso = filaDet && filaDet[provKey] ? filaDet[provKey] : \"\";\n          const cat  = filaDet && filaDet[`__EMPTY_${col + 1}`] ? filaDet[`__EMPTY_${col + 1}`] : \"\";\n          const und  = filaDet && filaDet[`__EMPTY_${col + 2}`] ? filaDet[`__EMPTY_${col + 2}`] : \"\";\n          \n          // Antes poníamos estado=\"ocupado\" directamente\n          // Ahora verificamos si el texto contiene \"reagendado\", \"cancelado\" o \"fuera de servicio\".\n          const nuevoEstado = determinarEstadoOcupado(proveedor, ordenCompra, peso, cat, und);\n          \n          // Asignamos los datos\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].estado = nuevoEstado;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].proveedor = proveedor;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].ordenCompra = ordenCompra;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].peso = peso;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].categoria = cat;\n          mallaEstructurada.dias[diaOk][muelleKey][franja.hora].unidades = und;\n        }\n      });\n    };\n    \n    if (muellesInfo.muelle1) {\n      asignarCita('muelle1', muellesInfo.muelle1);\n    }\n    if (muellesInfo.muelle2) {\n      asignarCita('muelle2', muellesInfo.muelle2);\n    }\n  });\n}\n\n// -------------------------------------------------------------\n// 2) FUNCIONES PARA CONSULTAR LA MALLA\n// -------------------------------------------------------------\nfunction buscarFranjasDisponibles(categoria, duracionHoras) {\n  const muelle = \"muelle1\"; // Ajusta si usas \"categoria -> muelle\" real\n  \n  const franjasDisponibles = [];\n  Object.keys(mallaEstructurada.dias).forEach(dia => {\n    const libres = [];\n    for (let i = 0; i <= mallaEstructurada.franjas.length - duracionHoras; i++) {\n      let disponible = true;\n      for (let h = 0; h < duracionHoras; h++) {\n        const idxF = i + h;\n        const horaAct = mallaEstructurada.franjas[idxF].hora;\n        if (\n          mallaEstructurada.dias[dia][muelle][horaAct].estado !== 'disponible'\n        ) {\n          disponible = false;\n          break;\n        }\n      }\n      if (disponible) {\n        libres.push({\n          horaInicio: mallaEstructurada.franjas[i].hora,\n          duracion: duracionHoras\n        });\n      }\n    }\n    if (libres.length > 0) {\n      franjasDisponibles.push({ dia, franjas: libres });\n    }\n  });\n  return franjasDisponibles;\n}\n\nfunction buscarCitasProveedor(nombreProveedor) {\n  const citas = [];\n  Object.keys(mallaEstructurada.dias).forEach(dia => {\n    const muelle1 = mallaEstructurada.dias[dia].muelle1;\n    const muelle2 = mallaEstructurada.dias[dia].muelle2;\n    mallaEstructurada.franjas.forEach(f => {\n      const hora = f.hora;\n      // muelle1\n      if (normalizarTexto(muelle1[hora].proveedor) === normalizarTexto(nombreProveedor)) {\n        citas.push({\n          dia,\n          hora,\n          muelle: \"Muelle 01\",\n          ordenCompra: muelle1[hora].ordenCompra,\n          peso: muelle1[hora].peso,\n          categoria: muelle1[hora].categoria,\n          unidades: muelle1[hora].unidades,\n          estado: muelle1[hora].estado\n        });\n      }\n      // muelle2\n      if (normalizarTexto(muelle2[hora].proveedor) === normalizarTexto(nombreProveedor)) {\n        citas.push({\n          dia,\n          hora,\n          muelle: \"Muelle 02\",\n          ordenCompra: muelle2[hora].ordenCompra,\n          peso: muelle2[hora].peso,\n          categoria: muelle2[hora].categoria,\n          unidades: muelle2[hora].unidades,\n          estado: muelle2[hora].estado\n        });\n      }\n    });\n  });\n  return citas;\n}\n\nfunction consultarFranjasDisponibles(categoria, duracionHoras) {\n  return buscarFranjasDisponibles(categoria, duracionHoras);\n}\n\nfunction consultarCitasProveedor(nombreProveedor) {\n  return buscarCitasProveedor(nombreProveedor);\n}\n\nfunction obtenerInfoMalla() {\n  return {\n    titulo: mallaEstructurada.titulo,\n    año: mallaEstructurada.año,\n    semana: mallaEstructurada.semana,\n    rangoDias: mallaEstructurada.rangoDias,\n    franjas: mallaEstructurada.franjas.map(f => f.hora)\n  };\n}\n\nfunction estaDisponible(dia, hora, muelle) {\n  const info = mallaEstructurada.dias[dia]?.[muelle]?.[hora];\n  return info ? (info.estado === 'disponible') : false;\n}\n\nfunction obtenerCoordenadasCita(dia, hora, muelle) {\n  // Ajustar con tu mapeo de celdas en Excel\n  return {\n    proveedor: `${dia}_${hora}_${muelle}_proveedor`,\n    ordenCompra: `${dia}_${hora}_${muelle}_ordenCompra`,\n    peso: `${dia}_${hora}_${muelle}_peso`,\n    categoria: `${dia}_${hora}_${muelle}_categoria`,\n    unidades: `${dia}_${hora}_${muelle}_unidades`\n  };\n}\n\n// -------------------------------------------------------------\n// 3) EJECUTAR TODO Y RETORNAR\n// -------------------------------------------------------------\nconst malla = procesarDatos(excelData);\n\nconst resultado = {\n  datosMallaProxSemana: malla,\n  funciones: {\n    consultarFranjasDisponibles,\n    consultarCitasProveedor,\n    obtenerInfoMalla,\n    estaDisponible,\n    obtenerCoordenadasCita\n  }\n};\n\nreturn [resultado];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -39808,
        -4272
      ],
      "id": "adefa713-4a4f-40f1-bd1e-41674afec7c2",
      "name": "Estructuración, Datos, Consulta, Citas Proxima Semana4"
    },
    {
      "parameters": {
        "jsCode": "// Obtener los datos de la cita desde la consulta SQL\nconst citaBD = $('Microsoft SQL Obtener Cita para Cancelar').first().json;\n\n// Obtener los datos de las mallas\nconst datosMalla = $('Unificación y consistencia de datos5').first().json;\nconst mallaActual = datosMalla.datosMalla;\nconst mallaProxSemana = datosMalla.datosMallaProxSemana;\n\n// Función para normalizar texto (quitar espacios, convertir a minúsculas)\nfunction normalizarTexto(texto) {\n  if (!texto) return \"\";\n  return texto.toString().trim().toLowerCase();\n}\n\n// Función para buscar cita en una malla específica\nfunction buscarCitaEnMalla(malla, citaBuscar) {\n  const diasSemana = ['lunes', 'martes', 'miércoles', 'jueves', 'viernes'];\n  const muelles = ['muelle1', 'muelle2'];\n  \n  for (const dia of diasSemana) {\n    if (!malla.dias[dia]) continue;\n    \n    for (const muelle of muelles) {\n      if (!malla.dias[dia][muelle]) continue;\n      \n      // Revisar todas las franjas horarias\n      for (const [hora, citaMalla] of Object.entries(malla.dias[dia][muelle])) {\n        // Solo revisar citas ocupadas\n        if (citaMalla.estado !== 'ocupado') continue;\n        \n        // Comparar campos clave\n        const proveedorCoincide = normalizarTexto(citaMalla.proveedor) === normalizarTexto(citaBuscar.nombre);\n        const ordenCoincide = normalizarTexto(citaMalla.ordenCompra) === normalizarTexto(citaBuscar.orden_compra);\n        \n        // Verificar peso (puede ser number o string)\n        let pesoCoincide = false;\n        const pesoBD = parseFloat(citaBuscar.peso) || 0;\n        const pesoMalla = parseFloat(citaMalla.peso) || 0;\n        pesoCoincide = Math.abs(pesoBD - pesoMalla) < 0.01; // tolerancia para decimales\n        \n        // Verificar unidades\n        let unidadesCoincide = false;\n        const unidadesBD = parseFloat(citaBuscar.unidades) || 0;\n        const unidadesMalla = parseFloat(citaMalla.unidades) || 0;\n        unidadesCoincide = Math.abs(unidadesBD - unidadesMalla) < 0.01;\n        \n        // Si coinciden los campos principales, es la misma cita\n        if (proveedorCoincide && ordenCoincide && pesoCoincide && unidadesCoincide) {\n          return {\n            encontrada: true,\n            ubicacion: {\n              malla: malla.semana,\n              dia: dia,\n              hora: hora,\n              muelle: muelle,\n              fechaDia: malla.dias[dia].fechaDia || \"Fecha no disponible\"\n            },\n            detalles: citaMalla\n          };\n        }\n      }\n    }\n  }\n  \n  return { encontrada: false };\n}\n\n// Buscar la cita en ambas mallas\nlet citaEncontrada = null;\nlet ubicacionEncontrada = null;\n\n// Primero buscar en la malla actual\nconst resultadoMallaActual = buscarCitaEnMalla(mallaActual, citaBD);\nif (resultadoMallaActual.encontrada) {\n  citaEncontrada = resultadoMallaActual.detalles;\n  ubicacionEncontrada = resultadoMallaActual.ubicacion;\n}\n\n// Si no se encontró en la malla actual, buscar en la próxima semana\nif (!citaEncontrada) {\n  const resultadoMallaProxima = buscarCitaEnMalla(mallaProxSemana, citaBD);\n  if (resultadoMallaProxima.encontrada) {\n    citaEncontrada = resultadoMallaProxima.detalles;\n    ubicacionEncontrada = resultadoMallaProxima.ubicacion;\n  }\n}\n\n// Generar respuesta basada en si se encontró o no la cita\nif (citaEncontrada) {\n  // Cita encontrada - continuar con el proceso de cancelación\n  return [{\n    validacionExitosa: true,\n    citaEncontrada: true,\n    datosValidacion: {\n      citaBD: {\n        id: citaBD.id,\n        nombre: citaBD.nombre,\n        ordenCompra: citaBD.orden_compra,\n        peso: citaBD.peso,\n        unidades: citaBD.unidades,\n        fechaCita: citaBD.fecha_cita,\n        estado: citaBD.estado\n      },\n      citaMalla: citaEncontrada,\n      ubicacion: ubicacionEncontrada\n    },\n    mensaje: `✅ **Validación exitosa**\\n\\n` +\n             `Se ha verificado que la cita 🔖 **${citaBD.id}** con orden de compra **${citaBD.orden_compra}** ` +\n             `se encuentra correctamente registrada en la malla de la ${ubicacionEncontrada.malla}.\\n\\n` +\n             `📍 **Ubicación en malla:**\\n` +\n             `• **Día:** ${ubicacionEncontrada.dia} (${ubicacionEncontrada.fechaDia})\\n` +\n             `• **Hora:** ${ubicacionEncontrada.hora}\\n` +\n             `• **Muelle:** ${ubicacionEncontrada.muelle.replace('muelle', 'Muelle ')}\\n` +\n             `• **Proveedor:** ${citaEncontrada.proveedor}\\n\\n` +\n             `Procediendo con la cancelación de la cita...`\n  }];\n} else {\n  // Cita NO encontrada - generar error\n  return [{\n    validacionExitosa: false,\n    citaEncontrada: false,\n    error: true,\n    datosValidacion: {\n      citaBD: {\n        id: citaBD.id,\n        nombre: citaBD.nombre,\n        ordenCompra: citaBD.orden_compra,\n        peso: citaBD.peso,\n        unidades: citaBD.unidades,\n        fechaCita: citaBD.fecha_cita,\n        estado: citaBD.estado\n      },\n      mallaRevisada: {\n        semanaActual: mallaActual.semana,\n        rangoActual: mallaActual.rangoDias,\n        semanaProxima: mallaProxSemana.semana,\n        rangoProximo: mallaProxSemana.rangoDias\n      }\n    },\n    mensaje: `❌ **Error de validación de malla**\\n\\n` +\n             `La cita 🔖 **${citaBD.id}** con orden de compra **${citaBD.orden_compra}** ` +\n             `se encuentra registrada en la base de datos como **PROGRAMADA**, pero ` +\n             `**NO coincide** con ninguna cita ocupada en la malla de horarios.\\n\\n` +\n             `📊 **Datos de la cita en BD:**\\n` +\n             `• **Proveedor:** ${citaBD.nombre}\\n` +\n             `• **Orden de compra:** ${citaBD.orden_compra}\\n` +\n             `• **Peso:** ${citaBD.peso} kg\\n` +\n             `• **Unidades:** ${citaBD.unidades}\\n` +\n             `• **Fecha programada:** ${citaBD.fecha_cita}\\n\\n` +\n             `🔍 **Mallas revisadas:**\\n` +\n             `• ${mallaActual.semana}: ${mallaActual.rangoDias}\\n` +\n             `• ${mallaProxSemana.semana}: ${mallaProxSemana.rangoDias}\\n\\n` +\n             `⚠️ **Acción requerida:**\\n` +\n             `Por favor comuníquese con el **área de bodega** para verificar qué sucedió con esta cita. ` +\n             `Es posible que haya una inconsistencia entre la base de datos y la malla de horarios.\\n\\n` +\n             `📞 **Contacto:** Extensión 1234 - Coordinación de Bodega\\n\\n` +\n             `🔄 **Esta conversación será eliminada** para mantener la trazabilidad del historial.`,\n    codigoError: \"CITA_NO_ENCONTRADA_EN_MALLA\",\n    accionRequerida: \"CONTACTAR_BODEGA\"\n  }];\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -38960,
        -4368
      ],
      "id": "b6d07032-f4cf-4cae-b9c8-7e53d2a02519",
      "name": "Code validación de cita en malla"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "64a1bea0-f03e-4e93-8f05-f2e606167be0",
              "leftValue": "={{ $json.citaEncontrada }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -38688,
        -4368
      ],
      "id": "a80f97f5-e845-4364-b0dc-dfa86705a6b0",
      "name": "If validar cita existe"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "4bfbecb3-9d4f-4425-aa76-a92abc7708fb",
              "leftValue": "={{ $('Code validación de cita en malla').first().json.mensaje.length }}",
              "rightValue": 70,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -38256,
        -3984
      ],
      "id": "dc0f700a-1444-4329-ba6e-aa9fd6e3f388",
      "name": "Validación de longitud de caracteres14"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d9c2ff70-4fd1-4b93-8571-6d0ac5a0093e",
              "name": "mensaje.ia",
              "value": "={{ $('Code validación de cita en malla').first().json.mensaje }}",
              "type": "string"
            },
            {
              "id": "ac8a03be-0292-4735-9580-39a385945c47",
              "name": "mensaje.longitud",
              "value": "={{ $('Code validación de cita en malla').first().json.mensaje.length }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -37984,
        -3920
      ],
      "id": "7c8eb951-a69f-46c3-a125-35d5900ab91c",
      "name": "Organiza variables del mensaje14"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -37808,
        -4128
      ],
      "id": "ce030f5e-80ce-447e-9e09-9ed2c249f46f",
      "name": "No Operation, do nothing18"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $('Code Respuesta Faltantes').item.json.text }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -37984,
        -4128
      ],
      "id": "c8798a31-31cc-4d8d-9c52-8479134a0ef0",
      "name": "HTTP Request Enviar Mensaje por WhatsApp17"
    },
    {
      "parameters": {
        "jsCode": "// Código adaptado para CANCELACIÓN de citas\nconst datosValidacion = $('Code validación de cita en malla').first().json.datosValidacion;\nconst citaBD = datosValidacion.citaBD;\nconst ubicacionCita = datosValidacion.ubicacion;\n// Usar la fecha de la cita para determinar qué malla usar\nconst mallaActual = $('Unificación y consistencia de datos5').first().json.datosMalla;\nconst mallaProxima = $('Unificación y consistencia de datos5').first().json.datosMallaProxSemana;\n\nconst fechaCita = new Date(citaBD.fechaCita);\n\n// Función para verificar si una fecha está en un rango de malla\nfunction fechaEnMalla(fecha, malla) {\n  if (!malla.dias) return false;\n  \n  const fechaBuscada = fecha.toLocaleDateString('es-ES', { \n    day: 'numeric', \n    month: 'long', \n    year: 'numeric' \n  });\n  \n  for (const dia of Object.keys(malla.dias)) {\n    const diaData = malla.dias[dia];\n    if (diaData.fechaDia && diaData.fechaDia === fechaBuscada) {\n      console.log(`Fecha encontrada en día ${dia}: ${diaData.fechaDia}`);\n      return true;\n    }\n  }\n  return false;\n}\n\nlet datosMalla;\nif (fechaEnMalla(fechaCita, mallaActual)) {\n  datosMalla = mallaActual;\n  console.log(\"Usando malla actual para fecha:\", fechaCita.toDateString());\n} else if (fechaEnMalla(fechaCita, mallaProxima)) {\n  datosMalla = mallaProxima;\n  console.log(\"Usando malla próxima para fecha:\", fechaCita.toDateString());\n} else {\n  console.log(\"Fecha no encontrada en ninguna malla\");\n  return {\n    json: {\n      error: true,\n      mensaje: `No se encontró la fecha ${fechaCita.toDateString()} en ninguna malla`,\n      datosValidacion\n    }\n  };\n}\n\nconsole.log(\"=== ESTRUCTURA DATOS MALLA ===\");\nconsole.log(\"Claves disponibles en datosMalla:\", Object.keys(datosMalla || {}));\nconsole.log(\"Claves en datosMalla.dias:\", Object.keys(datosMalla?.dias || {}));\nconsole.log(\"Estructura completa dias:\", datosMalla?.dias);\n\nconsole.log(`Preparando cancelación de cita ID ${citaBD.id} ubicada en: ${ubicacionCita.dia} ${ubicacionCita.hora} ${ubicacionCita.muelle}`);\n\n// Función para calcular las franjas ocupadas por la cita\nfunction calcularFranjasOcupadas() {\n  const franjas = [];\n  \n  console.log(\"=== DEBUG CANCELACIÓN ===\");\n  console.log(\"Ubicación cita:\", ubicacionCita);\n  console.log(\"Datos cita BD:\", citaBD);\n  \n  // Encontrar la franja de inicio\n  const franjasOrdenadas = [...datosMalla.franjas].sort((a, b) => {\n    function horaAMinutos(hora) {\n      const match = hora.match(/(\\\\d+):(\\\\d+)\\\\s*([AP]M)/i);\n      if (!match) return 0;\n      \n      let horas = parseInt(match[1], 10);\n      const minutos = parseInt(match[2], 10);\n      const periodo = match[3].toUpperCase();\n      \n      if (periodo === 'PM' && horas !== 12) {\n        horas += 12;\n      } else if (periodo === 'AM' && horas === 12) {\n        horas = 0;\n      }\n      \n      return horas * 60 + minutos;\n    }\n    \n    return horaAMinutos(a.hora) - horaAMinutos(b.hora);\n  });\n  \n  console.log(\"Franjas ordenadas:\", franjasOrdenadas.map(f => f.hora));\n  \n  // Encontrar el índice de la franja actual\n  const indiceInicio = franjasOrdenadas.findIndex(f => \n    f.hora.trim().toLowerCase() === ubicacionCita.hora.trim().toLowerCase()\n  );\n  \n  console.log(`Buscando hora: \"${ubicacionCita.hora}\" - Índice encontrado: ${indiceInicio}`);\n  \n  if (indiceInicio === -1) {\n    console.log(`No se encontró la franja ${ubicacionCita.hora} en la malla`);\n    return [];\n  }\n  \n  const muelleKey = ubicacionCita.muelle.toLowerCase().includes(\"1\") ? \"muelle1\" : \"muelle2\";\n  const diaData = datosMalla.dias[ubicacionCita.dia];\n  \n  console.log(`Día: ${ubicacionCita.dia}, Muelle: ${muelleKey}`);\n  console.log(\"Datos del día:\", Object.keys(diaData || {}));\n  console.log(\"Datos del muelle:\", Object.keys(diaData?.[muelleKey] || {}));\n  \n  if (!diaData || !diaData[muelleKey]) {\n    console.log(`No se encontraron datos para ${ubicacionCita.dia} ${muelleKey}`);\n    return [];\n  }\n  \n  // Buscar franjas consecutivas con los mismos datos de la cita\n  for (let i = indiceInicio; i < franjasOrdenadas.length; i++) {\n    const franja = franjasOrdenadas[i];\n    const datosFramja = diaData[muelleKey][franja.hora];\n    \n    console.log(`\\n--- Evaluando franja ${franja.hora} ---`);\n    console.log(\"Datos franja:\", datosFramja);\n    \n    if (!datosFramja) {\n      console.log(\"No hay datos para esta franja\");\n      break;\n    }\n    \n    // Comparaciones individuales para debug\n    const estadoOK = datosFramja.estado === 'ocupado';\n    const proveedorOK = datosFramja.proveedor && citaBD.nombre && \n      String(datosFramja.proveedor).trim().toLowerCase() === String(citaBD.nombre).trim().toLowerCase();\n    const ordenOK = String(datosFramja.ordenCompra) === String(citaBD.ordenCompra);\n    \n    console.log(`Estado OK: ${estadoOK} (${datosFramja.estado} === 'ocupado')`);\n    console.log(`Proveedor OK: ${proveedorOK} (\"${datosFramja.proveedor}\" === \"${citaBD.nombre}\")`);\n    console.log(`Orden OK: ${ordenOK} (${datosFramja.ordenCompra} === ${citaBD.ordenCompra})`);\n    \n    const mismaCita = datosFramja && estadoOK && proveedorOK && ordenOK;\n    \n    if (mismaCita) {\n      const filaBase = calcularFilaExcel(franja.hora, franjasOrdenadas);\n      if (filaBase) {\n        franjas.push({\n          hora: franja.hora,\n          fila: filaBase,\n          datos: {\n            proveedor: \"\",\n            ordenCompra: \"\",\n            peso: \"\",\n            categoria: \"\",\n            unidades: \"\"\n          }\n        });\n        console.log(`✅ Franja añadida: ${franja.hora}`);\n      }\n    } else {\n      console.log(`❌ No es la misma cita, deteniendo búsqueda`);\n      break;\n    }\n  }\n  \n  console.log(`=== RESULTADO: ${franjas.length} franjas encontradas ===`);\n  return franjas;\n}\n\n// Funciones auxiliares (mantener las mismas del nodo original)\nfunction calcularFilaExcel(hora, franjas) {\n  const franjasOrdenadas = [...franjas].sort((a, b) => {\n    function horaAMinutos(hora) {\n      const match = hora.match(/(\\\\d+):(\\\\d+)\\\\s*([AP]M)/i);\n      if (!match) return 0;\n      \n      let horas = parseInt(match[1], 10);\n      const minutos = parseInt(match[2], 10);\n      const periodo = match[3].toUpperCase();\n      \n      if (periodo === 'PM' && horas !== 12) {\n        horas += 12;\n      } else if (periodo === 'AM' && horas === 12) {\n        horas = 0;\n      }\n      \n      return horas * 60 + minutos;\n    }\n    \n    return horaAMinutos(a.hora) - horaAMinutos(b.hora);\n  });\n  \n  const posicion = franjasOrdenadas.findIndex(f => \n    f.hora.trim().toLowerCase() === hora.trim().toLowerCase()\n  );\n  \n  if (posicion === -1) {\n    console.log(`No se encontró la posición para la hora ${hora}`);\n    return null;\n  }\n  \n  const FILA_PRIMERA_FRANJA = 12;\n  const INCREMENTO_ESTANDAR = 3;\n  \n  if (posicion === 3) {\n    return 21;\n  } else if (posicion === 4) {\n    return 24;\n  } else if (posicion === 5) {\n    return 27;\n  } else if (posicion < 3) {\n    return FILA_PRIMERA_FRANJA + (posicion * INCREMENTO_ESTANDAR);\n  } else {\n    return 27 + ((posicion - 5) * INCREMENTO_ESTANDAR);\n  }\n}\n\nfunction procesarFranjas(franjas, nombreHoja) {\n  let actualizaciones = [];\n  \n  const diaSemana = ubicacionCita.dia;\n  const muelleKey = ubicacionCita.muelle.toLowerCase().includes(\"1\") ? \"muelle1\" : \"muelle2\";\n  \n  const mapeoColumnas = {\n    'lunes': { 'muelle1': 'C', 'muelle2': 'F' },\n    'martes': { 'muelle1': 'I', 'muelle2': 'L' },\n    'miércoles': { 'muelle1': 'O', 'muelle2': 'R' },\n    'jueves': { 'muelle1': 'U', 'muelle2': 'X' },\n    'viernes': { 'muelle1': 'AA', 'muelle2': 'AD' }\n  };\n  \n  if (!mapeoColumnas[diaSemana] || !mapeoColumnas[diaSemana][muelleKey]) {\n    console.log(`No hay mapeo para: día=${diaSemana}, muelle=${muelleKey}`);\n    return [];\n  }\n  \n  const columnaBase = mapeoColumnas[diaSemana][muelleKey];\n  \n  function siguienteColumna(columna) {\n    if (columna.length === 1) {\n      return String.fromCharCode(columna.charCodeAt(0) + 1);\n    } else {\n      const primerChar = columna.charAt(0);\n      const segundoChar = columna.charAt(1);\n      \n      if (segundoChar === 'Z') {\n        return String.fromCharCode(primerChar.charCodeAt(0) + 1) + 'A';\n      } else {\n        return primerChar + String.fromCharCode(segundoChar.charCodeAt(0) + 1);\n      }\n    }\n  }\n  \n  franjas.forEach((franja, index) => {\n    const filaBase = franja.fila;\n    const columnaLineas = siguienteColumna(columnaBase);\n    const columnaUnd = siguienteColumna(columnaLineas);\n    \n    const rangoCeldas = {\n      proveedor: `${columnaBase}${filaBase}`,\n      ordenCompra: `${columnaBase}${filaBase + 1}`,\n      peso: `${columnaBase}${filaBase + 2}`,\n      categoria: `${columnaLineas}${filaBase + 2}`,\n      unidades: `${columnaUnd}${filaBase + 2}`\n    };\n    \n    console.log(`Limpiando franja ${index + 1}: ${franja.hora} - Celdas: ${JSON.stringify(rangoCeldas)}`);\n    \n    // Para cancelación, todos los valores son vacíos\n    actualizaciones.push(\n      { celda: rangoCeldas.proveedor, valor: \"\", nombreHoja },\n      { celda: rangoCeldas.ordenCompra, valor: \"\", nombreHoja },\n      { celda: rangoCeldas.peso, valor: \"\", nombreHoja },\n      { celda: rangoCeldas.categoria, valor: \"\", nombreHoja },\n      { celda: rangoCeldas.unidades, valor: \"\", nombreHoja }\n    );\n  });\n  \n  return actualizaciones;\n}\n\n// Ejecutar la lógica de cancelación\nconst franjasACancelar = calcularFranjasOcupadas();\n\nif (franjasACancelar.length === 0) {\n  return {\n    json: {\n      error: true,\n      mensaje: \"No se pudieron identificar las franjas de la cita para cancelar\",\n      datosValidacion\n    }\n  };\n}\n\n// Usar la semana de la ubicación encontrada\nconst nombreHojaActual = ubicacionCita.malla;\n\n// Procesar las franjas para cancelación (limpieza)\nconst actualizacionesCancelacion = procesarFranjas(franjasACancelar, nombreHojaActual);\n\n// Preparar el formato para Microsoft Graph\nconst actualizacionesGraph = actualizacionesCancelacion.map(act => ({\n  address: act.celda,\n  values: [[act.valor]], // Valores vacíos para cancelación\n  nombreHoja: act.nombreHoja\n}));\n\n// Preparar el resultado\nreturn {\n  json: {\n    success: true,\n    accion: \"CANCELACION\",\n    mensaje: `Preparadas ${actualizacionesCancelacion.length} operaciones de limpieza para cancelar la cita ID ${citaBD.id}`,\n    nombreHoja: nombreHojaActual,\n    citaCancelada: {\n      id: citaBD.id,\n      proveedor: citaBD.nombre,\n      ordenCompra: citaBD.ordenCompra,\n      ubicacion: ubicacionCita\n    },\n    graphRequestData: {\n      updates: actualizacionesGraph\n    },\n    detalles: {\n      actualizacionesDetalladas: actualizacionesCancelacion,\n      franjasLimpiadas: franjasACancelar.length,\n      informacionCita: {\n        id: citaBD.id,\n        dia: ubicacionCita.dia,\n        hora: ubicacionCita.hora,\n        muelle: ubicacionCita.muelle,\n        proveedor: citaBD.nombre,\n        ordenCompra: citaBD.ordenCompra\n      }\n    }\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -38000,
        -5312
      ],
      "id": "ed1c3caa-203a-4a80-912d-d99c251f8d77",
      "name": "Code (Preparar Cuerpo de Petición)2"
    },
    {
      "parameters": {
        "jsCode": "// Código modificado para \"Code Agrupar Franjas3\" - CANCELACIÓN\n// Ahora devuelve los valores individuales igual que en crear cita\nconst input = $input.first().json;\n\n// Verificar que tenemos la estructura esperada\nif (!input || !input.graphRequestData || !input.graphRequestData.updates) {\n  console.log('Estructura de datos de entrada no válida');\n  return {\n    json: {\n      error: \"FORMATO_INVALIDO\",\n      mensaje: \"La estructura de datos de entrada no es válida\"\n    }\n  };\n}\n\nconst updates = input.graphRequestData.updates;\nconst resultados = [];\n\n// Recorremos cada actualización y creamos un item individual\nupdates.forEach((update, index) => {\n  // Para cancelación, el valor siempre es vacío\n  resultados.push({\n    json: {\n      valor: \"\", // Siempre vacío para cancelación\n      indice: Math.floor(index / 5) + 1, // Agrupar cada 5 items como una franja\n      nombreHoja: input.nombreHoja,\n      address: update.address,\n      informacionCita: input.detalles?.informacionCita || {},\n      accion: \"CANCELACION\"\n    }\n  });\n});\n\nconsole.log(`Se prepararon ${resultados.length} operaciones de limpieza para cancelación`);\nreturn resultados;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -37808,
        -5312
      ],
      "id": "b94ffa50-b910-49d9-9ba0-80ac13392e87",
      "name": "Code Agrupar Franjas3"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        -37504,
        -5312
      ],
      "id": "12c5570d-b8f7-4c92-9e00-dc59704fc301",
      "name": "Loop Over Uno a Uno2"
    },
    {
      "parameters": {
        "jsCode": "// Código para preparar cada limpieza (cancelación) para Microsoft Graph API\nconst input = $input.first().json;\n\n// Constantes para los IDs de SharePoint/OneDrive\nconst siteId = \"gexpresscargo.sharepoint.com,a592f886-4560-4e62-9646-1eee7add7abe,8b514073-41ae-4619-8f76-724bd912bc65\";\nconst driveId = \"b!hviSpWBFYk6WRh7uet16vnNAUYuuQRlGj3ZyS9kSvGVZ4DSg6c5MRqYYm2MdAER8\";\nconst itemId = \"01PPLUUYXY5E2GK3SJ25EZLJPUYJ43H3ME\";\n\n// Verificar que tenemos la estructura esperada (igual que en crear cita)\nif (!input || input.valor === undefined || !input.address || !input.nombreHoja) {\n  console.log('Estructura de datos de entrada no válida para la cancelación');\n  return {\n    json: {\n      error: \"FORMATO_INVALIDO\",\n      mensaje: \"La estructura de datos de entrada no es válida para la cancelación\"\n    }\n  };\n}\n\n// Para cancelación, siempre usamos valor vacío\nconst valorFormateado = [[\"\"]];\n\n// Generar un ID único para esta solicitud\nconst requestId = `cancelacion_${input.address}_${input.indice}_${Date.now()}`;\n\n// Crear la estructura de solicitud para Microsoft Graph $batch\nconst requestBody = {\n  requests: [\n    {\n      id: requestId,\n      method: \"PATCH\",\n      url: `/sites/${siteId}/drives/${driveId}/items/${itemId}/workbook/worksheets/${encodeURIComponent(input.nombreHoja)}/range(address='${input.address}')`,\n      body: {\n        values: valorFormateado // Siempre [[\"\"]] para limpiar\n      },\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    }\n  ],\n  _metadata: {\n    celda: input.address,\n    valor: \"\", // Vacío para cancelación\n    indice: input.indice,\n    accion: input.accion || \"CANCELACION\",\n    informacionCita: input.informacionCita || {}\n  }\n};\n\nconsole.log(`Preparada solicitud ${requestId} para limpiar celda ${input.address} en la hoja \"${input.nombreHoja}\"`);\n\n// Retornar el objeto request listo para ser enviado a Microsoft Graph $batch\nreturn {\n  json: requestBody\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -37248,
        -5200
      ],
      "id": "822d1c00-b810-4f5a-9606-5fd43d5d9d8e",
      "name": "Code Preparar cada Insercion2"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://graph.microsoft.com/v1.0/$batch",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "microsoftOAuth2Api",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -36976,
        -5200
      ],
      "id": "a99d6c21-46d0-4ef1-9d57-30dcb8396ccf",
      "name": "HTTP Request Actualizar Excel2",
      "credentials": {
        "microsoftOAuth2Api": {
          "id": "mh8Z8hxFvd7LDO8D",
          "name": "CuentaMy SharePoint App Desarrollador1 Konfie "
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Código para verificar si la limpieza fue exitosa (cancelación)\nconst input = $input.first().json;\n\n// Verificar que tenemos la estructura esperada en la respuesta\nif (!input || !input.responses || !Array.isArray(input.responses) || input.responses.length === 0) {\n  console.log('Estructura de datos de respuesta no válida');\n  return {\n    json: {\n      error: \"RESPUESTA_INVALIDA\",\n      mensaje: \"La estructura de datos de la respuesta no es válida\",\n      exito: false\n    }\n  };\n}\n\n// Obtener la primera respuesta\nconst response = input.responses[0];\n\n// Extraer información de la solicitud original del ID\nconst idPartes = response.id.split('_');\nconst tipoOperacion = idPartes[0]; // \"cancelacion\"\nconst celdaOriginal = idPartes[1];\nconst indice = idPartes[2];\n\n// Verificar que la respuesta tiene un cuerpo\nif (!response.body || !response.body.address) {\n  console.log(`Error: La respuesta no contiene información sobre la dirección de celda`);\n  return {\n    json: {\n      error: \"RESPUESTA_SIN_DIRECCION\",\n      mensaje: \"La respuesta no incluye información sobre la dirección de celda\",\n      requestId: response.id,\n      status: response.status,\n      celdaOriginal: celdaOriginal,\n      exito: false\n    }\n  };\n}\n\n// Extraer la dirección de celda de la respuesta\nlet direccionRespuesta = \"\";\nif (response.body && response.body.address) {\n  const partesDireccion = response.body.address.split('!');\n  if (partesDireccion.length > 1) {\n    direccionRespuesta = partesDireccion[1];\n  }\n}\n\n// Obtener el valor de la respuesta (debe ser vacío para cancelación)\nconst valorRespuesta = response.body.values && response.body.values[0] && response.body.values[0][0];\n\n// Verificar si la operación se realizó en la celda correcta\nconst celdaCorrecta = direccionRespuesta === celdaOriginal;\n\n// Verificar el código de estado HTTP\nconst estadoExitoso = response.status >= 200 && response.status < 300;\n\n// Para cancelación, también verificamos que el valor sea vacío\nconst valorCorrecto = tipoOperacion === \"cancelacion\" ? valorRespuesta === \"\" : true;\n\n// Crear objeto para almacenar el resultado de la verificación\nconst resultado = {\n  exito: celdaCorrecta && estadoExitoso && valorCorrecto,\n  tipoOperacion: tipoOperacion,\n  celdaOriginal: celdaOriginal,\n  celdaInsertada: direccionRespuesta,\n  valorInsertado: valorRespuesta,\n  statusCode: response.status,\n  requestId: response.id,\n  indice: indice,\n  celdasDiferentes: !celdaCorrecta && estadoExitoso,\n  falloEstado: !estadoExitoso,\n  falloValor: !valorCorrecto\n};\n\nconst chatId = $('Organiza el Mensaje').first().json.infoMensaje.chat_id;\n\nif (!resultado.exito) {\n  console.log(`Error en ${tipoOperacion}: celda=${celdaOriginal}, insertada=${direccionRespuesta}, status=${response.status}, valor=\"${valorRespuesta}\"`);\n} else {\n  console.log(`${tipoOperacion} exitosa en celda ${celdaOriginal}`);\n}\n\n// Incluir la respuesta original para tener toda la información\nresultado.respuestaOriginal = response;\n\n// Retornar el resultado de la verificación\nreturn {\n  json: resultado,\n  chat_id: chatId\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -36768,
        -5200
      ],
      "id": "426ef262-98bb-4999-bf36-321506c9ad4e",
      "name": "Code Verificar Inserción2"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "fb1eda05-eb5e-4683-8556-1cf2b5b8e4d5",
              "leftValue": "={{ $json.exito }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -36528,
        -5152
      ],
      "id": "67d9d453-a744-4dec-9e7a-fa7b69c6b9ea",
      "name": "If Verificar Inserción2"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "15a95144-dd82-4ea5-b9ba-9eb924d2ae5c",
              "leftValue": "={{ $json.celdasDiferentes }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -36304,
        -5072
      ],
      "id": "d4761b06-2677-4413-ae7e-25fea8cc0d29",
      "name": "If Diferente Caso2"
    },
    {
      "parameters": {
        "jsCode": "// Código para limpiar una celda donde se insertó incorrectamente un valor\n// Actualizado para manejar la nueva estructura con operaciones de inserción y eliminación\nconst input = $input.first().json;\n\n// Constantes para los IDs de SharePoint/OneDrive\nconst siteId = \"gexpresscargo.sharepoint.com,a592f886-4560-4e62-9646-1eee7add7abe,8b514073-41ae-4619-8f76-724bd912bc65\";\nconst driveId = \"b!hviSpWBFYk6WRh7uet16vnNAUYuuQRlGj3ZyS9kSvGVZ4DSg6c5MRqYYm2MdAER8\";\nconst itemId = \"01PPLUUYXY5E2GK3SJ25EZLJPUYJ43H3ME\";\n\n// Verificar que tenemos la información necesaria\nif (!input || (!input.operaciones && !input.celdaInsertada)) {\n  console.log('Información insuficiente para limpiar la celda incorrecta');\n  return {\n    json: {\n      error: \"INFORMACION_INSUFICIENTE\",\n      mensaje: \"No hay suficiente información para limpiar la celda incorrecta\"\n    }\n  };\n}\n\n// Determinar qué celdas necesitan limpieza\nconst celdasALimpiar = [];\n\n// Verificar si estamos usando la nueva estructura con operaciones\nif (input.operaciones) {\n  // Nueva estructura: usar información de las operaciones\n  const { insercion, eliminacion } = input.operaciones;\n  \n  // Si la inserción falló, agregarla para limpieza\n  if (insercion && !insercion.exito && insercion.celdaRespuesta) {\n    celdasALimpiar.push({\n      celda: insercion.celdaRespuesta,\n      hoja: insercion.hoja || \"\"\n    });\n  }\n  \n  // Si la eliminación falló, agregarla para limpieza\n  if (eliminacion && !eliminacion.exito && eliminacion.celdaRespuesta) {\n    celdasALimpiar.push({\n      celda: eliminacion.celdaRespuesta,\n      hoja: eliminacion.hoja || \"\"\n    });\n  }\n} else {\n  // Estructura anterior: solo tenemos información de inserción\n  // Obtener la celda a limpiar y la información de la hoja\n  const celdaALimpiar = input.celdaInsertada;\n  let hojaExcel = input.nombreHoja || \"\"; // Usar el nombreHoja del input\n  \n  // Intentar extraer el nombre de la hoja de la dirección en la respuesta si no está disponible\n  if ((!hojaExcel || hojaExcel === \"\") && input.respuestaOriginal?.body?.address) {\n    const direccionCompleta = input.respuestaOriginal.body.address;\n    hojaExcel = direccionCompleta.split('!')[0].replace(/'/g, '');\n  }\n  \n  celdasALimpiar.push({\n    celda: celdaALimpiar,\n    hoja: hojaExcel\n  });\n}\n\n// Si no hay celdas para limpiar, devolver error\nif (celdasALimpiar.length === 0) {\n  console.log('No se identificaron celdas para limpiar');\n  return {\n    json: {\n      error: \"NO_HAY_CELDAS\",\n      mensaje: \"No se identificaron celdas que necesiten limpieza\",\n      input: input\n    }\n  };\n}\n\n// Crear solicitudes para limpiar cada celda identificada\nconst solicitudes = celdasALimpiar.map((info, index) => {\n  console.log(`Limpiando celda incorrecta ${info.celda} en hoja ${info.hoja}`);\n  \n  return {\n    id: `Limpiar_${info.celda}_${Date.now()}_${index}`,\n    method: \"PATCH\",\n    url: `/sites/${siteId}/drives/${driveId}/items/${itemId}/workbook/worksheets/${encodeURIComponent(info.hoja)}/range(address='${info.celda}')`,\n    body: {\n      values: [[\"\"]] // Valor vacío para limpiar la celda\n    },\n    headers: {\n      \"Content-Type\": \"application/json\"\n    }\n  };\n});\n\n// Crear la solicitud para limpiar las celdas\nconst requestBody = {\n  requests: solicitudes,\n  _metadata: {\n    accion: \"limpiar\",\n    celdasLimpiadas: celdasALimpiar,\n    datoOriginal: input\n  }\n};\n\n// Retornar el request para limpiar la celda\nreturn {\n  json: requestBody\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -36000,
        -5248
      ],
      "id": "fe74a0a9-8a79-4c3b-ba70-f390b4943530",
      "name": "Code Limpiar Celda Incorrecta2",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://graph.microsoft.com/v1.0/$batch",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "microsoftOAuth2Api",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -35776,
        -5248
      ],
      "id": "a12b5672-d259-443c-814c-9b4109789a32",
      "name": "HTTP Request Limpiar Celda2",
      "credentials": {
        "microsoftOAuth2Api": {
          "id": "mh8Z8hxFvd7LDO8D",
          "name": "CuentaMy SharePoint App Desarrollador1 Konfie "
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "e570827e-13d0-4d6f-b23e-184ca2d3368c",
              "leftValue": "={{ $json.falloEstado }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -35840,
        -4864
      ],
      "id": "1dff2efc-25b3-479d-99b8-536ee552cb21",
      "name": "If fallo Estado2"
    },
    {
      "parameters": {
        "jsCode": "// Código para reintentar la inserción en la celda correcta\n// Actualizado para manejar la nueva estructura con operaciones de inserción y eliminación\nconst input = $input.first().json;\n\n// Constantes para los IDs de SharePoint/OneDrive\nconst siteId = \"gexpresscargo.sharepoint.com,a592f886-4560-4e62-9646-1eee7add7abe,8b514073-41ae-4619-8f76-724bd912bc65\";\nconst driveId = \"b!hviSpWBFYk6WRh7uet16vnNAUYuuQRlGj3ZyS9kSvGVZ4DSg6c5MRqYYm2MdAER8\";\nconst itemId = \"01PPLUUYXY5E2GK3SJ25EZLJPUYJ43H3ME\";\n\n// Si el input viene del nodo anterior de limpiar celda, extraer el dato original\nconst datoOriginal = input._metadata?.datoOriginal || input;\n\n// Verificar que tenemos la información necesaria\nif (!datoOriginal) {\n  console.log('Información insuficiente para reintentar la inserción/eliminación');\n  return {\n    json: {\n      error: \"INFORMACION_INSUFICIENTE\",\n      mensaje: \"No hay suficiente información para reintentar las operaciones\"\n    }\n  };\n}\n\n// Operaciones a reintentar\nconst operacionesAReintentar = [];\n\n// Determinar qué operaciones necesitan reintento\nif (datoOriginal.operaciones) {\n  // Nueva estructura: evaluar inserción y eliminación\n  const { insercion, eliminacion } = datoOriginal.operaciones;\n  \n  // Verificar si la inserción necesita reintento\n  if (insercion && !insercion.exito) {\n    operacionesAReintentar.push({\n      tipo: \"insercion\",\n      celda: insercion.celda,\n      valor: insercion.valor,\n      hoja: insercion.hoja || datoOriginal.resultadoDetallado?.operaciones?.insercion?.hoja || \"\"\n    });\n  }\n  \n  // Verificar si la eliminación necesita reintento\n  if (eliminacion && !eliminacion.exito) {\n    operacionesAReintentar.push({\n      tipo: \"eliminacion\",\n      celda: eliminacion.celda,\n      valor: \"\", // Para eliminación, siempre usamos valor vacío\n      hoja: eliminacion.hoja || datoOriginal.resultadoDetallado?.operaciones?.eliminacion?.hoja || \"\"\n    });\n  }\n} else {\n  // Estructura anterior: solo tenemos información de inserción\n  // Obtener la celda correcta donde insertar y el valor a insertar\n  const celdaCorrecta = datoOriginal.celdaOriginal;\n  \n  // Intentar obtener el valor correcto a insertar\n  let valorAInsertar;\n  \n  // Primero, verificar si tenemos el valor de la respuesta original\n  if (datoOriginal.valorInsertado !== undefined) {\n    valorAInsertar = datoOriginal.valorInsertado;\n  } \n  // Si no, intentar obtenerlo del body de la respuesta\n  else if (datoOriginal.respuestaOriginal?.body?.values?.[0]?.[0] !== undefined) {\n    valorAInsertar = datoOriginal.respuestaOriginal.body.values[0][0];\n  } \n  // Como último recurso, usar un valor vacío\n  else {\n    valorAInsertar = \"\";\n    console.log('No se pudo determinar el valor a insertar, usando valor vacío');\n  }\n  \n  // Obtener la hoja de Excel - primero del dato original\n  let hojaExcel = datoOriginal.nombreHoja || \"\"; \n  \n  // Si no está disponible en el objeto principal, intentar obtenerlo de otros lugares\n  if (!hojaExcel || hojaExcel === \"\") {\n    // Verificar si está en el _metadata\n    hojaExcel = input._metadata?.hoja || \"\";\n    \n    // Como último recurso, extraer de la dirección en la respuesta\n    if ((!hojaExcel || hojaExcel === \"\") && datoOriginal.respuestaOriginal?.body?.address) {\n      const direccionCompleta = datoOriginal.respuestaOriginal.body.address;\n      hojaExcel = direccionCompleta.split('!')[0].replace(/'/g, '');\n    }\n  }\n  \n  operacionesAReintentar.push({\n    tipo: \"insercion\",\n    celda: celdaCorrecta,\n    valor: valorAInsertar,\n    hoja: hojaExcel\n  });\n}\n\n// Si no hay operaciones para reintentar, devolver error\nif (operacionesAReintentar.length === 0) {\n  console.log('No se identificaron operaciones para reintentar');\n  return {\n    json: {\n      error: \"NO_HAY_OPERACIONES\",\n      mensaje: \"No se identificaron operaciones que necesiten reintento\",\n      input: datoOriginal\n    }\n  };\n}\n\n// Crear solicitudes para cada operación a reintentar\nconst solicitudes = operacionesAReintentar.map((op, index) => {\n  // Determinar el tipo de valor y formatearlo adecuadamente\n  let valorFormateado;\n  if (typeof op.valor === 'number') {\n    valorFormateado = [[op.valor]]; // Mantener el tipo numérico\n  } else {\n    valorFormateado = [[op.valor.toString()]]; // Convertir a string para otros tipos\n  }\n  \n  console.log(`Reintentando ${op.tipo} en celda ${op.celda} de la hoja ${op.hoja} con valor \"${op.valor}\"`);\n  \n  return {\n    id: `Reintento_${op.tipo}_${op.celda}_${Date.now()}_${index}`,\n    method: \"PATCH\",\n    url: `/sites/${siteId}/drives/${driveId}/items/${itemId}/workbook/worksheets/${encodeURIComponent(op.hoja)}/range(address='${op.celda}')`,\n    body: {\n      values: valorFormateado\n    },\n    headers: {\n      \"Content-Type\": \"application/json\"\n    }\n  };\n});\n\n// Crear la solicitud para reintentar las operaciones\nconst requestBody = {\n  requests: solicitudes,\n  _metadata: {\n    accion: \"reintentar\",\n    operaciones: operacionesAReintentar,\n    datoOriginal: datoOriginal,\n    intentos: (datoOriginal._metadata?.intentos || 0) + 1\n  }\n};\n\n// Retornar el request para reintentar las operaciones\nreturn {\n  json: requestBody\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -35504,
        -5184
      ],
      "id": "898601ac-f410-4a80-907a-1cdf56027d2c",
      "name": "Code Reintentar Inserción2",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://graph.microsoft.com/v1.0/$batch",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "microsoftOAuth2Api",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -35264,
        -5072
      ],
      "id": "60bbcff1-2982-4839-a09c-672599bc374c",
      "name": "HTTP Request Reintentar Inserción2",
      "credentials": {
        "microsoftOAuth2Api": {
          "id": "mh8Z8hxFvd7LDO8D",
          "name": "CuentaMy SharePoint App Desarrollador1 Konfie "
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Código para verificar si la inserción y eliminación fueron exitosas\n// Actualizado para manejar la nueva estructura\nconst input = $input.first().json;\n\n// Verificar que tenemos la estructura esperada en la respuesta\nif (!input || !input.responses || !Array.isArray(input.responses)) {\n  console.log('Estructura de datos de respuesta no válida');\n  return {\n    json: {\n      error: \"RESPUESTA_INVALIDA\",\n      mensaje: \"La estructura de datos de la respuesta no es válida\",\n      exito: false\n    }\n  };\n}\n\n// Si no hay respuestas, devolver error\nif (input.responses.length === 0) {\n  console.log('No se recibieron respuestas del servidor');\n  return {\n    json: {\n      error: \"SIN_RESPUESTAS\",\n      mensaje: \"No se recibieron respuestas del servidor\",\n      exito: false\n    }\n  };\n}\n\n// Analizar las respuestas para determinar a qué operación corresponde cada una\nconst respuestas = input.responses.map(response => {\n  // Extraer información del ID de la respuesta\n  const idPartes = response.id.split('_');\n  const tipoOperacion = idPartes[0].toLowerCase(); // \"reintento\", \"limpiar\", etc.\n  const tipoEntidad = idPartes[1]?.toLowerCase(); // \"insercion\", \"eliminacion\", etc.\n  const celda = idPartes[2] || \"\"; // La celda como I21, K23, etc.\n  \n  // Extraer información de la dirección en la respuesta\n  let direccionRespuesta = \"\";\n  let hojaExcel = \"\";\n  \n  if (response.body && response.body.address) {\n    const direccionCompleta = response.body.address;\n    const partesDireccion = direccionCompleta.split('!');\n    \n    if (partesDireccion.length > 1) {\n      // Quitar las comillas simples del nombre de la hoja\n      hojaExcel = partesDireccion[0].replace(/'/g, '');\n      direccionRespuesta = partesDireccion[1];\n    }\n  }\n  \n  // Obtener el valor de la respuesta\n  const valor = response.body?.values?.[0]?.[0];\n  \n  // Verificar si la operación fue exitosa (código 200-299)\n  const estadoExitoso = response.status >= 200 && response.status < 300;\n  \n  // Verificar si la celda en la respuesta coincide con la esperada\n  const celdaCorrecta = direccionRespuesta === celda;\n  \n  return {\n    id: response.id,\n    tipoOperacion,\n    tipoEntidad,\n    celda,\n    direccionRespuesta,\n    hoja: hojaExcel,\n    valor,\n    estadoExitoso,\n    celdaCorrecta,\n    statusCode: response.status,\n    respuesta: response\n  };\n});\n\n// Separar las respuestas por tipo de operación\nconst respuestasInsercion = respuestas.filter(r => \n  r.tipoEntidad === \"insercion\" || \n  (r.tipoOperacion === \"reintento\" && input._metadata?.operaciones?.[0]?.tipo === \"insercion\")\n);\n\nconst respuestasEliminacion = respuestas.filter(r => \n  r.tipoEntidad === \"eliminacion\" || \n  (r.tipoOperacion === \"reintento\" && input._metadata?.operaciones?.[0]?.tipo === \"eliminacion\")\n);\n\n// Determinar éxito por tipo de operación\nconst insercionExitosa = respuestasInsercion.length > 0 && \n                        respuestasInsercion.every(r => r.estadoExitoso && r.celdaCorrecta);\n\nconst eliminacionExitosa = respuestasEliminacion.length > 0 && \n                          respuestasEliminacion.every(r => r.estadoExitoso && r.celdaCorrecta);\n\n// Determinar éxito global basado en las operaciones presentes\nlet exitoGlobal;\n\nif (respuestasInsercion.length > 0 && respuestasEliminacion.length > 0) {\n  // Si hay ambas operaciones, ambas deben ser exitosas\n  exitoGlobal = insercionExitosa && eliminacionExitosa;\n} else if (respuestasInsercion.length > 0) {\n  // Si solo hay inserción, solo esa debe ser exitosa\n  exitoGlobal = insercionExitosa;\n} else if (respuestasEliminacion.length > 0) {\n  // Si solo hay eliminación, solo esa debe ser exitosa\n  exitoGlobal = eliminacionExitosa;\n} else {\n  // Si no hay operaciones identificables, considerar como no exitoso\n  exitoGlobal = false;\n}\n\n// Obtener la información más relevante para cada tipo de operación\nconst infoInsercion = respuestasInsercion.length > 0 ? respuestasInsercion[0] : null;\nconst infoEliminacion = respuestasEliminacion.length > 0 ? respuestasEliminacion[0] : null;\n\n// Crear el resultado detallado\nconst resultadoDetallado = {\n  exito: exitoGlobal,\n  operaciones: {\n    insercion: infoInsercion ? {\n      exito: infoInsercion.estadoExitoso && infoInsercion.celdaCorrecta,\n      celda: infoInsercion.celda,\n      direccionRespuesta: infoInsercion.direccionRespuesta,\n      hoja: infoInsercion.hoja,\n      valor: infoInsercion.valor,\n      statusCode: infoInsercion.statusCode\n    } : null,\n    eliminacion: infoEliminacion ? {\n      exito: infoEliminacion.estadoExitoso && infoEliminacion.celdaCorrecta,\n      celda: infoEliminacion.celda,\n      direccionRespuesta: infoEliminacion.direccionRespuesta,\n      hoja: infoEliminacion.hoja,\n      valor: infoEliminacion.valor,\n      statusCode: infoEliminacion.statusCode\n    } : null\n  },\n  mensaje: exitoGlobal ? \n    \"Todas las operaciones se completaron exitosamente\" : \n    \"Hubo problemas con una o más operaciones\",\n  respuestasCompletas: respuestas\n};\n\n// Crear el resultado compatible con el formato anterior\nconst resultadoCompatible = {\n  exito: exitoGlobal,\n  // Usar la primera respuesta para compatibilidad\n  celdaOriginal: infoInsercion?.celda || infoEliminacion?.celda || \"\",\n  celdaInsertada: infoInsercion?.direccionRespuesta || infoEliminacion?.direccionRespuesta || \"\",\n  valorInsertado: infoInsercion?.valor || infoEliminacion?.valor || \"\",\n  statusCode: infoInsercion?.statusCode || infoEliminacion?.statusCode || 0,\n  requestId: infoInsercion?.id || infoEliminacion?.id || \"\",\n  indice: infoInsercion?.celda || infoEliminacion?.celda || \"\",\n  celdasDiferentes: (infoInsercion && infoInsercion.celda !== infoInsercion.direccionRespuesta) ||\n                   (infoEliminacion && infoEliminacion.celda !== infoEliminacion.direccionRespuesta),\n  falloEstado: !exitoGlobal,\n  // Información adicional para la versión mejorada\n  resultadoDetallado: resultadoDetallado\n};\n\n// Registrar el resultado en consola\nif (exitoGlobal) {\n  console.log(\"Operaciones completadas exitosamente:\");\n  if (infoInsercion) {\n    console.log(`- Inserción en hoja ${infoInsercion.hoja}, celda ${infoInsercion.celda}, valor: \"${infoInsercion.valor}\"`);\n  }\n  if (infoEliminacion) {\n    console.log(`- Eliminación en hoja ${infoEliminacion.hoja}, celda ${infoEliminacion.celda}`);\n  }\n} else {\n  console.log(\"Problemas detectados en las operaciones:\");\n  if (infoInsercion && (!infoInsercion.estadoExitoso || !infoInsercion.celdaCorrecta)) {\n    console.log(`- Fallo en inserción: celda=${infoInsercion.celda}, dirección respuesta=${infoInsercion.direccionRespuesta}, status=${infoInsercion.statusCode}`);\n  }\n  if (infoEliminacion && (!infoEliminacion.estadoExitoso || !infoEliminacion.celdaCorrecta)) {\n    console.log(`- Fallo en eliminación: celda=${infoEliminacion.celda}, dirección respuesta=${infoEliminacion.direccionRespuesta}, status=${infoEliminacion.statusCode}`);\n  }\n}\n\n// Retornar el resultado\nreturn {\n  json: resultadoCompatible\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -35040,
        -5072
      ],
      "id": "ce0825fb-5ccc-4329-aadb-0448065eafe8",
      "name": "Code Volver a validar Inserción2",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "f7205e4e-147c-4e77-8fa8-08d082980b48",
              "leftValue": "={{ $json.exito }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -34816,
        -5072
      ],
      "id": "90ecbccd-de49-4794-b696-6e206b7950aa",
      "name": "If Verificar Inserción 1"
    },
    {
      "parameters": {
        "amount": 3
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        -35920,
        -5072
      ],
      "id": "72f82505-6b69-4a59-acab-0d4ffa87e445",
      "name": "Wait6",
      "webhookId": "a4bbf2b1-ea0c-4b02-af2c-64b29f2bdb5c"
    },
    {
      "parameters": {
        "amount": 3
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        -34528,
        -4880
      ],
      "id": "caf763fd-17dd-4b62-9cd1-66f12bbefafc",
      "name": "Wait7",
      "webhookId": "9d944db7-9c4f-439e-9990-d9937f2fb18e"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -34080,
        -4528
      ],
      "id": "eb8424c9-f97f-4585-9bfa-558b2fbe7119",
      "name": "OpenAI Chat Model18",
      "credentials": {
        "openAiApi": {
          "id": "AD8kPcNVReuclASd",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "=define",
        "text": "=Eres un asistente de un sistema de agendamiento de citas para la entrega de mercancía en bodega. Debes notificar al cliente que ha ocurrido un error en el sistema durante el proceso de cancelación de la cita en el sistema de Excel.\n\nGenera un mensaje directo (sin saludos iniciales ni mencionar nombres) que:\n\n1. Comunique claramente que se produjo un error técnico al intentar cancelación la cita en el sistema.\n\n2. Indique que es urgente que se comunique con el área de bodega en los próximos 5 minutos para que puedan cancelar la cita manualmente.\n\n4. Aclare que esta situación es poco común y se debe a un inconveniente técnico en el sistema de agendamiento.\n\n5. Pida disculpas por los inconvenientes ocasionados y agradezca la comprensión.\n\nTono: urgente pero profesional, enfatizando la importancia de la acción inmediata para mantener la franja horaria seleccionada.\n"
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        -34000,
        -4752
      ],
      "id": "f4d9761a-c955-4836-9f17-1d00487668ef",
      "name": "Basic LLM Notificar No Disponibilidad4",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "4bfbecb3-9d4f-4425-aa76-a92abc7708fb",
              "leftValue": "={{ $('Basic LLM Notificar No Disponibilidad4').item.json.text.length }}",
              "rightValue": 70,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -33600,
        -4560
      ],
      "id": "05eb218b-bd1f-4d4d-9748-f783e49c0124",
      "name": "Validación de longitud de caracteres16"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d9c2ff70-4fd1-4b93-8571-6d0ac5a0093e",
              "name": "mensaje.ia",
              "value": "={{ $('Basic LLM Notificar No Disponibilidad4').item.json.text }}",
              "type": "string"
            },
            {
              "id": "ac8a03be-0292-4735-9580-39a385945c47",
              "name": "mensaje.longitud",
              "value": "={{ $('Basic LLM Notificar No Disponibilidad4').item.json.text.length }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -33296,
        -4544
      ],
      "id": "8f30f096-b2a9-47cf-b197-6a6eed182469",
      "name": "Organiza variables del mensaje15"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -33120,
        -4768
      ],
      "id": "0de6766d-3d0b-4595-99c1-41f1e1c6b152",
      "name": "No Operation, do nothing20"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $('Code Respuesta Faltantes').item.json.text }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -33296,
        -4768
      ],
      "id": "113a2540-25cd-4d9b-aa48-93298e3be70a",
      "name": "HTTP Request Enviar Mensaje por WhatsApp19"
    },
    {
      "parameters": {
        "jsCode": "/*\n===========================================================\n  Nodo Code - VALIDAR INSERCIONES EN EXCEL (n8n)\n  • Analiza la salida del “Loop Over Uno a Uno”.\n  • Agrupa los ítems por franja (campo `indice` si existe;\n    de lo contrario, cada bloque de 5 ítems forma una franja).\n  • Verifica que cada inserción tenga:\n        exito === true\n        statusCode === 200\n        falloEstado === false\n  • Devuelve un único objeto JSON con:\n        – Resumen global.\n        – Detalle por franja (éxitos / fallos y celdas con error).\n===========================================================\n*/\n\n// 1) Obtener todos los ítems que llegan al nodo\nconst items = $input.all();\n\n// 2) Función auxiliar para determinar el identificador de la franja\nfunction obtenerIdFranja(item, idx) {\n  // Si existe 'indice', úsalo; de lo contrario agrupa cada 5 ítems\n  if (item.json && item.json.indice !== undefined && item.json.indice !== null) {\n    return String(item.json.indice).trim();\n  }\n  // +1 para que las franjas queden 1-basadas\n  return String(Math.floor(idx / 5) + 1);\n}\n\n// 3) Agrupar ítems por franja\nconst franjas = {};\nitems.forEach((item, idx) => {\n  const idFranja = obtenerIdFranja(item, idx);\n  if (!franjas[idFranja]) {\n    franjas[idFranja] = { id: idFranja, items: [] };\n  }\n  franjas[idFranja].items.push(item.json);\n});\n\n// 4) Analizar cada franja y construir el detalle\nconst detallesPorFranja = Object.values(franjas).map(franja => {\n  const totalOps   = franja.items.length;\n  const exitosas   = franja.items.filter(i =>\n    i.exito === true &&\n    i.statusCode === 200 &&\n    i.falloEstado === false\n  ).length;\n\n  const fallidas   = totalOps - exitosas;\n  const exitoTotal = fallidas === 0;\n\n  // Celdas con error para un diagnóstico claro\n  const celdasFallidas = franja.items\n    .filter(i => !(i.exito && i.statusCode === 200 && !i.falloEstado))\n    .map(i => ({\n      celdaOriginal   : i.celdaOriginal,\n      celdaInsertada  : i.celdaInsertada,\n      statusCode      : i.statusCode,\n      falloEstado     : i.falloEstado,\n      celdasDiferentes: i.celdasDiferentes,\n      mensaje         : 'Inserción fallida'\n    }));\n\n  return {\n    idFranja                : franja.id,\n    exitoFranja             : exitoTotal,\n    operacionesTotales      : totalOps,\n    operacionesExitosas     : exitosas,\n    operacionesFallidas     : fallidas,\n    porcentajeExitosas      : ((exitosas / totalOps) * 100).toFixed(2) + '%',\n    celdasFallidas\n  };\n});\n\n// 5) Resumen global\nconst operacionesTotales   = items.length;\nconst operacionesExitosas  = detallesPorFranja.reduce((sum, f) => sum + f.operacionesExitosas, 0);\nconst operacionesFallidas  = operacionesTotales - operacionesExitosas;\n\nconst franjasTotales   = detallesPorFranja.length;\nconst franjasExitosas  = detallesPorFranja.filter(f => f.exitoFranja).length;\nconst franjasFallidas  = franjasTotales - franjasExitosas;\n\n\nconst resumen = {\n  estadoGeneral              : franjasFallidas === 0 ? 'ÉXITO_COMPLETO' : 'ÉXITO_PARCIAL',\n  franjasTotales,\n  franjasExitosas,\n  franjasFallidas,\n  porcentajeFranjasExitosas  : ((franjasExitosas / franjasTotales) * 100).toFixed(2) + '%',\n  operacionesTotales,\n  operacionesExitosas,\n  operacionesFallidas,\n  porcentajeOperacionesExitosas : ((operacionesExitosas / operacionesTotales) * 100).toFixed(2) + '%',\n  detallesPorFranja\n};\n\n// 6) Devolver un único ítem con el resumen\nreturn [\n  {\n    json: resumen\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -37120,
        -5408
      ],
      "id": "6c415adf-be0e-4b9c-a83c-f567ac9d4f7c",
      "name": "Code Validar inserciones2"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "8c501d95-bdf3-4635-a037-224926c2528d",
              "leftValue": "={{ $json.estadoGeneral }}",
              "rightValue": "ÉXITO_COMPLETO",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -36784,
        -5408
      ],
      "id": "886f6583-4767-4ec8-828f-df582dd47885",
      "name": "If Validar inserciones2"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.1,
      "position": [
        -36480,
        -5520
      ],
      "id": "763d75bd-bf71-4e9f-812d-fbc0945d3b0e",
      "name": "Merge6"
    },
    {
      "parameters": {
        "numberInputs": 3
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.1,
      "position": [
        -33648,
        -5088
      ],
      "id": "3bf96dcb-4255-42de-a23e-18449b5f54f7",
      "name": "Merge7"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -33328,
        -4992
      ],
      "id": "83c083b0-b318-4ac0-a398-425fb46d13d8",
      "name": "OpenAI Chat Model19",
      "credentials": {
        "openAiApi": {
          "id": "AD8kPcNVReuclASd",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "4bfbecb3-9d4f-4425-aa76-a92abc7708fb",
              "leftValue": "={{ $('Basic LLM Notificar Cancelar Cita').item.json.text.length }}",
              "rightValue": 70,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -32784,
        -5024
      ],
      "id": "4629725c-d5e1-4895-8e80-a8f0eba039ce",
      "name": "Validación de longitud de caracteres17"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d9c2ff70-4fd1-4b93-8571-6d0ac5a0093e",
              "name": "mensaje.ia",
              "value": "={{ $('Basic LLM Notificar Cancelar Cita').item.json.text }}",
              "type": "string"
            },
            {
              "id": "ac8a03be-0292-4735-9580-39a385945c47",
              "name": "mensaje.longitud",
              "value": "={{ $('Basic LLM Notificar Cancelar Cita').item.json.text.length }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -32480,
        -4912
      ],
      "id": "ec8c7d8e-bef5-4f75-99ed-eb17d8d38e89",
      "name": "Organiza variables del mensaje16"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -32320,
        -5120
      ],
      "id": "9e95a021-ea9a-41e5-827e-d62bd920aab5",
      "name": "No Operation, do nothing21"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $('Code Respuesta Faltantes').item.json.text }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -32496,
        -5120
      ],
      "id": "491c24e7-a56a-413b-9bf1-2112860acae9",
      "name": "HTTP Request Enviar Mensaje por WhatsApp20"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "BEGIN TRANSACTION;\n\nDELETE FROM MensajesWhatsApp\nWHERE chat_id = '{{ $('Unificación y consistencia de datos').first().json.infoMensaje.chat_id }}'\n   OR (chat_id = 'agenteAI'\n       AND message_id IN (\n           SELECT message_id \n           FROM MensajesWhatsApp\n           WHERE chat_id = '{{ $('Unificación y consistencia de datos').first().json.infoMensaje.chat_id }}'\n       )\n   );\n\nDELETE FROM FranjasDisponiblesTemp \nWHERE chat_id = '{{ $('Unificación y consistencia de datos').first().json.infoMensaje.chat_id }}';\n\nCOMMIT;\n"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        -34208,
        -4864
      ],
      "id": "8deb1334-fe50-4983-9eb7-9a76937730c6",
      "name": "Microsoft SQL Eliminar Mensajes5",
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "DECLARE @id           INT = {{ $('Code validación de cita en malla').first().json.datosValidacion.citaBD.id }};\nDECLARE @nowBogota    DATETIME;\n\n/* Obtener fecha/hora actual en Bogotá */\nSET @nowBogota = CONVERT(DATETIME, SYSDATETIMEOFFSET() AT TIME ZONE 'SA Pacific Standard Time');\n\n/* UPDATE para CANCELACIÓN */\nUPDATE dbo.CitasRecepcion\nSET estado = N'CANCELADA',\n    fecha_modificacion = @nowBogota\nWHERE id = @id;\n\n/* Devolver la fila modificada */\nSELECT *\nFROM dbo.CitasRecepcion\nWHERE id = @id;"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        -34576,
        -5328
      ],
      "id": "0d006839-6392-43e9-bc26-2876dafc7f80",
      "name": "Microsoft SQLUpdate Cita Anterior1",
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Código para preparar datos de CANCELACIÓN\nconst datosValidacion = $('Code validación de cita en malla').first().json.datosValidacion;\nconst citaBD = datosValidacion.citaBD;\nconst chatId = $('Organiza el Mensaje').first().json.infoMensaje.chat_id;\nconst historialMensajes = $('Unificación y consistencia de datos').first().json.infoMensaje.historialMensajes;\n\nconsole.log(`Preparando datos para cancelación de cita ID ${citaBD.id}`);\n\nconst datosCancelacion = {\n  // Datos identificadores\n  id: citaBD.id,\n  chat_id: chatId,\n  \n  // Datos de la cita cancelada\n  proveedor: citaBD.nombre,\n  orden_compra: citaBD.ordenCompra,\n  peso: citaBD.peso,\n  unidades: citaBD.unidades,\n  fecha_cita_original: citaBD.fechaCita,\n  \n  // Estado y auditoría\n  estado_anterior: \"PROGRAMADA\",\n  estado_nuevo: \"CANCELADA\",\n  chat_historial: historialMensajes,\n  fecha_cancelacion: new Date().toISOString(),\n  \n  // Información adicional\n  ubicacion_malla: datosValidacion.ubicacion,\n  accion: \"CANCELACION\",\n  motivo: \"cancelacion_por_proveedor\"\n};\n\nconsole.log(`Cancelación preparada: ${datosCancelacion.proveedor} - O/C: ${datosCancelacion.orden_compra}`);\n\nreturn {\n  json: datosCancelacion\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -37120,
        -5552
      ],
      "id": "4ca84d77-04e5-475a-9b06-b5f740b8fe7e",
      "name": "Code Datos Cancelar Cita"
    },
    {
      "parameters": {
        "promptType": "=define",
        "text": "=# Rol\nEres el asistente virtual de **Konfíe Logistics**.  \nTu objetivo es notificar al proveedor que su cita se **canceló exitosamente**.\n\n# Datos disponibles  \n- idCita           = {{ $('Code validación de cita en malla').first().json.datosValidacion.citaBD.id }}  \n- ordenCompra      = {{ $('Code validación de cita en malla').first().json.datosValidacion.citaBD.ordenCompra }}\n- proveedor        = {{ $('Code validación de cita en malla').first().json.datosValidacion.citaBD.nombre }}\n- peso             = {{ $('Code validación de cita en malla').first().json.datosValidacion.citaBD.peso }}\n- unidades         = {{ $('Code validación de cita en malla').first().json.datosValidacion.citaBD.unidades }}\n- fechaCita        = {{ $('Code validación de cita en malla').first().json.datosValidacion.citaBD.fechaCita }}\n- ubicacionMalla   = {{ $('Code validación de cita en malla').first().json.datosValidacion.ubicacion }}\n\n# Instrucciones de redacción\n1. Mantén un tono profesional, comprensivo y servicial.  \n2. Empieza confirmando la cancelación exitosa (ej: \"✅ Cancelación confirmada\" o \"🚫 Cita cancelada exitosamente\").  \n3. Muestra los **detalles de la cita cancelada** con emojis:  \n   • 🔖 **Cita cancelada:** {{ $('Code validación de cita en malla').first().json.datosValidacion.citaBD.id }}\n   • 👤 **Proveedor:** {{ $('Code validación de cita en malla').first().json.datosValidacion.citaBD.nombre }}\n   • 🏷️ **O/C:** {{ $('Code validación de cita en malla').first().json.datosValidacion.citaBD.ordenCompra }}\n   • 📅 **Fecha programada:** {{ $('Code validación de cita en malla').first().json.datosValidacion.citaBD.fechaCita }}\n   • ⚖️ **Peso:** {{ $('Code validación de cita en malla').first().json.datosValidacion.citaBD.peso }} kg\n   • 📦 **Unidades:** {{ $('Code validación de cita en malla').first().json.datosValidacion.citaBD.unidades }}\n4. Informa que si necesita **agendar una nueva cita**, puede iniciar una nueva conversación.\n5. Agradece por haber notificado la cancelación con anticipación.\n6. Devuelve **solo** el mensaje final, sin encabezados.\n\n# Salida esperada (ejemplo de estilo)\n\n🚫 **Cita cancelada exitosamente**\n\nLos siguientes datos han sido cancelados en nuestro sistema:\n- 🔖 **Cita:** 12345  \n- 👤 **Proveedor:** SPB COLOMBIA S.A.S  \n- 🏷️ **O/C:** ARGM47896  \n- 📅 **Fecha:** 10 de junio de 2025  \n- ⚖️ **Peso:** 300 kg | 📦 **Unidades:** 600  \n\nSi necesitas agendar una nueva cita, puedes iniciar una nueva conversación en cualquier momento.\n\n¡Gracias por notificar la cancelación con anticipación! 🙏"
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        -33216,
        -5168
      ],
      "id": "5670fdea-6089-4122-8fe7-73939b590c13",
      "name": "Basic LLM Notificar Cancelar Cita",
      "alwaysOutputData": true,
      "executeOnce": true
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -40464,
        -1520
      ],
      "id": "3bf7d77b-9a66-4326-a31a-293d30a217df",
      "name": "OpenAI Chat Model5",
      "credentials": {
        "openAiApi": {
          "id": "AD8kPcNVReuclASd",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "b2110549-dd58-46b3-9707-dbbe0a5004f2",
              "leftValue": "={{ $('Estructuración, de datos').item.json.mensajeParaEnviar.length }}",
              "rightValue": 70,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -39648,
        -1728
      ],
      "id": "cc37ff3a-8030-4348-acdd-710eaf94a906",
      "name": "Validación de longitud de caracteres15"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -39104,
        -1872
      ],
      "id": "4eb453b7-f1db-47f8-a59e-84284c517abb",
      "name": "No Operation, do nothing19"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $('Estructuración, de datos').item.json.mensajeParaEnviar }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -39296,
        -1872
      ],
      "id": "a47c5faa-ead7-4a4d-931e-8e8a85a78803",
      "name": "HTTP Request Enviar Mensaje por WhatsApp18"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d9c2ff70-4fd1-4b93-8571-6d0ac5a0093e",
              "name": "mensaje.ia",
              "value": "={{ $('Estructuración, de datos').item.json.mensajeParaEnviar }}",
              "type": "string"
            },
            {
              "id": "ac8a03be-0292-4735-9580-39a385945c47",
              "name": "mensaje.longitud",
              "value": "={{ $('Estructuración, de datos').item.json.mensajeParaEnviar.length }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -34848,
        -1744
      ],
      "id": "48bd83e4-6d07-4acd-91bc-37350d5f50fd",
      "name": "Organiza variables del mensaje17"
    },
    {
      "parameters": {
        "promptType": "=define",
        "text": "=# ASISTENTE DE INFORMACIÓN GENERAL - KONFIE IA LOGISTICS\n\nEres un asistente especializado en proporcionar información general sobre Konfie IA Logistics, una empresa pionera en logística inteligente en Colombia.\n\n## CONTEXTO IMPORTANTE DEL CHAT\n**PROPÓSITO ESPECÍFICO:** Este chat de WhatsApp está diseñado EXCLUSIVAMENTE para que los proveedores de Konfie IA Logistics puedan gestionar citas de entrega de mercancía en la bodega de la empresa. No está autorizado ni programado para otras gestiones comerciales, ventas, contrataciones o servicios generales.\n\n**AUDIENCIA:** Proveedores que necesitan agendar, consultar, modificar o cancelar citas de descargue de mercancía.\n\n## INFORMACIÓN DE LA EMPRESA\n\n### Acerca de Konfie IA Logistics\n**Misión:** Redefinir los límites de lo posible en logística a través de la transparencia y la innovación.\n**Visión:** Transformar la logística en una experiencia sin precedentes.\n**Especialidad:** Logística inteligente con tecnología de inteligencia artificial y sistemas GPS de última generación.\n\n### Servicios Principales\n1. **Transporte Impo y Expo**\n   - Operaciones de transporte de carga contenerizada desde y hacia los puertos\n   - Servicios FTL (Full Truck Load), LTL (Less Than Truck Load), ITR\n\n2. **Carga Masiva Nacional**\n   - Transporte masivo nacional\n   - Servicios urbanos y nacionales\n   - Multientregas con rutas lógicas\n   - Diferentes tipos de vehículos\n\n3. **Distribución Multientrega**\n   - Transporte a múltiples destinos\n   - Seguimiento en tiempo real\n   - Información detallada de cada entrega por separado\n\n4. **Almacenamiento**\n   - Administración, control y seguridad de mercancía\n   - Gestión integral de inventarios\n\n5. **Última Milla**\n   - Distribución a cliente final\n   - Desde centros de distribución o almacenamiento\n   - Cualquier tipo de vehículo requerido\n   - Servicio de urgencias\n\n6. **ITR (Inland Terminal Rail)**\n   - Operación de patios en puertos\n   - Cargue y descargue de vehículos\n   - Consolidación de mercancías\n\n7. **Flotas Dedicadas**\n   - Ajuste a especificaciones técnicas específicas\n   - Flotas personalizadas según tipo de vehículo requerido\n\n### Tecnología e Innovación\n- **Inteligencia Artificial:** Optimización de rutas y procesos\n- **Sistemas GPS:** Tecnología de última generación para seguimiento\n- **Seguimiento en tiempo real:** Información oportuna y veraz\n- **Sostenibilidad:** Prácticas responsables con el medio ambiente\n\n### Cobertura\n- **País principal:** Colombia\n- **Alcance:** Envíos en toda Colombia\n- **Experiencia:** Años de trayectoria en el mercado logístico\n\n### Sitio Web\n- **URL:** https://www.konfie.com/es_CO\n- **Redes sociales:** Facebook - Konfie IA Logistics\n\n## INSTRUCCIONES PARA RESPONDER\n\n1. **SIEMPRE mencionar el propósito del chat:** En cada respuesta, recuerda al usuario que este chat está destinado exclusivamente para gestión de citas de entrega de mercancía en la bodega\n2. **Respuestas claras y concisas:** Proporciona información directa y útil sobre la empresa\n3. **Tono profesional y amigable:** Mantén un tono cordial pero profesional\n4. **Información específica:** Cuando sea posible, proporciona detalles específicos sobre servicios de la empresa\n5. **Redirección apropiada:** Siempre orienta hacia el propósito principal del chat (gestión de citas)\n6. **Respuestas completas:** Asegúrate de abordar la consulta pero contextualizar el propósito del chat\n\n## TIPOS DE PREGUNTAS QUE PUEDES RESPONDER\n- Información sobre servicios y capacidades de Konfie IA Logistics\n- Ubicación y cobertura geográfica de la empresa\n- Tecnología y diferenciadores de la empresa\n- Proceso general de trabajo de la empresa\n- Información corporativa de Konfie IA Logistics\n- Preguntas sobre sostenibilidad y responsabilidad ambiental de la empresa\n\n**IMPORTANTE:** Independientemente del tipo de pregunta, SIEMPRE debes contextualizar que este chat es para gestión de citas de entrega de mercancía.\n\n## MANEJO DE CONSULTAS NO RELACIONADAS CON LA EMPRESA\n\n### Si la pregunta NO tiene relación con Konfie IA Logistics:\n**Ejemplo de respuesta:**\n\"Hola, espero que estés bien. Este chat pertenece a **Konfie IA Logistics**, una empresa especializada en logística inteligente que ofrece servicios como transporte de carga, distribución, almacenamiento y última milla en Colombia. \n\nEspecíficamente, este chat está diseñado para que nuestros **proveedores puedan gestionar citas de entrega de mercancía en nuestra bodega** (agendar, consultar, modificar o cancelar citas de descargue).\n\nSi necesitas más información sobre nuestra empresa, puedes visitar: https://www.konfie.com/es_CO\n\n¿En qué puedo ayudarte con la gestión de tu cita de entrega?\"\n\n### Si la pregunta SÍ está relacionada con Konfie pero NO con citas de entrega:\n**Ejemplo de respuesta:**\n\"Te comparto la información sobre [responder la pregunta específica sobre la empresa]. \n\nEs importante mencionar que este chat está específicamente diseñado para que nuestros **proveedores gestionen citas de entrega de mercancía en nuestra bodega**. Para consultas comerciales, contrataciones o otros servicios, te recomiendo contactar directamente a través de nuestro sitio web: https://www.konfie.com/es_CO\n\n¿Necesitas ayuda con alguna gestión de cita de entrega de mercancía?\"\n\n## LIMITACIONES\n- **NO proporciones información de precios específicos** (solicita que contacten directamente)\n- **NO hagas promesas sobre tiempos de entrega específicos** sin conocer detalles\n- **NO proporciones información de contacto específica** que no tengas confirmada\n- **NO gestiones consultas comerciales, ventas o contrataciones** (este chat es solo para citas de entrega)\n- **SIEMPRE contextualiza** que este chat es para gestión de citas de entrega de mercancía en la bodega\n\n---\n\n## DATOS DEL MENSAJE ACTUAL\n**Pregunta del usuario:**\n```\n{{ $json.infoMensaje.mensajeActual }}\n```\n\n**Historial de conversación:**\n```\n{{ $json.infoMensaje.historialMensajes }}\n```\n\n**Fecha:** {{ $json.infoMensaje.fechaMensajeActual }}\n**Hora:** {{ $json.infoMensaje.horaMensajeActual }}\n\n---\n\n### INSTRUCCIONES FINALES\n1. Analiza la pregunta del usuario en el contexto del historial\n2. **SIEMPRE menciona** que este chat está diseñado para gestión de citas de entrega de mercancía por parte de proveedores\n3. Proporciona información útil y completa sobre Konfie IA Logistics cuando sea relevante\n4. Si la pregunta no está relacionada con la empresa, explica qué es Konfie IA Logistics y redirige al propósito del chat\n5. Si la pregunta está relacionada con la empresa pero no con citas de entrega, proporciona la información pero contextualiza el propósito específico del chat\n6. Mantén un tono profesional pero cercano\n7. Si necesitan información muy específica (precios, cotizaciones, servicios comerciales), invítalos a contactar directamente a través del sitio web\n8. **SIEMPRE finaliza** preguntando si necesitan ayuda con gestión de citas de entrega\n\n**FORMATO DE RESPUESTA:**\n- Responde la consulta de manera útil\n- Contextualiza el propósito específico del chat (gestión de citas de entrega de mercancía)\n- Proporciona el sitio web si es necesario: https://www.konfie.com/es_CO\n- Pregunta si necesitan ayuda con citas de entrega\n\n**EJEMPLOS DE CIERRE:**\n- \"¿Necesitas ayuda con alguna gestión de cita de entrega de mercancía?\"\n- \"¿En qué puedo ayudarte con la gestión de tu cita de entrega?\"\n- \"¿Requieres agendar, consultar o modificar alguna cita de entrega en nuestra bodega?\""
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        -40384,
        -1728
      ],
      "id": "4f770141-038a-4387-995e-c4b38c60c55b",
      "name": "Basic LLM CONVERSACIÓN GENERAL"
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\nconst output = [];\n\nfor (const item of items) {\n  try {\n    // Para PREGUNTA_GENERAL, el LLM devuelve texto plano, no JSON\n    let respuestaTexto = item.json.text ? item.json.text.trim() : \"\";\n    \n    // Verificar que hay contenido\n    if (!respuestaTexto) {\n      throw new Error(\"Respuesta vacía del modelo LLM\");\n    }\n    \n    // Estructurar la salida para PREGUNTA_GENERAL\n    output.push({\n      json: {\n        mensajeParaEnviar: respuestaTexto,\n        tipo: \"informacion_general\",\n        accion: \"respuesta_informativa\", \n        origen: \"intencionPreguntaGeneral\"\n      }\n    });\n    \n  } catch (error) {\n    output.push({\n      json: {\n        error: true,\n        mensaje: \"Error al interpretar la respuesta del modelo LLM\",\n        detalle: error.message,\n        contenidoOriginal: item.json.text || \"No hay contenido\",\n        tipo: \"error\",\n        accion: \"error_procesamiento\",\n        origen: \"intencionPreguntaGeneral\"\n      }\n    });\n  }\n}\n\nreturn output;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -39984,
        -1728
      ],
      "id": "b3623d02-31d3-4657-8445-29b46c37c4b6",
      "name": "Estructuración, de datos"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "b2110549-dd58-46b3-9707-dbbe0a5004f2",
              "leftValue": "={{ $('Estructuración, de datos1').item.json.message.length }}",
              "rightValue": 70,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -39632,
        -688
      ],
      "id": "bb21ab7a-042c-4ec8-8232-d41fc950c5f4",
      "name": "Validación de longitud de caracteres18"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -39088,
        -832
      ],
      "id": "2125f938-1f79-4285-8d10-84d241af3c32",
      "name": "No Operation, do nothing22"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $('Estructuración, de datos1').item.json.mensajeParaEnviar }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -39264,
        -832
      ],
      "id": "05c6b773-5026-4e66-a618-5d9a0c70330e",
      "name": "HTTP Request Enviar Mensaje por WhatsApp21"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d9c2ff70-4fd1-4b93-8571-6d0ac5a0093e",
              "name": "mensaje.ia",
              "value": "={{ $('Estructuración, de datos1').item.json.message }}",
              "type": "string"
            },
            {
              "id": "ac8a03be-0292-4735-9580-39a385945c47",
              "name": "mensaje.longitud",
              "value": "={{ $('Estructuración, de datos1').item.json.message.length }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -34816,
        -704
      ],
      "id": "9b21fcfa-4a27-4b17-a748-6e51d7cb6a24",
      "name": "Organiza variables del mensaje18"
    },
    {
      "parameters": {
        "jsCode": "return [\n  {\n    json: {\n      message: `✅ **ELIMINACIÓN DE CONVERSACIÓN EXITOSA**\n\nLa eliminación de mensajes en la base de datos se ha completado correctamente.\n\n🔄 **Puedes empezar una nueva conversación**\nAhora puedes iniciar una conversación completamente limpia con el asistente.\n\n📅 **Tus citas están seguras**\nSi tenías citas programadas, no te preocupes - las citas NO se han eliminado. Solo se eliminó el historial de conversación para hacer limpieza del sistema.\n\n💬 **Conversación limpia lista**\nPuedes comenzar de nuevo y tener una experiencia fresca con el asistente. Todos tus datos importantes permanecen intactos.\n\n¡Escribe tu mensaje para empezar una nueva conversación!`,\n      success: true,\n      timestamp: new Date().toISOString()\n    }\n  }\n];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -40384,
        -992
      ],
      "id": "b4ca90d8-e51b-46db-ad86-b0c12b78ea51",
      "name": "Estructuración, de datos1"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Borrar el mensaje por ID recibido desde el flujo de n8n\nDELETE FROM MensajesWhatsApp\nWHERE id = {{ $('Unificación y consistencia de datos').first().json.infoMensaje.chat_id }};\nDBCC CHECKIDENT ('MensajesWhatsApp', RESEED, 0);\n\n-- Borrar franja disponible por ID recibido desde el flujo de n8n\nDELETE FROM FranjasDisponiblesTemp\nWHERE id = {{ $('Unificación y consistencia de datos').first().json.infoMensaje.chat_id }};\nDBCC CHECKIDENT ('FranjasDisponiblesTemp', RESEED, 0);"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        -41344,
        -560
      ],
      "id": "32001efc-a9d7-4af5-b9e1-6be9f109713a",
      "name": "Microsoft SQL Eliminación Mensajes",
      "alwaysOutputData": true,
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      },
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "b2110549-dd58-46b3-9707-dbbe0a5004f2",
              "leftValue": "={{ $('Estructuración, de datos2').item.json.message.length }}",
              "rightValue": 70,
              "operator": {
                "type": "number",
                "operation": "lt"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -39456,
        192
      ],
      "id": "e9e51200-b00b-4c3b-b789-546f6291f848",
      "name": "Validación de longitud de caracteres19"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -38896,
        48
      ],
      "id": "0e5c2a11-049e-4029-826f-2b3ffd061463",
      "name": "No Operation, do nothing23"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://evolutionapi-evolution-api.cpyock.easypanel.host/message/sendText/{{ $('Mensaje Entrada').first().json.body.instance }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $('Mensaje Entrada').first().json.body.apikey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "number",
              "value": "={{ $('Mensaje Entrada').first().json.body.data.key.remoteJid }}"
            },
            {
              "name": "text",
              "value": "={{ $('Estructuración, de datos2').item.json.mensajeParaEnviar }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -39088,
        48
      ],
      "id": "995d10c5-74c6-486d-a97e-c61269051b68",
      "name": "HTTP Request Enviar Mensaje por WhatsApp22"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "d9c2ff70-4fd1-4b93-8571-6d0ac5a0093e",
              "name": "mensaje.ia",
              "value": "={{ $('Estructuración, de datos2').item.json.message }}",
              "type": "string"
            },
            {
              "id": "ac8a03be-0292-4735-9580-39a385945c47",
              "name": "mensaje.longitud",
              "value": "={{ $('Estructuración, de datos2').item.json.message.length }}",
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -34640,
        176
      ],
      "id": "9a36ea4d-f022-4dfa-b2b3-35bd7e9fd991",
      "name": "Organiza variables del mensaje19"
    },
    {
      "parameters": {
        "jsCode": "return [\n  {\n    json: {\n      message: `❌ **ERROR EN ELIMINACIÓN DE CONVERSACIÓN**\n\nLamentamos informarte que ha ocurrido un error durante la eliminación automática de la conversación en nuestro sistema.\n\n🔧 **Acción requerida**\nPor favor, comunícate directamente con el **área de Bodega de Konfíe** para que validen manualmente qué sucedió con la eliminación de datos en el sistema.\n\n📞 **Contacto necesario**\nEl equipo de Bodega deberá revisar y procesar manualmente la eliminación de tu conversación para garantizar que se complete correctamente.\n\n⚠️ **Situación excepcional**\nTe pedimos disculpas por este inconveniente. Este tipo de errores son muy poco frecuentes en nuestro sistema, pero requieren atención manual para resolverse adecuadamente.\n\n🙏 **Disculpas por las molestias**\nSentimos mucho las molestias causadas por esta situación técnica. El equipo de Bodega te ayudará a resolver esto lo antes posible.\n\nPor favor contacta a Bodega de Konfíe para continuar con el proceso.`,\n      success: false,\n      error: true,\n      timestamp: new Date().toISOString(),\n      action_required: \"contact_bodega\"\n    }\n  }\n];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -40208,
        -128
      ],
      "id": "4361e9f8-618a-463f-af0d-96eef70def9d",
      "name": "Estructuración, de datos2"
    },
    {
      "parameters": {
        "promptType": "=define",
        "text": "=### SISTEMA\n\nEres un asistente especializado en logística de bodegas para **Konfíe IA Logistics**. \n\nEl usuario ha enviado un mensaje que **NO está relacionado con el contexto de nuestro negocio** (logística, citas, entregas, horarios, etc.).\n\n### TU TAREA:\n\n1. **Responder de manera amable pero firme** que el mensaje no está relacionado con el servicio de gestión de citas de bodega.\n\n2. **Redirigir la conversación** hacia los servicios que sí puedes ofrecer:\n   - Agendar nuevas citas de entrega\n   - Consultar disponibilidad de horarios\n   - Editar citas existentes\n   - Cancelar entregas programadas\n\n3. **Advertir suavemente** que si continúa enviando mensajes fuera del contexto empresarial, la conversación podría ser reiniciada.\n\n### EJEMPLOS DE RESPUESTAS:\n\n**Para mensajes románticos/personales:**\n\"Entiendo tu mensaje, pero soy un asistente especializado en gestión de citas de bodega para Konfíe IA Logistics. No puedo ayudarte con temas personales.\n\n¿Te gustaría que te ayude con alguna cita de entrega? Puedo ayudarte a:\n• Agendar una nueva cita\n• Consultar horarios disponibles\n• Modificar una cita existente\n• Cancelar una entrega\n\nSi continúas enviando mensajes no relacionados con nuestro servicio, tendré que reiniciar nuestra conversación.\"\n\n**Para solicitudes de entretenimiento:**\n\"Aprecio tu interés, pero mi función es específicamente ayudarte con la gestión de citas de descarga en nuestra bodega.\n\nEstoy aquí para asistirte con:\n• Programar entregas\n• Revisar disponibilidad de franjas horarias\n• Gestionar tus citas existentes\n\n¿Hay algo relacionado con el servicio de bodega en lo que pueda ayudarte? Si no, por favor mantengamos la conversación enfocada en nuestros servicios para evitar interrupciones.\"\n\n### MENSAJE DEL USUARIO:\n{{ $('Unificación y consistencia de datos').first().json.infoMensaje.mensajeActual }}\n\n### HISTORIAL DE CONVERSACIÓN:\n{{ $node[\"Unificación y consistencia de datos\"].json[\"infoMensaje\"][\"historialMensajes\"] }}\n\n### FORMATO DE RESPUESTA (JSON válido):\n```json\n{\n  \"mensajeSistema\": \"Respuesta amable pero firme redirigiendo hacia el contexto empresarial y advirtiendo sobre el reinicio de conversación si continúa fuera del contexto\"\n}\n```"
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        -45008,
        -6848
      ],
      "id": "91c32dca-72b9-4991-8bcd-9388d0881155",
      "name": "Basic LLM MANEJO FUERA CONTEXTO"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=-- Consultar estado conversacional actual\nSELECT \n  ISNULL(estado_actual, 'INICIAL') as estado_actual,\n  ISNULL(contexto_proceso, '{\"descripcion\": \"Estado inicial\"}') as contexto_proceso,\n  ISNULL(contador_fuera_contexto, 0) as contador_fuera_contexto,\n  ultimo_mensaje_fuera_contexto\nFROM EstadoConversacional \nWHERE chat_id = '{{ $('Parametrización').first().json.message.chat.id }}'\n\nUNION ALL\n\n-- Si no existe registro, devolver valores por defecto\nSELECT \n  'INICIAL' as estado_actual,\n  '{\"descripcion\": \"Estado inicial\"}' as contexto_proceso,\n  0 as contador_fuera_contexto,\n  NULL as ultimo_mensaje_fuera_contexto\nWHERE NOT EXISTS (\n  SELECT 1 FROM EstadoConversacional \n  WHERE chat_id = '{{ $('Parametrización').first().json.message.chat.id }}'\n);"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        -49328,
        -7408
      ],
      "id": "d2a7a9bf-f5a3-4d72-84c8-d8a530512867",
      "name": "Consultar Estado Conversacional",
      "alwaysOutputData": true,
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=-- Actualizar estado conversacional basado en intención detectada\nMERGE EstadoConversacional AS target\nUSING (\n  SELECT \n    '{{ $('Parametrización').first().json.message.chat.id }}' AS chat_id,\n    CASE \n      WHEN '{{ $json.intencionDetectada }}' = 'CREAR_CITA' THEN 'SOLICITANDO_DATOS_CREAR'\n      WHEN '{{ $json.intencionDetectada }}' = 'EDITAR_CITA' THEN 'SOLICITANDO_DATOS_EDITAR'\n      WHEN '{{ $json.intencionDetectada }}' = 'CANCELAR_CITA' THEN 'CONFIRMANDO_CANCELACION'\n      WHEN '{{ $json.intencionDetectada }}' = 'CONSULTAR_MALLA' THEN 'CONSULTANDO_DISPONIBILIDAD'\n      WHEN '{{ $json.intencionDetectada }}' = 'CONFIRMACION_CITA' THEN 'CONFIRMANDO_FRANJA'\n      WHEN '{{ $json.intencionDetectada }}' = 'SALUDO' THEN 'SALUDANDO'\n      WHEN '{{ $json.intencionDetectada }}' = 'PREGUNTA_GENERAL' THEN 'RESPONDIENDO_PREGUNTA'\n      WHEN '{{ $json.intencionDetectada }}' = 'RESPUESTA_FUERA_CONTEXTO' THEN 'FUERA_CONTEXTO'\n      WHEN '{{ $json.intencionDetectada }}' = 'ELIMINAR_MENSAJES' THEN 'ELIMINANDO_MENSAJES'\n      ELSE 'INICIAL'\n    END AS estado_actual,\n    CASE \n      WHEN '{{ $json.intencionDetectada }}' = 'RESPUESTA_FUERA_CONTEXTO' THEN \n        '{\"intencion_detectada\": \"{{ $json.intencionDetectada }}\", \"timestamp\": \"{{ new Date().toISOString() }}\", \"accion\": \"incrementar_contador\"}'\n      ELSE \n        '{\"intencion_detectada\": \"{{ $json.intencionDetectada }}\", \"timestamp\": \"{{ new Date().toISOString() }}\", \"accion\": \"cambio_estado\"}'\n    END AS contexto_proceso\n) AS source ON (target.chat_id = source.chat_id)\nWHEN MATCHED THEN\n    UPDATE SET \n      estado_actual = source.estado_actual, \n      contexto_proceso = source.contexto_proceso, \n      fecha_actualizacion = GETDATE(),\n      contador_fuera_contexto = CASE \n        WHEN '{{ $json.intencionDetectada }}' = 'RESPUESTA_FUERA_CONTEXTO' THEN contador_fuera_contexto + 1\n        ELSE CASE WHEN '{{ $json.intencionDetectada }}' != 'RESPUESTA_FUERA_CONTEXTO' THEN 0 ELSE contador_fuera_contexto END\n      END,\n      ultimo_mensaje_fuera_contexto = CASE \n        WHEN '{{ $json.intencionDetectada }}' = 'RESPUESTA_FUERA_CONTEXTO' THEN GETDATE()\n        ELSE ultimo_mensaje_fuera_contexto\n      END\nWHEN NOT MATCHED THEN\n    INSERT (chat_id, estado_actual, contexto_proceso, contador_fuera_contexto, ultimo_mensaje_fuera_contexto) \n    VALUES (\n      source.chat_id, \n      source.estado_actual, \n      source.contexto_proceso,\n      CASE WHEN '{{ $json.intencionDetectada }}' = 'RESPUESTA_FUERA_CONTEXTO' THEN 1 ELSE 0 END,\n      CASE WHEN '{{ $json.intencionDetectada }}' = 'RESPUESTA_FUERA_CONTEXTO' THEN GETDATE() ELSE NULL END\n    );\n\n-- Devolver la intención para el siguiente nodo\nSELECT '{{ $json.intencionDetectada }}' as intencionDetectada, \n       '{{ $('Parametrización').first().json.message.chat.id }}' as chat_id,\n       GETDATE() as timestamp_actualizacion;"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        -45536,
        -7200
      ],
      "id": "14218482-c4a1-4eb8-8d63-3f513ad1cfb8",
      "name": "Actualizar Estado por Intención",
      "alwaysOutputData": true,
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "leftValue": "",
                    "rightValue": "",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "2a4110a6-abce-4bf4-88e0-942700219980"
                  }
                ],
                "combinator": "and"
              }
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3,
      "position": [
        -45312,
        -7200
      ],
      "id": "ae49afc3-ac51-4a34-9f70-0d46f7110f22",
      "name": "Switch Redistribución por Intención"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=-- Verificar si necesita reinicio automático por exceso de mensajes fuera de contexto\nSELECT \n  chat_id,\n  estado_actual,\n  contador_fuera_contexto,\n  CASE \n    WHEN contador_fuera_contexto >= 3 THEN 'REINICIAR_CONVERSACION'\n    WHEN contador_fuera_contexto = 2 THEN 'ADVERTENCIA_FINAL'\n    WHEN contador_fuera_contexto = 1 THEN 'PRIMERA_ADVERTENCIA'\n    ELSE 'NORMAL'\n  END as accion_requerida,\n  CASE \n    WHEN contador_fuera_contexto >= 3 THEN 'Has enviado varios mensajes que no están relacionados con nuestro servicio de gestión de citas. Para poder ayudarte mejor, voy a reiniciar nuestra conversación. Por favor, cuéntame en qué puedo asistirte con el servicio de bodega.'\n    WHEN contador_fuera_contexto = 2 THEN 'Te recuerdo que soy un asistente especializado en gestión de citas de bodega. Si continúas con mensajes no relacionados, tendré que reiniciar nuestra conversación. ¿Hay algo sobre el servicio de bodega en lo que pueda ayudarte?'\n    ELSE ''\n  END as mensaje_especial\nFROM EstadoConversacional \nWHERE chat_id = '{{ $('Parametrización').first().json.message.chat.id }}';\n\n-- Si el contador es >= 3, reiniciar automáticamente\nUPDATE EstadoConversacional \nSET estado_actual = 'INICIAL', \n    contexto_proceso = '{\"descripcion\": \"Conversación reiniciada automáticamente por exceso de mensajes fuera de contexto\", \"reinicio_automatico\": true}',\n    contador_fuera_contexto = 0,\n    ultimo_mensaje_fuera_contexto = NULL,\n    fecha_actualizacion = GETDATE()\nWHERE chat_id = '{{ $('Parametrización').first().json.message.chat.id }}'\n  AND contador_fuera_contexto >= 3;"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        -44560,
        -6848
      ],
      "id": "ea7f7d73-9aff-4d5d-8dad-a32645780b2e",
      "name": "Verificar Reinicio Fuera Contexto",
      "alwaysOutputData": true,
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=-- Resetear estado a INICIAL después de operación exitosa\nUPDATE EstadoConversacional \nSET estado_actual = 'INICIAL', \n    contexto_proceso = '{\"descripcion\": \"Operación completada exitosamente\", \"ultima_accion\": \"cita_creada\", \"timestamp\": \"{{ new Date().toISOString() }}\"}',\n    contador_fuera_contexto = 0,\n    ultimo_mensaje_fuera_contexto = NULL,\n    fecha_actualizacion = GETDATE()\nWHERE chat_id = '{{ $('Parametrización').first().json.message.chat.id }}';\n\n-- Confirmar actualización\nSELECT \n  'INICIAL' as nuevo_estado,\n  'OPERACION_EXITOSA' as tipo_reseteo,\n  '{{ $('Parametrización').first().json.message.chat.id }}' as chat_id,\n  GETDATE() as timestamp_reseteo;"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        -11008,
        -2880
      ],
      "id": "31ac391f-69dd-4ef0-8668-19788001547f",
      "name": "Resetear Estado - Cita Exitosa",
      "alwaysOutputData": true,
      "credentials": {
        "microsoftSql": {
          "id": "UNJs1wxs3vPQMTeN",
          "name": "Microsoft SQL account"
        }
      }
    }
  ],
  "pinData": {},
  "connections": {
    "Mensaje Entrada": {
      "main": [
        [
          {
            "node": "Parametrización",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parametrización": {
      "main": [
        [
          {
            "node": "Guarda el mensaje en SQL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Guarda el mensaje en SQL": {
      "main": [
        [
          {
            "node": "Recupera todos los mensajes",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Recupera todos los mensajes": {
      "main": [
        [
          {
            "node": "Count y Tiempo Último Mensaje",
            "type": "main",
            "index": 0
          },
          {
            "node": "Consultar Estado Conversacional",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Count y Tiempo Último Mensaje": {
      "main": [
        [
          {
            "node": "If (Salida 0 - No hacer nada)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If (Salida 0 - No hacer nada)": {
      "main": [
        [
          {
            "node": "No Operation, do nothing",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "If (Salida 1 - Esperar)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If (Salida 1 - Esperar)": {
      "main": [
        [
          {
            "node": "Espera X segundos",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "If (Salida 2 - Seguir)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Espera X segundos": {
      "main": [
        [
          {
            "node": "Recupera todos los mensajes",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If (Salida 2 - Seguir)": {
      "main": [
        [
          {
            "node": "Merge de Datos",
            "type": "main",
            "index": 1
          }
        ],
        [
          {
            "node": "No Operation, do nothing1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organización y estructuracion de mensajes": {
      "main": [
        [
          {
            "node": "Organiza el Mensaje",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza el Mensaje": {
      "main": [
        [
          {
            "node": "Merge de Datos para session ID",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Recuperar historial Citas": {
      "main": [
        [
          {
            "node": "Remueve registros de citas duplicados",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge de Datos": {
      "main": [
        [
          {
            "node": "Organización y estructuracion de mensajes",
            "type": "main",
            "index": 0
          },
          {
            "node": "Recuperar historial Citas",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Remueve registros de citas duplicados": {
      "main": [
        [
          {
            "node": "Organización y estructuracion historial citas",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organización y estructuracion historial citas": {
      "main": [
        [
          {
            "node": "Organiza el historial de citas",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza el historial de citas": {
      "main": [
        [
          {
            "node": "Merge de Datos para session ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge de Datos para session ID": {
      "main": [
        [
          {
            "node": "Unificación y consistencia de datos",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Unificación y consistencia de datos": {
      "main": [
        [
          {
            "node": "Basic LLM CLASIFICADOR",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request MALLA DE RECIBO 2025": {
      "main": [
        [
          {
            "node": "Extract MALLA DE RECIBO 2025",
            "type": "main",
            "index": 0
          },
          {
            "node": "Extract MALLA DE RECIBO Semana Siguiente",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract MALLA DE RECIBO 2025": {
      "main": [
        [
          {
            "node": "Estructuración, Datos, Consulta, Citas",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Malla Fija": {
      "main": [
        [
          {
            "node": "Extract Datos Proveedor",
            "type": "main",
            "index": 0
          },
          {
            "node": "Extract from Categorias",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Datos Proveedor": {
      "main": [
        [
          {
            "node": "Estructuración, Consulta, Datos Proveedor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Estructuración, Datos, Consulta, Citas": {
      "main": [
        [
          {
            "node": "Merge datos Excel",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Estructuración, Consulta, Datos Proveedor": {
      "main": [
        [
          {
            "node": "Merge datos Excel",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "Merge datos Excel": {
      "main": [
        [
          {
            "node": "Unificación y consistencia de datos1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from Categorias": {
      "main": [
        [
          {
            "node": "Estructuración, Consulta, Datos Categorias",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Estructuración, Consulta, Datos Categorias": {
      "main": [
        [
          {
            "node": "Merge datos Excel",
            "type": "main",
            "index": 3
          }
        ]
      ]
    },
    "Unificación y consistencia de datos1": {
      "main": [
        [
          {
            "node": "Basic LLM Chain RECOLECCIÓN1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM CLASIFICADOR",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM CLASIFICADOR": {
      "main": [
        [
          {
            "node": "Almacenar la intención detectada",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model2": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM CONVERSACIÓN (SALUDO)",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "Basic LLM MANEJO FUERA CONTEXTO",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Switch basado en intención": {
      "main": [
        [
          {
            "node": "Actualizar Estado por Intención",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Actualizar Estado por Intención",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Actualizar Estado por Intención",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Actualizar Estado por Intención",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Actualizar Estado por Intención",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Actualizar Estado por Intención",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Actualizar Estado por Intención",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Actualizar Estado por Intención",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Actualizar Estado por Intención",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Almacenar la intención detectada": {
      "main": [
        [
          {
            "node": "Switch basado en intención",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model3": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Chain RECOLECCIÓN",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Chain RECOLECCIÓN": {
      "main": [
        [
          {
            "node": "Code (Formatear JSON RECOLECCIÓN)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code (Formatear JSON RECOLECCIÓN)": {
      "main": [
        [
          {
            "node": "IF Datos Completos",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Datos Completos": {
      "main": [
        [
          {
            "node": "Basic LLM Chain EXTRACCIÓN_DATOS_CITA",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Code Respuesta Faltantes",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Respuesta Faltantes": {
      "main": [
        [
          {
            "node": "Setear estado conversacional",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Setear estado conversacional": {
      "main": [
        [
          {
            "node": "Validación de longitud de caracteres",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validación de longitud de caracteres": {
      "main": [
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Organiza variables del mensaje",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza variables del mensaje": {
      "main": [
        [
          {
            "node": "Basic LLM Separación de Mensaje",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser": {
      "ai_outputParser": [
        [
          {
            "node": "Basic LLM Separación de Mensaje",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model4": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Separación de Mensaje",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp": {
      "main": [
        [
          {
            "node": "No Operation, do nothing2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Separación de Mensaje": {
      "main": [
        [
          {
            "node": "Split Out Separa el Mensaje",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Out Separa el Mensaje": {
      "main": [
        [
          {
            "node": "Loop Over Items Recorre las Partes",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Items Recorre las Partes": {
      "main": [
        [
          {
            "node": "Merge2",
            "type": "main",
            "index": 1
          },
          {
            "node": "Merge3",
            "type": "main",
            "index": 1
          }
        ],
        [
          {
            "node": "Recuento de Caracteres",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Recuento de Caracteres": {
      "main": [
        [
          {
            "node": "Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch": {
      "main": [
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp1": {
      "main": [
        [
          {
            "node": "Microsoft SQL1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp2": {
      "main": [
        [
          {
            "node": "Microsoft SQL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp3": {
      "main": [
        [
          {
            "node": "Microsoft SQL2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Microsoft SQL": {
      "main": [
        [
          {
            "node": "Wait",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Microsoft SQL1": {
      "main": [
        [
          {
            "node": "Wait",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Microsoft SQL2": {
      "main": [
        [
          {
            "node": "Wait",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait": {
      "main": [
        [
          {
            "node": "Loop Over Items Recorre las Partes",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract MALLA DE RECIBO Semana Siguiente": {
      "main": [
        [
          {
            "node": "Estructuración, Datos, Consulta, Citas Proxima Semana",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Estructuración, Datos, Consulta, Citas Proxima Semana": {
      "main": [
        [
          {
            "node": "Merge datos Excel",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "OpenAI Chat Model6": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM CONSULTAR MALLA",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Malla Fija1": {
      "main": [
        [
          {
            "node": "Extract from Categorias1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from Categorias1": {
      "main": [
        [
          {
            "node": "Estructuración, Consulta, Datos Categorias1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Estructuración, Consulta, Datos Categorias1": {
      "main": [
        [
          {
            "node": "Basic LLM CONSULTAR MALLA",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM CONSULTAR MALLA": {
      "main": [
        [
          {
            "node": "Consistencia de datos, intención consultar malla",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Consistencia de datos, intención consultar malla": {
      "main": [
        [
          {
            "node": "Validación de longitud de caracteres1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp4": {
      "main": [
        [
          {
            "node": "No Operation, do nothing3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validación de longitud de caracteres1": {
      "main": [
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp4",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Organiza variables del mensaje1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza variables del mensaje1": {
      "main": [
        [
          {
            "node": "Basic LLM Separación de Mensaje",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM CONVERSACIÓN (SALUDO)": {
      "main": [
        [
          {
            "node": "Estructuración, Consulta, Datos Categorias2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validación de longitud de caracteres2": {
      "main": [
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp5",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Organiza variables del mensaje2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp5": {
      "main": [
        [
          {
            "node": "No Operation, do nothing4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Estructuración, Consulta, Datos Categorias2": {
      "main": [
        [
          {
            "node": "Validación de longitud de caracteres2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza variables del mensaje2": {
      "main": [
        [
          {
            "node": "Basic LLM Separación de Mensaje",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model7": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Chain MOSTRAR_FRANJAS",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model8": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Chain EXTRACCIÓN_DATOS_CITA",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Chain EXTRACCIÓN_DATOS_CITA": {
      "main": [
        [
          {
            "node": "Microsoft SQL Guardar EXTRACCIÓN_DATOS_CITA",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser1": {
      "ai_outputParser": [
        [
          {
            "node": "Basic LLM Chain EXTRACCIÓN_DATOS_CITA",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Chain MOSTRAR_FRANJAS": {
      "main": [
        [
          {
            "node": "Code estandarizar respuestas MOSTRAR_FRANJAS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Microsoft SQL Guardar EXTRACCIÓN_DATOS_CITA": {
      "main": [
        [
          {
            "node": "Code MOSTRAR_FRANJAS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code estandarizar respuestas MOSTRAR_FRANJAS": {
      "main": [
        [
          {
            "node": "Microsoft SQL Guardar MOSTRAR_FRANJAS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code MOSTRAR_FRANJAS": {
      "main": [
        [
          {
            "node": "Basic LLM Chain MOSTRAR_FRANJAS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code RECOLECCIÓN": {
      "main": [
        [
          {
            "node": "Basic LLM Chain RECOLECCIÓN",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validación de longitud de caracteres3": {
      "main": [
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp6",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Organiza variables del mensaje3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp6": {
      "main": [
        [
          {
            "node": "No Operation, do nothing5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Microsoft SQL Guardar MOSTRAR_FRANJAS": {
      "main": [
        [
          {
            "node": "Validación de longitud de caracteres3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza variables del mensaje3": {
      "main": [
        [
          {
            "node": "Basic LLM Separación de Mensaje",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Microsoft SQL Obtener Alternativas": {
      "main": [
        [
          {
            "node": "Code Verificar Tiempo Transcurrido",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Verificar Tiempo Transcurrido": {
      "main": [
        [
          {
            "node": "If Verificar Expiración",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model9": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Notificar No Disponibilidad",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "If Verificar Expiración": {
      "main": [
        [
          {
            "node": "Basic LLM Notificar No Disponibilidad",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "HTTP Request MALLA DE RECIBO ",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request MALLA DE RECIBO ": {
      "main": [
        [
          {
            "node": "Extract MALLA DE RECIBO ",
            "type": "main",
            "index": 0
          },
          {
            "node": "Extract MALLA DE RECIBO Semana Siguiente1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract MALLA DE RECIBO ": {
      "main": [
        [
          {
            "node": "Estructuración, Datos, Consulta, Citas1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Estructuración, Datos, Consulta, Citas1": {
      "main": [
        [
          {
            "node": "Merge datos Excel1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge datos Excel1": {
      "main": [
        [
          {
            "node": "Unificación y consistencia de datos2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract MALLA DE RECIBO Semana Siguiente1": {
      "main": [
        [
          {
            "node": "Estructuración, Datos, Consulta, Citas Proxima Semana1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Estructuración, Datos, Consulta, Citas Proxima Semana1": {
      "main": [
        [
          {
            "node": "Merge datos Excel1",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Unificación y consistencia de datos2": {
      "main": [
        [
          {
            "node": "Basic LLM Validar selección alternativa",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code VALIDACIÓN DE CITA EN CRONOGRAMA": {
      "main": [
        [
          {
            "node": "If CREACION DE CITA EN CRONOGRAMA",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If CREACION DE CITA EN CRONOGRAMA": {
      "main": [
        [
          {
            "node": "Code (Preparar Cuerpo de Petición)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Basic LLM Notificar No Disponibilidad1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model10": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Notificar No Disponibilidad1",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Validación de longitud de caracteres4": {
      "main": [
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp7",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Organiza variables del mensaje4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp7": {
      "main": [
        [
          {
            "node": "No Operation, do nothing6",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Notificar No Disponibilidad": {
      "main": [
        [
          {
            "node": "Validación de longitud de caracteres4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza variables del mensaje4": {
      "main": [
        [
          {
            "node": "Basic LLM Separación de Mensaje",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validación de longitud de caracteres5": {
      "main": [
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp8",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Organiza variables del mensaje5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp8": {
      "main": [
        [
          {
            "node": "No Operation, do nothing7",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Notificar No Disponibilidad1": {
      "main": [
        [
          {
            "node": "Validación de longitud de caracteres5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza variables del mensaje5": {
      "main": [
        [
          {
            "node": "Basic LLM Separación de Mensaje",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model11": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Validar selección alternativa",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Validar selección alternativa": {
      "main": [
        [
          {
            "node": "Code VALIDACIÓN DE CITA EN CRONOGRAMA",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser2": {
      "ai_outputParser": [
        [
          {
            "node": "Basic LLM Validar selección alternativa",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Code (Preparar Cuerpo de Petición)": {
      "main": [
        [
          {
            "node": "Code Agrupar Franjas",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Agrupar Franjas": {
      "main": [
        [
          {
            "node": "Loop Over Uno a Uno",
            "type": "main",
            "index": 0
          },
          {
            "node": "Code Datos Insert Cita",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Uno a Uno": {
      "main": [
        [
          {
            "node": "Code Validar inserciones",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Code Preparar cada Insercion",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Preparar cada Insercion": {
      "main": [
        [
          {
            "node": "HTTP Request Actualizar Excel1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Actualizar Excel1": {
      "main": [
        [
          {
            "node": "Code Verificar Inserción",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Verificar Inserción": {
      "main": [
        [
          {
            "node": "If Verificar Inserción",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Verificar Inserción": {
      "main": [
        [
          {
            "node": "Wait2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "If Diferente Caso",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Diferente Caso": {
      "main": [
        [
          {
            "node": "Code Limpiar Celda Incorrecta",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "If fallo Estado",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Limpiar Celda Incorrecta": {
      "main": [
        [
          {
            "node": "HTTP Request Limpiar Celda",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If fallo Estado": {
      "main": [
        [
          {
            "node": "Code Reintentar Inserción",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "HTTP Request Limpiar Celda": {
      "main": [
        [
          {
            "node": "Code Reintentar Inserción",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Reintentar Inserción": {
      "main": [
        [
          {
            "node": "HTTP Request Reintentar Inserción",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Reintentar Inserción": {
      "main": [
        [
          {
            "node": "Code Volver a validar Inserción",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Volver a validar Inserción": {
      "main": [
        [
          {
            "node": "If Verificar Inserción 2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait2": {
      "main": [
        [
          {
            "node": "Loop Over Uno a Uno",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Verificar Inserción 2": {
      "main": [
        [
          {
            "node": "Wait3",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Wait3": {
      "main": [
        [
          {
            "node": "Loop Over Uno a Uno",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model12": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Notificar No Disponibilidad2",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Validación de longitud de caracteres6": {
      "main": [
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp9",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Organiza variables del mensaje6",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp9": {
      "main": [
        [
          {
            "node": "No Operation, do nothing8",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Notificar No Disponibilidad2": {
      "main": [
        [
          {
            "node": "Validación de longitud de caracteres6",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza variables del mensaje6": {
      "main": [
        [
          {
            "node": "Basic LLM Separación de Mensaje",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Chain RECOLECCIÓN1",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Chain RECOLECCIÓN1": {
      "main": [
        [
          {
            "node": "Code RECOLECCIÓN",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser3": {
      "ai_outputParser": [
        [
          {
            "node": "Basic LLM Chain RECOLECCIÓN1",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Code Datos Insert Cita": {
      "main": [
        [
          {
            "node": "Microsoft SQL Franjas Temporales",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Validar inserciones": {
      "main": [
        [
          {
            "node": "If Validar inserciones",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Microsoft SQL Franjas Temporales": {
      "main": [
        [
          {
            "node": "Code Estructuración de franjas temporales",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Validar inserciones": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ],
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Merge2",
            "type": "main",
            "index": 0
          },
          {
            "node": "Microsoft SQL Insertar Cita",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Estructuración de franjas temporales": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge1": {
      "main": [
        [
          {
            "node": "Microsoft SQL Eliminar Mensajes2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Microsoft SQL Insertar Cita": {
      "main": [
        [
          {
            "node": "Basic LLM Notificar Cita Exitosa",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model13": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Notificar Cita Exitosa",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Validación de longitud de caracteres7": {
      "main": [
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp10",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Organiza variables del mensaje7",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp10": {
      "main": [
        [
          {
            "node": "No Operation, do nothing9",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Notificar Cita Exitosa": {
      "main": [
        [
          {
            "node": "Resetear Estado - Cita Exitosa",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Microsoft SQL Eliminar Mensajes": {
      "main": [
        [
          {
            "node": "No Operation, do nothing10",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza variables del mensaje7": {
      "main": [
        [
          {
            "node": "Basic LLM Separación de Mensaje",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Microsoft SQL Eliminar Mensajes2": {
      "main": [
        [
          {
            "node": "Basic LLM Notificar No Disponibilidad2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model14": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Extracción y Validacion de Datos Editar Cita",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser4": {
      "ai_outputParser": [
        [
          {
            "node": "Basic LLM Extracción y Validacion de Datos Editar Cita",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Extracción y Validacion de Datos Editar Cita": {
      "main": [
        [
          {
            "node": "Code Validación de datos para reprogramación de citas",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Validar si la operación es posible (todoCorrecto)": {
      "main": [
        [
          {
            "node": "Microsoft SQL Obtener Cita",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "If Verificar si se intenta modificar datos no permitidos",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Verificar si se intenta modificar datos no permitidos": {
      "main": [
        [
          {
            "node": "Validación de longitud de caracteres8",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "If Verificar si es un rechazo por motivos temporales",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Verificar si es un rechazo por motivos temporales": {
      "main": [
        [
          {
            "node": "Validación de longitud de caracteres8",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "If Verificar si faltan datos",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Verificar si faltan datos": {
      "main": [
        [
          {
            "node": "Validación de longitud de caracteres8",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Code Mensaje Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validación de longitud de caracteres8": {
      "main": [
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp11",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Organiza variables del mensaje8",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp11": {
      "main": [
        [
          {
            "node": "No Operation, do nothing11",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Mensaje Error": {
      "main": [
        [
          {
            "node": "Validación de longitud de caracteres8",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza variables del mensaje8": {
      "main": [
        [
          {
            "node": "Basic LLM Separación de Mensaje",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Microsoft SQL Obtener Cita": {
      "main": [
        [
          {
            "node": "If existe cita",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If existe cita": {
      "main": [
        [
          {
            "node": "HTTP Request MALLA DE RECIBO 2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Code Mensaje Error1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Mensaje Error1": {
      "main": [
        [
          {
            "node": "Validación de longitud de caracteres8",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge2": {
      "main": [
        [
          {
            "node": "Recupera todos los mensajes1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code integracion de mensajes": {
      "main": [
        [
          {
            "node": "Microsoft SQL Actualiza la Cita",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Recupera todos los mensajes1": {
      "main": [
        [
          {
            "node": "Code integracion de mensajes",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Microsoft SQL Actualiza la Cita": {
      "main": [
        [
          {
            "node": "Microsoft SQL Eliminar Mensajes",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Validación de datos para reprogramación de citas": {
      "main": [
        [
          {
            "node": "If Validar si la operación es posible (todoCorrecto)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge3": {
      "main": [
        [
          {
            "node": "Microsoft SQL Eliminar Mensajes3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Microsoft SQL Eliminar Mensajes3": {
      "main": [
        [
          {
            "node": "No Operation, do nothing12",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request MALLA DE RECIBO 2": {
      "main": [
        [
          {
            "node": "Extract MALLA DE RECIBO 2",
            "type": "main",
            "index": 0
          },
          {
            "node": "Extract MALLA DE RECIBO Semana Siguiente3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract MALLA DE RECIBO 2": {
      "main": [
        [
          {
            "node": "Estructuración, Datos, Consulta, Citas3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Estructuración, Datos, Consulta, Citas3": {
      "main": [
        [
          {
            "node": "Merge datos Excel3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge datos Excel3": {
      "main": [
        [
          {
            "node": "Unificación y consistencia de datos4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract MALLA DE RECIBO Semana Siguiente3": {
      "main": [
        [
          {
            "node": "Estructuración, Datos, Consulta, Citas Proxima Semana3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Estructuración, Datos, Consulta, Citas Proxima Semana3": {
      "main": [
        [
          {
            "node": "Merge datos Excel3",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Unificación y consistencia de datos4": {
      "main": [
        [
          {
            "node": "Code Validacion de Cita en cronograma para reprogramación",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Validacion de Cita en cronograma para reprogramación": {
      "main": [
        [
          {
            "node": "If validacion de reprogramacion",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If validacion de reprogramacion": {
      "main": [
        [
          {
            "node": "Code (Preparar Cuerpo de Petición)1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Validación de longitud de caracteres9",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validación de longitud de caracteres9": {
      "main": [
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp12",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Organiza variables del mensaje9",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp12": {
      "main": [
        [
          {
            "node": "No Operation, do nothing13",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza variables del mensaje9": {
      "main": [
        [
          {
            "node": "Basic LLM Separación de Mensaje",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code (Preparar Cuerpo de Petición)1": {
      "main": [
        [
          {
            "node": "Code Agrupar Franjas2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Agrupar Franjas2": {
      "main": [
        [
          {
            "node": "Loop Over Uno a Uno1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Code Datos Insert Cita1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Uno a Uno1": {
      "main": [
        [
          {
            "node": "Code Validar inserciones1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Code Preparar cada Insercion1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Preparar cada Insercion1": {
      "main": [
        [
          {
            "node": "HTTP Request Actualizar Excel",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Actualizar Excel": {
      "main": [
        [
          {
            "node": "Code Verificar Inserción1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Verificar Inserción1": {
      "main": [
        [
          {
            "node": "If Verificar Inserción1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Verificar Inserción1": {
      "main": [
        [
          {
            "node": "Wait4",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "If Diferente Caso1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Diferente Caso1": {
      "main": [
        [
          {
            "node": "Code Limpiar Celda Incorrecta1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "If fallo Estado1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Limpiar Celda Incorrecta1": {
      "main": [
        [
          {
            "node": "HTTP Request Limpiar Celda1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Limpiar Celda1": {
      "main": [
        [
          {
            "node": "Code Reintentar Inserción1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If fallo Estado1": {
      "main": [
        [
          {
            "node": "Code Reintentar Inserción1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Merge5",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "Code Reintentar Inserción1": {
      "main": [
        [
          {
            "node": "HTTP Request Reintentar Inserción1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Reintentar Inserción1": {
      "main": [
        [
          {
            "node": "Code Volver a validar Inserción1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Volver a validar Inserción1": {
      "main": [
        [
          {
            "node": "If Verificar Inserción ",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Verificar Inserción ": {
      "main": [
        [
          {
            "node": "Wait5",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Merge5",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Wait4": {
      "main": [
        [
          {
            "node": "Loop Over Uno a Uno1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait5": {
      "main": [
        [
          {
            "node": "Loop Over Uno a Uno1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model15": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Notificar No Disponibilidad3",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Notificar No Disponibilidad3": {
      "main": [
        [
          {
            "node": "Validación de longitud de caracteres10",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validación de longitud de caracteres10": {
      "main": [
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp13",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Organiza variables del mensaje10",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp13": {
      "main": [
        [
          {
            "node": "No Operation, do nothing14",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Validar inserciones1": {
      "main": [
        [
          {
            "node": "If Validar inserciones1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Datos Insert Cita1": {
      "main": [
        [
          {
            "node": "Merge4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Validar inserciones1": {
      "main": [
        [
          {
            "node": "Merge4",
            "type": "main",
            "index": 1
          }
        ],
        [
          {
            "node": "Merge5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge4": {
      "main": [
        [
          {
            "node": "Microsoft SQLUpdate Cita Anterior",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge5": {
      "main": [
        [
          {
            "node": "Microsoft SQL Eliminar Mensajes4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Microsoft SQL Insertar Cita1": {
      "main": [
        [
          {
            "node": "Basic LLM Notificar Cita Exitosa1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model16": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Notificar Cita Exitosa1",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Validación de longitud de caracteres11": {
      "main": [
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp14",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Organiza variables del mensaje11",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp14": {
      "main": [
        [
          {
            "node": "No Operation, do nothing15",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Notificar Cita Exitosa1": {
      "main": [
        [
          {
            "node": "Validación de longitud de caracteres11",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Microsoft SQL Eliminar Mensajes4": {
      "main": [
        [
          {
            "node": "Basic LLM Notificar No Disponibilidad3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Microsoft SQLUpdate Cita Anterior": {
      "main": [
        [
          {
            "node": "Microsoft SQL Insertar Cita1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza variables del mensaje11": {
      "main": [
        [
          {
            "node": "Basic LLM Separación de Mensaje",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza variables del mensaje10": {
      "main": [
        [
          {
            "node": "Basic LLM Separación de Mensaje",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model17": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Extracción Datos Cancelar Cita",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser5": {
      "ai_outputParser": [
        [
          {
            "node": "Basic LLM Extracción Datos Cancelar Cita",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Extracción Datos Cancelar Cita": {
      "main": [
        [
          {
            "node": "Code Validación datos para cancelación de citas",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Validación datos para cancelación de citas": {
      "main": [
        [
          {
            "node": "If Validar si los datos están completos",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Validar si los datos están completos": {
      "main": [
        [
          {
            "node": "Microsoft SQL Obtener Cita para Cancelar",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Validación de longitud de caracteres12",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validación de longitud de caracteres12": {
      "main": [
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp15",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Organiza variables del mensaje12",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp15": {
      "main": [
        [
          {
            "node": "No Operation, do nothing16",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza variables del mensaje12": {
      "main": [
        [
          {
            "node": "Basic LLM Separación de Mensaje",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Microsoft SQL Obtener Cita para Cancelar": {
      "main": [
        [
          {
            "node": "If cita para cancelar",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If cita para cancelar": {
      "main": [
        [
          {
            "node": "HTTP Request MALLA DE RECIBO 3",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Code respuesta cita no programada",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validación de longitud de caracteres13": {
      "main": [
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp16",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Organiza variables del mensaje13",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp16": {
      "main": [
        [
          {
            "node": "No Operation, do nothing17",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code respuesta cita no programada": {
      "main": [
        [
          {
            "node": "Validación de longitud de caracteres13",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza variables del mensaje13": {
      "main": [
        [
          {
            "node": "Basic LLM Separación de Mensaje",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request MALLA DE RECIBO 3": {
      "main": [
        [
          {
            "node": "Extract MALLA DE RECIBO 3",
            "type": "main",
            "index": 0
          },
          {
            "node": "Extract MALLA DE RECIBO Semana Siguiente4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract MALLA DE RECIBO 3": {
      "main": [
        [
          {
            "node": "Estructuración, Datos, Consulta, Citas4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Estructuración, Datos, Consulta, Citas4": {
      "main": [
        [
          {
            "node": "Merge datos Excel4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge datos Excel4": {
      "main": [
        [
          {
            "node": "Unificación y consistencia de datos5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract MALLA DE RECIBO Semana Siguiente4": {
      "main": [
        [
          {
            "node": "Estructuración, Datos, Consulta, Citas Proxima Semana4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Estructuración, Datos, Consulta, Citas Proxima Semana4": {
      "main": [
        [
          {
            "node": "Merge datos Excel4",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Unificación y consistencia de datos5": {
      "main": [
        [
          {
            "node": "Code validación de cita en malla",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code validación de cita en malla": {
      "main": [
        [
          {
            "node": "If validar cita existe",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validación de longitud de caracteres14": {
      "main": [
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp17",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Organiza variables del mensaje14",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp17": {
      "main": [
        [
          {
            "node": "No Operation, do nothing18",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If validar cita existe": {
      "main": [
        [
          {
            "node": "Code (Preparar Cuerpo de Petición)2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Validación de longitud de caracteres14",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza variables del mensaje14": {
      "main": [
        [
          {
            "node": "Basic LLM Separación de Mensaje",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code (Preparar Cuerpo de Petición)2": {
      "main": [
        [
          {
            "node": "Code Agrupar Franjas3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Agrupar Franjas3": {
      "main": [
        [
          {
            "node": "Loop Over Uno a Uno2",
            "type": "main",
            "index": 0
          },
          {
            "node": "Code Datos Cancelar Cita",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Uno a Uno2": {
      "main": [
        [
          {
            "node": "Code Validar inserciones2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Code Preparar cada Insercion2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Preparar cada Insercion2": {
      "main": [
        [
          {
            "node": "HTTP Request Actualizar Excel2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Actualizar Excel2": {
      "main": [
        [
          {
            "node": "Code Verificar Inserción2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Verificar Inserción2": {
      "main": [
        [
          {
            "node": "If Verificar Inserción2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Verificar Inserción2": {
      "main": [
        [
          {
            "node": "Wait6",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "If Diferente Caso2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Diferente Caso2": {
      "main": [
        [
          {
            "node": "Code Limpiar Celda Incorrecta2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "If fallo Estado2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Limpiar Celda Incorrecta2": {
      "main": [
        [
          {
            "node": "HTTP Request Limpiar Celda2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Limpiar Celda2": {
      "main": [
        [
          {
            "node": "Code Reintentar Inserción2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If fallo Estado2": {
      "main": [
        [
          {
            "node": "Code Reintentar Inserción2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Merge7",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "Code Reintentar Inserción2": {
      "main": [
        [
          {
            "node": "HTTP Request Reintentar Inserción2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Reintentar Inserción2": {
      "main": [
        [
          {
            "node": "Code Volver a validar Inserción2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Volver a validar Inserción2": {
      "main": [
        [
          {
            "node": "If Verificar Inserción 1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Verificar Inserción 1": {
      "main": [
        [
          {
            "node": "Wait7",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Merge7",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Wait6": {
      "main": [
        [
          {
            "node": "Loop Over Uno a Uno2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait7": {
      "main": [
        [
          {
            "node": "Loop Over Uno a Uno2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model18": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Notificar No Disponibilidad4",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Notificar No Disponibilidad4": {
      "main": [
        [
          {
            "node": "Validación de longitud de caracteres16",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validación de longitud de caracteres16": {
      "main": [
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp19",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Organiza variables del mensaje15",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp19": {
      "main": [
        [
          {
            "node": "No Operation, do nothing20",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Validar inserciones2": {
      "main": [
        [
          {
            "node": "If Validar inserciones2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Validar inserciones2": {
      "main": [
        [
          {
            "node": "Merge6",
            "type": "main",
            "index": 1
          }
        ],
        [
          {
            "node": "Merge7",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge6": {
      "main": [
        [
          {
            "node": "Microsoft SQLUpdate Cita Anterior1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge7": {
      "main": [
        [
          {
            "node": "Microsoft SQL Eliminar Mensajes5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model19": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Notificar Cancelar Cita",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Validación de longitud de caracteres17": {
      "main": [
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp20",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Organiza variables del mensaje16",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp20": {
      "main": [
        [
          {
            "node": "No Operation, do nothing21",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Microsoft SQL Eliminar Mensajes5": {
      "main": [
        [
          {
            "node": "Basic LLM Notificar No Disponibilidad4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Microsoft SQLUpdate Cita Anterior1": {
      "main": [
        [
          {
            "node": "Basic LLM Notificar Cancelar Cita",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Datos Cancelar Cita": {
      "main": [
        [
          {
            "node": "Merge6",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Notificar Cancelar Cita": {
      "main": [
        [
          {
            "node": "Validación de longitud de caracteres17",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza variables del mensaje15": {
      "main": [
        [
          {
            "node": "Basic LLM Separación de Mensaje",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza variables del mensaje16": {
      "main": [
        [
          {
            "node": "Basic LLM Separación de Mensaje",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model5": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM CONVERSACIÓN GENERAL",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Validación de longitud de caracteres15": {
      "main": [
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp18",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Organiza variables del mensaje17",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp18": {
      "main": [
        [
          {
            "node": "No Operation, do nothing19",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM CONVERSACIÓN GENERAL": {
      "main": [
        [
          {
            "node": "Estructuración, de datos",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Estructuración, de datos": {
      "main": [
        [
          {
            "node": "Validación de longitud de caracteres15",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza variables del mensaje17": {
      "main": [
        [
          {
            "node": "Basic LLM Separación de Mensaje",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validación de longitud de caracteres18": {
      "main": [
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp21",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Organiza variables del mensaje18",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp21": {
      "main": [
        [
          {
            "node": "No Operation, do nothing22",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Estructuración, de datos1": {
      "main": [
        [
          {
            "node": "Validación de longitud de caracteres18",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Microsoft SQL Eliminación Mensajes": {
      "main": [
        [
          {
            "node": "Estructuración, de datos1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Estructuración, de datos2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza variables del mensaje18": {
      "main": [
        [
          {
            "node": "Basic LLM Separación de Mensaje",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validación de longitud de caracteres19": {
      "main": [
        [
          {
            "node": "HTTP Request Enviar Mensaje por WhatsApp22",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Organiza variables del mensaje19",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request Enviar Mensaje por WhatsApp22": {
      "main": [
        [
          {
            "node": "No Operation, do nothing23",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Estructuración, de datos2": {
      "main": [
        [
          {
            "node": "Validación de longitud de caracteres19",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organiza variables del mensaje19": {
      "main": [
        [
          {
            "node": "Basic LLM Separación de Mensaje",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM MANEJO FUERA CONTEXTO": {
      "main": [
        [
          {
            "node": "Verificar Reinicio Fuera Contexto",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Consultar Estado Conversacional": {
      "main": [
        [
          {
            "node": "Merge de Datos",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Actualizar Estado por Intención": {
      "main": [
        [
          {
            "node": "Switch Redistribución por Intención",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch Redistribución por Intención": {
      "main": [
        [
          {
            "node": "Basic LLM CONVERSACIÓN (SALUDO)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Verificar Reinicio Fuera Contexto": {
      "main": [
        [
          {
            "node": "Estructuración, de datos2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Resetear Estado - Cita Exitosa": {
      "main": [
        [
          {
            "node": "Validación de longitud de caracteres7",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "4696293c-f50f-4c33-a243-348508b41fe5",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "1eb0088037a07ba7867394f235324ea67bbb89bb030f5b44da808ec979ca0c6d"
  },
  "id": "NUOSkgdmXeUwNDBX",
  "tags": []
}